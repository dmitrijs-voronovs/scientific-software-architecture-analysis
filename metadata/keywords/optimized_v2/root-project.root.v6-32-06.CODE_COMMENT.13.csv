quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Integrability,"// FIXME: Using definitions and declarations should be decl extracted.; // Until we have that, don't wrap them if they are the only input.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp:101,wrap,wrap,101,interpreter/cling/lib/Utils/SourceNormalization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp,1,['wrap'],['wrap']
Integrability,// FIXME: Visit dependent template names.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:16,depend,dependent,16,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,1,['depend'],['dependent']
Integrability,// FIXME: We are currently always generating CMPs because we don't support; // generating CMN through the backend. This is not as good as the natural; // CMP case because it causes a register dependency and cannot be folded; // later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:192,depend,dependency,192,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['depend'],['dependency']
Integrability,// FIXME: We could do this check for dependent types with non-dependent; // bases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:37,depend,dependent,37,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,2,['depend'],['dependent']
Integrability,// FIXME: We currently don't use control-dependence but simply include all; // blocks (possibly empty at the end) and let simplifycfg mostly clean this; // up.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:41,depend,dependence,41,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,1,['depend'],['dependence']
Integrability,"// FIXME: We don't currently have the ability to accurately; // compute the length of an initializer list without; // performing full type-checking of the initializer list; // (since we have to determine where braces are implicitly; // introduced and such). So, we fall back to making the array; // type a dependently-sized array type with no specified; // bound.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:306,depend,dependently-sized,306,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['depend'],['dependently-sized']
Integrability,"// FIXME: We fail roottest root/io/newdelete if we issue this message!; // Error(""TClingClassInfo::New()"", ""Class has no default constructor: %s"",; // FullyQualifiedName(GetDecl()).c_str());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx:62,message,message,62,core/metacling/src/TClingClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx,1,['message'],['message']
Integrability,"// FIXME: We fail roottest root/io/newdelete if we issue this message!; //Error(""TClingClassInfo::New(arena)"",; // ""Class has no default constructor: %s"",; // FullyQualifiedName(GetDecl()).c_str());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx:62,message,message,62,core/metacling/src/TClingClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx,1,['message'],['message']
Integrability,"// FIXME: We fail roottest root/io/newdelete if we issue this message!; //Error(""TClingClassInfo::New(n)"",; // ""Class has no default constructor: %s"",; // FullyQualifiedName(GetDecl()).c_str());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx:62,message,message,62,core/metacling/src/TClingClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx,1,['message'],['message']
Integrability,"// FIXME: We fail roottest root/io/newdelete if we issue this message!; //Error(""TClingClassInfo::New(n, arena)"",; // ""Class has no default constructor: %s"",; // FullyQualifiedName(GetDecl()).c_str());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx:62,message,message,62,core/metacling/src/TClingClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx,1,['message'],['message']
Integrability,// FIXME: We have no generic interface for allocating custom PSVs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/ReducerWorkItem.cpp:29,interface,interface,29,interpreter/llvm-project/llvm/tools/llvm-reduce/ReducerWorkItem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/ReducerWorkItem.cpp,1,['interface'],['interface']
Integrability,"// FIXME: We have no way of representing inherited dependent alignments; // in a case like:; // template<int A, int B> struct alignas(A) X;; // template<int A, int B> struct alignas(B) X {};; // For now, we just ignore any alignas attributes which are not on the; // definition in such a case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,depend,dependent,51,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,// FIXME: We have to enter REG-EXCESS before we reach the actual threshold; // to increase the likelihood we don't go over the limits. We should improve; // the analysis to look through dependencies to find the path with the least; // register pressure.; // We only need to update the RPDelta for instructions that increase register; // pressure. Instructions that decrease or keep reg pressure the same will be; // marked as RegExcess in tryCandidate() when they are compared with; // instructions that increase the register pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:186,depend,dependencies,186,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['depend'],['dependencies']
Integrability,// FIXME: We may add to the interface of evalAssume the list of symbols; // whose assumptions have changed. For now we just iterate through the; // bindings and check if any of the tracked symbols are NULL. This isn't; // too bad since the number of symbols we will track in practice are; // probably small and evalAssume is only called at branches and a few; // other places.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:28,interface,interface,28,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,1,['interface'],['interface']
Integrability,"// FIXME: We may need different solutions, depending on the symbol; // involved. Blocks can be casted to/from 'id', as they can be treated; // as Objective-C objects. This could possibly be handled by enhancing; // our reasoning of downcasts of symbolic objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:43,depend,depending,43,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,1,['depend'],['depending']
Integrability,// FIXME: We need a callback mechanism for the tool writer to output a; // customized message for each file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:86,message,message,86,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,1,['message'],['message']
Integrability,"// FIXME: We need an error message here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:27,message,message,27,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,4,['message'],['message']
Integrability,"// FIXME: We need and error message here, no streamer info, so cannot set offsets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:28,message,message,28,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['message'],['message']
Integrability,// FIXME: We ought to do this for -integrated-as without -via-file-asm too.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:35,integrat,integrated-as,35,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['integrat'],['integrated-as']
Integrability,// FIXME: We ought to do this for -integrated-as without -via-file-asm too.; // FIXME: This should propagate failure up to parseStatement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:35,integrat,integrated-as,35,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['integrat'],['integrated-as']
Integrability,// FIXME: We presumably shouldn't strip off ElaboratedTypes with; // instantation-dependent qualifiers. See; // https://github.com/itanium-cxx-abi/cxx-abi/issues/114.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:82,depend,dependent,82,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['depend'],['dependent']
Integrability,// FIXME: We should be able to cast NonLoc -> Loc; // (when Loc::isLocType(CastTy) is true); // But it's hard to do as SymbolicRegions can't refer to SymbolCasts holding; // generic SymExprs. Check the commit message for the details.; // Symbol to pointer and whatever else.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:209,message,message,209,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,1,['message'],['message']
Integrability,"// FIXME: We should be able to return ""true"" here, but it can lead to extra; // error messages. E.g. in Sema/array-init.c.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:86,message,messages,86,interpreter/llvm-project/clang/lib/AST/Expr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp,1,['message'],['messages']
Integrability,"// FIXME: We should not hardcode this path. We can use a similar to the; // windows technique to get the path to the executable. The easiest way; // to do this is to depend on LLVMSupport and use getMainExecutable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/FoundationUtils.cxx:166,depend,depend,166,core/foundation/src/FoundationUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/FoundationUtils.cxx,1,['depend'],['depend']
Integrability,"// FIXME: We should optimize this routine instead making it do the wrong thing; // returning an empty comment if the decl came from the AST.; // In order to do that we need to: check if the decl has an attribute and; // return the attribute content (including walking the redecl chain) and if; // this is not the case we should try finding it in the header file.; // This will allow us to move the implementation of TCling*Info::Title() in; // TClingDeclInfo.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:34,rout,routine,34,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['rout'],['routine']
Integrability,"// FIXME: We should remove all of them. However, AArch64 emits an; // invalid `DBG_VALUE $lr` with only one operand instead of; // the usual three and has a test that depends on it's; // preservation. Preserve it for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp:167,depend,depends,167,interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStripDebug.cpp,1,['depend'],['depends']
Integrability,"// FIXME: We shouldn't need this, the protocol decl should contain enough; // information to tell us whether this was a declaration or a definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:38,protocol,protocol,38,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['protocol'],['protocol']
Integrability,"// FIXME: We want bug reports to always have the same checker name associated; // with them, yet here, if RetainCountChecker is disabled but; // OSObjectRetainCountChecker is enabled, the checker names will be different.; // This hack will make it so that the checker name depends on which checker is; // enabled rather than on the registration order.; // For the most part, we want **non-hidden checkers** to be associated with; // diagnostics, and **hidden checker options** with the fine-tuning of; // modeling. Following this logic, OSObjectRetainCountChecker should be the; // latter, but we can't just remove it for backward compatibility reasons.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:273,depend,depends,273,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,1,['depend'],['depends']
Integrability,"// FIXME: We will have to rework the repairing cost model.; // The repairing cost depends on the register bank that MO has.; // However, when we break down the value into different values,; // MO may not have a register bank while still needing repairing.; // For the fast mode, we don't compute the cost so that is fine,; // but still for the repairing code, we will have to make a choice.; // For the greedy mode, we should choose greedily what is the best; // choice based on the next use of MO.; // Sums up the repairing cost of MO at each insertion point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:82,depend,depends,82,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['depend'],['depends']
Integrability,// FIXME: We'd better diagnose missing or duplicate default labels even; // in the dependent case. Because default labels themselves are never; // dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:83,depend,dependent,83,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,2,['depend'],['dependent']
Integrability,// FIXME: What about dependent types?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:21,depend,dependent,21,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['depend'],['dependent']
Integrability,// FIXME: What we're doing here is modifying the type-specifier that; // precedes the first Decl. In the future the DeclGroup should have; // a separate type-specifier that we can rewrite.; // NOTE: We need to avoid rewriting the DeclStmt if it is within; // the context of an ObjCForCollectionStmt. For example:; // NSArray *someArray;; // for (id <FooProtocol> index in someArray) ;; // This is because RewriteObjCForCollectionStmt() does textual rewriting; // and it depends on the original text locations/positions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:470,depend,depends,470,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['depend'],['depends']
Integrability,"// FIXME: When interfaces are DeclContexts, we'll need to add; // these to the interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:15,interface,interfaces,15,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['interface'],"['interface', 'interfaces']"
Integrability,"// FIXME: Why it is here? Shouldn't it be in DeclExtractor?; // if no body remove the wrapper",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValuePrinterSynthesizer.cpp:86,wrap,wrapper,86,interpreter/cling/lib/Interpreter/ValuePrinterSynthesizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValuePrinterSynthesizer.cpp,1,['wrap'],['wrapper']
Integrability,"// FIXME: Without optimizations, the temporary result from `await_suspend()`; // may be put on the coroutine frame since the coroutine frame constructor; // will think the temporary variable will escape from the; // `coroutine_handle<>::address()` call. This is problematic since the; // coroutine should be considered to be suspended after it enters; // `await_suspend` so it shouldn't access/update the coroutine frame after; // that.; //; // See https://github.com/llvm/llvm-project/issues/65054 for the report.; //; // The long term solution may wrap the whole logic about `await-suspend`; // into a standalone function. This is similar to the proposed solution; // in tryMarkAwaitSuspendNoInline. See the comments there for details.; //; // The short term solution here is to mark `coroutine_handle<>::address()`; // function as always-inline so that the coroutine frame constructor won't; // think the temporary result is escaped incorrectly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:550,wrap,wrap,550,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,1,['wrap'],['wrap']
Integrability,"// FIXME: Wrap this union around more members, or perhaps store the; // kind-specific members in the RAII object owning the context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:10,Wrap,Wrap,10,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['Wrap'],['Wrap']
Integrability,"// FIXME: better error handling. For now, just print an error message in the; // release version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:62,message,message,62,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,1,['message'],['message']
Integrability,"// FIXME: better error handling. For now, just print error message and skip; // the replacement for the release version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp:59,message,message,59,interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/SortJavaScriptImports.cpp,1,['message'],['message']
Integrability,"// FIXME: better error handling. For now, just print error message in the; // release version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:59,message,message,59,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,4,['message'],['message']
Integrability,// FIXME: better error handling. for now just print error message and skip; // for the release version.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:58,message,message,58,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,1,['message'],['message']
Integrability,"// FIXME: chdir is thread hostile; on the other hand, creating the same; // behavior as chdir is complex: chdir resolves the path once, thus; // guaranteeing that all subsequent relative path operations work; // on the same path the original chdir resulted in. This makes a; // difference for example on network filesystems, where symlinks might be; // switched during runtime of the tool. Fixing this depends on having a; // file system abstraction that allows openat() style interactions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:402,depend,depends,402,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,1,['depend'],['depends']
Integrability,// FIXME: check return code ?; // Print out the error messages generated by CC if possible...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:54,message,messages,54,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,1,['message'],['messages']
Integrability,// FIXME: declarations with dependent or templated scope.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:28,depend,dependent,28,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['depend'],['dependent']
Integrability,// FIXME: dependent operand expressions?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:10,depend,dependent,10,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['depend'],['dependent']
Integrability,"// FIXME: different platforms make different information available ""for free""; // when traversing a directory. The design of this class wraps most of the; // information in basic_file_status, so on platforms where we can't populate; // that whole structure, callers end up paying for a stat().; // std::filesystem::directory_entry may be a better model.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:136,wrap,wraps,136,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['wrap'],['wraps']
Integrability,// FIXME: do something more useful with the error message,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCompilationDatabase.cpp:50,message,message,50,interpreter/llvm-project/clang/tools/libclang/CXCompilationDatabase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXCompilationDatabase.cpp,1,['message'],['message']
Integrability,// FIXME: duplicated from Target/WebAssembly/WebAssembly.h; // don't want to depend on target specific headers in this code?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:77,depend,depend,77,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,1,['depend'],['depend']
Integrability,"// FIXME: employ to empty module dependencies *within* the *current* module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalExecutor.cpp:33,depend,dependencies,33,interpreter/cling/lib/Interpreter/IncrementalExecutor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalExecutor.cpp,1,['depend'],['dependencies']
Integrability,// FIXME: fail correctly when there are dependent paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:40,depend,dependent,40,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['depend'],['dependent']
Integrability,"// FIXME: handle error. For now, print error message and skip the; // replacement for release version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:45,message,message,45,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,1,['message'],['message']
Integrability,// FIXME: handle forward protocol that are declared across multiple lines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:25,protocol,protocol,25,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,4,['protocol'],['protocol']
Integrability,// FIXME: handle protocol headers that are declared across multiple lines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:17,protocol,protocol,17,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['protocol'],['protocol']
Integrability,"// FIXME: in some cases the meaning of a negative direction vector; // may not be straightforward, e.g.,; // for (int i = 0; i < 32; ++i) {; // Src: A[i] = ...;; // Dst: use(A[31 - i]);; // }; // The dependency is; // flow { Src[i] -> Dst[31 - i] : when i >= 16 } and; // anti { Dst[i] -> Src[31 - i] : when i < 16 },; // -- hence a [<>].; // As long as a dependence result contains '>' ('<>', '<=>', ""*""), it; // means that a reversed/normalized dependence needs to be considered; // as well. Nevertheless, current isDirectionNegative() only returns; // true with a '>' or '>=' dependency for ease of canonicalizing the; // dependency vector, since the reverse of '<>', '<=>' and ""*"" is itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:200,depend,dependency,200,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,5,['depend'],"['dependence', 'dependency']"
Integrability,"// FIXME: in the future, continue lexing to extract relevant PP directives;; // return wrapPoint; // There is something else here that needs to be wrapped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp:87,wrap,wrapPoint,87,interpreter/cling/lib/Utils/SourceNormalization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp,2,['wrap'],"['wrapPoint', 'wrapped']"
Integrability,"// FIXME: it'd be better to introduce a new Callback interface type; // that does not allow multiplexing, and thus enforces that there; // is only one single listener.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/MultiplexInterpreterCallbacks.h:53,interface,interface,53,interpreter/cling/lib/Interpreter/MultiplexInterpreterCallbacks.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/MultiplexInterpreterCallbacks.h,1,['interface'],['interface']
Integrability,"// FIXME: lli aims to provide both, RuntimeDyld and JITLink, as the dynamic; // loaders for it's JIT implementations. And they both offer debugging via the; // GDB JIT interface, which builds on the two well-known symbol names below.; // As these symbols must be unique accross the linked executable, we can only; // define them in one of the libraries and make the other depend on it.; // OrcTargetProcess is a minimal stub for embedding a JIT client in remote; // executors. For the moment it seems reasonable to have the definition there; // and let ExecutionEngine depend on it, until we find a better solution.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp:168,interface,interface,168,interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp,3,"['depend', 'interface']","['depend', 'interface']"
Integrability,// FIXME: maybe we should warn on these if we can find a sensible diagnostic; // message,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:81,message,message,81,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,1,['message'],['message']
Integrability,// FIXME: move remaining dependence computation from MemberExpr::Create(),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:25,depend,dependence,25,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,1,['depend'],['dependence']
Integrability,// FIXME: move the computing dependency logic to ComputeDependence.h,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp:29,depend,dependency,29,interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,1,['depend'],['dependency']
Integrability,// FIXME: must also be instantiation-dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp:37,depend,dependent,37,interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp,1,['depend'],['dependent']
Integrability,// FIXME: need to go through this whole constant islands port and check; // the math for branch ranges and clean this up and make some functions; // to calculate things that are done many times identically.; // Need to refactor some of the code to call this routine.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:258,rout,routine,258,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,1,['rout'],['routine']
Integrability,"// FIXME: remove dependence on MCDwarfLineAddr::encode.; // As we reuse MCDwarfLineAddr::encode, we need to create/initialize; // some MC* classes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DebugLineSectionEmitter.h:17,depend,dependence,17,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DebugLineSectionEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DebugLineSectionEmitter.h,1,['depend'],['dependence']
Integrability,// FIXME: remove remaining dependence computation to computeDependence().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:27,depend,dependence,27,interpreter/llvm-project/clang/lib/AST/Expr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp,1,['depend'],['dependence']
Integrability,"// FIXME: remove the type-dependent bit from subexpressions, if the; // RecoveryExpr has a non-dependent type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:26,depend,dependent,26,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,2,['depend'],['dependent']
Integrability,// FIXME: should we consider SymbolRef wrapped in CodeTextRegion?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp:39,wrap,wrapped,39,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SVals.cpp,2,['wrap'],['wrapped']
Integrability,"// FIXME: the motivation for capturing post-merge bitcode and command line; // is replicating the compilation environment from bitcode, without needing; // to understand the dependencies (the functions to be imported). This; // assumes a clang - based invocation, case in which we have the command; // line.; // It's not very clear how the above motivation would map in the; // linker-based case, so we currently don't plumb the command line args in; // that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp:174,depend,dependencies,174,interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOBackend.cpp,1,['depend'],['dependencies']
Integrability,"// FIXME: the template-template arg was a DependentTemplateName,; // so it was provided with a template keyword. However, its source; // location is not stored in the template argument structure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:42,Depend,DependentTemplateName,42,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['Depend'],['DependentTemplateName']
Integrability,"// FIXME: this implementation should be micro-architecture dependent, so a; // micro-architecture target hook should be introduced here in future.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:59,depend,dependent,59,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['depend'],['dependent']
Integrability,"// FIXME: this is incorrect for cases where we have a non-dependent; // requirement, but its parameters are instantiation-dependent. RequiresExpr; // should be instantiation-dependent if it has instantiation-dependent; // parameters.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp:58,depend,dependent,58,interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,4,['depend'],['dependent']
Integrability,"// FIXME: this is not quite the right error message since we don't allow; // floating point types, or member pointers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:44,message,message,44,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['message'],['message']
Integrability,"// FIXME: this is required to be an integer expression (or dependent), so we; // should ensure that is the case by passing this to SEMA here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:59,depend,dependent,59,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,1,['depend'],['dependent']
Integrability,"// FIXME: to do this check properly, we will need to preserve the; // first-qualifier-in-scope here, just in case we had a dependent; // base (and therefore couldn't do the check) and a; // nested-name-qualifier (and therefore could do the lookup).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:123,depend,dependent,123,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['depend'],['dependent']
Integrability,// FIXME: use RequirementDependence to model dependence?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprConcepts.h:45,depend,dependence,45,interpreter/llvm-project/clang/include/clang/AST/ExprConcepts.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprConcepts.h,1,['depend'],['dependence']
Integrability,"// FIXME: we could just insert an ISD::MEMBARRIER here, except we are at; // the IR level, so we must wrap it in an intrinsic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:102,wrap,wrap,102,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['wrap'],['wrap']
Integrability,// FIXME: we may want to suppress diagnostics for all; // kind of forbidden type messages on unavailable functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:81,message,messages,81,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['message'],['messages']
Integrability,// FIXME: whether we should create std::span type depends on the Strategy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:50,depend,depends,50,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['depend'],['depends']
Integrability,// FIXME:Is it useful to print out the expression for a non-dependent; // noexcept specification?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:60,depend,dependent,60,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,1,['depend'],['dependent']
Integrability,"// FPv5 and FP-ARMv8 have the same instructions, so are modeled as one; // FPU, but there are two different names for it depending on the CPU.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp:121,depend,depending,121,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp,1,['depend'],['depending']
Integrability,// FSEventStreamStop and Invalidate must be called after Start and; // SetDispatchQueue to follow FSEvents API contract. The call to Receiver; // also uses Queue to not race with the initial scan.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/mac/DirectoryWatcher-mac.cpp:111,contract,contract,111,interpreter/llvm-project/clang/lib/DirectoryWatcher/mac/DirectoryWatcher-mac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/mac/DirectoryWatcher-mac.cpp,1,['contract'],['contract']
Integrability,"// FTFont wrapper",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveTextGL.h:10,wrap,wrapper,10,graf3d/eve/inc/TEveTextGL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveTextGL.h,1,['wrap'],['wrapper']
Integrability,"// FTGL wrapper functions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLFontManager.h:8,wrap,wrapper,8,graf3d/gl/inc/TGLFontManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLFontManager.h,1,['wrap'],['wrapper']
Integrability,// Fall back: let the parser try to parse it as an instance message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:60,message,message,60,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,2,['message'],['message']
Integrability,"// Fall through to create a dependent typename type, from which we can recover; // better.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:28,depend,dependent,28,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,"// Fall through to deal with other dependent record types (e.g.,; // anonymous unions in class templates).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:35,depend,dependent,35,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['depend'],['dependent']
Integrability,// Fall through; this isn't a message send.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:30,message,message,30,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['message'],['message']
Integrability,// Fall through; we'll just parse the expression and; // (possibly) treat this like an Objective-C message send; // later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:99,message,message,99,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,1,['message'],['message']
Integrability,"// Fallback to -o as dependency target, as in the driver.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:21,depend,dependency,21,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,1,['depend'],['dependency']
Integrability,"// Fast path if we're building some type units and one has already used the; // address pool we know we're going to throw away all this work anyway, so; // don't bother building dependent types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:178,depend,dependent,178,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,1,['depend'],['dependent']
Integrability,// Fatbin wrapper magic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:10,wrap,wrapper,10,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,1,['wrap'],['wrapper']
Integrability,// Features with no dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/X86TargetParser.cpp:20,depend,dependencies,20,interpreter/llvm-project/llvm/lib/TargetParser/X86TargetParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/X86TargetParser.cpp,1,['depend'],['dependencies']
Integrability,// Fetch the injected class name type and check whether its; // injected type is equal to the type we just built.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:13,inject,injected,13,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,2,['inject'],['injected']
Integrability,// Figure out the diagnostic level of this message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:43,message,message,43,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,2,['message'],['message']
Integrability,// Figure out which interface we're in.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:20,interface,interface,20,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['interface'],['interface']
Integrability,// Figure out which interface we're looking into.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:20,interface,interface,20,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['interface'],['interface']
Integrability,"// File Transfer Protocol class using rootd",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TFTP.h:17,Protocol,Protocol,17,net/net/inc/TFTP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TFTP.h,1,['Protocol'],['Protocol']
Integrability,// File header related interfaces.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h:23,interface,interfaces,23,interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,1,['interface'],['interfaces']
Integrability,// Fill in protocol qualifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:11,protocol,protocol,11,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['protocol'],['protocol']
Integrability,// Fill in the error message and copy the path (in reverse order).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp:21,message,message,21,interpreter/llvm-project/llvm/lib/Support/JSON.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp,1,['message'],['message']
Integrability,"// Fill position vector for non-integrated observables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx:32,integrat,integrated,32,roofit/roofitcore/src/RooMultiVarGaussian.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx,1,['integrat'],['integrated']
Integrability,"// Fill the integration variable with dummy value for now. This will then; // be reset in the sampling loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:12,integrat,integration,12,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['integrat'],['integration']
Integrability,"// Fill the message now",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TVirtualPacketizer.cxx:12,message,message,12,proof/proof/src/TVirtualPacketizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TVirtualPacketizer.cxx,3,['message'],['message']
Integrability,"// Fill the profile histogram; // no entries/bin is available so can fill only using bin content as weight; // implement filling of projected histogram; // outbin is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; // inbin is the axis being integrated. Loop is done only on the selected bins",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:280,integrat,integrated,280,hist/hist/src/TH2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx,1,['integrat'],['integrated']
Integrability,// Fill vector with interface file objects created by parsing the YAML file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TextAPI/TextStub.cpp:20,interface,interface,20,interpreter/llvm-project/llvm/lib/TextAPI/TextStub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TextAPI/TextStub.cpp,1,['interface'],['interface']
Integrability,"// Filter and process dependencies, computing the earliest issue cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:22,depend,dependencies,22,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,1,['depend'],['dependencies']
Integrability,"// Filter of tools unused flags such as -no-integrated-as and -Wa,*.; // They are not used for syntax checking, and could confuse targets; // which don't support these options.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:44,integrat,integrated-as,44,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,1,['integrat'],['integrated-as']
Integrability,"// Filter out useless results (non-locals, etc). Keep track of the blocks; // where we have a value available in repl, also keep track of whether we see; // dependencies that produce an unknown value for the load (such as a call; // that could potentially clobber the load).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:157,depend,dependencies,157,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['depend'],['dependencies']
Integrability,"// Filtering is not implemented a very efficient way to keep it simple, but the; // implementation ensures that the performance drop is opt-in. Only when filters are; // used there is a performance loss.; // The intended use case of filtering is for debugging, when highest performance; // does not matter. Filtering is only every attempted if the message passes the; // threshold level.; // Filtering is very fast when the filter is empty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnPrint.cxx:348,message,message,348,math/minuit2/src/MnPrint.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnPrint.cxx,1,['message'],['message']
Integrability,"// Filtering works like grep, the message is shown if any of the filter strings match.; // To only match the beginning of the prefix, use ""^"". For example ""^MnHesse"" only; // matches direct execution of MnHesse, but not MnHesse called by MnMigrad.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnPrint.cxx:34,message,message,34,math/minuit2/src/MnPrint.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnPrint.cxx,1,['message'],['message']
Integrability,// Finally hoist the base constant and emit materialization code for dependent; // constants.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:69,depend,dependent,69,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,1,['depend'],['dependent']
Integrability,"// Finally, go through the codegen dag and translate it into a Result object; // (with an arbitrary DAG of depended-on Results hanging off it).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:107,depend,depended-on,107,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,1,['depend'],['depended-on']
Integrability,"// Find 'ToSymbol' using symbol number or address, depending on whether the; // paired UNSIGNED relocation is extern.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp:51,depend,depending,51,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachO_arm64.cpp,2,['depend'],['depending']
Integrability,"// Find a scratch register that we can use at the start of the prologue to; // re-align the stack pointer. We avoid using callee-save registers since they; // may appear to be free when this is called from canUseAsPrologue (during; // shrink wrapping), but then no longer be free when this is called from; // emitPrologue.; //; // FIXME: This is a bit conservative, since in the above case we could use one; // of the callee-save registers as a scratch temp to re-align the stack pointer,; // but we would then have to make sure that we were in fact saving at least one; // callee-save register in the prologue, which is additional complexity that; // doesn't seem worth the benefit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:242,wrap,wrapping,242,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['wrap'],['wrapping']
Integrability,"// Find a scratch register that we can use in the prologue. We avoid using; // callee-save registers since they may appear to be free when this is called; // from canUseAsPrologue (during shrink wrapping), but then no longer be free; // when this is called from emitPrologue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:195,wrap,wrapping,195,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['wrap'],['wrapping']
Integrability,"// Find a solution to a fully reduced graph by backpropagation.; //; // Given a graph and a reduction order, pop each node from the reduction; // order and greedily compute a minimum solution based on the node costs, and; // the dependent costs due to previously solved nodes.; //; // Note - This does not return the graph to its original (pre-reduction); // state: the existing solvers destructively alter the node and edge; // costs. Given that, the backpropagate function doesn't attempt to; // replace the edges either, but leaves the graph in its reduced; // state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/ReductionRules.h:229,depend,dependent,229,interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/ReductionRules.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/ReductionRules.h,1,['depend'],['dependent']
Integrability,"// Find all debug info in F. This is actually overkill in terms of what we; // want to do, but we want to try and be as resilient as possible in the face; // of potential debug info changes by using the formal interfaces given to us; // as much as possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp:210,interface,interfaces,210,interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/StripSymbols.cpp,1,['interface'],['interfaces']
Integrability,// Find all implicit conforming protocols for this class; // and make them explicit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:32,protocol,protocols,32,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,1,['protocol'],['protocols']
Integrability,// Find all invalidation methods in this @interface declaration and parents.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:42,interface,interface,42,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,1,['interface'],['interface']
Integrability,"// Find all nodes that depend exclusively on constant parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx:23,depend,depend,23,roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,2,['depend'],['depend']
Integrability,// Find already scheduled copies with a single physreg dependence and move; // them just above the scheduled instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:55,depend,dependence,55,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['depend'],['dependence']
Integrability,"// Find any function dependents that are AClean; // and switch them temporarily to ADirty",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:21,depend,dependents,21,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['depend'],['dependents']
Integrability,// Find category interface decl and then check that all methods declared; // in this interface are implemented in the category @implementation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:17,interface,interface,17,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['interface'],['interface']
Integrability,"// Find largest set of observables that can be integrated in one go",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:47,integrat,integrated,47,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['integrat'],['integrated']
Integrability,// Find out if this block has a local dependency for QueryInst.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:38,depend,dependency,38,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['dependency']
Integrability,// Find out what registers are live. Note this routine is ignoring other live; // registers which are only used by instructions in successor blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:47,rout,routine,47,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['rout'],['routine']
Integrability,"// Find protocol",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUrl.cxx:8,protocol,protocol,8,core/base/src/TUrl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUrl.cxx,1,['protocol'],['protocol']
Integrability,// Find store->load dependences (consequently true dep). Both lexically; // forward and backward dependences qualify. Disqualify loads that have; // other unknown dependences.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:20,depend,dependences,20,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,3,['depend'],['dependences']
Integrability,// Find stream with that name and read its data.; // FIXME: Consider validating (or even loading) all this in; // InjectedSourceStream so that no error can happen here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/NativeEnumInjectedSources.cpp:114,Inject,InjectedSourceStream,114,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/NativeEnumInjectedSources.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/NativeEnumInjectedSources.cpp,1,['Inject'],['InjectedSourceStream']
Integrability,// Find the class to which we are sending this message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:47,message,message,47,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,2,['message'],['message']
Integrability,// Find the corresponding interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:26,interface,interface,26,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['interface'],['interface']
Integrability,"// Find the corresponding interface. If we couldn't find the interface, the; // program itself is ill-formed. However, we'll try to be helpful still by; // providing the list of all of the categories we know about.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:26,interface,interface,26,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,2,['interface'],['interface']
Integrability,"// Find the function to call and the mangled name for the message; // ref structure. Using a different mangled name wouldn't actually; // be a problem; it would just be a waste.; //; // The runtime currently never uses vtable dispatch for anything; // except normal, non-super message-sends.; // FIXME: don't use this for that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:58,message,message,58,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,2,['message'],"['message', 'message-sends']"
Integrability,"// Find the injected-class-name declaration. Note that we make no attempt to; // diagnose cases where the injected-class-name is shadowed: the only; // declaration that can validly shadow the injected-class-name is a; // non-static data member, and if the class contains both a non-static data; // member and a constructor then it is ill-formed (we check that in; // CheckCompletedCXXClass).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:12,inject,injected-class-name,12,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,3,['inject'],['injected-class-name']
Integrability,"// Find the last bit of each run of ones, circularly. For runs which wrap; // around from bit 0 to bit 63, this is the bit before the most-significant; // zero, otherwise it is the least-significant bit in the run of ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandImm.cpp:69,wrap,wrap,69,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandImm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandImm.cpp,1,['wrap'],['wrap']
Integrability,// Find the predecessor which is not data dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:42,depend,dependence,42,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['depend'],['dependence']
Integrability,"// Find the scope in which the identifier is injected and the corresponding; // DeclContext.; // FIXME: C89 does not say what happens if there is no enclosing block scope.; // In that case, we inject the declaration into the translation unit scope; // instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:45,inject,injected,45,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['inject'],"['inject', 'injected']"
Integrability,"// Find the subset directVars that only depend on a single PDF in the product",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:40,depend,depend,40,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['depend'],['depend']
Integrability,"// Find the underlying objects for MI. The Objs vector is either; // empty, or filled with the Values of memory locations which this; // SU depends on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:140,depend,depends,140,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['depend'],['depends']
Integrability,// Find wrapper functions that represent parallel kernels.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:8,wrap,wrapper,8,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['wrap'],['wrapper']
Integrability,"// Finds an integer D for an affine AddRec expression {C,+,x} such that the top; // level addition in (D + {C-D,+,x}) would not wrap (signed or unsigned) and the; // number of trailing zeros of (C - D + x * n) is maximized, where C is the \p; // ConstantStart, x is an arbitrary \p Step, and n is the loop trip count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:128,wrap,wrap,128,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,"// Finds an integer D for an expression (C + x + y + ...) such that the top; // level addition in (D + (C - D + x + y + ...)) would not wrap (signed or; // unsigned) and the number of trailing zeros of (C - D + x + y + ...) is; // maximized, where C is the \p ConstantTerm, x, y, ... are arbitrary SCEVs, and; // the (C + x + y + ...) expression is \p WholeAddExpr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:136,wrap,wrap,136,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,// Finish the compiler invocation. Requires dependencies and the context hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:44,depend,dependencies,44,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,1,['depend'],['dependencies']
Integrability,// Finish the reduction.; // Need to add extra arguments and not vectorized possible reduction; // values.; // Try to avoid dependencies between the scalar remainders after; // reductions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:124,depend,dependencies,124,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['depend'],['dependencies']
Integrability,"// First a side track to insure proper end of process behavior.; // Register for each loaded dictionary (and thus for each library),; // that we need to Close the ROOT files as soon as this library; // might start being unloaded after main.; //; // By calling atexit here (rather than directly from within the; // library) we make sure that this is not called if the library is; // 'only' dlclosed.; // On Ubuntu the linker strips the unused libraries. Eventhough; // stressHistogram is explicitly linked against libNet, it is not; // retained and thus is loaded only as needed in the middle part of; // the execution. Concretely this also means that it is loaded; // *after* the construction of the TApplication object and thus; // after the registration (atexit) of the EndOfProcessCleanups; // routine. Consequently, after the end of main, libNet is; // unloaded before EndOfProcessCleanups is called. When; // EndOfProcessCleanups is executed it indirectly needs the TClass; // for TSocket and its search will use resources that have already; // been unloaded (technically the function static in TUnixSystem's; // DynamicPath and the dictionary from libNet).; // Similarly, the ordering (before this commit) was broken in the; // following case:; // TApplication creation (EndOfProcessCleanups registration); // load UserLibrary; // create TFile; // Append UserObject to TFile; // and after the end of main the order of execution was; // unload UserLibrary; // call EndOfProcessCleanups; // Write the TFile; // attempt to write the user object.; // ....; // where what we need is to have the files closen/written before; // the unloading of the library.; // To solve the problem we now register an atexit function for; // every dictionary thus making sure there is at least one executed; // before the first library tear down after main.; // If atexit is called directly within a library's code, the; // function will called *either* when the library is 'dlclose'd or; // after then end of main (w",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:797,rout,routine,797,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['rout'],['routine']
Integrability,"// First barrier for synchronization, ensures main thread has updated; // values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:21,synchroniz,synchronization,21,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['synchroniz'],['synchronization']
Integrability,"// First build manually the specializations of all non-remainder states, as the remainder state depends on these",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimWSTool.cxx:96,depend,depends,96,roofit/roofitcore/src/RooSimWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimWSTool.cxx,1,['depend'],['depends']
Integrability,"// First check if the optname exists in the list of the; // objects. This does not depend on the existence of a [] in; // the optname. Sometimes the [] is part of the optname and; // does not describe an array",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Configurable.cxx:83,depend,depend,83,tmva/tmva/src/Configurable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Configurable.cxx,1,['depend'],['depend']
Integrability,"// First iteration, determine what each component can integrate analytically",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx:54,integrat,integrate,54,roofit/roofitcore/src/RooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx,1,['integrat'],['integrate']
Integrability,"// First reference to Interface, register it now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassRegistry.cpp:22,Interface,Interface,22,interpreter/llvm-project/llvm/lib/IR/PassRegistry.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassRegistry.cpp,1,['Interface'],['Interface']
Integrability,"// First step. Check to see if there are any floating-point recurrences.; // If there are, change them into integer recurrences, permitting analysis by; // the SCEV routines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:165,rout,routines,165,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['rout'],['routines']
Integrability,"// First the protocol",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TNetFile.cxx:13,protocol,protocol,13,net/net/src/TNetFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TNetFile.cxx,1,['protocol'],['protocol']
Integrability,// First try assuming that any undefined bits above the highest set bit; // and below the lowest set bit are 1s. This increases the likelihood of; // being able to use a sign-extended element value in VECTOR REPLICATE; // IMMEDIATE or a wraparound mask in VECTOR GENERATE MASK.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:237,wrap,wraparound,237,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['wrap'],['wraparound']
Integrability,// First two fields are bit width dependent. The rest of them are fixed width.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp:34,depend,dependent,34,interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,1,['depend'],['dependent']
Integrability,"// First undo, the external call to SetEntries; // We could improve the interface to optional tell the TTreeCloner that the; // SetEntries was not done.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCloner.cxx:72,interface,interface,72,tree/tree/src/TTreeCloner.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCloner.cxx,1,['interface'],['interface']
Integrability,"// First, as a sanity check, let's see if the parameter; // itself actually exists and if the model depends on it:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistFactoryNavigation.cxx:100,depend,depends,100,roofit/histfactory/src/HistFactoryNavigation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistFactoryNavigation.cxx,1,['depend'],['depends']
Integrability,"// First, change the ABI of every function in the module. ABI-listed; // functions keep their original ABI and get a wrapper function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:117,wrap,wrapper,117,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,1,['wrap'],['wrapper']
Integrability,"// First, check for the ""frontier"" instructions (those that will clear the; // higher-order 32 bits.; // For RLWINM and RLWNM, we need to make sure that the mask does not wrap; // around. If it does not, then these instructions will clear the; // higher-order bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:171,wrap,wrap,171,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['wrap'],['wrap']
Integrability,"// First, check whether we can build the full function type. If the; // function type depends on an incomplete type (e.g. a struct or enum), we; // cannot lower the function type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp:86,depend,depends,86,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp,1,['depend'],['depends']
Integrability,"// First, collect constants depending on this IP of the base.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:28,depend,depending,28,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,1,['depend'],['depending']
Integrability,"// First, go through each memory operation and assign them to consecutive; // partitions (the order of partitions follows program order). Put those; // with unsafe dependences into ""cyclic"" partition otherwise put each store; // in its own ""non-cyclic"" partition (we'll merge these later).; //; // Note that a memory operation (e.g. Load2 below) at a program point that; // has an unsafe dependence (Store3->Load1) spanning over it must be; // included in the same cyclic partition as the dependent operations. This; // is to preserve the original program order after distribution. E.g.:; //; // NumUnsafeDependencesStartOrEnd NumUnsafeDependencesActive; // Load1 -. 1 0->1; // Load2 | /Unsafe/ 0 1; // Store3 -' -1 1->0; // Load4 0 0; //; // NumUnsafeDependencesActive > 0 indicates this situation and in this case; // we just keep assigning to the same cyclic partition until; // NumUnsafeDependencesActive reaches 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:164,depend,dependences,164,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,3,['depend'],"['dependence', 'dependences', 'dependent']"
Integrability,"// First, perform the cheaper check that compares the base register.; // If they are the same and the load offset is less than the store; // offset, then mark the dependence as loop carried potentially.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:163,depend,dependence,163,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['dependence']
Integrability,"// First, the shift amount will be CIV or CIV+1, depending on; // whether the value is early or late. Instead of creating CIV+1,; // do a single shift of the value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:49,depend,depending,49,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,1,['depend'],['depending']
Integrability,"// First, we calculate the list of enabled checkers as specified by the; // invocation. Weak dependencies will not enable their unspecified strong; // depenencies, but its only after resolving strong dependencies for all; // checkers when we know whether they will be enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:93,depend,dependencies,93,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,2,['depend'],['dependencies']
Integrability,"// First, we see if we are out of scope or empty. If so,; // and there equivalences, we try to replace the top of; // stack with equivalences (if it's on the stack, it must; // not have been eliminated yet).; // Then we synchronize to our current scope, by; // popping until we are back within a DFS scope that; // dominates the current member.; // Then, what happens depends on a few factors; // If the stack is now empty, we need to push; // If we have a constant or a local equivalence we want to; // start using, we also push.; // Otherwise, we walk along, processing members who are; // dominated by this scope, and eliminate them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:220,synchroniz,synchronize,220,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,2,"['depend', 'synchroniz']","['depends', 'synchronize']"
Integrability,// Fixup the subtarget dependent default value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:23,depend,dependent,23,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,1,['depend'],['dependent']
Integrability,// Flags for context-dependent keywords. WantFunctionLikeCasts is only; // used/meaningful when WantCXXNamedCasts is false.; // TODO: Expand these to apply to non-keywords or possibly remove them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TypoCorrection.h:21,depend,dependent,21,interpreter/llvm-project/clang/include/clang/Sema/TypoCorrection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TypoCorrection.h,1,['depend'],['dependent']
Integrability,"// Floating-point to integer conversions.; // i64 conversions are done via library routines even when generating VFP; // instructions, so use the same ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:83,rout,routines,83,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['rout'],['routines']
Integrability,// Floating-point.; // All F80 and PPCF128 routines are unsupported.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRuntimeLibcallSignatures.cpp:43,rout,routines,43,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRuntimeLibcallSignatures.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRuntimeLibcallSignatures.cpp,1,['rout'],['routines']
Integrability,"// Flow conditions are tracked symbolically: each unique flow condition is; // associated with a fresh symbolic variable (token), bound to the clause that; // defines the flow condition. Conceptually, each binding corresponds to an; // ""iff"" of the form `FC <=> (C1 ^ C2 ^ ...)` where `FC` is a flow condition; // token (an atomic boolean) and `Ci`s are the set of constraints in the flow; // flow condition clause. The set of constraints (C1 ^ C2 ^ ...) are stored in; // the `FlowConditionConstraints` map, keyed by the token of the flow; // condition.; //; // Flow conditions depend on other flow conditions if they are created using; // `forkFlowCondition` or `joinFlowConditions`. The graph of flow condition; // dependencies is stored in the `FlowConditionDeps` map.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysisContext.h:579,depend,depend,579,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysisContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysisContext.h,2,['depend'],"['depend', 'dependencies']"
Integrability,"// Flush any previous messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMsgService.cxx:22,message,messages,22,roofit/roofitcore/src/RooMsgService.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMsgService.cxx,2,['message'],['messages']
Integrability,"// Fold fsub [+-]0 into fneg. This may not have folded depending on the; // denormal mode, but we're implicitly canonicalizing in a source operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp:55,depend,depending,55,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,2,['depend'],['depending']
Integrability,// Follow the use-def chains to form a transitive closure of all the; // instructions that the originally seeded instructions depend on.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:126,depend,depend,126,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,1,['depend'],['depend']
Integrability,"// For 'operator<=>', we also form a 'cmp != 0' expression, and might; // synthesize a three-way comparison from '<' and '=='. In a dependent; // context, we also need to look up '==' in case we implicitly declare a; // defaulted 'operator=='.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:132,depend,dependent,132,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['dependent']
Integrability,"// For @llvm.memset.* intrinsic cases with constant value and length arguments; // are emulated via ""storing"" a constant array to the destination. For other; // cases we wrap the intrinsic in @spirv.llvm_memset_* function and expand the; // intrinsic to a loop via expandMemSetAsLoop().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp:170,wrap,wrap,170,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPrepareFunctions.cpp,1,['wrap'],['wrap']
Integrability,"// For @synchronized, call objc_sync_enter(sync.expr). The; // evaluation of the expression must occur before we enter the; // @synchronized. We can't avoid a temp here because we need the; // value to be preserved. If the backend ever does liveness; // correctly after setjmp, this will be unnecessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:8,synchroniz,synchronized,8,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,2,['synchroniz'],['synchronized']
Integrability,"// For ARM, we should only check the first bit, rather than the entire byte:; //; // ARM C++ ABI 3.2.3.1:; // To support the potential use of initialization guard variables; // as semaphores that are the target of ARM SWP and LDREX/STREX; // synchronizing instructions we define a static initialization; // guard variable to be a 4-byte aligned, 4-byte word with the; // following inline access protocol.; // #define INITIALIZED 1; // if ((obj_guard & INITIALIZED) != INITIALIZED) {; // if (__cxa_guard_acquire(&obj_guard)); // ...; // }; //; // and similarly for ARM64:; //; // ARM64 C++ ABI 3.2.2:; // This ABI instead only specifies the value bit 0 of the static guard; // variable; all other bits are platform defined. Bit 0 shall be 0 when the; // variable is not initialized and 1 when it is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:242,synchroniz,synchronizing,242,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,2,"['protocol', 'synchroniz']","['protocol', 'synchronizing']"
Integrability,"// For Define'd columns, add the systematic variations they depend on to the set",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx:60,depend,depend,60,tree/dataframe/src/RDFColumnRegister.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx,1,['depend'],['depend']
Integrability,"// For ELF, x86-64 pointer size depends on the ABI.; // For x86-64 without the x32 ABI, pointer size is 8. For x86 and for x86-64; // with the x32 ABI, pointer size remains the default 4.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp:32,depend,depends,32,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp,1,['depend'],['depends']
Integrability,"// For MEMCPY/MOMMOVE/MEMSET these will be the first use (the dst), as the; // mempy/etc routines return the same parameter. For other it will be the; // returned value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:89,rout,routines,89,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['rout'],['routines']
Integrability,"// For ObjC methods and properties, look through categories and use the; // interface as context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:76,interface,interface,76,interpreter/llvm-project/clang/lib/AST/Decl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp,1,['interface'],['interface']
Integrability,"// For Order dependences:; // 1. Volatile loads/stores can be packetized together, unless other; // rules prevent is.; // 2. Store followed by a load is not allowed.; // 3. Store followed by a store is valid.; // 4. Load followed by any memory operation is allowed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:13,depend,dependences,13,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['depend'],['dependences']
Integrability,"// For PROOF-Lite we redirect this output to a the open log file so that the; // memory monitor can pick these messages up",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:111,message,messages,111,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['message'],['messages']
Integrability,"// For a @synchronized (or a @try with no catches), just branch; // through the cleanup to the rethrow block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:10,synchroniz,synchronized,10,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['synchroniz'],['synchronized']
Integrability,"// For a defaulted function in a dependent class, defer all remaining checks; // until instantiation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:33,depend,dependent,33,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['dependent']
Integrability,"// For a dependent 'if constexpr', the result is dependent if it depends on; // the value of the condition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:9,depend,dependent,9,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,3,['depend'],"['dependent', 'depends']"
Integrability,"// For a dependent type, the set of template parameters that we; // expect to see.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:9,depend,dependent,9,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,"// For a given source instruction, collect its backwards dependence slice; // consisting of instructions exclusively computed for producing the operands; // of the source instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:57,depend,dependence,57,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,1,['depend'],['dependence']
Integrability,"// For a given source instruction, collect its backwards dependence slice; // consisting of instructions exclusively computed for the purpose of producing; // the operands of the source instruction. As an approximation; // (sufficiently-accurate in practice), we populate this set with the; // instructions of the backwards dependence slice that only have one-use and; // form an one-use chain that leads to the source instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:57,depend,dependence,57,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,2,['depend'],['dependence']
Integrability,"// For a non-type template parameter, the natural parameter is `T V` (for a; // prvalue argument) or `T &V` (for a glvalue argument), where `T` is the; // type of the argument, which we require to exactly match. If the actual; // parameter has a deduced or instantiation-dependent type, it is not; // equivalent to the natural parameter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:271,depend,dependent,271,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['depend'],['dependent']
Integrability,"// For a normal instance message, we should extend unless the; // receiver is loaded from a variable with precise lifetime.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:25,message,message,25,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['message'],['message']
Integrability,"// For a reference, the result of the wrapper function is a pointer to; // the referenced object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:38,wrap,wrapper,38,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['wrap'],['wrapper']
Integrability,"// For a set of live pointers (base and/or derived), identify the base; // pointer of the object which they are derived from. This routine will; // mutate the IR graph as needed to make the 'base' pointer live at the; // definition site of 'derived'. This ensures that any use of 'derived' can; // also use 'base'. This may involve the insertion of a number of; // additional PHI nodes.; //; // preconditions: live is a set of pointer type Values; //; // side effects: may insert PHI nodes into the existing CFG, will preserve; // CFG, will not remove or mutate any existing nodes; //; // post condition: PointerToBase contains one (derived, base) pair for every; // pointer in live. Note that derived can be equal to base if the original; // pointer was a base pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:131,rout,routine,131,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['rout'],['routine']
Integrability,"// For a transform such as reassociation, the cost equation is; // conservatively calculated so that we must improve the depth (data; // dependency cycles) in the critical path to proceed with the transform.; // Being conservative also protects against inaccuracies in the underlying; // machine trace metrics and CPU models.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:137,depend,dependency,137,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,1,['depend'],['dependency']
Integrability,"// For a value-dependent argument, CheckConvertedConstantExpression is; // permitted (and expected) to be unable to determine a value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:15,depend,dependent,15,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,"// For accessor stubs, go back to the interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:38,interface,interface,38,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,1,['interface'],['interface']
Integrability,"// For all other instructions, make sure only one of the two; // predication operands is left behind, depending on whether we should; // use the vector predication.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:102,depend,depending,102,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['depend'],['depending']
Integrability,"// For an enclosing lambda to be capture ready for an entity, all; // intervening lambda's have to be able to capture that entity. If even; // one of the intervening lambda's is not capable of capturing the entity; // then no enclosing lambda can ever capture that entity.; // For e.g.; // const int x = 10;; // [=](auto a) { #1; // [](auto b) { #2 <-- an intervening lambda that can never capture 'x'; // [=](auto c) { #3; // f(x, c); <-- can not lead to x's speculative capture by #1 or #2; // }; }; };; // If they do not have a default implicit capture, check to see; // if the entity has already been explicitly captured.; // If even a single dependent enclosing lambda lacks the capability; // to ever capture this variable, there is no further enclosing; // non-dependent lambda that can capture this variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:647,depend,dependent,647,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,2,['depend'],['dependent']
Integrability,"// For an instruction to be added into Worklist above, all its users inside; // the loop should also be in Worklist. However, this condition cannot be; // true for phi nodes that form a cyclic dependence. We must process phi; // nodes separately. An induction variable will remain uniform if all users; // of the induction variable and induction variable update remain uniform.; // The code below handles both pointer and non-pointer induction variables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:193,depend,dependence,193,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['depend'],['dependence']
Integrability,"// For an instruction with opcode Opc, calculate the set of bits that it; // uses in a register in operand OpN. This only calculates the set of used; // bits for cases where it does not depend on any operands (as is the case; // in shifts, for example). For concrete instructions from a program, the; // operand may be a subregister of a larger register, while Bits would; // correspond to the larger register in its entirety. Because of that,; // the parameter Begin can be used to indicate which bit of Bits should be; // considered the LSB of the operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:186,depend,depend,186,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,1,['depend'],['depend']
Integrability,"// For an objc container, delay protocol reference checking until after we; // can set the objc decl as the availability context, otherwise check now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:32,protocol,protocol,32,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['protocol'],['protocol']
Integrability,"// For any dependent type, we consider it a non-pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:11,depend,dependent,11,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['depend'],['dependent']
Integrability,"// For any module that this module depends on, push it on the; // stack (if it hasn't already been marked as visited).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:35,depend,depends,35,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,2,['depend'],['depends']
Integrability,"// For atomic-qualified class (and array) types in C++, initialize the; // _Atomic-wrapped subobject directly, in-place.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:83,wrap,wrapped,83,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['wrap'],['wrapped']
Integrability,"// For backward compatibility, for rootd we need to understand; // whether we are talking to a OLD client: protocol information is; // available only later on ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:107,protocol,protocol,107,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['protocol'],['protocol']
Integrability,"// For backward-compatibility with CINT we must support stmts like:; // x = 4; y = new MyClass();; // I.e we should ""inject"" a C++11 auto keyword in front of ""x"" and ""y""; // This has to have higher precedence than the dynamic scopes. It is claimed; // that if one assigns to a name and the lookup of that name fails if *must*; // auto keyword must be injected and the stmt evaluation must not be delayed; // until runtime.; // For now supported only at the prompt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:117,inject,inject,117,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,2,['inject'],"['inject', 'injected']"
Integrability,// For class messages it is sufficient for the declaration to be; // annotated _Nonnull.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp:13,message,messages,13,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp,1,['message'],['messages']
Integrability,"// For class-scope explicit specializations of function templates,; // if the lexical context is dependent, then the specialization; // is dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:97,depend,dependent,97,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['depend'],['dependent']
Integrability,"// For code in dependent contexts, we'll do this at instantiation time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:15,depend,dependent,15,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['depend'],['dependent']
Integrability,"// For compatibility with other compilers and older versions of Clang,; //; // nested-name-specifier type-name :: ~ type-name; //; // also looks for type-name in the scope. Unfortunately, we can't; // reasonably apply this fallback for dependent nested-name-specifiers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:236,depend,dependent,236,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['depend'],['dependent']
Integrability,"// For coroutines expressions, traverse either the operand; // as written or the implied calls, depending on what the; // derived class requests.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h:96,depend,depending,96,interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h,1,['depend'],['depending']
Integrability,"// For datasets with weight errors or sumW2, the interface to fill; // RooDataHist and RooDataSet is not the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx:49,interface,interface,49,roofit/roofitcore/src/RooAbsData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx,1,['interface'],['interface']
Integrability,"// For dependent noexcept, we can't just take the expression from the old; // prototype. It likely contains references to the old prototype's parameters.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:7,depend,dependent,7,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,1,['depend'],['dependent']
Integrability,"// For dependent types, the diagnostic is deferred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:7,depend,dependent,7,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,"// For dependently-typed local extern declarations and friends, we can't; // perform a correct type check in general until instantiation:; //; // int f();; // template<typename T> void g() { T f(); }; //; // (valid if g() is only instantiated with T = int).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:7,depend,dependently-typed,7,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependently-typed']
Integrability,"// For direct calls:; // Ignore register dependences for call instructions for packetization; // purposes except for those due to r31 and predicate registers.; //; // For indirect calls:; // Same as direct calls + check for true dependences to the register; // used in the indirect call.; //; // We completely ignore Order dependences for call instructions.; //; // For returns:; // Ignore register dependences for return instructions like jumpr,; // dealloc return unless we have dependencies on the explicit uses; // of the registers used by jumpr (like r31) or dealloc return; // (like r29 or r30).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:41,depend,dependences,41,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,5,['depend'],"['dependences', 'dependencies']"
Integrability,"// For each dependant, transfer this node's emitted dependencies to; // it. If the dependant node is ready (i.e. has no unemitted; // dependencies) then notify any pending queries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:12,depend,dependant,12,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,4,['depend'],"['dependant', 'dependencies']"
Integrability,"// For each invariant address, check its last stored value is the result; // of one of our reductions.; //; // We do not check if dependence with loads exists because they are; // currently rejected earlier in LoopAccessInfo::analyzeLoop. In case this; // behaviour changes we have to modify this code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:130,depend,dependence,130,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['depend'],['dependence']
Integrability,"// For each section that remains alive, we want to remove the dead references.; // This either might update the content of the section (e.g. remove symbols; // from symbol table that belongs to removed section) or trigger an error if; // a live section critically depends on a section being removed somehow; // (e.g. the removed section is referenced by a relocation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp:264,depend,depends,264,interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp,1,['depend'],['depends']
Integrability,"// For each select, compute the sinkable dependence chains of the true and; // false operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:41,depend,dependence,41,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,1,['depend'],['dependence']
Integrability,"// For each unknwon option, call ErrorFn with a formatted error message. The; // message includes a suggested alternative option spelling if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Option/OptTable.cpp:64,message,message,64,interpreter/llvm-project/llvm/lib/Option/OptTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Option/OptTable.cpp,2,['message'],['message']
Integrability,"// For each vector width, delegate to a specialized lowering routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:61,rout,routine,61,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['rout'],['routine']
Integrability,"// For equality to 0 of a no-wrap multiply, decompose and test each op:; // X * Y == 0 --> (X == 0) || (Y == 0); // X * Y != 0 --> (X != 0) && (Y != 0); // TODO: This bails out if minsize is set, but if the target doesn't have a; // single instruction multiply for this type, it would likely be; // smaller to decompose.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:29,wrap,wrap,29,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['wrap'],['wrap']
Integrability,// For error messages,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:13,message,messages,13,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['message'],['messages']
Integrability,"// For extended class, unimplemented methods in its protocols will; // be reported in the primary class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:52,protocol,protocols,52,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['protocol'],['protocols']
Integrability,"// For finding modules needing to be imported for fixit messages,; // we need to make the global index cover all modules, so we do that here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:56,message,messages,56,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['message'],['messages']
Integrability,"// For finding modules needing to be imported for fixit messages,; // we need to make the global index cover all modules, so we do that here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:56,message,messages,56,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['message'],['messages']
Integrability,"// For friend function specializations, this is a dependent; // specialization if its semantic context is dependent, its; // type is dependent, or if its template-id is dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:50,depend,dependent,50,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,4,['depend'],['dependent']
Integrability,"// For instance methods, look for ivars in the method's interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:56,interface,interface,56,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['interface'],['interface']
Integrability,"// For instruction that requires multiple iterations, make sure that; // the dependent instruction is not scheduled past the definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:77,depend,dependent,77,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['dependent']
Integrability,"// For integer IVs, if we evaluated the limit in the narrower bitwidth to; // avoid the expensive expansion of the limit expression in the wider type,; // emit a truncate to narrow the IV to the ExitCount type. This is safe; // since we know (from the exit count bitwidth), that we can't self-wrap in; // the narrower type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:293,wrap,wrap,293,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['wrap'],['wrap']
Integrability,"// For internal linkage variables, we don't need an external or weak wrapper.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:69,wrap,wrapper,69,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['wrap'],['wrapper']
Integrability,"// For invalid AAs we can fix dependent AAs that have a required dependence,; // thereby folding long dependence chains in a single step without the need; // to run updates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:30,depend,dependent,30,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,3,['depend'],"['dependence', 'dependent']"
Integrability,// For linker redefined symbols (via --wrap or --defsym) we want to; // switch the linkage to `weak` to prevent IPOs from happening.; // Find the summary in the module for this very GV and record the new; // linkage so that we can switch it when we import the GV.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:39,wrap,wrap,39,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['wrap'],['wrap']
Integrability,"// For message sends and property references, we try to find an; // actual method. FIXME: we should infer retention by selector in; // cases where we don't have an actual method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:7,message,message,7,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['message'],['message']
Integrability,"// For non-PHIs, determine the addressing mode being computed. Note that; // the result may differ depending on what other uses our candidate; // addressing instructions might have.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:99,depend,depending,99,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['depend'],['depending']
Integrability,"// For now the following line would lead to the (unwanted) instantiation; // of class template. This could/would need to be resurrected only if; // we re-introduce so sort of automatic instantiation. However this would; // have to include carefull look at the template parameter to avoid; // creating instance we can not really use (if the parameter are only forward; // declaration or do not have all the necessary interfaces).; // TClingClassInfo tci(fInterpreter, classname);; // if (1 || !tci.IsValid()) {",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:416,interface,interfaces,416,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['interface'],['interfaces']
Integrability,"// For now we handle only constant steps.; //; // TODO: Handle a nonconstant Step given AddRec<NUW>. If the; // AddRec is NUW, then (in an unsigned sense) it cannot be counting up to wrap; // to 0, it must be counting down to equal 0. Consequently, N = Start / -Step.; // We have not yet seen any such cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:183,wrap,wrap,183,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,"// For now, allow missing resource libraries to support developers who may; // not have compiler-rt checked out or integrated into their build (unless; // we explicitly force linking with this library).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:115,integrat,integrated,115,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['integrat'],['integrated']
Integrability,"// For now, allow missing resource libraries to support developers who may; // not have compiler-rt checked out or integrated into their build.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:115,integrat,integrated,115,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['integrat'],['integrated']
Integrability,"// For now, no need to lock this routines as fRuntimeProperties is; // the only atomic set here and this is done at the end; // and there is no downside if the execution is done twice.; // Note SetRuntimeProperties is set to const as it is technically; // thread-safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:33,rout,routines,33,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['rout'],['routines']
Integrability,"// For now, signedness of polynomial types depends on target",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:43,depend,depends,43,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,1,['depend'],['depends']
Integrability,"// For now, the only problematic case is a generic lambda's templated; // call operator, so we don't need to look for all the other ways we; // could have reached a dependent parameter pack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp:165,depend,dependent,165,interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,1,['depend'],['dependent']
Integrability,"// For others:; // Do nothing. Retained out parameters will either point to a +1 reference; // or NULL, but the way you check for failure differs depending on the; // API. Consequently, we don't have a good way to track them yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:146,depend,depending,146,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,1,['depend'],['depending']
Integrability,"// For our task, both backward and forward approaches suite well.; // However, in order to report better diagnostics, we decided to go with; // backward analysis.; //; // Let's consider the following CFG and how forward and backward analyses; // will work for it.; //; // FORWARD: | BACKWARD:; // #1 | #1; // +---------+ | +-----------+; // | if | | |MaybeCalled|; // +---------+ | +-----------+; // |NotCalled| | | if |; // +---------+ | +-----------+; // / \ | / \; // #2 / \ #3 | #2 / \ #3; // +----------------+ +---------+ | +----------------+ +---------+; // | foo() | | ... | | |DefinitelyCalled| |NotCalled|; // +----------------+ +---------+ | +----------------+ +---------+; // |DefinitelyCalled| |NotCalled| | | foo() | | ... |; // +----------------+ +---------+ | +----------------+ +---------+; // \ / | \ /; // \ #4 / | \ #4 /; // +-----------+ | +---------+; // | ... | | |NotCalled|; // +-----------+ | +---------+; // |MaybeCalled| | | ... |; // +-----------+ | +---------+; //; // The most natural way to report lacking call in the block #3 would be to; // message that the false branch of the if statement in the block #1 doesn't; // have a call. And while with the forward approach we'll need to find a; // least common ancestor or something like that to find the 'if' to blame,; // backward analysis gives it to us out of the box.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:1075,message,message,1075,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,1,['message'],['message']
Integrability,"// For predicated instructions, if the predicates are complements then; // there can be no dependence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:91,depend,dependence,91,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['depend'],['dependence']
Integrability,"// For protocol properties, synthesized and dynamic have no meaning, so we; // reuse these flags to indicate that this is a protocol property (both set; // has no meaning, as a property can't be both synthesized and dynamic)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:7,protocol,protocol,7,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,2,['protocol'],['protocol']
Integrability,"// For protocols, this is an objc_method_description_list, which has; // a slightly different structure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:7,protocol,protocols,7,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['protocol'],['protocols']
Integrability,"// For purposes of this check, interfaces match too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:31,interface,interfaces,31,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['interface'],['interfaces']
Integrability,"// For rare, surprising errors (e.g. ""out of file handles""), diag the EC; // message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:77,message,message,77,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,1,['message'],['message']
Integrability,"// For sequential GEP indices (all except those into structs), the index value; // can be translated into a byte offset by multiplying with an element stride.; // This function returns this stride, which both depends on the element type,; // and the containing aggregate type, as vectors always tightly bit-pack their; // elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GetElementPtrTypeIterator.h:209,depend,depends,209,interpreter/llvm-project/llvm/include/llvm/IR/GetElementPtrTypeIterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GetElementPtrTypeIterator.h,1,['depend'],['depends']
Integrability,"// For simplicity and speed, data dependency check can be; // avoided if read from memory doesn't exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:34,depend,dependency,34,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,1,['depend'],['dependency']
Integrability,"// For some instructions, it is interesting to measure how it's performance; // characteristics differ depending on it's operands.; // This allows us to produce all the interesting variants.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:103,depend,depending,103,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,1,['depend'],['depending']
Integrability,"// For stores, it's a bit trickier and it depends on whether we're storing; // the full vector or not. If we're storing the full vector, we don't need; // to know the current value. If this is a store of a single element, we; // need to know the value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp:42,depend,depends,42,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp,1,['depend'],['depends']
Integrability,"// For symbols re-defined with linker -wrap and -defsym options,; // set the linkage to weak to inhibit IPO. The linkage will be; // restored by the linker.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:39,wrap,wrap,39,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['wrap'],['wrap']
Integrability,"// For synthesized ivars, use the location of its name in the; // corresponding @synthesize. If there isn't one, use the containing; // @implementation's location, rather than the property's location,; // otherwise the header file containing the @interface will have different; // indexing contents based on whether the @implementation was present or; // not in the translation unit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp:247,interface,interface,247,interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp,1,['interface'],['interface']
Integrability,"// For tail calls lower the arguments to the 'real' stack slot.; //; // Force all the incoming stack arguments to be loaded from the stack; // before any new outgoing arguments are stored to the stack, because the; // outgoing stack slots may alias the incoming argument stack slots, and; // the alias isn't otherwise explicit. This is slightly more conservative; // than necessary, because it means that each store effectively depends; // on every argument instead of just those arguments it would clobber.; //; // Do not flag preceding copytoreg stuff together with the following stuff.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:428,depend,depends,428,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['depend'],['depends']
Integrability,"// For targets where __sync_* routines are reliably available, we use them; // if necessary.; //; // ARM Linux always supports 64-bit atomics through kernel-assisted atomic; // routines (kernel 3.1 or later). FIXME: Not with compiler-rt?; //; // ARMv6 targets have native instructions in ARM mode. For Thumb mode,; // such targets should provide __sync_* routines, which use the ARM mode; // instructions. (ARMv6 doesn't have dmb, but it has an equivalent; // encoding; see ARMISD::MEMBARRIER_MCR.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:30,rout,routines,30,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,3,['rout'],['routines']
Integrability,"// For targets which wrap address, unwrap for analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:21,wrap,wrap,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['wrap'],['wrap']
Integrability,"// For template specialization types, we want to match the template; // declaration, as long as the type is still dependent, and otherwise the; // declaration of the instantiated tag type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h:114,depend,dependent,114,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,1,['depend'],['dependent']
Integrability,// For the GISel interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SwitchLoweringUtils.h:17,interface,interface,17,interpreter/llvm-project/llvm/include/llvm/CodeGen/SwitchLoweringUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SwitchLoweringUtils.h,1,['interface'],['interface']
Integrability,"// For the error message, use the original type server name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewReader.cpp:17,message,message,17,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewReader.cpp,2,['message'],['message']
Integrability,"// For the real scheduling we use a more sophisticated ready-list: it is; // sorted by the original instruction location. This lets the final schedule; // be as close as possible to the original instruction order.; // WARNING: If changing this order causes a correctness issue, that means; // there is some missing dependence edge in the schedule data graph.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:315,depend,dependence,315,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['depend'],['dependence']
Integrability,"// For the size() == 1 case, we simply return that one matcher.; // No need to wrap it in a variadic operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h:79,wrap,wrap,79,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,1,['wrap'],['wrap']
Integrability,"// For the topmost routine, get file/line info from line table.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp:19,rout,routine,19,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,1,['rout'],['routine']
Integrability,"// For these purposes, a method in an @implementation overrides a; // declaration in the @interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:90,interface,interface,90,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['interface'],['interface']
Integrability,"// For these, lower word of output in these operations, depends only on; // the lower word of input. So, we check all uses only read lower word.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:56,depend,depends,56,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,1,['depend'],['depends']
Integrability,"// For this case, the list will be immutable once constructed; // (i.e. in this case, by the end of this routine).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:105,rout,routine,105,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['rout'],['routine']
Integrability,"// For unmasked ""VOp"" with rounding mode operand, that is interfaces like; // (..., rm, vl) or (..., rm, vl, policy).; // Its masked version is (..., vm, rm, vl, policy).; // Check the rounding mode pseudo nodes under RISCVInstrInfoVPseudos.td",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:58,interface,interfaces,58,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['interface'],['interfaces']
Integrability,"// For unqualified lookup in a class template in MSVC mode, look into; // dependent base classes where the primary class template is known.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:74,depend,dependent,74,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['depend'],['dependent']
Integrability,// For use with PostRAScheduling: get the anti-dependence breaking that should; // be performed before post-RA scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:47,depend,dependence,47,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,2,['depend'],['dependence']
Integrability,"// For use with PostRAScheduling: in CriticalPathRCs, return any register; // classes that should only be considered for anti-dependence breaking if they; // are on the critical path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:126,depend,dependence,126,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,1,['depend'],['dependence']
Integrability,"// For valid code, we should always know the primary interface; // declaration by now, however for invalid code we'll keep parsing; // but we won't find the primary interface and IDecl will be nil.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:53,interface,interface,53,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['interface'],['interface']
Integrability,// For z13 we prefer LDE over LE to avoid partial register dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp:59,depend,dependencies,59,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp,1,['depend'],['dependencies']
Integrability,// For z13 we prefer LDR over LER to avoid partial register dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:60,depend,dependencies,60,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,1,['depend'],['dependencies']
Integrability,"// Force RooRealIntegral to offer all observables for internal integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAddition.h:63,integrat,integration,63,roofit/roofitcore/inc/RooAddition.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAddition.h,2,['integrat'],['integration']
Integrability,"// Force all observables to be offered for internal integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCachedReal.h:52,integrat,integration,52,roofit/roofitcore/inc/RooAbsCachedReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCachedReal.h,1,['integrat'],['integration']
Integrability,"// Force all the incoming stack arguments to be loaded from the stack; // before any new outgoing arguments are stored to the stack, because the; // outgoing stack slots may alias the incoming argument stack slots, and; // the alias isn't otherwise explicit. This is slightly more conservative; // than necessary, because it means that each store effectively depends; // on every argument instead of just those arguments it would clobber.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:359,depend,depends,359,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,2,['depend'],['depends']
Integrability,"// Force internal handling of integration of given observable if any; // of the product terms depend on it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx:30,integrat,integration,30,roofit/roofitcore/src/RooProduct.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx,2,"['depend', 'integrat']","['depend', 'integration']"
Integrability,"// Force lambda numbering in CUDA/HIP as we need to name lambdas following; // ODR. Both device- and host-compilation need to have a consistent naming; // on kernel functions. As lambdas are potential part of these `__global__`; // function names, they needs numbering following ODR.; // Also force for SYCL, since we need this for the; // __builtin_sycl_unique_stable_name implementation, which depends on lambda; // mangling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:396,depend,depends,396,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,1,['depend'],['depends']
Integrability,// Force linking against the system libraries sanitizers depends on; // (see PR15823 why this is necessary).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:57,depend,depends,57,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,1,['depend'],['depends']
Integrability,"// Force numerical integration for the reference value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRealIntegral.cxx:19,integrat,integration,19,roofit/roofitcore/test/testRooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRealIntegral.cxx,1,['integrat'],['integration']
Integrability,"// Force using numeric integration; // use special numeric integrator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/PiecewiseInterpolation.cxx:23,integrat,integration,23,roofit/histfactory/src/PiecewiseInterpolation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/PiecewiseInterpolation.cxx,2,['integrat'],"['integration', 'integrator']"
Integrability,"// Forcibly abandon all the inner analyses with dependencies, but; // invalidate nothing else.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:48,depend,dependencies,48,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,1,['depend'],['dependencies']
Integrability,// Forget that the previous declaration is the injected-class-name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:47,inject,injected-class-name,47,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['inject'],['injected-class-name']
Integrability,// Form id<protocol-list>.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:11,protocol,protocol-list,11,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['protocol'],['protocol-list']
Integrability,// Form vpaddl.sN or vpaddl.uN depending on the kind of extension.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:31,depend,depending,31,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['depend'],['depending']
Integrability,"// FormObjects, Patterns etc. might use other FormObjects/Patterns/Images; // which means their resource dictionaries must contain the already resolved; // object ids. For this reason we defer the serialization of the resource; // dicts until all objects have been serialized and have object ids.; //; // In order to prevent cyclic dependencies (which Adobe Reader doesn't like),; // we only put all oids that are smaller than the oid of the object the; // resource dict belongs to. This is correct behavior, since the streams; // may only use other objects that have already been defined and thus appear; // earlier in their respective collection.; // Currently, this only affects tiling patterns, but a (more) correct; // implementation of FormObjects would also define their own resource dicts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:332,depend,dependencies,332,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['depend'],['dependencies']
Integrability,"// Format text given a format string and replacement parameters.; //; // ===General Description===; //; // Formats textual output. `Fmt` is a string consisting of one or more; // replacement sequences with the following grammar:; //; // rep_field ::= ""{"" index ["","" layout] ["":"" format] ""}""; // index ::= <non-negative integer>; // layout ::= [[[char]loc]width]; // format ::= <any string not containing ""{"" or ""}"">; // char ::= <any character except ""{"" or ""}"">; // loc ::= ""-"" | ""="" | ""+""; // width ::= <positive integer>; //; // index - A non-negative integer specifying the index of the item in the; // parameter pack to print. Any other value is invalid.; // layout - A string controlling how the field is laid out within the available; // space.; // format - A type-dependent string used to provide additional options to; // the formatting operation. Refer to the documentation of the; // various individual format providers for per-type options.; // char - The padding character. Defaults to ' ' (space). Only valid if; // `loc` is also specified.; // loc - Where to print the formatted text within the field. Only valid if; // `width` is also specified.; // '-' : The field is left aligned within the available space.; // '=' : The field is centered within the available space.; // '+' : The field is right aligned within the available space (this; // is the default).; // width - The width of the field within which to print the formatted text.; // If this is less than the required length then the `char` and `loc`; // fields are ignored, and the field is printed with no leading or; // trailing padding. If this is greater than the required length,; // then the text is output according to the value of `loc`, and padded; // as appropriate on the left and/or right by `char`.; //; // ===Special Characters===; //; // The characters '{' and '}' are reserved and cannot appear anywhere within a; // replacement sequence. Outside of a replacement sequence, in order to print; // a literal '{' ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadic.h:772,depend,dependent,772,interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadic.h,1,['depend'],['dependent']
Integrability,// Format the SFINAE diagnostic into the argument string.; // FIXME: Add a general mechanism to include a PartialDiagnostic *'s; // formatted message in another diagnostic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:142,message,message,142,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['message'],['message']
Integrability,// Format the message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/LogDiagnosticPrinter.cpp:14,message,message,14,interpreter/llvm-project/clang/lib/Frontend/LogDiagnosticPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/LogDiagnosticPrinter.cpp,1,['message'],['message']
Integrability,"// Formula for integration over m when p=0.5",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooArgusBG.cxx:15,integrat,integration,15,roofit/roofit/src/RooArgusBG.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooArgusBG.cxx,1,['integrat'],['integration']
Integrability,// Forward interface declarations; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:11,interface,interface,11,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,1,['interface'],['interface']
Integrability,// Forward remarks passes to the LLVM backend in the wrapper.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:53,wrap,wrapper,53,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['wrap'],['wrapper']
Integrability,"// Forward slash is allowed to be unquoted, but we quote it anyway. We have; // many tests that use FileCheck against YAML output, and this output often; // contains paths. If we quote backslashes but not forward slashes then; // paths will come out either quoted or unquoted depending on which platform; // the test is run on, making FileCheck comparisons difficult.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:276,depend,depending,276,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,1,['depend'],['depending']
Integrability,// ForwardingMM - Adapter to connect MCJIT to Orc's Remote; // memory manager.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h:18,Adapter,Adapter,18,interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/ForwardingMemoryManager.h,1,['Adapter'],['Adapter']
Integrability,"// Found PDF depending on arg; // If multiple PDFs depend on arg directGen is not safe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:13,depend,depending,13,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,2,['depend'],"['depend', 'depending']"
Integrability,"// Found one possible dependency, keep track of it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:22,depend,dependency,22,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,1,['depend'],['dependency']
Integrability,// Found the injected-class-name for a class template. This will be; // dumped as part of its surrounding class so we don't need to dump it; // here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTNodeTraverser.h:13,inject,injected-class-name,13,interpreter/llvm-project/clang/include/clang/AST/ASTNodeTraverser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTNodeTraverser.h,2,['inject'],['injected-class-name']
Integrability,"// Friend declarations in dependent contexts aren't anonymous in the usual; // sense, but they cannot be found by name lookup in their semantic context; // (or indeed in any context), so we treat them as anonymous.; //; // This doesn't apply to friend tag decls; Sema makes those available to name; // lookup in the surrounding context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp:26,depend,dependent,26,interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTCommon.cpp,1,['depend'],['dependent']
Integrability,// Friend function declarations are dependent if their *lexical*; // context is dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:36,depend,dependent,36,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,2,['depend'],['dependent']
Integrability,"// From asking WolframAlpha: integrate exp(-x/tau) * (x / tau)^2 over x.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTruthModel.cxx:29,integrat,integrate,29,roofit/roofitcore/src/RooTruthModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTruthModel.cxx,1,['integrat'],['integrate']
Integrability,"// From asking WolframAlpha: integrate exp(-x/tau) over x.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTruthModel.cxx:29,integrat,integrate,29,roofit/roofitcore/src/RooTruthModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTruthModel.cxx,1,['integrat'],['integrate']
Integrability,"// From asking WolframAlpha: integrate exp(-x/tau)* x / tau over x.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTruthModel.cxx:29,integrat,integrate,29,roofit/roofitcore/src/RooTruthModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTruthModel.cxx,1,['integrat'],['integrate']
Integrability,"// From asking WolframAlpha: integrate exp(-x/tau)*cos(x*m) over x.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTruthModel.cxx:29,integrat,integrate,29,roofit/roofitcore/src/RooTruthModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTruthModel.cxx,1,['integrat'],['integrate']
Integrability,"// From asking WolframAlpha: integrate exp(-x/tau)*cosh(x*m/2) over x.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTruthModel.cxx:29,integrat,integrate,29,roofit/roofitcore/src/RooTruthModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTruthModel.cxx,1,['integrat'],['integrate']
Integrability,"// From asking WolframAlpha: integrate exp(-x/tau)*sin(x*m) over x.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTruthModel.cxx:29,integrat,integrate,29,roofit/roofitcore/src/RooTruthModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTruthModel.cxx,1,['integrat'],['integrate']
Integrability,"// From asking WolframAlpha: integrate exp(-x/tau)*sinh(x*m/2) over x.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTruthModel.cxx:29,integrat,integrate,29,roofit/roofitcore/src/RooTruthModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTruthModel.cxx,1,['integrat'],['integrate']
Integrability,"// From no-self-wrap, we need to then prove no-(un)signed-wrap. This; // follows trivially from the fact that every (un)signed-wrapped, but; // not self-wrapped value must be LT than the last value before; // (un)signed wrap. Since we know that last value didn't exit, nor; // will any smaller one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:16,wrap,wrap,16,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,5,['wrap'],"['wrap', 'wrapped']"
Integrability,// From the first-implied list we have to finish building the final protocol; // list. If a protocol in the first-implied list was already implied via some; // inheritance path through some other protocols then it would be redundant to; // add it here and so we skip over it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:68,protocol,protocol,68,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,3,['protocol'],"['protocol', 'protocols']"
Integrability,"// Full numeric integration over requested observables maps always to code zero",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx:16,integrat,integration,16,roofit/roofitcore/src/RooMultiVarGaussian.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx,1,['integrat'],['integration']
Integrability,"// Function Template interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TInterpreter.h:21,interface,interface,21,core/meta/inc/TInterpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TInterpreter.h,2,['interface'],['interface']
Integrability,// Function specialization. No need to waste extra space wrapping with a; // std::optional.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:57,wrap,wrapping,57,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['wrap'],['wrapping']
Integrability,"// FunctionDecl interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TInterpreter.h:16,interface,interface,16,core/meta/inc/TInterpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TInterpreter.h,1,['interface'],['interface']
Integrability,"// FunctionDecl interface ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.h:16,interface,interface,16,core/metacling/src/TCling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.h,1,['interface'],['interface']
Integrability,"// Functions needed beyond the interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/LossFunction.h:31,interface,interface,31,tmva/tmva/inc/TMVA/LossFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/LossFunction.h,1,['interface'],['interface']
Integrability,"// Functions that interface with the parallel library used as a backend",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TThreadExecutor.hxx:18,interface,interface,18,core/imt/inc/ROOT/TThreadExecutor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TThreadExecutor.hxx,1,['interface'],['interface']
Integrability,"// Further reduce number of conforming protocols. If protocol P1 is in the list; // protocol P2 (P2<P1>), No need to include P1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:39,protocol,protocols,39,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,3,['protocol'],"['protocol', 'protocols']"
Integrability,"// GCC 4.x doesn't have the proper UTF-8 conversion routines. So use the; // LLVM conversion routines (which require a buffer 4x string length).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValuePrinter.cpp:52,rout,routines,52,interpreter/cling/lib/Interpreter/ValuePrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValuePrinter.cpp,2,['rout'],['routines']
Integrability,"// GCC's choice of assembler options for inline assembly code ('at', 'macro'; // and 'reorder') is different from LLVM's choice for generated code ('noat',; // 'nomacro' and 'noreorder').; // In order to maintain compatibility with inline assembly code which depends; // on GCC's assembler options being used, we have to switch to those options; // for the duration of the inline assembly block and then switch back.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp:259,depend,depends,259,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAsmPrinter.cpp,1,['depend'],['depends']
Integrability,"// GET_GICOMBINER_DEPS, which pulls in extra dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp:45,depend,dependencies,45,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,1,['depend'],['dependencies']
Integrability,"// GL 3 component vector helper/wrapper class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h:32,wrap,wrapper,32,graf3d/gl/inc/TGLUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h,1,['wrap'],['wrapper']
Integrability,"// GL 3 component vertex helper/wrapper class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h:32,wrap,wrapper,32,graf3d/gl/inc/TGLUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h,1,['wrap'],['wrapper']
Integrability,"// GL line wrapper class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h:11,wrap,wrapper,11,graf3d/gl/inc/TGLUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h,1,['wrap'],['wrapper']
Integrability,"// GL matrix helper/wrapper class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h:20,wrap,wrapper,20,graf3d/gl/inc/TGLUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h,1,['wrap'],['wrapper']
Integrability,"// GL plane helper/wrapper class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h:19,wrap,wrapper,19,graf3d/gl/inc/TGLUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h,1,['wrap'],['wrapper']
Integrability,"// GL rect helper/wrapper class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h:18,wrap,wrapper,18,graf3d/gl/inc/TGLUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h,1,['wrap'],['wrapper']
Integrability,"// GL-interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/LinkDef1.h:6,interface,interface,6,graf3d/eve/inc/LinkDef1.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/LinkDef1.h,1,['interface'],['interface']
Integrability,"// GL-scene filled via TPad-TVirtualViewer interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLScenePad.h:43,interface,interface,43,graf3d/gl/inc/TGLScenePad.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLScenePad.h,1,['interface'],['interface']
Integrability,"// GNU C permits a K&R definition to follow a prototype declaration; // if the declared types of the parameters in the K&R definition; // match the types in the prototype declaration, even when the; // promoted types of the parameters from the K&R definition differ; // from the types in the prototype. GCC then keeps the types from; // the prototype.; //; // If a variadic prototype is followed by a non-variadic K&R definition,; // the K&R definition becomes variadic. This is sort of an edge case, but; // it's legal per the standard depending on how you read C99 6.7.5.3p15 and; // C99 6.9.1p8.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:537,depend,depending,537,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['depending']
Integrability,"// GNU ObjC bizarre protocol extension: <proto1,proto2> with implicit 'id'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:20,protocol,protocol,20,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,['protocol'],['protocol']
Integrability,"// GNU windres passes the arguments almost as-is on to popen() (it only; // backslash escapes spaces in the arguments), where a shell would; // unescape backslash escapes for quotes and similar. This means that; // when calling GNU windres, callers need to double escape chars like; // quotes, e.g. as -DSTRING=\\\""1.2.3\\\"".; //; // Exactly how the arguments are interpreted depends on the platform; // though - but the cases where this matters (where callers would have; // done this double escaping) probably is confined to cases like these; // quoted string defines, and those happen to work the same across unix; // and windows.; //; // If GNU windres is executed with --use-temp-file, it doesn't use; // popen() to invoke the preprocessor, but uses another function which; // actually preserves tricky characters better. To mimic this behaviour,; // don't unescape arguments here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/llvm-rc.cpp:376,depend,depends,376,interpreter/llvm-project/llvm/tools/llvm-rc/llvm-rc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/llvm-rc.cpp,1,['depend'],['depends']
Integrability,"// GPLUSPLUS_TOOL_INCLUDE_DIR. If Triple is not empty, add a target-dependent; // include directory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:68,depend,dependent,68,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['depend'],['dependent']
Integrability,"// GSL Integrator. Will really get it only if MathMore enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx:7,Integrat,Integrator,7,roofit/roofitcore/src/RooBinSamplingPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx,1,['Integrat'],['Integrator']
Integrability,"// GSL integrator is now in RooFitMore and it register itself; //RooAdaptiveGaussKronrodIntegrator1D::registerIntegrator(*this) ;; //RooGaussKronrodIntegrator1D::registerIntegrator(*this) ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumIntFactory.cxx:7,integrat,integrator,7,roofit/roofitcore/src/RooNumIntFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumIntFactory.cxx,1,['integrat'],['integrator']
Integrability,"// GUI thread message handler func",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx:14,message,message,14,core/winnt/src/TWinNTSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx,1,['message'],['message']
Integrability,// Gather dependences unless we accumulated MaxDependences; // dependences. In that case return as soon as we find the first; // unsafe dependence. This puts a limit on this quadratic; // algorithm.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:10,depend,dependences,10,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,3,['depend'],"['dependence', 'dependences']"
Integrability,// Gather the set of reserved registers (depends on function's calling; // convention and target machine).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h:41,depend,depends,41,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.h,1,['depend'],['depends']
Integrability,"// Generally we try to report as many issues as possible at once, but in; // this case it's not clear what should we be comparing the size of the; // scalar with: the size of the whole vector or its lane. Instead of; // making an arbitrary choice and emitting not so helpful message, let's; // avoid the extra noise and stop here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:275,message,message,275,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,1,['message'],['message']
Integrability,"// Generate EH Info Table.; // The EH Info Table, aka, 'compat unwind section' on AIX, have the following; // format: struct eh_info_t {; // unsigned version; /* EH info verion 0 */; // #if defined(__64BIT__); // char _pad[4]; /* padding */; // #endif; // unsigned long lsda; /* Pointer to LSDA */; // unsigned long personality; /* Pointer to the personality routine */; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp:359,rout,routine,359,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp,1,['rout'],['routine']
Integrability,"// Generate a reference to the class pointer, which will be the receiver.; // Assumes that the method was introduced in the class that should be; // messaged (avoids pulling it out of the result type).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:149,message,messaged,149,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['message'],['messaged']
Integrability,// Generate an error node. This isn't a sink since; // a null mutex just means no synchronization occurs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp:82,synchroniz,synchronization,82,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCAtSyncChecker.cpp,1,['synchroniz'],['synchronization']
Integrability,"// Generate classes entry for Flang clauses in the Flang parse-tree; // If the clause as a non-generic class, no entry is generated.; // If the clause does not hold a value, an EMPTY_CLASS is used.; // If the clause class is generic then a WRAPPER_CLASS is used. When the value; // is optional, the value class is wrapped into a std::optional.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DirectiveEmitter.cpp:314,wrap,wrapped,314,interpreter/llvm-project/llvm/utils/TableGen/DirectiveEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DirectiveEmitter.cpp,1,['wrap'],['wrapped']
Integrability,"// Generate delta-t dependent",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooBCPEffDecay.cxx:20,depend,dependent,20,roofit/roofit/src/RooBCPEffDecay.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooBCPEffDecay.cxx,5,['depend'],['dependent']
Integrability,// Generate epilogue instrumentation. The epilogue intrumentation can be; // function-based or inlined depending on which mechanism the target is; // providing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:103,depend,depending,103,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,1,['depend'],['depending']
Integrability,"// Generate function setup to be used in callbacks (wrappers and overrides).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx:52,wrap,wrappers,52,bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Utility.cxx,1,['wrap'],['wrappers']
Integrability,"// Generate invoke wrapper seqence with preamble and postamble; // Preamble:; // __THREW__ = 0;; // Postamble:; // %__THREW__.val = __THREW__; __THREW__ = 0;; // Returns %__THREW__.val, which indicates whether an exception is thrown (or; // whether longjmp occurred), for future use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:19,wrap,wrapper,19,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,1,['wrap'],['wrapper']
Integrability,// Generate routines that check the names of sub-rules.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:12,rout,routines,12,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,1,['rout'],['routines']
Integrability,"// Generate the dependency filename",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:16,depend,dependency,16,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['depend'],['dependency']
Integrability,"// Generate the dependency via standard output, not searching the; // standard include directories,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:16,depend,dependency,16,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['depend'],['dependency']
Integrability,// Generate the message send.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:16,message,message,16,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['message'],['message']
Integrability,// Generate the move bracket error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:35,message,message,35,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['message'],['message']
Integrability,// Generate the widened condition for the forward loop:; // guardStart u< guardLimit &&; // latchLimit <pred> guardLimit - 1 - guardStart + latchStart; // where <pred> depends on the latch condition predicate. See the file; // header comment for the reasoning.; // guardLimit - guardStart + latchStart - 1,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:168,depend,depends,168,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,1,['depend'],['depends']
Integrability,"// Generate uniform variables (non-dependents)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenContext.cxx:35,depend,dependents,35,roofit/roofitcore/src/RooGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenContext.cxx,2,['depend'],['dependents']
Integrability,"// Generated source and branch proxy interface are out of sync.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TBranchProxyTemplate.h:37,interface,interface,37,tree/treeplayer/inc/TBranchProxyTemplate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TBranchProxyTemplate.h,1,['interface'],['interface']
Integrability,// Generates code templates that has a self-dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h:44,depend,dependency,44,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h,1,['depend'],['dependency']
Integrability,"// Genereated code calls putchar, and output is not guaranteed without fflush.; // The better place for fflush(stdout) call would be the generated code, but it; // is unmanageable because stdout linkage name depends on stdlib implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainFDriver.cpp:208,depend,depends,208,interpreter/llvm-project/llvm/examples/BrainF/BrainFDriver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainFDriver.cpp,1,['depend'],['depends']
Integrability,"// Generic message handler",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMessageHandler.h:11,message,message,11,core/base/inc/TMessageHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMessageHandler.h,1,['message'],['message']
Integrability,"// Generic message: read out the type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:11,message,message,11,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,1,['message'],['message']
Integrability,"// GenericSelectionExpr is followed by several trailing objects.; // They are (in order):; //; // * A single Stmt * for the controlling expression or a TypeSourceInfo * for; // the controlling type, depending on the result of isTypePredicate() or; // isExprPredicate().; // * An array of getNumAssocs() Stmt * for the association expressions.; // * An array of getNumAssocs() TypeSourceInfo *, one for each of the; // association expressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:199,depend,depending,199,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['depend'],['depending']
Integrability,"// Get a message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx:9,message,message,9,net/net/src/TApplicationServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx,1,['message'],['message']
Integrability,"// Get a promoted operand and sign or zero extend it to the final size; // (depending on TargetLoweringInfo::isSExtCheaperThanZExt). For a given; // subtarget and type, the choice of sign or zero-extension will be; // consistent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h:76,depend,depending,76,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h,1,['depend'],['depending']
Integrability,// Get all alive instructions that depend on the current instruction.; // Takes Instruction* instead of index because the instruction is already; // shuffled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp:35,depend,depend,35,interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp,1,['depend'],['depend']
Integrability,"// Get an instance of the interface class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSocket.cxx:26,interface,interface,26,net/net/src/TSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSocket.cxx,1,['interface'],['interface']
Integrability,"// Get back startup message of proofserv (we are now talking with; // the real proofserver and not anymore with the proofd front-end)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlaveLite.cxx:20,message,message,20,proof/proof/src/TSlaveLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlaveLite.cxx,1,['message'],['message']
Integrability,"// Get client protocol",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServLite.cxx:14,protocol,protocol,14,proof/proof/src/TProofServLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServLite.cxx,1,['protocol'],['protocol']
Integrability,// Get constant for the default value (0 or 1 depending on which; // function).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:46,depend,depending,46,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,1,['depend'],['depending']
Integrability,// Get dependencies from PHIs in the trace successor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:7,depend,dependencies,7,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,1,['depend'],['dependencies']
Integrability,// Get matching invoke wrapper based on callee signature,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:23,wrap,wrapper,23,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,1,['wrap'],['wrapper']
Integrability,"// Get message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:7,message,message,7,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['message'],['message']
Integrability,"// Get next message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx:12,message,message,12,proof/proofplayer/src/TPacketizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx,2,['message'],['message']
Integrability,"// Get platform dependent values of some macros.; // Try our best to parse this from the Preprocessor, otherwise fallback to a; // default value (what is found in a library header).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:16,depend,dependent,16,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,1,['depend'],['dependent']
Integrability,"// Get protocol first; // Failure typically indicate special actions like cleanup; // which do not need additional work; // The calling program will then decide what to do",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:7,protocol,protocol,7,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['protocol'],['protocol']
Integrability,"// Get server protocol level",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSocket.cxx:14,protocol,protocol,14,net/net/src/TSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSocket.cxx,1,['protocol'],['protocol']
Integrability,"// Get the @interface declaration for a (possibly-qualified) Objective-C; // object pointer type, e.g., NSString*",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:12,interface,interface,12,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,1,['interface'],['interface']
Integrability,// Get the @interface declaration for an Objective-C object type,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:12,interface,interface,12,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,1,['interface'],['interface']
Integrability,// Get the LHS object's interface type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,interface,interface,24,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['interface'],['interface']
Integrability,// Get the PAL version major (idx 0) or minor (idx 1). This is an internal; // helper for the public wrapper functions that request Major or Minor,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUPALMetadata.h:101,wrap,wrapper,101,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUPALMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUPALMetadata.h,1,['wrap'],['wrapper']
Integrability,"// Get the actual kernel, could be the caller of the anchor scope if we have; // a debug wrapper.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:89,wrap,wrapper,89,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['wrap'],['wrapper']
Integrability,// Get the class for a C++ injected-class-name,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:27,inject,injected-class-name,27,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,1,['inject'],['injected-class-name']
Integrability,"// Get the count of DS_WRITES with V_PERM predecessors which; // have loop carried dependencies (WAR) on the same VMEM_READs.; // We consider partial overlap as a miss -- in other words,; // for a given DS_W, we only consider another DS_W as matching; // if there is a corresponding (in terms of the VMEM_R it uses) V_PERM pred; // for every V_PERM pred of this DS_W.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:83,depend,dependencies,83,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,1,['depend'],['dependencies']
Integrability,"// Get the dependence distance, stride, type size and what access writes for; // the dependence between A and B.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:11,depend,dependence,11,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,2,['depend'],['dependence']
Integrability,"// Get the dependence distance, stride, type size in whether i is a write for; // the dependence between A and B. Returns a DepType, if we can prove there's; // no dependence or the analysis fails. Outlined to lambda to limit he scope; // of various temporary variables, like A/BPtr, StrideA/BPtr and others.; // Returns either the dependence result, if it could already be determined, or a; // tuple with (Distance, Stride, TypeSize, AIsWrite, BIsWrite).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:11,depend,dependence,11,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,4,['depend'],['dependence']
Integrability,"// Get the dependency info for Pointer in BB. If we have cached; // information, we will use it, otherwise we compute it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:11,depend,dependency,11,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['dependency']
Integrability,// Get the error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:17,message,message,17,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,1,['message'],['message']
Integrability,"// Get the input data dependencies of a PHI instruction, using Pred as the; // preferred predecessor.; // This will add at most one dependency to Deps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:22,depend,dependencies,22,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,2,['depend'],"['dependencies', 'dependency']"
Integrability,// Get the local instance/class method declared in this interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:56,interface,interface,56,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,2,['interface'],['interface']
Integrability,"// Get the maximum safe dependence distance in bits computed by LAA.; // It is computed by MaxVF * sizeOf(type) * 8, where type is taken from; // the memory accesses that is most restrictive (involved in the smallest; // dependence distance).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:24,depend,dependence,24,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,['depend'],['dependence']
Integrability,// Get the registers on which the loop controlling compare instruction; // depends.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp:75,depend,depends,75,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,1,['depend'],['depends']
Integrability,"// Get the standard interface for this object, but ignore the symbols field.; // We'll handle that manually to include promotion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:20,interface,interface,20,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,1,['interface'],['interface']
Integrability,"// Get the target from the triple. If a triple is not specified, then select; // the default triple for the host. If the triple doesn't correspond to any; // registered target, then exit with an error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:201,message,message,201,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,1,['message'],['message']
Integrability,// Get the total trip count from the count by adding 1. This may wrap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:65,wrap,wrap,65,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,"// Get the type of the parameter for deduction. If it's a (dependent) array; // or function type, we will not have decayed it yet, so do that now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:59,depend,dependent,59,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['depend'],['dependent']
Integrability,// Get the type used for calculating wraparound.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp:37,wrap,wraparound,37,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,2,['wrap'],['wraparound']
Integrability,// Get the unique string identifier for this dependence and cache the; // result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:45,depend,dependence,45,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['depend'],['dependence']
Integrability,"// Get the value in the widest-possible width. What is ""widest"" depends on; // whether the literal is a bit-precise integer or not. For a bit-precise; // integer type, try to scan the source to determine how many bits are; // needed to represent the value. This may seem a bit expensive, but trying; // to get the integer value from an overly-wide APInt is *extremely*; // expensive, so the naive approach of assuming; // llvm::IntegerType::MAX_INT_BITS is a big performance hit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:64,depend,depends,64,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['depend'],['depends']
Integrability,"// Get the wrapper around 'delete []'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx:11,wrap,wrapper,11,core/meta/src/TGenericClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx,1,['wrap'],['wrapper']
Integrability,"// Get the wrapper around 'delete'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx:11,wrap,wrapper,11,core/meta/src/TGenericClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx,1,['wrap'],['wrapper']
Integrability,"// Get the wrapper around 'new []'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx:11,wrap,wrapper,11,core/meta/src/TGenericClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx,1,['wrap'],['wrapper']
Integrability,"// Get the wrapper around 'new'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx:11,wrap,wrapper,11,core/meta/src/TGenericClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx,1,['wrap'],['wrapper']
Integrability,"// Get the wrapper around the destructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx:11,wrap,wrapper,11,core/meta/src/TGenericClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx,1,['wrap'],['wrapper']
Integrability,"// Get the wrapper around the directory-auto-add function .",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx:11,wrap,wrapper,11,core/meta/src/TGenericClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx,1,['wrap'],['wrapper']
Integrability,"// Get the wrapper function pointer from the ExecutionEngine (the JIT).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:11,wrap,wrapper,11,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,1,['wrap'],['wrapper']
Integrability,// Gets the ABI dependent registers that are used to pass arguments in a; // function call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:16,depend,dependent,16,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,1,['depend'],['dependent']
Integrability,"// Getting the block size:; // - approximate the size of an instruction by 4 bytes, and; // - ignore debug instructions.; // Note: getting the exact size of each block is target-dependent and can be; // done by extending the interface of MCCodeEmitter. Experimentally we do; // not see a perf improvement with the exact block sizes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:178,depend,dependent,178,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,2,"['depend', 'interface']","['dependent', 'interface']"
Integrability,// Give color to all non-colored SUs according to Reserved groups dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h:66,depend,dependencies,66,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,1,['depend'],['dependencies']
Integrability,"// Give full URL so Apache's virtual hosts solution works.; // Use protocol 0.9 for efficiency, we are not interested in the 1.0 headers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx:67,protocol,protocol,67,net/net/src/TWebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx,2,['protocol'],['protocol']
Integrability,"// Give function aliases prefixes when necessary, and build wrappers where the; // instrumentedness is inconsistent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:60,wrap,wrappers,60,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,1,['wrap'],['wrappers']
Integrability,// Give preference to a zero latency instruction if the dependent; // instruction is in the current packet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:56,depend,dependent,56,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,1,['depend'],['dependent']
Integrability,"// Give up on i/o failure.; // FIXME: We need an error message here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:55,message,message,55,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['message'],['message']
Integrability,"// Given (V >= Min && V != Min) we conclude V >= (Min + 1).; // This is true even if (Min + 1) wraps around -- in case of; // wraparound, (Min + 1) < Min, so (V >= Min => V >= (Min + 1)).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:95,wrap,wraps,95,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,2,['wrap'],"['wraparound', 'wraps']"
Integrability,"// Given a set of entries to a single loop, create a single entry for that; // loop by creating a dispatch block for them, routing control flow using; // a helper variable. Also updates Blocks with any new blocks created, so; // that we properly track all the blocks in the region. But this does not update; // ReachabilityGraph; this will be updated in the caller of this function as; // needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:123,rout,routing,123,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,1,['rout'],['routing']
Integrability,"// Given a tree of and/or(csel(0, 1, cc0), csel(0, 1, cc1)), we may be able to; // convert to csel(ccmp(.., cc0)), depending on cc1:; // (AND (CSET cc0 cmp0) (CSET cc1 (CMP x1 y1))); // =>; // (CSET cc1 (CCMP x1 y1 !cc1 cc0 cmp0)); //; // (OR (CSET cc0 cmp0) (CSET cc1 (CMP x1 y1))); // =>; // (CSET cc1 (CCMP x1 y1 cc1 !cc0 cmp0))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:115,depend,depending,115,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['depend'],['depending']
Integrability,"// Given an expression, we could either have a designator (if the next; // tokens are '...' or ']' or an objc message send. If this is an objc; // message send, handle it now. An objc-message send is the start of; // an assignment-expression production.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:110,message,message,110,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,3,['message'],['message']
Integrability,"// Given an instruction Opcode, we can make benchmarks (measurements) of the; // instruction characteristics/performance. Then, to facilitate further analysis; // we group the benchmarks with *similar* characteristics into clusters.; // Now, this is all not entirely deterministic. Some instructions have variable; // characteristics, depending on their arguments. And thus, if we do several; // benchmarks of the same instruction Opcode, we may end up with *different*; // performance characteristics measurements. And when we then do clustering,; // these several benchmarks of the same instruction Opcode may end up being; // clustered into *different* clusters. This is not great for further analysis.; // We shall find every opcode with benchmarks not in just one cluster, and move; // *all* the benchmarks of said Opcode into one new unstable cluster per Opcode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:335,depend,depending,335,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,1,['depend'],['depending']
Integrability,"// Given that host and device linking happen in separate processes, the device; // linker doesn't always have the visibility as to which device symbols are; // needed by a program, especially for the device symbol dependencies that are; // introduced through the host symbol resolution.; // For example: host_A() (A.obj) --> host_B(B.obj) --> device_kernel_B(); // (B.obj) In this case, the device linker doesn't know that A.obj actually; // depends on the kernel functions in B.obj. When linking to static device; // library, the device linker may drop some of the device global symbols if; // they aren't referenced. As a workaround, we are adding to the; // --whole-archive flag such that all global symbols would be linked in.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp:214,depend,dependencies,214,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp,2,['depend'],"['dependencies', 'depends']"
Integrability,"// Given the number of sampling points this routine fills the; // arrays x and w.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/GaussLegendreIntegrator.cxx:44,rout,routine,44,math/mathcore/src/GaussLegendreIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/GaussLegendreIntegrator.cxx,1,['rout'],['routine']
Integrability,// Global Address Wrapper,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.h:18,Wrap,Wrapper,18,interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.h,1,['Wrap'],['Wrapper']
Integrability,"// Global values may be plain old object addresses, TLS object; // addresses, constant pool entries, or jump tables. How we generate; // code for these may depend on small, medium, or large code model.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:156,depend,depend,156,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['depend'],['depend']
Integrability,// Go ahead and report unknown dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:31,depend,dependence,31,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// Go through the packet instructions and search for an anti dependency between; // them and DepReg from MI. Consider this case:; // Trying to add; // a) %r1 = TFRI_cdNotPt %p3, 2; // to this packet:; // {; // b) %p0 = C2_or killed %p3, killed %p0; // c) %p3 = C2_tfrrp %r23; // d) %r1 = C2_cmovenewit %p3, 4; // }; // The P3 from a) and d) will be complements after; // a)'s P3 is converted to .new form; // Anti-dep between c) and b) is irrelevant for this case",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:61,depend,dependency,61,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['depend'],['dependency']
Integrability,// Go up each hierarchy of superclasses and their protocols,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:50,protocol,protocols,50,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,1,['protocol'],['protocols']
Integrability,"// Going from XForm to DForm loads means that the displacement needs to be; // not just an immediate but also a multiple of 4, or 16 depending on the; // load. A DForm load cannot be represented if it is a multiple of say 2.; // XForm loads do not have this restriction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:133,depend,depending,133,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['depend'],['depending']
Integrability,"// Got close message for this MainFrame. Calls parent CloseWindow(); // (which destroys the window) and terminate the application.; // The close message is generated by the window manager when its close; // window menu item is selected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSGui.cxx:13,message,message,13,test/periodic/XSGui.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSGui.cxx,2,['message'],['message']
Integrability,"// Got close message for this MainFrame. Terminate the application; // or returns from the TApplication event loop (depending on the; // argument specified in TApplication::Run()).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/guitest.cxx:13,message,message,13,test/guitest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/guitest.cxx,2,"['depend', 'message']","['depending', 'message']"
Integrability,// Graph coloring utility used to partition nodes into two groups:; // they will correspond to nodes routed to the upper and lower networks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:101,rout,routed,101,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['rout'],['routed']
Integrability,"// Graphical User Interface for managing styles",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/inc/TStyleManager.h:18,Interface,Interface,18,gui/ged/inc/TStyleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/inc/TStyleManager.h,1,['Interface'],['Interface']
Integrability,"// Group irriducible terms that need to be (partially) integrated together",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:55,integrat,integrated,55,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['integrat'],['integrated']
Integrability,// Group scattered pseudo probes in a block to favor SelectionDAG. Scattered; // probes can be chained dependencies of other regular DAG nodes and block DAG; // combine optimizations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:103,depend,dependencies,103,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['depend'],['dependencies']
Integrability,"// Guard intrinsics are marked as arbitrarily writing so that proper control; // dependencies are maintained but they never mods any particular memory; // location.; //; // *Unlike* assumes, guard intrinsics are modeled as reading memory since the; // heap state at the point the guard is issued needs to be consistent in case; // the guard invokes the ""deopt"" continuation.; // NB! This function is *not* commutative, so we special case two; // possibilities for guard intrinsics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:81,depend,dependencies,81,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['depend'],['dependencies']
Integrability,"// GuessPointerPointer() is passed the address of what might be a pointer to; // a reference to an Objective-C class, selector, message ref or cfstring.; // If so the value of the pointer is returned and one of the booleans are set; // to true. If not zero is returned and all the booleans are set to false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp:128,message,message,128,interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,1,['message'],['message']
Integrability,"// HACK: This entire check is to handle two messages in the Cocoa frameworks:; // -[NSAssertionHandler; // handleFailureInMethod:object:file:lineNumber:description:]; // -[NSAssertionHandler; // handleFailureInFunction:file:lineNumber:description:]; // Eventually these should be annotated with __attribute__((noreturn)).; // Because ObjC messages use dynamic dispatch, it is not generally safe to; // assume certain methods can't return. In cases where it is definitely valid,; // see if you can mark the methods noreturn or analyzer_noreturn instead of; // adding more explicit checks to this method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp:44,message,messages,44,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp,2,['message'],['messages']
Integrability,"// HIP header includes standard library wrapper headers under clang; // cuda_wrappers directory. Since these wrapper headers include_next; // standard C++ headers, whereas libc++ headers include_next other clang; // headers. The include paths have to follow this order:; // - wrapper include path; // - standard C++ include path; // - other clang include path; // Since standard C++ and other clang include paths are added in other; // places after this function, here we only need to make sure wrapper; // include path is added.; //; // ROCm 3.5 does not fully support the wrapper headers. Therefore it needs; // a workaround.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp:40,wrap,wrapper,40,interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp,5,['wrap'],['wrapper']
Integrability,"// HIP toolchain does not support 'Fast' FPOpFusion in backends since it; // fuses multiplication/addition instructions without contract flag from; // device library functions in LLVM bitcode, which causes accuracy loss in; // certain math functions, e.g. tan(-1e20) becomes -0.933 instead of 0.8446.; // For device library functions in bitcode to work, 'Strict' or 'Standard'; // FPOpFusion options in backends is needed. Therefore 'fast-honor-pragmas'; // FP contract option is used to allow fuse across statements in frontend; // whereas respecting contract flag in backend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp:128,contract,contract,128,interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp,3,['contract'],['contract']
Integrability,"// Halves of WideVT are packed into registers in different order; // depending on platform endianness. This is usually handled by; // the C calling convention, but we can't defer to it in; // the legalizer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:69,depend,depending,69,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['depend'],['depending']
Integrability,// Handle (arch-dependent) fp16fml/fullfp16 relationship.; // Must happen before any features are disabled due to soft-float.; // FIXME: this fp16fml option handling will be reimplemented after the; // TargetParser rewrite.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:16,depend,dependent,16,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,1,['depend'],['dependent']
Integrability,// Handle -cc1 integrated tools.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:15,integrat,integrated,15,interpreter/llvm-project/clang/tools/driver/driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp,1,['integrat'],['integrated']
Integrability,// Handle _dispatch_once. In some versions of the OS X SDK we have the case; // that dispatch_once is a macro that wraps a call to _dispatch_once.; // _dispatch_once is then a function which then calls the real dispatch_once.; // Users do not care; they just want the warning at the top-level call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp:115,wrap,wraps,115,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,1,['wrap'],['wraps']
Integrability,// Handle a dependent template specialization for which we cannot resolve; // the template name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:12,depend,dependent,12,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['depend'],['dependent']
Integrability,"// Handle any --wrap options passed to gold, which are than passed; // along to the plugin.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:16,wrap,wrap,16,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,1,['wrap'],['wrap']
Integrability,"// Handle buildvectors, pulling out the correct lane depending on; // endianness.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:53,depend,depending,53,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['depend'],['depending']
Integrability,"// Handle cases of nested name specificier locations.; //; // The VisitNestedNameSpecifierLoc interface is not impelmented in; // RecursiveASTVisitor, we have to handle it explicitly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:94,interface,interface,94,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,1,['interface'],['interface']
Integrability,// Handle def-use chain dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:24,depend,dependencies,24,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['depend'],['dependencies']
Integrability,"// Handle dependencies",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:10,depend,dependencies,10,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,1,['depend'],['dependencies']
Integrability,// Handle dependency file generation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:10,depend,dependency,10,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['depend'],['dependency']
Integrability,// Handle dependency type for depend clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:10,depend,dependency,10,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,2,['depend'],"['depend', 'dependency']"
Integrability,"// Handle dependent statements by parsing the braces as a compound statement.; // This is not the same behavior as Visual C++, which don't treat this as a; // compound statement, but for Clang's type checking we can't have anything; // inside these braces escaping to the surrounding code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:10,depend,dependent,10,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['depend'],['dependent']
Integrability,// Handle empty record blocks where the brace has already been wrapped.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:63,wrap,wrapped,63,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,1,['wrap'],['wrapped']
Integrability,"// Handle generating dependencies, if requested.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:21,depend,dependencies,21,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['depend'],['dependencies']
Integrability,"// Handle identifier: [a-zA-Z_.$@#?][a-zA-Z0-9_.$@#?]*; // Whether or not the lexer accepts '$', '@', '#' and '?' at the start of; // an identifier is target-dependent. These characters are handled in the; // respective switch cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmLexer.cpp:158,depend,dependent,158,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmLexer.cpp,1,['depend'],['dependent']
Integrability,// Handle implicit toll-free bridging.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp:29,bridg,bridging,29,interpreter/llvm-project/clang/lib/AST/FormatString.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp,1,['bridg'],['bridging']
Integrability,// Handle invalid code where the @interface might not; // have been specified.; // FIXME: We should be able to generate this USR even if the; // @interface isn't available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:34,interface,interface,34,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,4,['interface'],['interface']
Integrability,"// Handle lib dependencies",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:14,depend,dependencies,14,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,1,['depend'],['dependencies']
Integrability,"// Handle messages send to the TestMainFrame object. E.g. all menu button; // messages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/guitest.cxx:10,message,messages,10,test/guitest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/guitest.cxx,2,['message'],['messages']
Integrability,"// Handle messages send to the XSGui object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSGui.cxx:10,message,messages,10,test/periodic/XSGui.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSGui.cxx,1,['message'],['messages']
Integrability,"// Handle messages to ""id"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:10,message,messages,10,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['message'],['messages']
Integrability,"// Handle messages to Class. This really isn't a message to an instance; // method, so we treat it the same way we would treat a message send to a; // class method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:10,message,messages,10,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,3,['message'],"['message', 'messages']"
Integrability,"// Handle messages to Class.; // We allow sending a message to a qualified Class (""Class<foo>""), which; // is ok as long as one of the protocols implements the selector (if not,; // warn).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:10,message,messages,10,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,3,"['message', 'protocol']","['message', 'messages', 'protocols']"
Integrability,// Handle messages to a pointer to interface type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:10,message,messages,10,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,2,"['interface', 'message']","['interface', 'messages']"
Integrability,"// Handle messages to a qualified ID (""id<foo>"").",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:10,message,messages,10,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['message'],['messages']
Integrability,// Handle messages to id and __kindof types (where we use the; // global method pool).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:10,message,messages,10,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['message'],['messages']
Integrability,// Handle module dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:17,depend,dependencies,17,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,1,['depend'],['dependencies']
Integrability,"// Handle only DeclRefExprs since they are local and the call wrapper; // won't ""see"" them. Consequently we don't need to handle:; // * DependentScopeDeclRefExpr; // * CallExpr; // * MemberExpr; // * CXXDependentScopeMemberExpr",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp:62,wrap,wrapper,62,interpreter/cling/lib/Interpreter/DynamicLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp,2,"['Depend', 'wrap']","['DependentScopeDeclRefExpr', 'wrapper']"
Integrability,"// Handle optional dependence modifier.; // iterator(iterators-definition); // where iterators-definition is iterator-specifier [,; // iterators-definition ]; // where iterator-specifier is [ iterator-type ] identifier =; // range-specification",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:19,depend,dependence,19,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,1,['depend'],['dependence']
Integrability,// Handle phi instructions that are generated when it's necessary to check; // whether the receiver of a message is null.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:105,message,message,105,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['message'],['message']
Integrability,// Handle recursive construction of Protocol and ProtocolList types,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:36,Protocol,Protocol,36,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,2,['Protocol'],"['Protocol', 'ProtocolList']"
Integrability,"// Handle special case of no integration with default algorithm",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:29,integrat,integration,29,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['integrat'],['integration']
Integrability,"// Handle special protocol cases: ""file:"", etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUrl.cxx:18,protocol,protocol,18,core/base/src/TUrl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUrl.cxx,1,['protocol'],['protocol']
Integrability,"// Handle special protocol cases: file:, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUrl.cxx:18,protocol,protocol,18,core/base/src/TUrl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUrl.cxx,1,['protocol'],['protocol']
Integrability,"// Handle the case when the error message is of specific type; // other than the generic Match_InvalidOperand, and the; // corresponding operand is missing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp:34,message,message,34,interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/AsmParser/CSKYAsmParser.cpp,3,['message'],['message']
Integrability,// Handle the case where the attribute has a text message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:50,message,message,50,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,2,['message'],['message']
Integrability,// Handle the cases where the attribute has a text message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:51,message,message,51,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['message'],['message']
Integrability,// Handle the control dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:22,depend,dependencies,22,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['depend'],['dependencies']
Integrability,// Handle the def-use chain dependencies.; // Decrement the unscheduled counter and insert to ready list if ready.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:28,depend,dependencies,28,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['depend'],['dependencies']
Integrability,// Handle the memory dependencies (if any).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21,depend,dependencies,21,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['depend'],['dependencies']
Integrability,// Handle the memory dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21,depend,dependencies,21,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['depend'],['dependencies']
Integrability,"// Handle the two forms of array designator:; // array-designator: '[' constant-expression ']'; // array-designator: '[' constant-expression '...' constant-expression ']'; //; // Also, we have to handle the case where the expression after the; // designator an an objc message send: '[' objc-message-expr ']'.; // Interesting cases are:; // [foo bar] -> objc message send; // [foo] -> array designator; // [foo ... bar] -> array designator; // [4][foo bar] -> obsolete GNU designation with objc message send.; //; // We do not need to check for an expression starting with [[ here. If it; // contains an Objective-C message send, then it is not an ill-formed; // attribute. If it is a lambda-expression within an array-designator, then; // it will be rejected because a constant-expression cannot begin with a; // lambda-expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:269,message,message,269,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,5,['message'],"['message', 'message-expr']"
Integrability,// Handle the very basic case when the two stores are in the same block; // so deciding which one forwards is easy. The later one forwards as; // long as they both have a dependence distance of one to the load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:171,depend,dependence,171,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,1,['depend'],['dependence']
Integrability,// Handle the wrap-around 1+0+1+ cases. Start then specifies the msb; // of the low 1s and End specifies the lsb of the high 1s.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:14,wrap,wrap-around,14,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,1,['wrap'],['wrap-around']
Integrability,"// Handle trivial case of no integration here explicitly",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:29,integrat,integration,29,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['integrat'],['integration']
Integrability,"// Handle trivial no-integration scenario",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/ParamHistFunc.cxx:21,integrat,integration,21,roofit/histfactory/src/ParamHistFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/ParamHistFunc.cxx,3,['integrat'],['integration']
Integrability,"// Handle unitary steps, which cannot wraparound.; // 1*N = -Start; -1*N = Start (mod 2^BW), so:; // N = Distance (as unsigned)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:38,wrap,wraparound,38,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wraparound']
Integrability,// Handle value-dependent integral null pointer constants correctly.; // http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#903,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:16,depend,dependent,16,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['depend'],['dependent']
Integrability,// Handled with other dependency code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:22,depend,dependency,22,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,2,['depend'],['dependency']
Integrability,// Hard float for mips16 means essentially to compile as soft float; // but to use a runtime library for soft float that is written with; // native mips32 floating point instructions (those runtime routines; // run in mips32 hard float mode).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:198,rout,routines,198,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,1,['rout'],['routines']
Integrability,"// Has this argument a defined range (dummy interface always returns false)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsArg.h:44,interface,interface,44,roofit/roofitcore/inc/RooAbsArg.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsArg.h,1,['interface'],['interface']
Integrability,"// Hash a subtree with compress_subtree_wide(), and then condense the resulting; // list of chaining values down to a single parent node. Don't compress that; // last parent node, however. Instead, return its message bytes (the; // concatenated chaining values of its children). This is necessary when the; // first call to update() supplies a complete subtree, because the topmost; // parent node of that subtree could end up being the root. It's also necessary; // for extended output in the general case.; //; // As with compress_subtree_wide(), this function is not used on inputs of 1; // chunk or less. That's a different codepath.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:209,message,message,209,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,1,['message'],['message']
Integrability,"// Hash interface for generic data of type T; // Data should implement a \fn getHashCode and a \fn isEqual; // Currently getHashCode is non-virtual to avoid the overhead of calling vtable,; // i.e we explicitly calculate hash of derived class, assign to base class's; // HashCode. This also provides the flexibility for calculating the hash code; // incrementally(like rolling hash) during frame stack unwinding since unwinding; // only changes the leaf of frame stack. \fn isEqual is a virtual function,; // which will have perf overhead. In the future, if we redesign a better hash; // function, then we can just skip this or switch to non-virtual function(like; // just ignore comparison if hash conflicts probabilities is low)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h:8,interface,interface,8,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h,1,['interface'],['interface']
Integrability,// Hash of dependency name,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h:11,depend,dependency,11,interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h,1,['depend'],['dependency']
Integrability,// Hash referenced protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp:19,protocol,protocols,19,interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,2,['protocol'],['protocols']
Integrability,"// Hash the module dependencies. These paths may differ even if the invocation; // is identical if they depend on the contents of the files in the TU -- for; // example, case-insensitive paths to modulemap files. Usually such a case; // would indicate a missed optimization to canonicalize, but it may be; // difficult to canonicalize all cases when there is a VFS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:19,depend,dependencies,19,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,2,['depend'],"['depend', 'dependencies']"
Integrability,// Hash the name only as a referenced protocol can be a forward declaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp:38,protocol,protocol,38,interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,2,['protocol'],['protocol']
Integrability,"// Hash the remaining partial chunk, if there is one. Note that the empty; // chunk (meaning the empty message) is a different codepath.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:103,message,message,103,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,1,['message'],['message']
Integrability,// Have we seen this protocol before?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:21,protocol,protocol,21,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['protocol'],['protocol']
Integrability,"// Having too many inputs is ok: drop the high bits (usual wrap-around).; // If there are too few, fill them with the sign bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:59,wrap,wrap-around,59,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['wrap'],['wrap-around']
Integrability,"// Headers in Foo.framework/Headers should not include headers; // from Foo.framework/PrivateHeaders, since this violates public/private; // API boundaries and can cause modular dependency cycles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:178,depend,dependency,178,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,1,['depend'],['dependency']
Integrability,// Helper Routines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h:10,Rout,Routines,10,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,1,['Rout'],['Routines']
Integrability,"// Helper class used to encapsulate the calls to the gradient interfaces,; // templated with a GradientTestTraits type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testGradient.cxx:62,interface,interfaces,62,math/mathcore/test/testGradient.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testGradient.cxx,1,['interface'],['interfaces']
Integrability,"// Helper function for factory interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooLagrangianMorphFunc.cxx:31,interface,interface,31,roofit/roofit/src/RooLagrangianMorphFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooLagrangianMorphFunc.cxx,1,['interface'],['interface']
Integrability,// Helper function that emits error message for intrinsics with chain and return; // merge values of a UNDEF and the chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:36,message,message,36,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['message'],['message']
Integrability,// Helper function that emits error message for intrinsics with void return; // value and return the chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:36,message,message,36,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['message'],['message']
Integrability,// Helper function that emits error message for intrinsics with/without chain; // and return a UNDEF or and the chain as the results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:36,message,message,36,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['message'],['message']
Integrability,"// Helper function that wraps RooAbsArg::getParameters and directly returns the; // output RooArgSet. To be used in the initializer list of the RooMinimizerFcn; // constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMinimizerFcn.cxx:24,wrap,wraps,24,roofit/roofitcore/src/RooMinimizerFcn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMinimizerFcn.cxx,1,['wrap'],['wraps']
Integrability,"// Helper function to create a new configuration that is just like the one; // associated to this integrator, but with a different summation rule.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooImproperIntegrator1D.cxx:98,integrat,integrator,98,roofit/roofitcore/src/RooImproperIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooImproperIntegrator1D.cxx,1,['integrat'],['integrator']
Integrability,"// Helper function to emit either (RemSimplificationC << X) or; // (RemSimplificationC * X) depending on whether we matched Op0/Op1 as; // (shl V, X) or (mul V, X) respectively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:92,depend,depending,92,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['depend'],['depending']
Integrability,// Helper function to generate the Advanced SIMD names depending on; // the value of the NDS when simdlen is not present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:55,depend,depending,55,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['depend'],['depending']
Integrability,// Helper routine to create either a signaling or a quiet FP comparison.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:10,rout,routine,10,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['rout'],['routine']
Integrability,"// Helper routine to look fo the scope::enum in the typesystem.; // If autoload and interpreter lookup is allowed, TClass::GetClass is called.; // If not, the list of classes and the list of protoclasses is inspected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TEnum.cxx:10,rout,routine,10,core/meta/src/TEnum.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TEnum.cxx,1,['rout'],['routine']
Integrability,// Helper routines to process parts of a DIE.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:10,rout,routines,10,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,1,['rout'],['routines']
Integrability,"// Helper to create DBG_INSTR_REFs or DBG_VALUEs, depending on what kind; // we've been asked to pursue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:50,depend,depending,50,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['depend'],['depending']
Integrability,"// Helper to push \p V to the worklist, after updating it to \p IV. Also; // prints a debug message with the updated value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:92,message,message,92,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,1,['message'],['message']
Integrability,// Here I know that I is predicate setting instruction with true; // data dep to candidate on the register we care about - c) in the; // above example. Now I need to see if there is an anti dependency; // from c) to any other instruction in the same packet on the pred; // reg of interest.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:190,depend,dependency,190,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['depend'],['dependency']
Integrability,"// Here the final cast is to match the interface of the C code and; // the data member. The length is the same!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/res/ROOT/RSha256.hxx:39,interface,interface,39,core/foundation/res/ROOT/RSha256.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/res/ROOT/RSha256.hxx,1,['interface'],['interface']
Integrability,"// Here we ""fuse"" clusters together if the number of clusters is too big with respect to; // the number of slots, otherwise we can incur in an overhead which is big enough; // to make parallelisation detrimental to performance.; // For example, this is the case when, following a merging of many small files, a file; // contains a tree with many entries and with clusters of just a few entries each.; // Another problematic case is a high number of slots (e.g. 256) coupled with a high number; // of files (e.g. 1000 files): the large amount of files might result in a large amount; // of tasks, but the elevated concurrency level makes the little synchronization required by; // task initialization very expensive. In this case it's better to simply process fewer, larger tasks.; // Cluster-merging can help reduce the number of tasks down to a minumum of one task per file.; //; // The criterion according to which we fuse clusters together is to have around; // TTreeProcessorMT::GetTasksPerWorkerHint() clusters per slot.; // Concretely, for each file we will cap the number of tasks to ceil(GetTasksPerWorkerHint() * nWorkers / nFiles).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProcessorMT.cxx:648,synchroniz,synchronization,648,tree/treeplayer/src/TTreeProcessorMT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProcessorMT.cxx,1,['synchroniz'],['synchronization']
Integrability,// Here we're passing the 2 arguments explicitly as 4 arguments that are; // pre-lowered to the correct types. This all depends upon WideVT not; // being a legal type for the architecture and thus has to be split to; // two arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:120,depend,depends,120,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['depend'],['depends']
Integrability,// Here's a great place to add any extra declarations that may be needed.; // Write out meta data for each @protocol(<expr>).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:108,protocol,protocol,108,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['protocol'],['protocol']
Integrability,"// Here, we're stuck: lambda introducers and Objective-C message sends are; // unambiguous, but it requires arbitrary lookhead. [a,b,c,d,e,f,g] is a; // lambda, and [a,b,c,d,e,f,g h] is a Objective-C message send. Instead of; // writing two routines to parse a lambda introducer, just try to parse; // a lambda introducer first, and fall back if that fails.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:57,message,message,57,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,3,"['message', 'rout']","['message', 'routines']"
Integrability,"// Heuristic: The compare conversion delays the execution of the branch; // instruction because we must wait for the inputs to the second compare as; // well. The branch has no dependent instructions, but delaying it increases; // the cost of a misprediction.; //; // Set a limit on the delay we will accept.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionalCompares.cpp:177,depend,dependent,177,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionalCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionalCompares.cpp,1,['depend'],['dependent']
Integrability,"// HiEqMBB:; //; // Otherwise, use VECTOR COMPARE HIGH LOGICAL.; // Since we already know the high parts are equal, the CC; // result will only depend on the low parts:; // CC 1 if low(Op0) > low(Op1); // CC 3 if low(Op0) <= low(Op1); //; // VCHLGS Tmp, Op0, Op1; // # fallthrough to JoinMBB",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:144,depend,depend,144,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['depend'],['depend']
Integrability,"// Hierarchically expands the direction vector; // search space, combining the directions of discovered dependences; // in the DirSet field of Bound. Returns the number of distinct; // dependences discovered. If the dependence is disproved,; // it will return 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:104,depend,dependences,104,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,3,['depend'],"['dependence', 'dependences']"
Integrability,// Higher level manipulation routines.; /// clone - Return a new copy of this tree.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h:29,rout,routines,29,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,1,['rout'],['routines']
Integrability,"// Histogram of original dependent variable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:25,depend,dependent,25,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['depend'],['dependent']
Integrability,"// Histogram of shifted dependent variable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:24,depend,dependent,24,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['depend'],['dependent']
Integrability,"// History interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TextInput.h:11,interface,interface,11,core/textinput/src/textinput/TextInput.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TextInput.h,1,['interface'],['interface']
Integrability,// Hoist the dependent condition values of the branches and the selects in the; // scope to the insert point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:13,depend,dependent,13,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,1,['depend'],['dependent']
Integrability,"// Holds coroutine data if the current function is a coroutine. We use a; // wrapper to manage its lifetime, so that we don't have to define CGCoroData; // in this header.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:77,wrap,wrapper,77,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['wrap'],['wrapper']
Integrability,// Holds one of:; // - the register that the value is assigned to;; // - the memory offset at which the value resides;; // - additional information about pending location; the exact interpretation; // of the data is target-dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:223,depend,dependent,223,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,1,['depend'],['dependent']
Integrability,// Honor -version.; //; // FIXME: Use a better -version message?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp:56,message,message,56,interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,2,['message'],['message']
Integrability,"// Honor -w: this disables all messages which are not Error/Fatal by; // default (disregarding attempts to upgrade severity from Warning to Error),; // as well as disabling all messages which are currently mapped to Warning; // (whether by default or downgraded from Error via e.g. -Wno-error or #pragma; // diagnostic.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:31,message,messages,31,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,2,['message'],['messages']
Integrability,"// Hook for further initializing the WM dependent application environment",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:40,depend,dependent,40,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['depend'],['dependent']
Integrability,"// Hook for objects with normalization-dependent parameters interpretation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:39,depend,dependent,39,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,1,['depend'],['dependent']
Integrability,"// Hook to server authentication wrapper",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TServerSocket.cxx:33,wrap,wrapper,33,net/net/src/TServerSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TServerSocket.cxx,1,['wrap'],['wrapper']
Integrability,"// Hooks for RooDataSet interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:24,interface,interface,24,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,1,['interface'],['interface']
Integrability,"// Hooks for RooTreeData interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsArg.h:25,interface,interface,25,roofit/roofitcore/inc/RooAbsArg.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsArg.h,1,['interface'],['interface']
Integrability,// Host dependences for device actions are not compatible with that same; // action being ignored.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:8,depend,dependences,8,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['depend'],['dependences']
Integrability,"// Host-side offloading compilation receives all device-side outputs. Include; // them in the host compilation depending on the target. If the host inputs; // are not empty we use the new-driver scheme, otherwise use the old scheme.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:111,depend,depending,111,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['depend'],['depending']
Integrability,"// However, if the range wraps around, it spans all possible values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:25,wrap,wraps,25,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,2,['wrap'],['wraps']
Integrability,"// However, if we're catching a pointer-to-record type that won't; // work, because the personality function might have adjusted; // the pointer. There's actually no way for us to fully satisfy; // the language/ABI contract here: we can't use Exn because it; // might have the wrong adjustment, but we can't use the by-value; // pointer because it's off by a level of abstraction.; //; // The current solution is to dump the adjusted pointer into an; // alloca, which breaks language semantics (because changing the; // pointer doesn't change the exception) but at least works.; // The better solution would be to filter out non-exact matches; // and rethrow them, but this is tricky because the rethrow; // really needs to be catchable by other sites at this landing; // pad. The best solution is to fix the personality function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:215,contract,contract,215,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['contract'],['contract']
Integrability,"// I don't want the dependency on <algorithm>; //return find(Nodes.begin(), Nodes.end(), BB) != Nodes.end();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Interval.h:20,depend,dependency,20,interpreter/llvm-project/llvm/include/llvm/Analysis/Interval.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Interval.h,1,['depend'],['dependency']
Integrability,"// I don't want the dependency on <algorithm>; //return find(Successors.begin(), Successors.end(), BB) != Successors.end();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Interval.h:20,depend,dependency,20,interpreter/llvm-project/llvm/include/llvm/Analysis/Interval.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Interval.h,1,['depend'],['dependency']
Integrability,"// I think we can be more aggressive here and make this nuw / nsw if the; // addition that feeds into the icmp for the latch's terminating branch is nuw; // / nsw. In any case, a wrapping 2's complement addition is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:179,wrap,wrapping,179,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,1,['wrap'],['wrapping']
Integrability,"// I/O streaming interface (machine readable)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsArg.h:17,interface,interface,17,roofit/roofitcore/inc/RooAbsArg.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsArg.h,14,['interface'],['interface']
Integrability,"// IF NAA .EQ. -1 , PROGRAM USES BWID INPUT FROM CALLING ROUTINE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:57,ROUT,ROUTINE,57,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,1,['ROUT'],['ROUTINE']
Integrability,"// IF we have climbed down to an intervening enclosing lambda that contains; // the variable declaration - it obviously can/must not capture the; // variable.; // Since its enclosing DC is dependent, all the lambdas between it and the; // innermost nested lambda are dependent (otherwise we wouldn't have; // arrived here) - so we don't yet have a lambda that can capture the; // variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:189,depend,dependent,189,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,2,['depend'],['dependent']
Integrability,"// IMPORTANT: final place where integrity of input message is checked!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:51,message,message,51,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['message'],['message']
Integrability,// INCLUDED BELOW #include <gsl/gsl_integration.h>; /* Workspace for adaptive integrators */; // WVE MOVED TO HEAD OF FILE; /* Definition of an integration rule */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx:78,integrat,integrators,78,roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.cxx,2,['integrat'],"['integration', 'integrators']"
Integrability,// INFO and DEBUG messages could be numerous and not particularly interesting,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp:18,message,messages,18,interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp,1,['message'],['messages']
Integrability,"// ISRs require spill slots for Status & ErrorPC Coprocessor 0 registers.; // The current implementation only supports Mips32r2+ not Mips64rX. Status; // is always 32 bits, ErrorPC is 32 or 64 bits dependent on architecture,; // however Mips32r2+ is the supported architecture.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp:198,depend,dependent,198,interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp,1,['depend'],['dependent']
Integrability,"// ISel process runs DAGCombiner after legalization; this step is called; // SelectionDAG optimization phase. This post-legalization combining process; // runs DAGCombiner on each node, and if there was a change to be made,; // re-runs legalization again on it and its user nodes to make sure; // everythiing is in a legalized state.; //; // The legalization calls lowering routines, and we do our custom lowering for; // build_vectors (LowerBUILD_VECTOR), which converts undef vector elements; // into zeros. But there is a set of routines in DAGCombiner that turns unused; // (= not demanded) nodes into undef, among which SimplifyDemandedVectorElts; // turns unused vector elements into undefs. But this routine does not work; // with our custom LowerBUILD_VECTOR, which turns undefs into zeros. This; // combination can result in a infinite loop, in which undefs are converted to; // zeros in legalization and back to undefs in combining.; //; // So after DAG is legalized, we prevent SimplifyDemandedVectorElts from; // running for build_vectors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:374,rout,routines,374,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,3,['rout'],"['routine', 'routines']"
Integrability,"// Ideally, as in gled, MIR execution would be steered by scenes themselves.; // But this requires alpha/beta/gamma MIR elements and scene dependenices,; // so dependent scenes can be locked, too.; // On top of that, one could also implements authorization framework, as in gled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveManager.cxx:139,depend,dependenices,139,graf3d/eve7/src/REveManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveManager.cxx,2,['depend'],"['dependenices', 'dependent']"
Integrability,"// Idempotent means X op X === X, so any non-zero weight is equivalent to a; // weight of 1. Keeping weights at zero or one also means that wrapping is; // not a problem.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:140,wrap,wrapping,140,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['wrap'],['wrapping']
Integrability,// Idempotent ops (like a*1) can still change the type of an expression.; // Wrap the LHS up in a NonLoc again and let evalCast do the; // dirty work.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:77,Wrap,Wrap,77,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,1,['Wrap'],['Wrap']
Integrability,// Identifier specifiers always represent dependent types,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp:42,depend,dependent,42,interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp,1,['depend'],['dependent']
Integrability,"// Identify S_ENDPGM instructions which may have to wait for outstanding VMEM; // stores. In this case it can be useful to send a message to explicitly; // release all VGPRs before the stores have completed, but it is only safe to; // do this if:; // * there are no outstanding scratch stores; // * we are not in Dynamic VGPR mode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:130,message,message,130,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['message'],['message']
Integrability,// Identify dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:12,depend,dependencies,12,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,1,['depend'],['dependencies']
Integrability,// Identify physreg dependencies for MI when scanning instructions upwards.; // Return the issue height of MI after considering any live regunits.; // Height is the issue height computed from virtual register dependencies alone.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:20,depend,dependencies,20,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,2,['depend'],['dependencies']
Integrability,"// Identify physreg dependencies for UseMI, and update the live regunit; // tracking set when scanning instructions downwards.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:20,depend,dependencies,20,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,1,['depend'],['dependencies']
Integrability,// Identify the diagnostic messages that should be produced.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:27,message,messages,27,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['message'],['messages']
Integrability,"// Identify what other metadata depends on the cloned version. After; // cloning, replace the metadata with the corrected version for both; // memory instructions and noalias intrinsics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:32,depend,depends,32,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,2,['depend'],['depends']
Integrability,"// If !HasCompiler, wrappers act like GCC. Fine: so do we.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp:20,wrap,wrappers,20,interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,1,['wrap'],['wrappers']
Integrability,"// If !IsNew, we will replace the Value with itself. However, replaced values; // are assumed to wrapped in an addrspacecast cast later so drop it now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:97,wrap,wrapped,97,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,1,['wrap'],['wrapped']
Integrability,"// If !hasReservedCallFrame the function might have SP adjustement in the; // body. So, even though the offset is statically known, it depends on where; // we are in the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:135,depend,depends,135,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['depend'],['depends']
Integrability,"// If 'Action 2' is host, we generate jobs for the device dependences and; // override the current action with the host dependence. Otherwise, we; // generate the host dependences and override the action with the device; // dependence. The dependences can't therefore be a top-level action.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:58,depend,dependences,58,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,5,['depend'],"['dependence', 'dependences']"
Integrability,// If -fno-integrated-as is used add -Q to the darwin assembler driver to make; // sure it runs its system assembler not clang's integrated assembler.; // Applicable to darwin11+ and Xcode 4+. darwin<10 lacked integrated-as.; // FIXME: at run-time detect assembler capabilities or rely on version; // information forwarded by -target-assembler-version.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:11,integrat,integrated-as,11,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,3,['integrat'],"['integrated', 'integrated-as']"
Integrability,"// If A is a load, dependencies are tolerable, there's nothing to do here.; // If both A and B belong to the same (store) group, they are independent,; // even if dependencies have not been recorded.; // If both GroupA and GroupB are null, there's nothing to do here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:19,depend,dependencies,19,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,2,['depend'],['dependencies']
Integrability,// If AR wraps around then; //; // abs(Step) * MaxBECount > unsigned-max(AR->getType()); // => SAdd != OperandExtendedAdd; //; // Thus (AR is not NW => SAdd != OperandExtendedAdd) <=>; // (SAdd == OperandExtendedAdd => AR is NW),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:9,wrap,wraps,9,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wraps']
Integrability,"// If ActOnTag said the type was dependent, try again with the; // less common call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:33,depend,dependent,33,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['depend'],['dependent']
Integrability,"// If B is a load and part of an interleave group, no earlier loads; // can be added to B's interleave group, because this would mean the; // DependentInst would move across store A. Mark the interleave group; // as complete.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:142,Depend,DependentInst,142,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['Depend'],['DependentInst']
Integrability,"// If B is a qualified id, then A must also be a qualified id and it must; // implement all of the protocols in B. It may not be a qualified class.; // For example, MyClass<A> can be assigned to id<A>, but MyClass<A> is a; // stricter definition so it is not substitutable for id<A>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:99,protocol,protocols,99,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['protocol'],['protocols']
Integrability,"// If BMsOrErr fails, consume the error and use the error message from; // parseIR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp:58,message,message,58,interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp,1,['message'],['message']
Integrability,"// If Call1 only reads memory, the only dependence on Call2 can be; // from Call1 reading memory written by Call2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:40,depend,dependence,40,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// If DV has any VReg location operands which haven't been mapped then; // either that node is no longer available or we just haven't visited the; // node yet. In the former case we should emit an undef dbg_value, but we; // can do it later. And for the latter we'll want to wait until all; // dependent nodes have been visited.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:294,depend,dependent,294,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['depend'],['dependent']
Integrability,"// If E is not value-dependent, then nothing will change when we transform it.; // Note: This is an instantiation-centric view.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:21,depend,dependent,21,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['depend'],['dependent']
Integrability,"// If EnableShrinkWrap is set, it takes precedence on whatever the; // target sets. The rational is that we assume we want to test; // something related to shrink-wrapping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:163,wrap,wrapping,163,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,1,['wrap'],['wrapping']
Integrability,"// If GroupB is a load group, we have to compare AI against all; // members of GroupB because if any load within GroupB has a dependency; // on AI, we need to mark GroupB as complete and also release the; // store GroupA (if A belongs to one). The former prevents incorrect; // hoisting of load B above store A while the latter prevents incorrect; // sinking of store A below load B.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:126,depend,dependency,126,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['depend'],['dependency']
Integrability,"// If I and V are pointers in different address space, it is not allowed to; // use replaceAllUsesWith since I and V have different types. A; // non-target-specific transformation should not use addrspacecast on V since; // the two address space may be disjoint depending on target.; //; // This class chases down uses of the old pointer until reaching the load; // instructions, then replaces the old pointer in the load instructions with; // the new pointer. If during the chasing it sees bitcast or GEP, it will; // create new bitcast or GEP with the new pointer and use them in the load; // instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:262,depend,depending,262,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['depend'],['depending']
Integrability,// If I has a regmask assume dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:29,depend,dependency,29,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['depend'],['dependency']
Integrability,"// If InvalidationMethod is present, we are processing the message send and; // should ensure we are invalidating with the appropriate method,; // otherwise, we are processing setting to 'nil'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:59,message,message,59,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,1,['message'],['message']
Integrability,"// If J is neither load nor store, assume a dependency.; // If J is a load, but I is neither, also assume a dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:44,depend,dependency,44,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,2,['depend'],['dependency']
Integrability,"// If LoopSimplify form is not available, stay out of trouble. Some notes:; // - LSR currently only supports LoopSimplify-form loops. Indvars'; // canonicalization can be a pessimization without LSR to ""clean up""; // afterwards.; // - We depend on having a preheader; in particular,; // Loop::getCanonicalInductionVariable only supports loops with preheaders,; // and we're in trouble if we can't find the induction variable even when; // we've manually inserted one.; // - LFTR relies on having a single backedge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:238,depend,depend,238,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['depend'],['depend']
Integrability,"// If MBB is the last block in the trace, and it has a back-edge to the; // loop header, get loop-carried dependencies from PHIs in the header. For; // that purpose, pretend that all the loop header PHIs have height 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:106,depend,dependencies,106,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,1,['depend'],['dependencies']
Integrability,"// If MBMI is bigger than MEMI, we always can not get run of ones.; // RotatedSrcMask non-wrap:; // 0........31|32........63; // RotatedSrcMask: B---E B---E; // MaskMI: -----------|--E B------; // Result: ----- --- (Bad candidate); //; // RotatedSrcMask wrap:; // 0........31|32........63; // RotatedSrcMask: --E B----|--E B----; // MaskMI: -----------|--E B------; // Result: --- -----|--- ----- (Bad candidate); //; // One special case is RotatedSrcMask is a full set mask.; // RotatedSrcMask full:; // 0........31|32........63; // RotatedSrcMask: ------EB---|-------EB---; // MaskMI: -----------|--E B------; // Result: -----------|--- ------- (Good candidate); // Mark special case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:90,wrap,wrap,90,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,2,['wrap'],['wrap']
Integrability,"// If MI kills this register, the false dependence is already broken.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:40,depend,dependence,40,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['depend'],['dependence']
Integrability,"// If NSLocalizedString macro is wrapped in another macro, we need to; // unwrap the expansion until we get to the NSLocalizedStringMacro.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:33,wrap,wrapped,33,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,1,['wrap'],['wrapped']
Integrability,"// If ObjC exceptions are enabled, this depends on the ABI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:40,depend,depends,40,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['depend'],['depends']
Integrability,"// If Objective-C is enabled and this is a typename (class message; // send) or send to 'super', parse this as a message send; // expression. We handle C++ and C separately, since C++ requires; // much more complicated parsing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:59,message,message,59,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,2,['message'],['message']
Integrability,"// If PDF depends on prototype data, direct generator cannot use static initialization; // in initGenerator()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenContext.cxx:10,depend,depends,10,roofit/roofitcore/src/RooGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenContext.cxx,1,['depend'],['depends']
Integrability,"// If RHS is zero LHS and REMAINDER are left unchanged, return one.; // Otherwise set LHS to LHS / RHS with the fractional part discarded,; // set REMAINDER to the remainder, return zero. i.e.; //; // OLD_LHS = RHS * LHS + REMAINDER; //; // SCRATCH is a bignum of the same size as the operands and result for; // use by the routine; its contents need not be initialized and are; // destroyed. LHS, REMAINDER and SCRATCH must be distinct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:324,rout,routine,324,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['rout'],['routine']
Integrability,"// If ROOT was NOT built with the fftw3 interface, we try to include fftw3.h; // with the interpreter and run the concolution in the interpreter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:40,interface,interface,40,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['interface'],['interface']
Integrability,"// If ROOT was built with the fftw3 interface, we can use it as a TVirtualFFT; // plugin. The advantage here is that nothing can go wrong if fftw3.h wahs; // not istalled by the user separately.; // Retrieve previously defined FFT transformation plans",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:36,interface,interface,36,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['interface'],['interface']
Integrability,"// If Record is an Objective-C interface record and it has a super class,; // record that Record is inherited from SuperClass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:31,interface,interface,31,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,1,['interface'],['interface']
Integrability,"// If RenameAs is equal to RegID, then RegID is subject to register renaming; // and false dependencies on RegID are all eliminated.; // If RenameAs references the invalid register, then we optimistically assume; // that it can be renamed. In the absence of tablegen descriptors for register; // files, RenameAs is always set to the invalid register ID. In all other; // cases, RenameAs must be either equal to RegID, or it must reference a; // super-register of RegID.; // If RenameAs is a super-register of RegID, then a write to RegID has always; // a false dependency on RenameAs. The only exception is for when the write; // implicitly clears the upper portion of the underlying register.; // If a write clears its super-registers, then it is renamed as `RenameAs`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp:91,depend,dependencies,91,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,2,['depend'],"['dependencies', 'dependency']"
Integrability,"// If RetE is not a message expression just return its type.; // If RetE is a message expression, return its types if it is something; /// more specific than id.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:20,message,message,20,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,2,['message'],['message']
Integrability,"// If SCEV guarantees that AR does not wrap, PN >= StartValue can be added; // unconditionally.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:39,wrap,wrap,39,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,1,['wrap'],['wrap']
Integrability,"// If ScalarEvolution can find an underlying object, form a new query.; // The correctness of this depends on ScalarEvolution not recognizing; // inttoptr and ptrtoint operators.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp:99,depend,depends,99,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionAliasAnalysis.cpp,1,['depend'],['depends']
Integrability,// If Scale is small enough so that abs(V*Scale) >= abs(Scale) holds.; // The max value of abs(V) is 2^ValOrigBW - 1. Multiplying with a; // constant smaller than 2^(bitwidth(Val) - ValOrigBW) won't wrap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:199,wrap,wrap,199,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['wrap'],['wrap']
Integrability,"// If T is a dependent type, we can't do the check now, so we; // assume that it is well-formed. Note that stripping off the; // qualifiers here is not really correct if T turns out to be; // an array type, but we'll recompute the type everywhere it's; // used during instantiation, so that should be OK. (Using the; // qualified type is equally wrong.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:13,depend,dependent,13,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,"// If T is an Objective-C object or interface type, or a pointer to an; // object or interface type, the associated namespace is the global; // namespace.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:36,interface,interface,36,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,2,['interface'],['interface']
Integrability,"// If T is not a dependent type or a variably-modified type, there; // is nothing to do.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:17,depend,dependent,17,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['depend'],['dependent']
Integrability,"// If URL is a file on an EOS FUSE mount, attempt redirection to XRootD protocol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:72,protocol,protocol,72,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['protocol'],['protocol']
Integrability,"// If a comdat with one member is not externally visible, we can drop it.; // Otherwise, the comdat can be used to establish dependencies among the; // group of sections. Thus we have to keep the comdat but switch it to; // nodeduplicate.; // Note: nodeduplicate is not necessary for COFF. wasm doesn't support; // nodeduplicate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:125,depend,dependencies,125,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,1,['depend'],['dependencies']
Integrability,"// If a destructor was marked as not selected, we skip it. We don't always; // have a selected destructor: dependent types, unnamed structs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:107,depend,dependent,107,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,1,['depend'],['dependent']
Integrability,"// If a lambda appears in a dependent context or is a generic lambda (has; // template parameters) and has an 'auto' return type, deduce it to a; // dependent type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:28,depend,dependent,28,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,2,['depend'],['dependent']
Integrability,"// If a method has a related return type:; // - if the method found is an instance method, but the message send; // was a class message send, T is the declared return type of the method; // found",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:99,message,message,99,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,2,['message'],['message']
Integrability,"// If a method is not implemented in the category implementation but; // has been declared in its primary class, superclass,; // or in one of their protocols, no need to issue the warning.; // This is because method will be implemented in the primary class; // or one of its super class implementation.; // Ugly, but necessary. Method declared in protocol might have; // have been synthesized due to a property declared in the class which; // uses the protocol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:148,protocol,protocols,148,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,3,['protocol'],"['protocol', 'protocols']"
Integrability,"// If a method lookup fails locally we still need to look and see if; // the method was implemented by a base class or an inherited; // protocol. This lookup is slow, but occurs rarely in correct code; // and otherwise would terminate in a warning.; // check unimplemented instance methods.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:136,protocol,protocol,136,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['protocol'],['protocol']
Integrability,"// If a non-zero global is <= 32 bytes, always use a memcpy. If it is large,; // do it if it will require 6 or fewer scalar stores.; // TODO: Should budget depends on the size? Avoiding a large global warrants; // plopping in more stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:156,depend,depends,156,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,1,['depend'],['depends']
Integrability,"// If a predecessor block is not live, mark it as control-flow live; // which will trigger marking live branches upon which; // that block is control dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:150,depend,dependent,150,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,1,['depend'],['dependent']
Integrability,"// If a rewritten operator were ever to be type-dependent, we should profile; // it following its syntactic operator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp:48,depend,dependent,48,interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp,1,['depend'],['dependent']
Integrability,"// If a specific method has been requested via the protocol; // set it as first",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:51,protocol,protocol,51,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['protocol'],['protocol']
Integrability,"// If a timeout has been specified extract the value and try to apply it (it requires; // support for asynchronous open, though; the following is completely transparent if; // such support if not available for the required protocol)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:223,protocol,protocol,223,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['protocol'],['protocol']
Integrability,"// If all components that depend on obs are binned that so is the product",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx:26,depend,depend,26,roofit/roofitcore/src/RooProduct.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx,1,['depend'],['depend']
Integrability,"// If all dependencies of the node are processed already,; // then the node can be computed now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:10,depend,dependencies,10,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,1,['depend'],['dependencies']
Integrability,"// If all else fails, we still print the usage message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/llvm-xray.cpp:47,message,message,47,interpreter/llvm-project/llvm/tools/llvm-xray/llvm-xray.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/llvm-xray.cpp,1,['message'],['message']
Integrability,"// If all of the names were (corrected to) protocols, these were; // protocol qualifiers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:43,protocol,protocols,43,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['protocol'],"['protocol', 'protocols']"
Integrability,"// If all of the names were protocols, these were protocol qualifiers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:28,protocol,protocols,28,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['protocol'],"['protocol', 'protocols']"
Integrability,// If all of the protocols in the protocol list are objc_non_runtime_protocol; // just return null,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:17,protocol,protocols,17,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,2,['protocol'],"['protocol', 'protocols']"
Integrability,"// If all operands are constant, constant fold the shuffle. This; // transformation depends on the value of the mask which is not known at; // compile time for scalable vectors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:84,depend,depends,84,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['depend'],['depends']
Integrability,"// If an identical load doesn't depends on any local instructions, it can; // be safely moved to PredBB.; // Also check for the implicit control flow instructions. See the comments; // in PerformLoadPRE for details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:32,depend,depends,32,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['depend'],['depends']
Integrability,"// If an instruction defines more than one item in the worklist, we may run; // into situations where a worklist register's value is (potentially); // described by the previous value of another register that is also defined; // by that instruction.; //; // This can for example occur in cases like this:; //; // $r1 = mov 123; // $r0, $r1 = mvrr $r1, 456; // call @foo, $r0, $r1; //; // When describing $r1's value for the mvrr instruction, we need to make sure; // that we don't finalize an entry value for $r0, as that is dependent on the; // previous value of $r1 (123 rather than 456).; //; // In order to not have to distinguish between those cases when finalizing; // entry values, we simply postpone adding new parameter registers to the; // worklist, by first keeping them in this temporary container until the; // instruction has been handled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:524,depend,dependent,524,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,1,['depend'],['dependent']
Integrability,"// If any instructions in the clearance range are reading Reg, insert a; // dependency breaking instruction, which is inexpensive and is likely to; // be hidden in other instruction's cycles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:76,depend,dependency,76,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['depend'],['dependency']
Integrability,"// If any of the branches in the computation graph of the function depend on; // the integrated variable, we can't do analytical integration. The only; // case where this would work is if the branch is an l-value with known; // Jacobian, but this case is already handled in step B) in the constructor; // by reexpressing the original integration variables in terms of; // higher-order l-values if possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:67,depend,depend,67,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,4,"['depend', 'integrat']","['depend', 'integrated', 'integration']"
Integrability,"// If any part of the result matrix type is still pending, just use; // Context.DependentTy, until all parts are resolved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:80,Depend,DependentTy,80,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['Depend'],['DependentTy']
Integrability,"// If any register operand is dependent, this load is dependent and we; // needn't check it.; // FIXME: Is this true in the case where we are hardening loads after; // they complete? Unclear, need to investigate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:30,depend,dependent,30,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,2,['depend'],['dependent']
Integrability,"// If both arguments are readonly, they have no dependence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:48,depend,dependence,48,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,1,['depend'],['dependence']
Integrability,"// If both blocks are identical and end in a branch, merge them unless they; // both have a fallthrough predecessor and successor.; // We can only do this after block placement because it depends on whether; // there are fallthroughs, and we don't know until after layout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:188,depend,depends,188,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['depend'],['depends']
Integrability,"// If both operands are interfaces and either operand can be; // assigned to the other, use that type as the composite; // type. This allows; // xxx ? (A*) a : (B*) b; // where B is a subclass of A.; //; // Additionally, as for assignment, if either type is 'id'; // allow silent coercion. Finally, if the types are; // incompatible then make sure to use 'id' as the composite; // type so the result is acceptable for sending messages to.; // FIXME: Consider unifying with 'areComparableObjCPointerTypes'.; // It could return the composite type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:24,interface,interfaces,24,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,"['interface', 'message']","['interfaces', 'messages']"
Integrability,"// If both sides are affine addrecs for the same loop, with equal; // steps, and we know the recurrences don't wrap, then we only; // need to check the predicate on the starting values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:111,wrap,wrap,111,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,"// If both values wrap regions, see if they're from different base regions.; // Note, heap base symbolic regions are assumed to not alias with; // each other; for example, we assume that malloc returns different address; // on each invocation.; // FIXME: ObjC object pointers always reside on the heap, but currently; // we treat their memory space as unknown, because symbolic pointers; // to ObjC objects may alias. There should be a way to construct; // possibly-aliasing heap-based regions. For instance, MacOSXApiChecker; // guesses memory space for ObjC object pointers manually instead of; // relying on us.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:18,wrap,wrap,18,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,1,['wrap'],['wrap']
Integrability,"// If cling cannot find a name it should ask ROOT before it issues an error.; // If ROOT knows the name then it has to create a new variable with that name; // and type in dedicated for that namespace (eg. __ROOT_SpecialObjects).; // For example if the interpreter is looking for h in h-Draw(), this routine; // will create; // namespace __ROOT_SpecialObjects {; // THist* h = (THist*) the_address;; // }; //; // Later if h is called again it again won't be found by the standart lookup; // because it is in our hidden namespace (nobody should do using namespace; // __ROOT_SpecialObjects). It caches the variable declarations and their; // last address. If the newly found decl with the same name (h) has different; // address than the cached one it goes directly at the address and updates it.; //; // returns true when declaration is found and no error should be emitted.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:300,rout,routine,300,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,1,['rout'],['routine']
Integrability,"// If deduction failed, don't diagnose if the initializer is dependent; it; // might acquire a matching type in the instantiation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:61,depend,dependent,61,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['depend'],['dependent']
Integrability,"// If denominator is an integral, make a clone with the integration range adjusted to; // the selected component of the normalization integral; // cout << ""NOW PROCESSING DENOMINATOR "" << den->ClassName() << ""::"" << den->GetName() << endl ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:56,integrat,integration,56,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['integrat'],['integration']
Integrability,"// If dependence information is not available from LoopAccessInfo,; // conservatively assume the instructions can't be reordered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:6,depend,dependence,6,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['depend'],['dependence']
Integrability,"// If dependency is trough an implicitly defined register, we should not; // newify the use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:6,depend,dependency,6,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['depend'],['dependency']
Integrability,"// If distribution is binned and not open-ended override with bin integrator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumIntFactory.cxx:66,integrat,integrator,66,roofit/roofitcore/src/RooNumIntFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumIntFactory.cxx,1,['integrat'],['integrator']
Integrability,"// If during the previous parse the coroutine still had a dependent promise; // statement, we may need to build some implicit coroutine statements; // (such as exception and fallthrough handlers) for the first time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:58,depend,dependent,58,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['depend'],['dependent']
Integrability,"// If either expression is type-dependent, always build an; // overloaded op.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,depend,dependent,32,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['depend'],['dependent']
Integrability,"// If either group contains multiple different pointers, bail out.; // TODO: Support multiple pointers by using the minimum or maximum pointer,; // depending on src & sink.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:148,depend,depending,148,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['depending']
Integrability,"// If either side is type-dependent, create an appropriate dependent; // expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:26,depend,dependent,26,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,4,['depend'],['dependent']
Integrability,"// If either the parameter has a dependent type or the argument is; // type-dependent, there's nothing we can check now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:33,depend,dependent,33,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,2,['depend'],['dependent']
Integrability,"// If evaluation raised FP exception, the result can depend on rounding; // mode. If the latter is unknown, folding is not possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:53,depend,depend,53,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['depend'],['depend']
Integrability,"// If fDisableOpen is set, only send message and emit signals.; // It allows user to customize handling of double click events.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGListTree.cxx:37,message,message,37,gui/gui/src/TGListTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGListTree.cxx,1,['message'],['message']
Integrability,// If fast-math is set then set the fp-contract mode to fast.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:39,contract,contract,39,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['contract'],['contract']
Integrability,"// If flag is true, integration limits are taken from definition in input function binding",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.h:20,integrat,integration,20,roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooAdaptiveGaussKronrodIntegrator1D.h,1,['integrat'],['integration']
Integrability,"// If for some reason CSE was not enabled, make sure that we invalidate the; // CSEInfo object (as we currently declare that the analysis is preserved).; // The next time get on the wrapper is called, it will force it to recompute; // the analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:182,wrap,wrapper,182,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,1,['wrap'],['wrapper']
Integrability,"// If found object is wrapper, return payload",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx:22,wrap,wrapper,22,roofit/roofitcore/src/RooWorkspace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx,2,['wrap'],['wrapper']
Integrability,"// If function acquires its own stack frame, then it is not a XPLeaf routine.; // At the time this function is called, only slots for local variables are; // allocated, so this is a very rough estimate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:69,rout,routine,69,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,1,['rout'],['routine']
Integrability,"// If function calls other functions including alloca, then it is not a XPLeaf; // routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:83,rout,routine,83,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,1,['rout'],['routine']
Integrability,"// If function modifies the ADA register, then it is not a XPLeaf routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:66,rout,routine,66,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,1,['rout'],['routine']
Integrability,"// If function modifies the return address register, then it is not a XPLeaf; // routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:81,rout,routine,81,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,1,['rout'],['routine']
Integrability,"// If function modifies the stack pointer register, then it is not a XPLeaf; // routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:80,rout,routine,80,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,1,['rout'],['routine']
Integrability,"// If inner loop has dependence and outer loop is loop independent then it; // is/ profitable to interchange to enable inner loop parallelism.; // If there are no dependences, interchanging will not improve anything.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:21,depend,dependence,21,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,2,['depend'],"['dependence', 'dependences']"
Integrability,"// If input is integral, recreate integral but override integration range to be targetRangeName",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:56,integrat,integration,56,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['integrat'],['integration']
Integrability,"// If input is sum of integrals, recreate integral from first component of set, but override integration range to be targetRangeName",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:93,integrat,integration,93,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['integrat'],['integration']
Integrability,"// If interface, check all parent protocols and super.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:6,interface,interface,6,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,2,"['interface', 'protocol']","['interface', 'protocols']"
Integrability,"// If invoke wrapper has already been generated for this call in; // previous EH phase, search for the load instruction; // %__THREW__.val = __THREW__;; // in postamble after the invoke wrapper call",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:13,wrap,wrapper,13,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,2,['wrap'],['wrapper']
Integrability,// If it is a newly kept DIE mark it as well as all its dependencies as; // kept.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:56,depend,dependencies,56,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,1,['depend'],['dependencies']
Integrability,"// If it is a || (or && depending on isEQ), process the operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:24,depend,depending,24,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['depend'],['depending']
Integrability,"// If it was ever a placeholder, it had to been deduced to DependentTy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:59,Depend,DependentTy,59,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,1,['Depend'],['DependentTy']
Integrability,"// If it weren't for layering issues (this header is in llvm/Support, but; // depends on MC?) this should take the Streamer by value rather than rvalue; // reference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/TargetRegistry.h:78,depend,depends,78,interpreter/llvm-project/llvm/include/llvm/MC/TargetRegistry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/TargetRegistry.h,1,['depend'],['depends']
Integrability,"// If it's a dependent specialization, it may not be possible; // to determine the primary template (for explicit specializations); // or befriended declaration (for friends) until the enclosing; // template is instantiated. In such cases, we store the declarations; // found by name lookup and defer resolution until instantiation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:13,depend,dependent,13,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,"// If it's an old version of the protocol try the default TFile::ReadBuffers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TNetFile.cxx:33,protocol,protocol,33,net/net/src/TNetFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TNetFile.cxx,1,['protocol'],['protocol']
Integrability,"// If it's out of range (max dimension is 3), we can just return the constant; // default value (0 or 1 depending on which query function).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:104,depend,depending,104,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,1,['depend'],['depending']
Integrability,"// If it's still dependent, make a dependent specialization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:17,depend,dependent,17,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['depend'],['dependent']
Integrability,"// If it's thread_local, emit a call to its wrapper function instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:44,wrap,wrapper,44,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['wrap'],['wrapper']
Integrability,"// If it's value-dependent, we can't tell whether it's narrowing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:17,depend,dependent,17,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,3,['depend'],['dependent']
Integrability,"// If largest set of observables that can be integrated is empty set, problem was ill defined; // Postpone error messaging and handling to end of function, exit loop here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:45,integrat,integrated,45,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['integrat'],['integrated']
Integrability,"// If libcalls are used to spill and restore callee-saved registers, the frame; // has two sections; the opaque section managed by the libcalls, and the; // section managed by MachineFrameInfo which can also hold callee saved; // registers in fixed stack slots, both of which have negative frame indices.; // This gets even more complicated when incoming arguments are passed via the; // stack, as these too have negative frame indices. An example is detailed; // below:; //; // | incoming arg | <- FI[-3]; // | libcallspill |; // | calleespill | <- FI[-2]; // | calleespill | <- FI[-1]; // | this_frame | <- FI[0]; //; // For negative frame indices, the offset from the frame pointer will differ; // depending on which of these groups the frame index applies to.; // The following calculates the correct offset knowing the number of callee; // saved registers spilt by the two methods.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:701,depend,depending,701,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['depend'],['depending']
Integrability,// If loads occur at a distance that is not a multiple of a feasible vector; // factor store-load forwarding does not take place.; // Positive dependences might cause troubles because vectorizing them might; // prevent store-load forwarding making vectorized code run a lot slower.; // a[i] = a[i-3] ^ a[i-8];; // The stores to a[i:i+1] don't align with the stores to a[i-3:i-2] and; // hence on your typical architecture store-load forwarding does not take; // place. Vectorizing in such cases does not make sense.; // Store-load forwarding distance.; // After this many iterations store-to-load forwarding conflicts should not; // cause any slowdowns.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:143,depend,dependences,143,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['dependences']
Integrability,// If lookahead indicates an ObjC message send...; // [identifier identifier,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:34,message,message,34,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['message'],['message']
Integrability,// If mad is not available this depends only on if f32 fma is full rate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:32,depend,depends,32,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['depend'],['depends']
Integrability,"// If message is kMESS_OBJECT pointer to object's class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TMessage.h:6,message,message,6,net/net/inc/TMessage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TMessage.h,1,['message'],['message']
Integrability,"// If needed for precedence reasons, wrap the inner part in grouping parens.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:37,wrap,wrap,37,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,4,['wrap'],['wrap']
Integrability,"// If no V1 inputs are used in place, then the result is created only from; // the zero mask and the V2 insertion - so remove V1 dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:129,depend,dependency,129,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['depend'],['dependency']
Integrability,"// If no array size was specified, but the new expression was; // instantiated with an array type (e.g., ""new T"" where T is; // instantiated with ""int[4]""), extract the outer bound from the; // array type as our array size. We do this with constant and; // dependently-sized array types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:257,depend,dependently-sized,257,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['depend'],['dependently-sized']
Integrability,"// If no availability attributes are found, inherit the attribute from the; // containing decl or the class or category interface decl.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:120,interface,interface,120,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['interface'],['interface']
Integrability,"// If no cross address space ordering then an ""S_WAITCNT lgkmcnt(0)"" is; // not needed as LDS operations for all waves are executed in a total; // global ordering as observed by all waves. Required if also; // synchronizing with global/GDS memory as LDS operations could be; // reordered with respect to later global/GDS memory operations of the; // same wave.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:210,synchroniz,synchronizing,210,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,3,['synchroniz'],['synchronizing']
Integrability,"// If no cross address space ordering then an GDS ""S_WAITCNT lgkmcnt(0)""; // is not needed as GDS operations for all waves are executed in a total; // global ordering as observed by all waves. Required if also; // synchronizing with global/LDS memory as GDS operations could be; // reordered with respect to later global/LDS memory operations of the; // same wave.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:214,synchroniz,synchronizing,214,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,2,['synchroniz'],['synchronizing']
Integrability,"// If no error has been generated before now, assume the problem is in; // the body and generate a message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp:99,message,message,99,interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp,1,['message'],['message']
Integrability,"// If no new location has been found, every variable that depends on this; // MLoc is dead, so end their existing MLoc->Var mappings as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:58,depend,depends,58,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['depend'],['depends']
Integrability,"// If no observables can be integrated analytically, return code 0 here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx:28,integrat,integrated,28,roofit/roofitcore/src/RooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx,1,['integrat'],['integrated']
Integrability,"// If no super class conforms to the protocol, we should not search; // for methods in the super class to implicitly satisfy the protocol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:37,protocol,protocol,37,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['protocol'],['protocol']
Integrability,"// If not inlinable, get reference to barrier depending on the instruction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp:46,depend,depending,46,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,1,['depend'],['depending']
Integrability,"// If not, then show an error message and leave.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx:30,message,message,30,gui/fitpanel/src/TFitEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx,1,['message'],['message']
Integrability,"// If nothing changed, just retain the existing message send.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:48,message,message,48,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['message'],['message']
Integrability,"// If nothing left to lex, then don't wrap any of it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp:38,wrap,wrap,38,interpreter/cling/lib/Utils/SourceNormalization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp,1,['wrap'],['wrap']
Integrability,"// If nothing was integrated analytically, swap back LVbranches for LVservers for subsequent numeric integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:18,integrat,integrated,18,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,2,['integrat'],"['integrated', 'integration']"
Integrability,"// If one of the SU in the subgraph depends on the result of SU j,; // there'll be a data dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:36,depend,depends,36,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,2,['depend'],"['dependency', 'depends']"
Integrability,"// If only few constants depend on this IP of base, skip rebasing,; // assuming the base and the rebased have the same materialization cost.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:25,depend,depend,25,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,1,['depend'],['depend']
Integrability,"// If optional error message is not empty, append it to the message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp:21,message,message,21,interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,4,['message'],['message']
Integrability,"// If our client can't cope with us being out of date, we can't cope with; // our dependency being missing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:82,depend,dependency,82,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['depend'],['dependency']
Integrability,"// If our contiguous sequence of ones wraps around from the MSB into the LSB,; // just swap indices and pretend we are materializing a contiguous sequence; // of zeros surrounded by a contiguous sequence of ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandImm.cpp:38,wrap,wraps,38,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandImm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandImm.cpp,1,['wrap'],['wraps']
Integrability,"// If our operands are only 32-bit wide, make sure we use 32-bit; // arithmetic for the check whether we can use CSINC. This ensures that; // the addition in the check will wrap around properly in case there is; // an overflow (which would not be the case if we do the check with; // 64-bit arithmetic).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:173,wrap,wrap,173,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['wrap'],['wrap']
Integrability,"// If our previous scan pointer is inside the buffer, assume we already; // scanned those bytes. This depends on raw_ostream to not change our buffer; // in unexpected ways.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FormattedStream.cpp:102,depend,depends,102,interpreter/llvm-project/llvm/lib/Support/FormattedStream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FormattedStream.cpp,1,['depend'],['depends']
Integrability,"// If our type is followed by an identifier and either ':' or ']', then; // this is probably an Objective-C message send where the leading '[' is; // missing. Recover as if that were the case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:108,message,message,108,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['message'],['message']
Integrability,"// If our type is instantiation-dependent but not dependent, we mangle; // it as it was written in the source, removing any top-level sugar.; // Otherwise, use the canonical type.; //; // FIXME: This is an approximation of the instantiation-dependent name; // mangling rules, since we should really be using the type as written and; // augmented via semantic analysis (i.e., with implicit conversions and; // default template arguments) for any instantiation-dependent type.; // Unfortunately, that requires several changes to our AST:; // - Instantiation-dependent TemplateSpecializationTypes will need to be; // uniqued, so that we can handle substitutions properly; // - Default template arguments will need to be represented in the; // TemplateSpecializationType, since they need to be mangled even though; // they aren't written.; // - Conversions on non-type template arguments need to be expressed, since; // they can affect the mangling of sizeof/alignof.; //; // FIXME: This is wrong when mapping to the canonical type for a dependent; // type discards instantiation-dependent portions of the type, such as for:; //; // template<typename T, int N> void f(T (&)[sizeof(N)]);; // template<typename T> void f(T() throw(typename T::type)); (pre-C++17); //; // It's also wrong in the opposite direction when instantiation-dependent,; // canonically-equivalent types differ in some irrelevant portion of inner; // type sugar. In such cases, we fail to form correct substitutions, eg:; //; // template<int N> void f(A<sizeof(N)> *, A<sizeof(N)> (*));; //; // We should instead canonicalize the non-instantiation-dependent parts,; // regardless of whether the type as a whole is dependent or instantiation; // dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:32,depend,dependent,32,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,11,['depend'],['dependent']
Integrability,"// If possible, merge the next line's wrapped left brace with the; // current line. Otherwise, leave it on the next line, as this is a; // multi-line control statement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:38,wrap,wrapped,38,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,1,['wrap'],['wrapped']
Integrability,"// If possible, use the hasAssumedIRAttr interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:41,interface,interface,41,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,4,['interface'],['interface']
Integrability,"// If post-load hardening is enabled, this load is compatible with; // post-load hardening, and we aren't already going to harden one of the; // address registers, queue it up to be hardened post-load. Notably,; // even once hardened this won't introduce a useful dependency that; // could prune out subsequent loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:264,depend,dependency,264,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['depend'],['dependency']
Integrability,"// If protocol, check all parent protocols.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:6,protocol,protocol,6,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,2,['protocol'],"['protocol', 'protocols']"
Integrability,"// If sign extension operations are disabled, allow sext_inreg only if operand; // is a vector extract of an i8 or i16 lane. SIMD does not depend on sign; // extension operations, but allowing sext_inreg in this context lets us have; // simple patterns to select extract_lane_s instructions. Expanding sext_inreg; // everywhere would be simpler in this file, but would necessitate large and; // brittle patterns to undo the expansion and select extract_lane_s; // instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:139,depend,depend,139,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,1,['depend'],['depend']
Integrability,"// If so, the canonical type of this TST is the injected; // class name type of the record we just found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:48,inject,injected,48,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['inject'],['injected']
Integrability,"// If somehow the Setup fails call the original Read to; // have the proper error handling (message only if the Setup fails; // and the current proxy entry is different than the TTree's current entry)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx:92,message,message,92,tree/treeplayer/src/TTreeReaderValue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx,1,['message'],['message']
Integrability,"// If someone can figure out a general rule for this, that would be great.; // It's probably just doomed to be platform-dependent, though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.cpp:120,depend,dependent,120,interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.cpp,1,['depend'],['dependent']
Integrability,"// If source is undef or we know it won't be used, use a zero vector; // to break register dependency.; // TODO: use undef instead and let BreakFalseDeps deal with it?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:91,depend,dependency,91,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['depend'],['dependency']
Integrability,"// If substitution fails, the default argument is set to a; // RecoveryExpr that wraps the uninstantiated default argument so; // that downstream diagnostics are omitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:81,wrap,wraps,81,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,3,['wrap'],['wraps']
Integrability,"// If symbol is unset, it might be created in the `parseSetAssignment`; // routine as an alias for a numeric register name.; // Lookup in the aliases list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:75,rout,routine,75,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['rout'],['routine']
Integrability,// If template type is not ODR-used its definition is only available; // in the template definition not its instantiation.; // FIXME: This logic doesn't work for types that depend on template; // parameter (PR58590).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:173,depend,depend,173,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['depend']
Integrability,"// If the Callee is a record type, then it is a not-yet-resolved; // dependent call to the call operator of that type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:69,depend,dependent,69,interpreter/llvm-project/clang/lib/AST/Expr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp,1,['depend'],['dependent']
Integrability,"// If the Keep flag is set, we are marking a required DIE's dependencies.; // If our target is already marked as kept, we're all set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:60,depend,dependencies,60,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,1,['depend'],['dependencies']
Integrability,"// If the LHS and RHS of the ADC node are zero, then it can't overflow and; // the result is either zero or one (depending on the input carry bit).; // Strength reduce this down to a ""set on carry"" aka SETCC_CARRY&1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:113,depend,depending,113,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['depend'],['depending']
Integrability,"// If the LHS has protocol qualifiers, determine whether all of them are; // satisfied by the RHS (i.e., the RHS has a superset of the protocols in the; // LHS).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:18,protocol,protocol,18,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,2,['protocol'],"['protocol', 'protocols']"
Integrability,"// If the Objective-C message expression is an implicit no-return that; // is not modeled in the CFG, set the tracked dataflow values to Unknown.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:22,message,message,22,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,1,['message'],['message']
Integrability,"// If the RHS is a qualified interface pointer ""NSString<P>*"",; // make sure we check the class hierarchy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:29,interface,interface,29,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['interface'],['interface']
Integrability,"// If the RHS is a unqualified interface pointer ""NSString*"",; // make sure we check the class hierarchy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:31,interface,interface,31,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['interface'],['interface']
Integrability,"// If the SU for the instruction being updated has debug information; // related to the anti-dependency register, make sure to update that; // as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:93,depend,dependency,93,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,1,['depend'],['dependency']
Integrability,"// If the SU for the instruction being updated has debug; // information related to the anti-dependency register, make; // sure to update that as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:93,depend,dependency,93,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,1,['depend'],['dependency']
Integrability,"// If the SUnit has other dependencies on the SUnit that it; // anti-depends on, don't bother breaking the anti-dependency; // since those edges would prevent such units from being; // scheduled past each other regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:26,depend,dependencies,26,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,5,['depend'],"['dependencies', 'dependency', 'depends']"
Integrability,"// If the SUnit has other dependencies on the SUnit that; // it anti-depends on, don't bother breaking the; // anti-dependency since those edges would prevent such; // units from being scheduled past each other; // regardless.; //; // Also, if there are dependencies on other SUnits with the; // same register as the anti-dependency, don't attempt to; // break it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:26,depend,dependencies,26,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,5,['depend'],"['dependencies', 'dependency', 'depends']"
Integrability,"// If the Ty is i128 and the function being called is a long double emulation; // routine, then the original type is f128.; // FIXME: This is unsound because these functions could be indirectly called",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.cpp:82,rout,routine,82,interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.cpp,1,['rout'],['routine']
Integrability,"// If the add does not wrap, we can always adjust the compare by subtracting; // the constants. Equality comparisons are handled elsewhere. SGE/SLE/UGE/ULE; // are canonicalized to SGT/SLT/UGT/ULT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:23,wrap,wrap,23,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['wrap'],['wrap']
Integrability,"// If the addition is not contractable, do not combine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:26,contract,contractable,26,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,2,['contract'],['contractable']
Integrability,"// If the argument is never passed through callbacks, no-alias cannot break; // synchronization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:80,synchroniz,synchronization,80,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['synchroniz'],['synchronization']
Integrability,"// If the argument is read-only, no-alias cannot break synchronization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:55,synchroniz,synchronization,55,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['synchroniz'],['synchronization']
Integrability,"// If the argument points to something that's not a symbolic region, it; // can be:; // - unknown (cannot reason about it); // - undefined (already reported by other checker); // - constant (null - should not be tracked,; // other constant will generate a compiler warning); // - goto (should be reported by other checker); // The call return value symbol should stay alive for as long as the; // allocated value symbol, since our diagnostics depend on the value; // returned by the call. Ex: Data should only be freed if noErr was; // returned during allocation.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:443,depend,depend,443,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,1,['depend'],['depend']
Integrability,"// If the argument type is dependent, instantiate it now based; // on the previously-computed template arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:27,depend,dependent,27,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,"// If the atomicrmw's result is used by a single bit AND, we may use; // bts/btr/btc instruction for these operations.; // Note: InstCombinePass can cause a de-optimization here. It replaces the; // SETCC(And(AtomicRMW(P, power_of_2), power_of_2)) with LShr and Xor; // (depending on CC). This pattern can only use bts/btr/btc but we don't; // detect it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:271,depend,depending,271,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['depend'],['depending']
Integrability,"// If the attribute is deprecated, print a message about it, and possibly; // provide a replacement attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:43,message,message,43,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,1,['message'],['message']
Integrability,"// If the backchain pointer should be stored, then it is not a XPLeaf routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:70,rout,routine,70,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,1,['rout'],['routine']
Integrability,"// If the base type is a TagType (struct/interface/union/class/enum), let's; // get the underlying Decl for better names and USRs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:41,interface,interface,41,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,1,['interface'],['interface']
Integrability,"// If the base type is an interface and there aren't any protocols or; // type arguments to add, then the interface type will do just fine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:26,interface,interface,26,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,3,"['interface', 'protocol']","['interface', 'protocols']"
Integrability,"// If the bit-width is type- or value-dependent, don't try to check; // it now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:38,depend,dependent,38,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,"// If the block has a dependency (i.e. it isn't completely transparent to; // the value), remember the association!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:22,depend,dependency,22,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['dependency']
Integrability,"// If the block has a dependency (i.e. it isn't completely transparent to; // the value), remember the reverse association because we just added it; // to Cache!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:22,depend,dependency,22,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['dependency']
Integrability,"// If the block has other successors, we can not delete it because; // it has other dependents.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:84,depend,dependents,84,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['depend'],['dependents']
Integrability,"// If the branch has a condition wrapped by __builtin_unpredictable,; // create metadata that specifies that the branch is unpredictable.; // Don't bother if not optimizing because that metadata would not be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:33,wrap,wrapped,33,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['wrap'],['wrapped']
Integrability,"// If the buffer contains preprocessor directives, we do more fine-grained; // rewrites. This is intended to fix code that looks like (which occurs in; // NSURL.h, for example):; //; // #ifdef XYZ; // @interface Foo : NSObject; // #else; // @interface FooBar : NSObject; // #endif; // {; // int i;; // }; // @end; //; // This clause is segregated to avoid breaking the common case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:202,interface,interface,202,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,2,['interface'],['interface']
Integrability,// If the build vector contains zeros or our first insertion is not the; // first index then insert into zero vector to break any register; // dependency else use SCALAR_TO_VECTOR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:143,depend,dependency,143,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['depend'],['dependency']
Integrability,"// If the cached entry is non-dirty, just return it. Note that this depends; // on MemDepResult's default constructing to 'dirty'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:68,depend,depends,68,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['depends']
Integrability,"// If the call is malloc/calloc like, we can assume that it doesn't; // modify any IR visible value. This is only valid because we assume these; // routines do not read values visible in the IR. TODO: Consider special; // casing realloc and strdup routines which access only their arguments as; // well. Or alternatively, replace all of this with inaccessiblememonly once; // that's implemented fully.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:148,rout,routines,148,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,2,['rout'],['routines']
Integrability,"// If the callee has attribute pure, const, or warn_unused_result, warn with; // a more specific message to make it clear what is happening. If the call; // is written in a macro body, only warn if it has the warn_unused_result; // attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:97,message,message,97,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['message'],['message']
Integrability,"// If the caller expects a signed compare, then try to use a signed range.; // Otherwise if both no-wraps are set, use the unsigned range because it; // is never larger than the signed range. Example:; // ""add nuw nsw i8 X, -2"" is unsigned [254,255] vs. signed [-128, 125].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:100,wrap,wraps,100,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['wrap'],['wraps']
Integrability,"// If the class has any dependent bases, then it's possible that; // one of those types will resolve to the same type as; // BaseType. Therefore, just treat this as a dependent base; // class initialization. FIXME: Should we try to check the; // initialization anyway? It seems odd.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:24,depend,dependent,24,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,2,['depend'],['dependent']
Integrability,"// If the class interface is declared inside the main file, assume it is not; // subcassed.; // TODO: It could actually be subclassed if the subclass is private as well.; // This is probably very rare.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:16,interface,interface,16,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,1,['interface'],['interface']
Integrability,"// If the class is non-dependent, mark the default arguments as ODR-used so; // that we can properly codegen the constructor closure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:23,depend,dependent,23,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['dependent']
Integrability,"// If the class's context can't instantiate to the friend's; // context, it can't be a dependent match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:87,depend,dependent,87,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['depend'],['dependent']
Integrability,"// If the client doesn't care about this message, don't issue it. If this is; // a note and the last real diagnostic was ignored, ignore it too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:41,message,message,41,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,1,['message'],['message']
Integrability,"// If the condition controls loop exit (the loop exits only if the expression; // is true) and the addition is no-wrap we can use unsigned divide to; // compute the backedge count. In this case, the step may not divide the; // distance, but we don't care because if the condition is ""missed"" the loop; // will have undefined behavior due to wrapping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:114,wrap,wrap,114,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,2,['wrap'],"['wrap', 'wrapping']"
Integrability,"// If the context isn't dependent, it can't be a dependent match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:24,depend,dependent,24,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,2,['depend'],['dependent']
Integrability,"// If the current CPSR has high latency, try to avoid the false dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:64,depend,dependency,64,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,1,['depend'],['dependency']
Integrability,"// If the declaration is a non-dependent, incomplete array type; // that has an initializer, then its type will be completed once; // the initializer is instantiated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:31,depend,dependent,31,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['depend'],['dependent']
Integrability,"// If the declaration is dependent or is in a dependent context, then the; // mangling is unlikely to be meaningful (and in some cases may cause; // ""don't know how to mangle this"" assertion failures.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp:25,depend,dependent,25,interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp,2,['depend'],['dependent']
Integrability,"// If the def has a ConstantExpr use, then the def is either a; // ConstantExpr use itself or null. In either case; // (recursively in the first, directly in the second), the oop; // it is ultimately dependent on is null and this particular; // use does not need to be fixed up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:200,depend,dependent,200,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['depend'],['dependent']
Integrability,"// If the depend or doacross clause is specified, the ordered construct; // is a stand-alone directive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:10,depend,depend,10,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,1,['depend'],['depend']
Integrability,"// If the dependant is emitted and this node was the last of its; // unemitted dependencies then the dependant node is now ready, so; // notify any pending queries on the dependant node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:10,depend,dependant,10,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,4,['depend'],"['dependant', 'dependencies']"
Integrability,"// If the dependence is to a store that writes to a superset of the bits; // read by the load, we can extract the bits we need for the load from the; // stored value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:10,depend,dependence,10,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['depend'],['dependence']
Integrability,"// If the dependency is in an error state then note this and continue,; // we will move this symbol to the error state below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:10,depend,dependency,10,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['depend'],['dependency']
Integrability,"// If the dependency is within the same block or loop level (being careful; // of irreducible loops), we know that AA will return a valid result for the; // memory dependency. (Both at the function level, outside of any loop,; // would also be valid but we currently disable that to limit compile time).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:10,depend,dependency,10,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,2,['depend'],['dependency']
Integrability,// If the dependency was not in the error state then add it to; // our list of dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:10,depend,dependency,10,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,2,['depend'],"['dependencies', 'dependency']"
Integrability,"// If the dependent action is a device action, we will attempt to collapse; // only with other device actions. Otherwise, we would do the same but; // with host actions only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:10,depend,dependent,10,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['depend'],['dependent']
Integrability,"// If the element is just cached and not repeat, we need to inject an element; // to insure the writing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:60,inject,inject,60,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,2,['inject'],['inject']
Integrability,"// If the element type isn't canonical or has qualifiers, or the array bound; // is instantiation-dependent, this won't be a canonical type either, so fill; // in the canonical type field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:98,depend,dependent,98,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['depend'],['dependent']
Integrability,"// If the enclosing function is not dependent, then this lambda is; // capture ready, so if we can capture this, do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:36,depend,dependent,36,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['depend'],['dependent']
Integrability,"// If the enclosingDC is not dependent, then the immediately nested lambda; // (one index above) is capture-ready.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:29,depend,dependent,29,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,1,['depend'],['dependent']
Integrability,"// If the expression is not value dependent (not templated), then we can; // apply the address space qualifiers just to the equivalent type.; // Otherwise, we make an AttributedType with the modified and equivalent; // type the same, and wrap it in a DependentAddressSpaceType. When this; // dependent type is resolved, the qualifier is added to the equivalent type; // later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:34,depend,dependent,34,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,4,"['Depend', 'depend', 'wrap']","['DependentAddressSpaceType', 'dependent', 'wrap']"
Integrability,"// If the expression is type-dependent, there's nothing for us to do.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:29,depend,dependent,29,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['depend'],['dependent']
Integrability,"// If the feature is an architecture feature (like v8.2a), add all previous; // architecture versions and any dependant target features.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:110,depend,dependant,110,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,1,['depend'],['dependant']
Integrability,"// If the first attempt failed, we instantiate an old interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofMgr.cxx:54,interface,interface,54,proof/proof/src/TProofMgr.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofMgr.cxx,1,['interface'],['interface']
Integrability,"// If the first name isn't at the module layer, wrap the pipeline up; // automatically.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp:48,wrap,wrap,48,interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,1,['wrap'],['wrap']
Integrability,"// If the function adjusts the stack, then it is not a XPLeaf routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:62,rout,routine,62,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,1,['rout'],['routine']
Integrability,"// If the function has a deduced return type, substitute it for a dependent; // type so that we treat it as a non-deduced context in what follows.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:66,depend,dependent,66,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['depend'],['dependent']
Integrability,"// If the function has a dependent exception specification, resolve it now,; // so we can check that the exception specification matches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:25,depend,dependent,25,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['depend'],['dependent']
Integrability,"// If the function has var Sized Objects, then it is not a XPLeaf routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp:66,rout,routine,66,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZFrameLowering.cpp,1,['rout'],['routine']
Integrability,"// If the function is shrink-wrapped, and if the function has a tail call, the; // tail call might not be in the new RestoreBlock, so real branch instruction; // won't be generated by emitEpilogue(), because shrink-wrap has chosen new; // RestoreBlock. So we handle this case here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:29,wrap,wrapped,29,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,2,['wrap'],"['wrap', 'wrapped']"
Integrability,"// If the function template has a non-dependent explicit specification,; // exclude it now if appropriate; we are not permitted to perform deduction; // and substitution in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:38,depend,dependent,38,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,2,['depend'],['dependent']
Integrability,"// If the function template is referenced directly (for instance, as a; // member of the current instantiation), pretend it has a dependent type.; // This is not really justified by the standard, but is the only sane; // thing to do.; // FIXME: For a friend function, we have not marked the function as being; // a friend yet, so 'isDependentContext' on the FD doesn't work.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:130,depend,dependent,130,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,"// If the function type is dependent, try to resolve it through the class's; // template arguments. If that fails, skip this function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx:27,depend,dependent,27,core/metacling/src/TClingMethodInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx,1,['depend'],['dependent']
Integrability,"// If the function we are wrapping was ExternWeak, it may be null.; // The original code before calling this wrapper may have checked for null,; // but replacing with a known-to-not-be-null wrapper can break this check.; // When replacing uses of the extern weak function with the wrapper we try; // to avoid replacing uses in conditionals, but this is not perfect.; // In the case where we fail, and accidentally optimize out a null check; // for a extern weak function, add a check here to help identify the issue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:26,wrap,wrapping,26,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,4,['wrap'],"['wrapper', 'wrapping']"
Integrability,// If the generation number wrapped recompute everything.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:28,wrap,wrapped,28,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrapped']
Integrability,"// If the given name refers to an interface type, retrieve the; // corresponding declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:34,interface,interface,34,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['interface'],['interface']
Integrability,"// If the head of the list is also a BaseClass, we'll overwrite it to avoid; // note messages like 'this->A::B::x'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:85,message,messages,85,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,1,['message'],['messages']
Integrability,"// If the identifier is ""super"" and there is no trailing dot, we're; // messaging super. If the identifier is ""super"" and there is a; // trailing dot, it's an instance message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:168,message,message,168,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['message'],['message']
Integrability,"// If the identifier is a class or not, and there is a trailing dot,; // it's an instance message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:90,message,message,90,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['message'],['message']
Integrability,"// If the increment is an inbounds GEP, then we know the address; // space cannot be wrapped around. We cannot make any guarantee; // about signed or unsigned overflow because pointers are; // unsigned but we may have a negative index from the base; // pointer. We can guarantee that no unsigned wrap occurs if the; // indices form a positive value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:85,wrap,wrapped,85,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,2,['wrap'],"['wrap', 'wrapped']"
Integrability,"// If the increment is positive, the SCEV NUW flag will also imply the; // WrapPredicate NUSW flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:75,Wrap,WrapPredicate,75,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Wrap'],['WrapPredicate']
Integrability,"// If the index is dependent on the store we will introduce a cycle when; // creating the load (the load uses the index, and by replacing the chain; // we will make the index dependent on the load). Also, the store might be; // dependent on the extractelement and introduce a cycle when creating; // the load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:19,depend,dependent,19,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,3,['depend'],['dependent']
Integrability,"// If the induction step is negative we have to invert source and sink of the; // dependence when measuring the distance between them. We should not swap; // AIsWrite with BIsWrite, as their uses expect them in program order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:82,depend,dependence,82,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// If the initializer might depend on the array index, run it for each; // array element.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:28,depend,depend,28,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['depend'],['depend']
Integrability,"// If the inlined code contained dynamic alloca instructions, wrap the inlined; // code with llvm.stacksave/llvm.stackrestore intrinsics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:62,wrap,wrap,62,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['wrap'],['wrap']
Integrability,"// If the inner loop is loop independent or doesn't carry any dependency; // it is not profitable to move this to outer position, since we are; // likely able to do inner loop vectorization already.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:62,depend,dependency,62,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,1,['depend'],['dependency']
Integrability,"// If the input has been truncated, try to integrate that trunc into the; // scatter instruction (we don't care about alignment here)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:43,integrat,integrate,43,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,1,['integrat'],['integrate']
Integrability,"// If the input is a BUILD_VECTOR with all constant elements, fold this now.; // Only do this before legalize types, unless both types are integer and the; // scalar type is legal. Only do this before legalize ops, since the target; // maybe depending on the bitcast.; // First check to see if this is all constant.; // TODO: Support FP bitcasts after legalize types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:242,depend,depending,242,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['depend'],['depending']
Integrability,"// If the instruction does not access memory and has no side effects, it has; // no additional dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:95,depend,dependencies,95,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,1,['depend'],['dependencies']
Integrability,"// If the instruction has a non-zero latency dependence with an instruction in; // the current packet, then it should not be scheduled yet. The case occurs; // when the dependent instruction is scheduled in a new packet, so the; // scheduler updates the current cycle and pending instructions become; // available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:45,depend,dependence,45,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,2,['depend'],"['dependence', 'dependent']"
Integrability,"// If the instruction has a true dependency, we can hide the false depdency; // behind it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:33,depend,dependency,33,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,1,['depend'],['dependency']
Integrability,"// If the instruction has side-effects, give up.; // TODO: The case of mayReadFromMemory we can handle but requires; // additional work with a dependence analysis so for now we give; // up on memory reads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:143,depend,dependence,143,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['depend'],['dependence']
Integrability,"// If the interface has the objc_runtime_visible attribute, we; // cannot implement a category for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:10,interface,interface,10,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['interface'],['interface']
Integrability,"// If the lambda expression's call operator is not explicitly marked constexpr; // and we are not in a dependent context, analyze the call operator to infer; // its constexpr-ness, suppressing diagnostics while doing so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:103,depend,dependent,103,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,1,['depend'],['dependent']
Integrability,"// If the latency is 0 and there is a data dependence between this; // instruction and any instruction in the current packet, we disregard any; // potential stalls due to the instructions in the previous packet. Most of; // the instruction pairs that can go together in the same packet have 0; // latency between them. The exceptions are; // 1. NewValueJumps as they're generated much later and the latencies can't; // be changed at that point.; // 2. .cur instructions, if its consumer has a 0 latency successor (such as; // .new). In this case, the latency between .cur and the consumer stays; // non-zero even though we can have both .cur and .new in the same packet.; // Changing the latency to 0 is not an option as it causes software pipeliner; // to not pipeline in some cases.; // For Example:; // {; // I1: v6.cur = vmem(r0++#1); // I2: v7 = valign(v6,v4,r2); // I3: vmem(r5++#1) = v7.new; // }; // Here I2 and I3 has 0 cycle latency, but I1 and I2 has 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:43,depend,dependence,43,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['depend'],['dependence']
Integrability,"// If the loop contains a convergent operation, the prelude we'd add; // to do the first few instructions before we hit the unrolled loop; // is unsafe -- it adds a control-flow dependency to the convergent; // operation. Therefore restrict remainder loop (try unrolling without).; //; // TODO: This is quite conservative. In practice, convergent_op(); // is likely to be called unconditionally in the loop. In this; // case, the program would be ill-formed (on most architectures); // unless n were the same on all threads in a thread group.; // Assuming n is the same on all threads, any kind of unrolling is; // safe. But currently llvm's notion of convergence isn't powerful; // enough to express this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:178,depend,dependency,178,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['depend'],['dependency']
Integrability,"// If the loop is in LoopSimplify form, then extract it only if this function; // is more than a minimal wrapper around the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp:105,wrap,wrapper,105,interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp,1,['wrap'],['wrapper']
Integrability,"// If the loop's critical path involves loop-carried dependences, the gradient; // of the gain needs to be at least GainGradientThreshold% (defaults to 25%).; // This check ensures that the latency reduction for the loop's critical path; // keeps decreasing with sufficient rate beyond the two analyzed loop; // iterations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:53,depend,dependences,53,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,1,['depend'],['dependences']
Integrability,"// If the method is a special member function, we need to mark it as; // ineligible so that Owner->addDecl() won't mark the class as non trivial.; // At the end of the class instantiation, we calculate eligibility again and; // then we adjust trivility if needed.; // We need this check to happen only after the method parameters are set,; // because being e.g. a copy constructor depends on the instantiated; // arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:381,depend,depends,381,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['depend'],['depends']
Integrability,"// If the multiply does not wrap or the constant is odd, try to divide the; // compare constant by the multiplication factor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:28,wrap,wrap,28,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['wrap'],['wrap']
Integrability,"// If the name is invalid, issue an error message and return a nullptr",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx:42,message,message,42,io/io/src/TDirectoryFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx,1,['message'],['message']
Integrability,"// If the name is still dependent, just build a new dependent name type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:24,depend,dependent,24,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['depend'],['dependent']
Integrability,"// If the name itself is dependent, then the result is dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:25,depend,dependent,25,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,2,['depend'],['dependent']
Integrability,"// If the name of this protocol is out-of-date, bring it up-to-date, which; // might bring in a definition.; // Note: a null value indicates that we don't have a definition and that; // modules are enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:23,protocol,protocol,23,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['protocol'],['protocol']
Integrability,"// If the named context is dependent, we can't decide much.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:27,depend,dependent,27,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['dependent']
Integrability,"// If the nested loop is an innermost loop, prefer to a 32-byte alignment,; // so that we can decrease cache misses and branch-prediction misses.; // Actual alignment of the loop will depend on the hotness check and other; // logic in alignBlocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:184,depend,depend,184,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['depend'],['depend']
Integrability,"// If the nested-name-specifier is dependent and couldn't be; // resolved to a type, build a typename type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:35,depend,dependent,35,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,"// If the next token signals the end of a template argument, then we have; // a (possibly-dependent) template name that could be a template template; // argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:90,depend,dependent,90,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['depend'],['dependent']
Integrability,"// If the null pointer is undefined, then a access sequence which would; // otherwise access it can be assumed not to unsigned wrap. Note that this; // assumes the object in memory is aligned to the natural alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:127,wrap,wrap,127,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['wrap'],['wrap']
Integrability,"// If the object was constructed with a constructor, its value is a; // LazyCompoundVal. If it's a raw CompoundVal, it means that we're; // performing aggregate initialization. The only exception from this; // rule is sending an Objective-C++ message that returns a C++ object; // to a nil receiver; in this case the semantics is to return a; // zero-initialized object even if it's a C++ object that doesn't have; // this sort of constructor; the CompoundVal is empty in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:243,message,message,243,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,1,['message'],['message']
Integrability,"// If the observable doesn't depend linearly on the integration; // variable we will not do analytical integration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHistPdf.cxx:29,depend,depend,29,roofit/roofitcore/src/RooHistPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHistPdf.cxx,3,"['depend', 'integrat']","['depend', 'integration']"
Integrability,"// If the old type was dependent, we can't merge with it, so the new type; // becomes dependent for now. We'll reproduce the original type when we; // instantiate the TypeSourceInfo for the variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:23,depend,dependent,23,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['depend'],['dependent']
Integrability,"// If the option is not specified, the default behavior about whether; // counter promotion is done depends on how instrumentaiton lowering; // pipeline is setup, i.e., the default value of true of this option; // does not mean the promotion will be done by default. Explicitly; // setting this option can override the default behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:100,depend,depends,100,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,1,['depend'],['depends']
Integrability,"// If the original flags and all inlined SCEVAddExprs are NUW, use the; // common NUW flag for expression after inlining. Other flags cannot be; // preserved, because they may depend on the original order of operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:176,depend,depend,176,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['depend'],['depend']
Integrability,"// If the original lookup was an unqualified lookup, fake an; // unqualified lookup. This is useful when (for example) the; // original lookup would not have found something because it was a; // dependent name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:195,depend,dependent,195,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['depend'],['dependent']
Integrability,// If the other symbol is already in the Ready state then there's no; // dependency to add.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:73,depend,dependency,73,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['depend'],['dependency']
Integrability,"// If the output is set to be emitted to standard out, and standard out is a; // console, print out a warning message and refuse to do it. We don't; // impress anyone by spewing tons of binary goo to a terminal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/opt/opt.cpp:110,message,message,110,interpreter/llvm-project/llvm/tools/opt/opt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/opt/opt.cpp,1,['message'],['message']
Integrability,"// If the output streamer does not have mature MC support or the integrated; // assembler has been disabled or not required, just emit the blob textually.; // Otherwise parse the asm and emit it via MC support.; // This is useful in case the asm parser doesn't handle something but the; // system assembler does.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp:65,integrat,integrated,65,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,1,['integrat'],['integrated']
Integrability,"// If the parameter type is not dependent, there is nothing to deduce.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:32,depend,dependent,32,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['depend'],['dependent']
Integrability,"// If the parameter's type is not dependent, update it to match the type; // in the pattern. They can differ in top-level cv-qualifiers, and we want; // the pattern's type here. If the type is dependent, they can't differ,; // per core issue 1668. Substitute into the type from the pattern, in case; // it's instantiation-dependent.; // FIXME: Updating the type to work around this is at best fragile.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:34,depend,dependent,34,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,3,['depend'],['dependent']
Integrability,// If the parent is a category extended from internal module then we need to; // pretend this belongs to the associated interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:120,interface,interface,120,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,1,['interface'],['interface']
Integrability,"// If the physreg is at the boundary, defer it. Otherwise schedule it; // immediately to free the dependent. We can hoist the copy later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:98,depend,dependent,98,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['depend'],['dependent']
Integrability,"// If the predicate ""ArLHS `Pred` RHS"" monotonically increases from false to; // true as the loop iterates, and the backedge is control dependent on; // ""ArLHS `Pred` RHS"" == true then we can reason as follows:; //; // * if the predicate was false in the first iteration then the predicate; // is never evaluated again, since the loop exits without taking the; // backedge.; // * if the predicate was true in the first iteration then it will; // continue to be true for all future iterations since it is; // monotonically increasing.; //; // For both the above possibilities, we can replace the loop varying; // predicate with its value on the first iteration of the loop (which is; // loop invariant).; //; // A similar reasoning applies for a monotonically decreasing predicate, by; // replacing true with false and false with true in the above two bullets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:136,depend,dependent,136,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['depend'],['dependent']
Integrability,"// If the previous instruction will already produce the correct carry, do not; // emit a carry generating instruction. E.g. for G_UADDE/G_USUBE sequences; // generated during legalization of wide add/sub. This optimization depends on; // these sequences not being interrupted by other instructions.; // We have to select the previous instruction before the carry-using; // instruction is deleted by the calling function, otherwise the previous; // instruction might become dead and would get deleted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:223,depend,depends,223,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['depend'],['depends']
Integrability,"// If the producing instruction does not depend on vsetvli, do not; // convert COPY to vmv.v.v. For example, VL1R_V or PseudoVRELOAD.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:41,depend,depend,41,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,1,['depend'],['depend']
Integrability,"// If the property is readwrite but it shadows a read-only property in its; // external interface, treat the property a read-only. If the outside; // world cannot write to a property then the internal implementation is free; // to make its own convention about whether the value is stored retained; // or not. We look up the shadow here rather than in; // getDeallocReleaseRequirement() because doing so can be expensive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:88,interface,interface,88,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,1,['interface'],['interface']
Integrability,"// If the receiver is type-dependent, we can't type-check anything; // at this point. Build a dependent expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:27,depend,dependent,27,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,2,['depend'],['dependent']
Integrability,"// If the receiver type is dependent, we can't type-check anything; // at this point. Build a dependent expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:27,depend,dependent,27,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,2,['depend'],['dependent']
Integrability,"// If the receiver was a type, we have a class message; parse; // the rest of it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:47,message,message,47,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,1,['message'],['message']
Integrability,"// If the receiver was an expression, we still don't know; // whether we have a message send or an array designator; just; // adopt the expression for further analysis below.; // FIXME: potentially-potentially evaluated expression above?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:80,message,message,80,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,1,['message'],['message']
Integrability,"// If the register is defined by a Phi, then create a true dependence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:59,depend,dependence,59,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['dependence']
Integrability,"// If the register is used by a Phi, then create an anti dependence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:57,depend,dependence,57,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['dependence']
Integrability,"// If the result might be in a dependent base class, this is a dependent; // id-expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:31,depend,dependent,31,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['depend'],['dependent']
Integrability,"// If the root of the pattern is a ComplexPattern and if it is specified to; // match some number of root opcodes, these are considered to be our variants.; // Depending on which variant we're generating code for, emit the root opcode; // check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp:160,Depend,Depending,160,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,1,['Depend'],['Depending']
Integrability,"// If the routine name is invalid, just skip until the closing paren to; // recover more gracefully.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:10,rout,routine,10,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,1,['rout'],['routine']
Integrability,// If the scheduling region got new instructions at the lower end (or it; // is a new region for the first bundle). This makes it necessary to; // recalculate all dependencies.; // Otherwise the compiler may crash trying to incorrectly calculate; // dependencies and emit instruction in the wrong order at the actual; // scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:163,depend,dependencies,163,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['depend'],['dependencies']
Integrability,"// If the shift amount was 0, pick A or B, depending on the direction.; // The opposite shift will also be by 0, so the ""Or"" will be incorrect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:43,depend,depending,43,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,1,['depend'],['depending']
Integrability,"// If the shift may wrap, we need to mask off the shifted bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:20,wrap,wrap,20,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['wrap'],['wrap']
Integrability,"// If the sign bit of the integer is set, the large number will be treated; // as a negative number. To counteract this, the dynamic code adds an; // offset depending on the data type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:157,depend,depending,157,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['depend'],['depending']
Integrability,"// If the static_assert passes, only verify that; // the message is grammatically valid without evaluating it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:57,message,message,57,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['message'],['message']
Integrability,"// If the stride would wrap around the i32 before exiting, we can't; // transform the IV.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:23,wrap,wrap,23,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,2,['wrap'],['wrap']
Integrability,"// If the subtraction is not contractable, do not combine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:29,contract,contractable,29,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['contract'],['contractable']
Integrability,"// If the switch has a condition wrapped by __builtin_unpredictable,; // create metadata that specifies that the switch is unpredictable.; // Don't bother if not optimizing because that metadata would not be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp:33,wrap,wrapped,33,interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,1,['wrap'],['wrapped']
Integrability,"// If the tail is to be folded by masking, round the number of iterations N; // up to a multiple of Step instead of rounding down. This is done by first; // adding Step-1 and then rounding down. Note that it's ok if this addition; // overflows: the vector induction variable will eventually wrap to zero given; // that it starts at zero and its Step is a power of two; the loop will then; // exit, with the last early-exit vector comparison also producing all-true.; // For scalable vectors the VF is not guaranteed to be a power of 2, but this; // is accounted for in emitIterationCountCheck that adds an overflow check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:291,wrap,wrap,291,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['wrap'],['wrap']
Integrability,"// If the target ABI uses function descriptors, then the alignment of function; // pointers depends on the alignment used to emit the descriptor. Otherwise,; // function pointers are aligned to 32 bits because the instructions must be.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:92,depend,depends,92,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,1,['depend'],['depends']
Integrability,"// If the template declaration spans multiple lines, force wrap before the; // function/class declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:59,wrap,wrap,59,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['wrap'],['wrap']
Integrability,"// If the template is dependent or an alias, match the template; // declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h:22,depend,dependent,22,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,1,['depend'],['dependent']
Integrability,"// If the template is non-dependent, we want to match the instantiated; // tag type.; // For example, given:; // template<typename T> struct X {}; X<int> a;; // The following matcher will match, which otherwise would not:; // templateSpecializationType(hasDeclaration(cxxRecordDecl())).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h:26,depend,dependent,26,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,1,['depend'],['dependent']
Integrability,"// If the template names don't match, it can't be a dependent; // match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:52,depend,dependent,52,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['depend'],['dependent']
Integrability,"// If the thread wrapper is replaceable, give it appropriate linkage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:17,wrap,wrapper,17,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['wrap'],['wrapper']
Integrability,"// If the top level header is expected to be findable at run-time,; // the direct header might not because the include path might be; // different enough and only the top-header is guaranteed to be seen; // by the user as an interface header to be available on the; // run-time include path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/AutoloadCallback.cpp:225,interface,interface,225,interpreter/cling/lib/Interpreter/AutoloadCallback.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/AutoloadCallback.cpp,1,['interface'],['interface']
Integrability,"// If the triple string is still empty, we don't fall back to; // sys::getDefaultTargetTriple() since we do not want to have differing; // behaviour dependent on the configured default triple. Therefore, if the; // user did not pass -mtriple or define an explicit triple/datalayout in; // the IR, we should default to an empty (default) DataLayout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/opt/opt.cpp:149,depend,dependent,149,interpreter/llvm-project/llvm/tools/opt/opt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/opt/opt.cpp,1,['depend'],['dependent']
Integrability,"// If the type is a template parameter, get its type, which can; // point to a type or scope, depending on the argument instance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVSymbol.cpp:94,depend,depending,94,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVSymbol.cpp,1,['depend'],['depending']
Integrability,"// If the type is a typedefed type, get the underlying TypedefNameDecl for a; // direct reference to the typedef instead of the wrapped type.; // 'id' type is a typedef for an ObjCObjectPointerType; // we treat it as a typedef",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:128,wrap,wrapped,128,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,1,['wrap'],['wrapped']
Integrability,"// If the type is dependent, then assume it might have; // implicit copy or move ctor because we won't know yet at this point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:18,depend,dependent,18,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['dependent']
Integrability,"// If the type is dependent, we won't do any other semantic analysis now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:18,depend,dependent,18,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,2,['depend'],['dependent']
Integrability,"// If the type is dependent, we won't do the semantic analysis now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:18,depend,dependent,18,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,1,['depend'],['dependent']
Integrability,"// If the type is omitted, it's 'int', and is not dependent in any way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:50,depend,dependent,50,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,1,['depend'],['dependent']
Integrability,"// If the type of the decomposition is dependent, then so is the type of; // each binding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:39,depend,dependent,39,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['dependent']
Integrability,"// If the type of the nested name specifier is the same as the; // injected class name of the named class template, we're entering; // into that class template definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:67,inject,injected,67,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['inject'],['injected']
Integrability,"// If the type wasn't dependent on fission addresses, finish adding the type; // and all its dependent types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:22,depend,dependent,22,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,2,['depend'],['dependent']
Integrability,"// If the types are imprecise (due to dependent constructs in friends or; // local extern declarations), it's OK if they differ. We'll check again; // during instantiation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:38,depend,dependent,38,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,"// If the unsigned range doesn't wrap, and isn't negative then it's a range; // from one positive number to another which is as good as we can generate.; // In this case, skip the extra work of generating signed ranges which aren't; // going to be better than this range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:33,wrap,wrap,33,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,1,['wrap'],['wrap']
Integrability,// If the user instruction is used for some reason in different; // vectorized nodes - make it depend on index.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:95,depend,depend,95,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['depend'],['depend']
Integrability,"// If the user passes in a function that we can't take the address of, we; // generally end up emitting really bad error messages. Here, we attempt to; // emit better ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:121,message,messages,121,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['message'],['messages']
Integrability,"// If the user was explicitly trying to use the extended version,; // we still give helpful extension-related error messages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:116,message,messages,116,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['message'],['messages']
Integrability,"// If the using scope was dependent, or we had dependent bases, we need to; // recheck the inheritance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:26,depend,dependent,26,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,2,['depend'],['dependent']
Integrability,"// If the value is dependent, we can not test anything.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp:19,depend,dependent,19,interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,1,['depend'],['dependent']
Integrability,"// If the value was constrained to null *after* it was passed through that; // location, it could not have been a concrete pointer *when* it was passed.; // In that case we would have handled the situation when the value was; // bound to that location, by emitting (or not emitting) a report.; // Therefore we are only interested in symbolic regions that can be either; // null or non-null depending on the value of their respective symbol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:390,depend,depending,390,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,1,['depend'],['depending']
Integrability,"// If the variable group involves parameters, the diagnostic message will; // NOT explain how the variables are grouped as the reason is non-trivial; // and irrelavant to users' experience:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:61,message,message,61,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['message'],['message']
Integrability,"// If the variable is clearly identified as non-odr-used and the full; // expression is not instantiation dependent, only then do we not; // need to check enclosing lambda's for speculative captures.; // For e.g.:; // Even though 'x' is not odr-used, it should be captured.; // int test() {; // const int x = 10;; // auto L = [=](auto a) {; // (void) +x + a;; // };; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:106,depend,dependent,106,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['depend'],['dependent']
Integrability,"// If there are available intervals that contain the reference point,; // traverse them; otherwise move to the left or right node, depending; // on the middle point value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h:131,depend,depending,131,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,1,['depend'],['depending']
Integrability,"// If there are dependent noexcept specs, assume everything is fine. Unlike; // with the equivalency check, this is safe in this case, because we don't; // want to merge declarations. Checks after instantiation will catch any; // omissions we make here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:16,depend,dependent,16,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,1,['depend'],['dependent']
Integrability,"// If there are more than 8 elements in the vector, then any immediate blend; // mask wraps around.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.cpp:86,wrap,wraps,86,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.cpp,1,['wrap'],['wraps']
Integrability,"// If there are multiple PHIs, sort their operands so that they all list; // the blocks in the same order. This will help identical PHIs be eliminated; // by other passes. Other passes shouldn't depend on this for correctness; // however.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:195,depend,depend,195,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,1,['depend'],['depend']
Integrability,"// If there are no functions to store, just build a dependent; // BinaryOperator or CompoundAssignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:52,depend,dependent,52,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['depend'],['dependent']
Integrability,// If there are no non-runtime protocols then we can just stop now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:31,protocol,protocols,31,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['protocol'],['protocols']
Integrability,"// If there are no qualifiers and no interface, we have an 'id'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:37,interface,interface,37,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['interface'],['interface']
Integrability,// If there are no registered plugins we don't need to wrap the consumer,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:55,wrap,wrap,55,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,1,['wrap'],['wrap']
Integrability,"// If there are no wrap guarentees, find the trailing zeros, which is the; // sum of trailing zeros for all its operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:19,wrap,wrap,19,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,// If there aren't any synthesized ivars then reuse the interface; // entry. Note we can't cache this because we simply free all; // entries later; however we shouldn't look up implementations; // frequently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:56,interface,interface,56,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['interface'],['interface']
Integrability,"// If there exists a layout predecessor of this entry and this predecessor; // is not that, we rather create a routing block after that layout; // predecessor to save a branch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:111,rout,routing,111,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,1,['rout'],['routing']
Integrability,"// If there is a base and this is a relational operator, we can only; // compare pointers within the object in question; otherwise, the result; // depends on where the object is located in memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:147,depend,depends,147,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['depend'],['depends']
Integrability,"// If there is a builtin counterpart to this file, add it now so it can; // wrap the system header.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:76,wrap,wrap,76,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,1,['wrap'],['wrap']
Integrability,"// If there is a function with a live 'returned' argument but a dead return; // value, then there are two possible actions:; // 1) Eliminate the return value and take off the 'returned' attribute on the; // argument.; // 2) Retain the 'returned' attribute and treat the return value (but not the; // entire function) as live so that it is not eliminated.; //; // It's not clear in the general case which option is more profitable because,; // even in the absence of explicit uses of the return value, code generation; // is free to use the 'returned' attribute to do things like eliding; // save/restores of registers across calls. Whether this happens is target and; // ABI-specific as well as depending on the amount of register pressure, so; // there's no good way for an IR-level pass to figure this out.; //; // Fortunately, the only places where 'returned' is currently generated by; // the FE are places where 'returned' is basically free and almost always a; // performance win, so the second option can just be used always for now.; //; // This should be revisited if 'returned' is ever applied more liberally.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:695,depend,depending,695,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,1,['depend'],['depending']
Integrability,"// If there is a gamma in the name,; // strip it from the list of dependencies",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/RooBarlowBeestonLL.cxx:66,depend,dependencies,66,roofit/histfactory/src/RooBarlowBeestonLL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/RooBarlowBeestonLL.cxx,1,['depend'],['dependencies']
Integrability,"// If there is a next operand and it is 0, ignore it. Otherwise print a; // diagnostic message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp:87,message,message,87,interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/AsmParser/LoongArchAsmParser.cpp,1,['message'],['message']
Integrability,"// If there is a static runtime with no dynamic list, force all the symbols; // to be dynamic to be sure we export sanitizer interface functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:125,interface,interface,125,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,1,['interface'],['interface']
Integrability,"// If there is an ambiguity, we need to go the long route.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp:52,rout,route,52,interpreter/cling/lib/Interpreter/LookupHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp,1,['rout'],['route']
Integrability,"// If there is any value related with Num is defined in a BB other than; // PhiBlock, it cannot depend on a phi in PhiBlock without going through; // a backedge. We can do an early exit in that case to save compile time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:96,depend,depend,96,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['depend'],['depend']
Integrability,"// If there is explict option disable integratedAS, we can't use it for; // inlineasm either.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:38,integrat,integratedAS,38,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,1,['integrat'],['integratedAS']
Integrability,// If there is no NSConstantString interface defined then treat this; // as error and recover from it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:35,interface,interface,35,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['interface'],['interface']
Integrability,"// If there is no NSString interface defined, implicitly declare; // a @class NSString; and use that instead. This is to make sure; // type of an NSString literal is represented correctly, instead of; // being an 'id' type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:27,interface,interface,27,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['interface'],['interface']
Integrability,// If there is no category @interface then there can be no properties.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:28,interface,interface,28,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['interface'],['interface']
Integrability,"// If there is no protocols associated with RHS, it is not a match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:18,protocol,protocols,18,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['protocol'],['protocols']
Integrability,"// If there is no space, an error message is shown:; // Error in <TString::AssertElement>: out of bounds: i = -1, Length = 0; // If there is no function selected, then put nothing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx:34,message,message,34,gui/fitpanel/src/TFitEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx,1,['message'],['message']
Integrability,"// If there is not already a fixpoint reached, we can now take the; // optimistic state. This is correct because we enforced a pessimistic one; // on abstract attributes that were transitively dependent on a changed one; // already above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:193,depend,dependent,193,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['depend'],['dependent']
Integrability,"// If there is only one call of the function, and it has internal linkage,; // the cost of inlining it drops dramatically. It may seem odd to update; // Cost in updateThreshold, but the bonus depends on the logic in this method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:192,depend,depends,192,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['depend'],['depends']
Integrability,"// If there's an interface, look in both the public and private APIs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:17,interface,interface,17,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['interface'],['interface']
Integrability,"// If there's exactly one branch-after and no other threads,; // we can route it without a switch.; // Skip for SEH, since ExitSwitch is used to generate code to indicate; // abnormal termination. (SEH: Except _leave and fall-through at; // the end, all other exits in a _try (return/goto/continue/break); // are considered as abnormal terminations, using NormalCleanupDestSlot; // to indicate abnormal termination)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:72,rout,route,72,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,1,['rout'],['route']
Integrability,"// If there's no signed wrap, and all the operands except initial value have; // the same sign or zero, the value won't ever be:; // 1: smaller than initial value if operands are non negative,; // 2: bigger than initial value if operands are non positive.; // For both cases, value can not cross signed min/max boundary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:24,wrap,wrap,24,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,"// If there's no unsigned wrap, the value will never be less than its; // initial value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:26,wrap,wrap,26,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,"// If there's only one option for Ptr, look it up after bounds and wrap; // checking, because assumptions might have been added to PSE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:67,wrap,wrap,67,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['wrap'],['wrap']
Integrability,"// If they both only read from memory, there is no dependence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:51,depend,dependence,51,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// If this BB has an EH pad successor, i.e., ends with an 'invoke', now we; // are going to wrap the invoke with try-delegate, making the 'delegate'; // BB the new successor instead, so remove the EH pad succesor here. The; // BB may not have an EH pad successor if calls in this BB throw to the; // caller.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:92,wrap,wrap,92,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,1,['wrap'],['wrap']
Integrability,"// If this action is used to forward single dependency, set the toolchain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Action.cpp:44,depend,dependency,44,interpreter/llvm-project/clang/lib/Driver/Action.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Action.cpp,1,['depend'],['dependency']
Integrability,"// If this block is currently in pass-through state and we encounter a; // call then whether we need a vzeroupper or not depends on whether this; // block has successors that exit dirty. Record the location of the call,; // and set the state to EXITS_CLEAN, but do not insert the vzeroupper yet.; // It will be inserted later if necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86VZeroUpper.cpp:121,depend,depends,121,interpreter/llvm-project/llvm/lib/Target/X86/X86VZeroUpper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86VZeroUpper.cpp,1,['depend'],['depends']
Integrability,"// If this block is not done, it makes little sense to make any decisions; // based on clearance information. We need to make a second pass anyway,; // and by then we'll have better information, so we can avoid doing the work; // to try and break dependencies now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:247,depend,dependencies,247,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,2,['depend'],['dependencies']
Integrability,"// If this category is the original class, jump to the interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:55,interface,interface,55,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['interface'],['interface']
Integrability,"// If this condition is false, typo correction must be performed eagerly; // rather than delayed in many places, as it makes use of dependent types.; // the condition is false for clang's C-only codepath, as it doesn't support; // dependent types yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:132,depend,dependent,132,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,2,['depend'],['dependent']
Integrability,"// If this context is a hidden protocol definition, don't find any; // methods there.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:31,protocol,protocol,31,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,1,['protocol'],['protocol']
Integrability,"// If this context is a hidden protocol definition, don't find any; // property.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:31,protocol,protocol,31,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,1,['protocol'],['protocol']
Integrability,"// If this could still be a protocol list, just capture the identifier.; // We don't want to turn it into a parameter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:28,protocol,protocol,28,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['protocol'],['protocol']
Integrability,"// If this declaration injected a name into a context different from its; // lexical context, and that context is an imported namespace, we need to; // update its visible declarations to include this name.; //; // This happens when we instantiate a class with a friend declaration or a; // function with a local extern declaration, for instance.; //; // FIXME: Can we handle this in AddedVisibleDecl instead?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:23,inject,injected,23,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,1,['inject'],['injected']
Integrability,"// If this file is older than the file it depends on, emit a diagnostic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:42,depend,depends,42,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['depend'],['depends']
Integrability,"// If this instruction actually reads a value from Reg, there is no unwanted; // dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:81,depend,dependency,81,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['depend'],['dependency']
Integrability,"// If this instruction's defs have special allocation requirement, don't; // break this anti-dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:93,depend,dependency,93,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,1,['depend'],['dependency']
Integrability,"// If this interface type is not provably derived from a known; // collection, penalize the corresponding completions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:11,interface,interface,11,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['interface'],['interface']
Integrability,"// If this is a CXXTempObjectRegion, the Expr responsible for its creation; // is wrapped inside of it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:82,wrap,wrapped,82,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,1,['wrap'],['wrapped']
Integrability,"// If this is a branch on an altivec predicate comparison, lower this so; // that we don't have to do a MFOCRF: instead, branch directly on CR6. This; // lowering is done pre-legalize, because the legalizer lowers the predicate; // compare down to code that is difficult to reassemble.; // This code also handles branches that depend on the result of a store; // conditional.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:327,depend,depend,327,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['depend'],['depend']
Integrability,"// If this is a canonical type, and its exception specification is dependent,; // then it's a dependent type. This only happens in C++17 onwards.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:67,depend,dependent,67,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,2,['depend'],['dependent']
Integrability,// If this is a class message the metaclass is passed as the target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:22,message,message,22,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,2,['message'],['message']
Integrability,"// If this is a class message, ignore the nullability of the receiver.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:22,message,message,22,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['message'],['message']
Integrability,"// If this is a dependent context, we don't need to mark variables as; // odr-used, but we may still need to track them for lambda capture.; // FIXME: Do we also need to do this inside dependent typeid expressions; // (which are modeled as unevaluated at this point)?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:16,depend,dependent,16,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['depend'],['dependent']
Integrability,"// If this is a dependent lambda, there might be an enclosing variable; // template. In this case, the next step is not the parent DeclContext (or; // even a DeclContext at all).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:16,depend,dependent,16,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,1,['depend'],['dependent']
Integrability,"// If this is a dependent type, then we consider it complete.; // FIXME: This is wrong; we should require a (visible) definition to; // exist in this case too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:16,depend,dependent,16,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['depend'],['dependent']
Integrability,"// If this is a dependent-scope lookup, diagnose that the 'template' keyword; // was missing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:16,depend,dependent-scope,16,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent-scope']
Integrability,"// If this is a direct call, avoid the wrapper if we don't need to do any; // loads or adds. This allows SDAG ISel to match direct calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:39,wrap,wrapper,39,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['wrap'],['wrapper']
Integrability,"// If this is a dynamic alloca, the value may depend on the loaded kernargs,; // so loads will need to be inserted before it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelArguments.cpp:46,depend,depend,46,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelArguments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelArguments.cpp,2,['depend'],['depend']
Integrability,"// If this is a forward protocol declaration, get its definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:24,protocol,protocol,24,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,3,['protocol'],['protocol']
Integrability,"// If this is a friend or a reference to a class in a dependent; // context, don't try to make a decl for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:54,depend,dependent,54,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,"// If this is a function that the ABI specifies returns 'this', initialize; // the return slot to 'this' at the start of the function.; //; // Unlike the setting of return types, this is done within the ABI; // implementation instead of by clients of CGCXXABI because:; // 1) getThisValue is currently protected; // 2) in theory, an ABI could implement 'this' returns some other way;; // HasThisReturn only specifies a contract, not the implementation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:419,contract,contract,419,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['contract'],['contract']
Integrability,"// If this is a local extern function or variable declared within a function; // template, don't add it into the enclosing namespace scope until it is; // instantiated; it might have a dependent type right now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:185,depend,dependent,185,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,"// If this is a nested initializer list, we might have changed its contents; // (and therefore some of its properties, such as instantiation-dependence); // while filling it in. Inform the outer initializer list so that its state; // can be updated to match.; // FIXME: We should fully build the inner initializers before constructing; // the outer InitListExpr instead of mutating AST nodes after they have; // been used as subexpressions of other nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:141,depend,dependence,141,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['depend'],['dependence']
Integrability,"// If this is a supermaster server, find the config file and start; // submaster servers as specified in the config file.; // There is a difference in startup between a slave and a submaster; // in which the submaster will issue a kPROOF_LOGFILE and; // then a kPROOF_LOGDONE message (which must be collected); // while slaves do not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofSuperMaster.cxx:276,message,message,276,proof/proof/src/TProofSuperMaster.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofSuperMaster.cxx,1,['message'],['message']
Integrability,"// If this is a templated friend in a dependent context we should not put it; // on the redecl chain. In some cases, the templated friend can be the most; // recent declaration tricking the template instantiator to make substitutions; // there.; // FIXME: Figure out how to combine with shouldLinkDependentDeclWithPrevious",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:38,depend,dependent,38,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,"// If this is a write - check other reads and writes for conflicts. If; // this is a read only check other writes for conflicts (but only if; // there is no other write to the ptr - this is an optimization to; // catch ""a[i] = a[i] + "" without having to do a dependence check).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:259,depend,dependence,259,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['dependence']
Integrability,// If this is an Objective-C @implementation or category and we have; // new fields here we should reset the layout of the interface since; // it will now change.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:123,interface,interface,123,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['interface'],['interface']
Integrability,"// If this is an allocation, and if we know that the accessed pointer is to; // the allocation, return Def. This means that there is no dependence and; // the access can be optimized based on that. For example, a load could; // turn into undef. Note that we can bypass the allocation itself when; // looking for a clobber in many cases; that's an alias property and is; // handled by BasicAA.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:136,depend,dependence,136,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// If this is an equality comparison, we require that the strided value; // exactly land on the exit value, otherwise the IV condition will wrap; // around and do things the fp IV wouldn't.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:140,wrap,wrap,140,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,2,['wrap'],['wrap']
Integrability,"// If this is an explicit specialization, inject it into cling, too, such that it can have; // externalLexicalStorage, see TCling.cxx's ExtVisibleStorageAdder::VisitClassTemplateSpecializationDecl.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:42,inject,inject,42,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['inject'],['inject']
Integrability,"// If this is an imaginary literal, create the ImaginaryLiteral wrapper.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:64,wrap,wrapper,64,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['wrap'],['wrapper']
Integrability,"// If this is an unbridged cast, wrap the result in an implicit; // cast that yields the unbridged-cast placeholder type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:33,wrap,wrap,33,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,1,['wrap'],['wrap']
Integrability,"// If this is dependent, just continue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:14,depend,dependent,14,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,1,['depend'],['dependent']
Integrability,"// If this is dependent, we need to record that. If not, we simply; // mangle it as the underlying type since they are equivalent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:14,depend,dependent,14,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['depend'],['dependent']
Integrability,"// If this is non-null, then MemOperation has a dependency on this; // instruction; and it needs to be hoisted to execute before MemOperation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:48,depend,dependency,48,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,1,['depend'],['dependency']
Integrability,"// If this is the name of a (dependent) template specialization, use the; // definition of the template, even though it might be specialized later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:29,depend,dependent,29,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,1,['depend'],['dependent']
Integrability,"// If this is weak/linkonce, put this in a coalescable section, either in text; // or data depending on if it is writable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:91,depend,depending,91,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,1,['depend'],['depending']
Integrability,"// If this isn't a TU in which this variable is defined, the thread; // wrapper is discardable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:72,wrap,wrapper,72,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['wrap'],['wrapper']
Integrability,"// If this load really doesn't depend on anything, then we must be loading an; // undef value. This can happen when loading for a fresh allocation with no; // intervening stores, for example. Note that this is only true in the case; // that the result of the allocation is pointer equal to the load ptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:31,depend,depend,31,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['depend'],['depend']
Integrability,"// If this loop must exit based on this condition (or execute undefined; // behaviour), and we can prove the test sequence produced must repeat; // the same values on self-wrap of the IV, then we can infer that IV; // doesn't self wrap because if it did, we'd have an infinite (undefined); // loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:172,wrap,wrap,172,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,2,['wrap'],['wrap']
Integrability,"// If this method belongs to a protocol but the method in list does not, or; // vice versa, we say the context is not the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:31,protocol,protocol,31,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['protocol'],['protocol']
Integrability,"// If this method was declared in a protocol, we can't check; // anything unless we have a receiver type that's an interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:36,protocol,protocol,36,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,"['interface', 'protocol']","['interface', 'protocol']"
Integrability,"// If this module specifies [no_undeclared_includes], we cannot find any; // file that's in a non-dependency module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:98,depend,dependency,98,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,1,['depend'],['dependency']
Integrability,"// If this name refers to both a protocol and a type (e.g., \c; // NSObject), don't conclude anything yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:33,protocol,protocol,33,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['protocol'],['protocol']
Integrability,"// If this node already has this dependence, don't add a redundant one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:33,depend,dependence,33,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,1,['depend'],['dependence']
Integrability,// If this node has both dependants and dependencies then add it to the; // worklist to propagate the dependencies to the dependants.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:25,depend,dependants,25,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,4,['depend'],"['dependants', 'dependencies']"
Integrability,"// If this polynomial has no terms it's a uniform distribution, and a uniform; // pdf is a reducer node because it doesn't depend on the observables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooPolynomial.h:123,depend,depend,123,roofit/roofit/inc/RooPolynomial.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooPolynomial.h,1,['depend'],['depend']
Integrability,"// If this protocol conforms to other protocols, build the conformance list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:11,protocol,protocol,11,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,2,['protocol'],"['protocol', 'protocols']"
Integrability,"// If this protocol has a definition in the translation unit we're coming; // from, but this particular declaration is not that definition, import the; // definition and map to that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:11,protocol,protocol,11,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['protocol'],['protocol']
Integrability,"// If this protocol is marked 'objc_protocol_requires_explicit_implementation'; // then we should check if any class in the super class hierarchy also; // conforms to this protocol, either directly or via protocol inheritance.; // If so, we can skip checking this protocol completely because we; // know that a parent class already satisfies this protocol.; //; // Note: we could generalize this logic for all protocols, and merely; // add the limit on looking at the super class chain for just; // specially marked protocols. This may be a good optimization. This; // change is restricted to 'objc_protocol_requires_explicit_implementation'; // protocols for now for controlled evaluation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:11,protocol,protocol,11,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,8,['protocol'],"['protocol', 'protocols']"
Integrability,"// If this proxy or the loop info is going to be invalidated, we also need; // to clear all the keys coming from that analysis. We also completely blow; // away the loop analyses if any of the standard analyses provided by the; // loop pass manager go away so that loop analyses can freely use these; // without worrying about declaring dependencies on them etc.; // FIXME: It isn't clear if this is the right tradeoff. We could instead make; // loop analyses declare any dependencies on these and use the more general; // invalidation logic below to act on that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:337,depend,dependencies,337,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,2,['depend'],['dependencies']
Integrability,"// If this successor was reached through a branch rather than fallthrough,; // we might have *broken* fallthrough and so need to inject a new; // unconditional branch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:129,inject,inject,129,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['inject'],['inject']
Integrability,// If this symbol dependended on any symbols in the error state then move; // this symbol to the error state too.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:18,depend,dependended,18,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['depend'],['dependended']
Integrability,"// If this type depends on an extension, ensure the extension macros are; // defined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:16,depend,depends,16,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,1,['depend'],['depends']
Integrability,"// If this type was written as an injected-class-name, it can be used as a; // template template argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:34,inject,injected-class-name,34,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['inject'],['injected-class-name']
Integrability,"// If this type was written as an injected-class-name, it may have been; // converted to a RecordType during instantiation. If the RecordType is; // *not* wrapped in a TemplateSpecializationType and denotes a class; // template specialization, it must have come from an injected-class-name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:34,inject,injected-class-name,34,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,3,"['inject', 'wrap']","['injected-class-name', 'wrapped']"
Integrability,"// If this variable location does not depend on any instructions or contains; // any stack locations, produce it as a standard debug value instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp:38,depend,depend,38,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp,1,['depend'],['depend']
Integrability,"// If this variable might have a constant initializer or might be usable in; // constant expressions, check whether or not it actually is now. We can't; // do this lazily, because the result might depend on things that change; // later, such as which constexpr functions happen to be defined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:197,depend,depend,197,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['depend']
Integrability,"// If this was the last or the last is not null stmt, means that; // we need to value print.; // If this is in a wrapper function's body then look for VP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp:113,wrap,wrapper,113,interpreter/cling/lib/Interpreter/DynamicLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp,1,['wrap'],['wrapper']
Integrability,// If toolchain choose to use MCAsmParser for inline asm don't pass the; // option to disable integrated-as explictly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:94,integrat,integrated-as,94,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['integrat'],['integrated-as']
Integrability,// If turning on conversion for stderr fails then the error message; // may be garbled. There is no solution to this problem.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/InitLLVM.cpp:60,message,message,60,interpreter/llvm-project/llvm/lib/Support/InitLLVM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/InitLLVM.cpp,1,['message'],['message']
Integrability,"// If two modules, share the same LLVMContext, different threads must; // not access them concurrently without locking the associated LLVMContext; // this implementation follows this contract.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp:183,contract,contract,183,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp,1,['contract'],['contract']
Integrability,"// If user is a PHI node, its vector code have to be inserted right before; // block terminator. Since the node was delayed, there were some unresolved; // dependencies at the moment when stab instruction was emitted. In a case; // when any of these dependencies turn out an operand of another PHI, coming; // from this same block, position of a stab instruction will become invalid.; // The is because source vector that supposed to feed this gather node was; // inserted at the end of the block [after stab instruction]. So we need; // to adjust insertion point again to the end of block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:156,depend,dependencies,156,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['depend'],['dependencies']
Integrability,"// If user provided -o, that is the dependency target, except; // when we are only generating a dependency file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:36,depend,dependency,36,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,2,['depend'],['dependency']
Integrability,// If we actually used liveness information so we have to record a; // dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:71,depend,dependence,71,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['depend'],['dependence']
Integrability,// If we already have a protocol or type. Check whether it is the; // right thing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:24,protocol,protocol,24,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['protocol'],['protocol']
Integrability,"// If we are building a module interface unit, we need to have seen the; // module declaration by now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:31,interface,interface,31,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['interface'],['interface']
Integrability,"// If we are comparing vectors, then the result needs to be a i1 boolean that; // is then extended back to the legal result type depending on how booleans; // are represented.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:129,depend,depending,129,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['depend'],['depending']
Integrability,"// If we are disabled just print the message and close the connection",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:37,message,message,37,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['message'],['message']
Integrability,"// If we are in a dependent context, template instantiation will; // perform this type-checking again. Just save the arguments that we; // received in a ParenListExpr.; // FIXME: This isn't quite ideal, since our ASTs don't capture all; // of the information that we have about the base; // initializer. However, deconstructing the ASTs is a dicey process,; // and this approach is far more likely to get the corner cases right.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:18,depend,dependent,18,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,2,['depend'],['dependent']
Integrability,"// If we are inside a class or category implementation, determine the; // interface we're in.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:74,interface,interface,74,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['interface'],['interface']
Integrability,"// If we are linking an image for multiple archs then the linker wants; // -arch_multiple and -final_output <final image name>. Unfortunately, this; // doesn't fit in cleanly because we have to pass this information down.; //; // FIXME: This is a hack; find a cleaner way to integrate this into the; // process.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:275,integrat,integrate,275,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['integrat'],['integrate']
Integrability,"// If we are matching a template template argument to a template; // template parameter and one of the non-type template parameter types; // is dependent, then we must wait until template instantiation time; // to actually compare the arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:144,depend,dependent,144,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,"// If we are not statically linked, we should register the pragmas ourselves; // because the dlopen happens after creating the clang::Preprocessor which; // calls RegisterBuiltinPragmas.; // FIXME: This can be avoided by refactoring our routine and moving it to; // the CIFactory. This requires an abstraction which allows us to; // conditionally create MultiplexingConsumers.; // Copied from Lex/Pragma.cpp; // Pragmas added by plugins",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp:237,rout,routine,237,interpreter/cling/lib/Interpreter/IncrementalParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp,1,['rout'],['routine']
Integrability,"// If we are outside of an update, thus before the actual fixpoint iteration; // started (= when we create AAs), we do not track dependences because we will; // put all AAs into the initial worklist anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:129,depend,dependences,129,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['depend'],['dependences']
Integrability,"// If we are part of expanded vector, make our neighbors depend on this store",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp:57,depend,depend,57,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,1,['depend'],['depend']
Integrability,"// If we are saving a 32-byte vector and 32-byte stores are slow, such as on; // Sandy Bridge, perform two 16-byte stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:87,Bridg,Bridge,87,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Bridg'],['Bridge']
Integrability,"// If we are talking to a old client protocol",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:37,protocol,protocol,37,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['protocol'],['protocol']
Integrability,"// If we are unable to embed a single device output into the host, we need to; // add each device output as a host dependency to ensure they are still built.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:115,depend,dependency,115,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['depend'],['dependency']
Integrability,"// If we are using XMM registers in the ABI and the condition of the select is; // a floating-point compare and we have blendv or conditional move, then it is; // cheaper to select instead of doing a cross-register move and creating a; // load that depends on the compare result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:249,depend,depends,249,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['depend'],['depends']
Integrability,"// If we aren't consuming the last token, the prior '>' is still hanging; // there. Consume it before we parse the protocol qualifiers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:115,protocol,protocol,115,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['protocol'],['protocol']
Integrability,"// If we call a macro, our local variables may be corrupted due to; // lack of proper lexical scoping. So, add a globally unique postfix; // to every variable.; //; // indexBody() should have set up the Dependencies set by now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:203,Depend,Dependencies,203,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,1,['Depend'],['Dependencies']
Integrability,"// If we can prove that; // (**) |Dist| > BackedgeTakenCount * Step; // where Step is the absolute stride of the memory accesses in bytes,; // then there is no dependence.; //; // Rationale:; // We basically want to check if the absolute distance (|Dist/Step|); // is >= the loop iteration count (or > BackedgeTakenCount).; // This is equivalent to the Strong SIV Test (Practical Dependence Testing,; // Section 4.2.1); Note, that for vectorization it is sufficient to prove; // that the dependence distance is >= VF; This is checked elsewhere.; // But in some cases we can prune dependence distances early, and; // even before selecting the VF, and without a runtime test, by comparing; // the distance against the loop iteration count. Since the vectorized code; // will be executed only if LoopCount >= VF, proving distance >= LoopCount; // also guarantees that distance >= VF.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:160,depend,dependence,160,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,4,"['Depend', 'depend']","['Dependence', 'dependence']"
Integrability,"// If we can unambiguously determine whether Var can never be used; // in a constant expression, return true.; // - if the variable and its initializer are non-dependent, then; // we can unambiguously check if the variable is a constant expression.; // - if the initializer is not value dependent - we can determine whether; // it can be used to initialize a constant expression. If Init can not; // be used to initialize a constant expression we conclude that Var can; // never be a constant expression.; // - FXIME: if the initializer is dependent, we can still do some analysis and; // identify certain cases unambiguously as non-const by using a Visitor:; // - such as those that involve odr-use of a ParmVarDecl, involve a new; // delete, lambda-expr, dynamic-cast, reinterpret-cast etc...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:160,depend,dependent,160,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,3,['depend'],['dependent']
Integrability,"// If we can't generally expand the expression (e.g. it contains; // a divide), but it is already at a loop invariant point before the; // loop, wrap it in an unknown (to prevent the expander from trying; // to re-expand in a potentially unsafe way.) The restriction to; // integer types is required because the unknown hides the base, and; // SCEV can't compute the difference of two unknown pointers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:145,wrap,wrap,145,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['wrap'],['wrap']
Integrability,"// If we can't tell what the underlying object was, assume there is a; // dependence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:74,depend,dependence,74,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// If we could not compute the declaration context, it's because the; // declaration context is dependent but does not refer to a class,; // class template, or class template partial specialization. Complain; // and return early, to avoid the coming semantic disaster.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:96,depend,dependent,96,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,// If we could not obtain a pointer for the instruction and the instruction; // touches memory then assume that this is a dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:122,depend,dependency,122,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['dependency']
Integrability,"// If we created a wrapper for main, rename the wrapper so that it's the; // one that gets called from startup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:19,wrap,wrapper,19,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,2,['wrap'],['wrapper']
Integrability,"// If we deduced a constant in one case and either a dependent expression or; // declaration in another case, keep the integral constant.; // If both are integral constants with the same value, keep that value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:53,depend,dependent,53,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['depend'],['dependent']
Integrability,"// If we deduced a declaration and a dependent expression, keep the; // declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:37,depend,dependent,37,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['depend'],['dependent']
Integrability,"// If we deduced a null pointer and a dependent expression, keep the; // null pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:38,depend,dependent,38,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['depend'],['dependent']
Integrability,"// If we deduced a value and a dependent expression, keep the value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:31,depend,dependent,31,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['depend'],['dependent']
Integrability,"// If we depend on multiple instructions and any of them doesn't; // dominate this DVI, we probably can't salvage it: moving it to; // after any of the instructions could cause us to lose the others.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:9,depend,depend,9,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['depend'],['depend']
Integrability,"// If we deserialized any C++ or Objective-C class definitions, any; // Objective-C protocol definitions, or any redeclarable templates, make sure; // that all redeclarations point to the definitions. Note that this can only; // happen now, after the redeclaration chains have been fully wired.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:84,protocol,protocol,84,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['protocol'],['protocol']
Integrability,"// If we determined that the generic selection is result-dependent, don't; // try to compute the result expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:57,depend,dependent,57,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['depend'],['dependent']
Integrability,"// If we didn't find a use of this identifier, and if the identifier; // corresponds to a compiler builtin, create the decl object for the builtin; // now, injecting it into translation unit scope, and return it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:156,inject,injecting,156,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,2,['inject'],['injecting']
Integrability,"// If we didn't find anything during our lookup, try again with; // ordinary name lookup, which can help us produce better error; // messages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:133,message,messages,133,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['message'],['messages']
Integrability,"// If we don't have FP, but need to generate unwind information,; // we need to set the correct CFA offset after the stack adjustment.; // How much we adjust the CFA offset depends on whether we're emitting; // CFI only for EH purposes or for debugging. EH only requires the CFA; // offset to be correct at each call site, while for debugging we want; // it to be more precise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:173,depend,depends,173,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['depend'],['depends']
Integrability,"// If we don't have FP, but need to generate unwind information,; // we need to set the correct CFA offset after the stack adjustment.; // How much we adjust the CFA offset depends on whether we're emitting; // CFI only for EH purposes or for debugging. EH only requires the CFA; // offset to be correct at each call site, while for debugging we want; // it to be more precise.; // TODO: When not using precise CFA, we also need to adjust for the; // InternalAmt here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:173,depend,depends,173,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,1,['depend'],['depends']
Integrability,"// If we don't have a collector, but we are collecting module dependencies,; // then we're the top level compiler instance and need to create one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:62,depend,dependencies,62,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['depend'],['dependencies']
Integrability,"// If we don't have a lambda-introducer, then we have an attribute or a; // message-send.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:76,message,message-send,76,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['message'],['message-send']
Integrability,"// If we don't have device dependencies, we don't have to create an offload; // action.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:27,depend,dependencies,27,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['depend'],['dependencies']
Integrability,"// If we don't have more CUDA actions, we don't have any dependences to; // create for the host.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:57,depend,dependences,57,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['depend'],['dependences']
Integrability,"// If we don't know anything about the callee, assume it depends on the; // stack layout of the caller. In that case, it's only legal to outline; // as a tail-call. Explicitly list the call instructions we know about so we; // don't get unexpected results with call pseudo-instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:57,depend,depends,57,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['depend'],['depends']
Integrability,"// If we don't know anything about the callee, assume it depends on the; // stack layout of the caller. In that case, it's only legal to outline; // as a tail-call. Explicitly list the call instructions we know about so; // we don't get unexpected results with call pseudo-instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:57,depend,depends,57,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['depend'],['depends']
Integrability,"// If we don't use pushes for a particular call site,; // we pay for not having a reserved call frame with an; // additional sub/add esp pair. The cost is ~3 bytes per instruction,; // depending on the size of the constant.; // TODO: Callee-pop functions should have a smaller penalty, because; // an add is needed even with a reserved call frame.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:185,depend,depending,185,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,1,['depend'],['depending']
Integrability,"// If we expanded the SETCC by inverting the condition code, then wrap; // the existing SETCC in a NOT to restore the intended condition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:66,wrap,wrap,66,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,2,['wrap'],['wrap']
Integrability,"// If we failed print error messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:28,message,messages,28,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,2,['message'],['messages']
Integrability,"// If we failed to complete the type for some reason, or if the type is; // dependent, don't diagnose the variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:76,depend,dependent,76,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,"// If we failed to enable any of the dependencies, don't enable this; // checker.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:37,depend,dependencies,37,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,2,['depend'],['dependencies']
Integrability,"// If we find a cycle containing all nodes originally in this RefSCC then; // the removal hasn't changed the structure at all. This is an important; // special case, and we can directly exit the entire routine more; // efficiently as soon as we discover it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:202,rout,routine,202,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,1,['rout'],['routine']
Integrability,"// If we find a pre-existing equivalent FunctionProtoType, we can just reuse; // it so long as our exception specification doesn't contain a dependent; // noexcept expression, or we're just looking for a canonical type.; // Otherwise, we're going to need to create a type; // sugar node to hold the concrete expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:141,depend,dependent,141,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['depend'],['dependent']
Integrability,"// If we found a select instruction for MemLoc pointer, return it as Def; // dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:77,depend,dependency,77,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['dependency']
Integrability,"// If we found a tag declaration outside of C++, skip it. This; // can happy because we look for any name when there is no; // bias to protocol or type names.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:135,protocol,protocol,135,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['protocol'],['protocol']
Integrability,"// If we get a keyboard or mouse message, hide the splash screen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/Win32Splash.cxx:33,message,message,33,core/winnt/src/Win32Splash.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/Win32Splash.cxx,1,['message'],['message']
Integrability,"// If we got a non-deduced auto ReturnType, we are in a dependent context and; // there is no point in allowing copy elision since we won't have it deduced; // by the point the VardDecl is instantiated, which is the last chance we have; // of deciding if the candidate is really copy elidable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:56,depend,dependent,56,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['depend'],['dependent']
Integrability,"// If we got here protocol must be at least its short form ""^root.*:"" :; // make sure that it is in the full form to avoid problems in TFTP",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TNetFile.cxx:18,protocol,protocol,18,net/net/src/TNetFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TNetFile.cxx,1,['protocol'],['protocol']
Integrability,"// If we got here, it's one of the messages we care about.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp:35,message,messages,35,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp,1,['message'],['messages']
Integrability,"// If we got here, this is the first time we process a message to this; // region, so split the path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:55,message,message,55,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,1,['message'],['message']
Integrability,"// If we got no declarator info from previous Sema routines,; // just fill with the typespec loc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:51,rout,routines,51,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['rout'],['routines']
Integrability,"// If we had errors before, ObjectType can be dependent even without any; // templates, do not report missing template keyword in that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:46,depend,dependent,46,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['depend'],['dependent']
Integrability,"// If we had errors before, ObjectType can be dependent even without any; // templates. Do not report missing template keyword in that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:46,depend,dependent,46,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['depend'],['dependent']
Integrability,"// If we had to process more than one hundred blocks to find the; // dependencies, this load isn't worth worrying about. Optimizing; // it will be too expensive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:69,depend,dependencies,69,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['depend'],['dependencies']
Integrability,"// If we have a ""main"" function, and its type isn't; // ""int main(int argc, char *argv[])"", create an artificial call with it; // bitcasted to that type so that we generate a wrapper for it, so that; // the C runtime can call it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:175,wrap,wrapper,175,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,1,['wrap'],['wrapper']
Integrability,"// If we have a 1/2/4-byte integer, we can use it only if the rest of the; // goodness in the source type is just tail padding. This is allowed to; // kick in for struct {double,int} on the int, but not on; // struct{double,int,int} because we wouldn't return the second int. We; // have to do this analysis on the source type because we can't depend on; // unions being lowered a specific way etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:344,depend,depend,344,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['depend'],['depend']
Integrability,"// If we have a cached entry, and it is non-dirty, use it as the value for; // this dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:84,depend,dependency,84,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['dependency']
Integrability,"// If we have a cached local dependence query for this instruction, remove it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:29,depend,dependence,29,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// If we have a constant or non-constant insertion into the low element of; // a vector, we can do this with SCALAR_TO_VECTOR + shuffle of zero into; // the rest of the elements. This will be matched as movd/movq/movss/movsd; // depending on what the source datatype is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:229,depend,depending,229,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['depend'],['depending']
Integrability,"// If we have a dependence with its left-most non-'=' direction; // being '>' we need to reverse the direction of the edge, because; // the source of the dependence cannot occur after the sink. For; // confused dependencies, we will create edges in both directions to; // represent the possibility of a cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:16,depend,dependence,16,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,3,['depend'],"['dependence', 'dependencies']"
Integrability,"// If we have a hit, it means we already generated the instruction; // as a dependency to something else. We need to make sure; // it is ordered properly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp:76,depend,dependency,76,interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-c-test/echo.cpp,1,['depend'],['dependency']
Integrability,// If we have a modifier wrap the inner expression,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AsmParser/AVRAsmParser.cpp:25,wrap,wrap,25,interpreter/llvm-project/llvm/lib/Target/AVR/AsmParser/AVRAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AsmParser/AVRAsmParser.cpp,1,['wrap'],['wrap']
Integrability,"// If we have a pointer to a dependent type and are using the -> operator,; // the object type is the type that the pointer points to. We might still; // have enough information about that type to do something useful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:29,depend,dependent,29,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['depend'],['dependent']
Integrability,"// If we have a single dependency, inherit the architecture from it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Action.cpp:23,depend,dependency,23,interpreter/llvm-project/clang/lib/Driver/Action.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Action.cpp,1,['depend'],['dependency']
Integrability,"// If we have a typedef to a template specialization with exactly one; // template argument of a function type, this looks like std::function,; // boost::function, or other function wrapper. Treat these typedefs as; // functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Comment.cpp:182,wrap,wrapper,182,interpreter/llvm-project/clang/lib/AST/Comment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Comment.cpp,1,['wrap'],['wrapper']
Integrability,"// If we have a wrapper header, parse it and ignore the non-bc file contents.; // The magic number is 0x0B17C0DE stored in little endian.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:16,wrap,wrapper,16,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['wrap'],['wrapper']
Integrability,"// If we have a wrapper header, parse it and ignore the non-bc file; // contents. The magic number is 0x0B17C0DE stored in little endian.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp:16,wrap,wrapper,16,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp,1,['wrap'],['wrapper']
Integrability,"// If we have already emitted a message for a superclass, don't also report; // the sub-class. We consider all operand classes that we don't have a; // specialised diagnostic for to be equal for the propose of this check,; // so that we don't report the generic error multiple times on the same; // operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:32,message,message,32,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['message'],['message']
Integrability,"// If we have an Objective-C class name followed by an identifier; // and either ':' or ']', this is an Objective-C class message; // send that's missing the opening '['. Recovery; // appropriately. Also take this path if we're performing code; // completion after an Objective-C class name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:122,message,message,122,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['message'],['message']
Integrability,"// If we have an Objective-C instance method, look for ivars; // in the corresponding interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:86,interface,interface,86,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['interface'],['interface']
Integrability,"// If we have any cached dependencies on this instruction, remove; // them.; // If the instruction is a pointer, remove it from both the load info and the; // store info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:25,depend,dependencies,25,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['dependencies']
Integrability,"// If we have any vulnerable SVE stack objects then the stack protector; // needs to be placed at the top of the SVE stack area, as the SVE locals; // are placed above the other locals, so we allocate it as if it were a; // scalable vector.; // FIXME: It may be worthwhile having a specific interface for this rather; // than doing it here in finalizeLowering.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:291,interface,interface,291,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['interface'],['interface']
Integrability,"// If we have at least one (non-frame-index, non-RIP) register operand,; // and neither operand is load-dependent, we need to check the load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:104,depend,dependent,104,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['depend'],['dependent']
Integrability,"// If we have both a builtin and system version of the file, the; // builtin version may want to inject macros into the system header, so; // force the system header to be treated as a textual header in this; // case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:97,inject,inject,97,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,1,['inject'],['inject']
Integrability,"// If we have explicit template arguments, check for dependent; // template arguments and whether they contain any unexpanded pack; // expansions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:53,depend,dependent,53,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,1,['depend'],['dependent']
Integrability,"// If we have generated a forward reference to this protocol, emit; // it now. Otherwise do nothing, the protocol objects are lazily; // emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:52,protocol,protocol,52,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,2,['protocol'],['protocol']
Integrability,"// If we have loads being hardened and we've asked for call and ret edges to; // get a full fence-based mitigation, inject that fence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:116,inject,inject,116,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['inject'],['inject']
Integrability,"// If we have more than one job, then disable integrated-cc1 for now. Do this; // also when we need to report process execution statistics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:46,integrat,integrated-,46,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['integrat'],['integrated-']
Integrability,"// If we have no source location, just emit the diagnostic message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:59,message,message,59,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,1,['message'],['message']
Integrability,"// If we have some kind of dependent-named type (e.g., ""typename T::type""),; // break it apart into its prefix and identifier, then reconsititute those; // as the canonical nested-name-specifier. This is required to canonicalize; // a dependent nested-name-specifier involving typedefs of dependent-name; // types, e.g.,; // typedef typename T::type T1;; // typedef typename T1::type T2;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:27,depend,dependent-named,27,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,3,['depend'],"['dependent', 'dependent-name', 'dependent-named']"
Integrability,"// If we have the only definition, we don't need a thread wrapper if we; // will emit the value as a constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp:58,wrap,wrapper,58,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp,1,['wrap'],['wrapper']
Integrability,"// If we have to ignore the dependency, we'll have to ignore this too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:28,depend,dependency,28,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['depend'],['dependency']
Integrability,"// If we haven't figured out whether we want types or protocols; // yet, try to figure it out from this name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:54,protocol,protocols,54,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['protocol'],['protocols']
Integrability,"// If we haven't looked up the dependencies for DependencyJD yet, do it; // now and cache the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:31,depend,dependencies,31,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,2,"['Depend', 'depend']","['DependencyJD', 'dependencies']"
Integrability,"// If we haven't seen any uses in this scheduling region, create a; // dependence edge to ExitSU to model the live-out latency. This is required; // for vreg defs with no in-region use, and prefetches with no vreg def.; //; // FIXME: NumDataSuccs would be more precise than NumSuccs here. This; // check currently relies on being called before adding chain deps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:71,depend,dependence,71,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['depend'],['dependence']
Integrability,"// If we hit EOL, wrap around",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TerminalDisplay.cpp:18,wrap,wrap,18,core/textinput/src/textinput/TerminalDisplay.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TerminalDisplay.cpp,1,['wrap'],['wrap']
Integrability,"// If we improved every element of TFOps, then we've lost the dependence on; // NewChain to successors of St and we need to add it back to TFOps. Do so at; // the beginning to keep relative order consistent with FindBetterChains.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:62,depend,dependence,62,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['depend'],['dependence']
Integrability,"// If we integrate a model that uses RooLinearVar and should be able to get; // integrated analytically, this should also work if we integrate over variable; // clones because RooFit considers them identical. Covers GitHub issue #12646.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRealIntegral.cxx:9,integrat,integrate,9,roofit/roofitcore/test/testRooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRealIntegral.cxx,3,['integrat'],"['integrate', 'integrated']"
Integrability,"// If we know `AR` == {`PreStart`+`Step`,+,`Step`} is `WrapType` (FlagNSW; // or FlagNUW) and that `PreStart` + `Step` is `WrapType` too, then; // `PreAR` == {`PreStart`,+,`Step`} is also `WrapType`. Cache this fact.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:55,Wrap,WrapType,55,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,3,['Wrap'],['WrapType']
Integrability,"// If we know there is a dependence from source to sink, assume the; // instructions can't be reordered. Otherwise, reordering is legal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:25,depend,dependence,25,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['depend'],['dependence']
Integrability,"// If we made a temporary, be sure to clean up after ourselves. Note that we; // can't depend on being inside of an ExprWithCleanups, so we need to manually; // pop this cleanup later on. Being eager about this is OK, since this; // temporary is 'invisible' outside of the callee.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:87,depend,depend,87,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['depend'],['depend']
Integrability,"// If we made an implicit import of the module interface, then return the; // imported module decl.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:47,interface,interface,47,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,1,['interface'],['interface']
Integrability,// If we need the symbol table to do the operation then check it here to; // produce a good error message as to where the Mach-O file comes from in; // the error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp:98,message,message,98,interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,2,['message'],['message']
Integrability,"// If we need to check two pointers to the same underlying object; // with a non-constant difference, we shouldn't perform any pointer; // grouping with those pointers. This is because we can easily get; // into cases where the resulting check would return false, even when; // the accesses are safe.; //; // The following example shows this:; // for (i = 0; i < 1000; ++i); // a[5000 + i * m] = a[i] + a[i + 9000]; //; // Here grouping gives a check of (5000, 5000 + 1000 * m) against; // (0, 10000) which is always false. However, if m is 1, there is no; // dependence. Not grouping the checks for a[i] and a[i + 9000] allows; // us to perform an accurate check in this case.; //; // The above case requires that we have an UnknownDependence between; // accesses to the same underlying object. This cannot happen unless; // FoundNonConstantDistanceDependence is set, and therefore UseDependencies; // is also false. In this case we will use the fallback path and create; // separate checking groups for all pointers.; // If we don't have the dependency partitions, construct a new; // checking pointer group for each pointer. This is also required; // for correctness, because in this case we can have checking between; // pointers to the same underlying object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:560,depend,dependence,560,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,2,['depend'],"['dependence', 'dependency']"
Integrability,"// If we need to dump all dependents, then iterate each index and find; // all dependents, adding them to a map ordered by TypeIndex.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-pdbutil/DumpOutputStyle.cpp:26,depend,dependents,26,interpreter/llvm-project/llvm/tools/llvm-pdbutil/DumpOutputStyle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-pdbutil/DumpOutputStyle.cpp,2,['depend'],['dependents']
Integrability,"// If we optimistically assume that the MIG routine never re-uses the storage; // that was passed to it as arguments when it invalidates it (but at most when; // it assigns to parameter variables directly), this procedure correctly; // determines if the value was loaded from the transitive closure of MIG; // routine arguments in the heap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:44,rout,routine,44,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,2,['rout'],['routine']
Integrability,"// If we parsed an identifier list, semantic analysis sorts out; // whether it refers to protocols or to type arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:89,protocol,protocols,89,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['protocol'],['protocols']
Integrability,"// If we performed lookup into a dependent context and did not find anything,; // that's fine: just build a dependent nested-name-specifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:33,depend,dependent,33,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,2,['depend'],['dependent']
Integrability,// If we remove a barrier we need to copy dependencies; // from the predecessor to maintain order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUExportClustering.cpp:42,depend,dependencies,42,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUExportClustering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUExportClustering.cpp,1,['depend'],['dependencies']
Integrability,"// If we see identifier: after an expression, and we're not already in a; // message send, then this is probably a message send with a missing; // opening bracket '['.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:77,message,message,77,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,2,['message'],['message']
Integrability,"// If we see something like '@interface' that's only allowed at the top; // level, bail out as if we saw an '@end'. We'll diagnose this below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:30,interface,interface,30,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['interface'],['interface']
Integrability,"// If we still haven't found a prototype to use but there are arguments to; // the call, diagnose this as calling a function without a prototype.; // However, if we found a function declaration, check to see if; // -Wdeprecated-non-prototype was disabled where the function was declared.; // If so, we will silence the diagnostic here on the assumption that this; // interface is intentional and the user knows what they're doing. We will; // also silence the diagnostic if there is a function declaration but it; // was implicitly defined (the user already gets diagnostics about the; // creation of the implicit function declaration, so the additional warning; // is not helpful).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:367,interface,interface,367,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['interface'],['interface']
Integrability,"// If we want protocols and we have a protocol, there's nothing; // more to do.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:14,protocol,protocols,14,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['protocol'],"['protocol', 'protocols']"
Integrability,"// If we were working with infinite precision arithmetic then the combined; // weight would be LHS + RHS. But we are using finite precision arithmetic,; // and the APInt sum LHS + RHS may not be correct if it wraps (it is correct; // for nilpotent operations and addition, but not for idempotent operations; // and multiplication), so it is important to correctly reduce the combined; // weight back into range if wrapping would be wrong.; // If RHS is zero then the weight didn't change.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:209,wrap,wraps,209,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,2,['wrap'],"['wrapping', 'wraps']"
Integrability,"// If we weren't able to parse a default template argument, delay lookup; // until instantiation time by making a non-dependent DependentTypeName. We; // pretend we saw a NestedNameSpecifier referring to the current scope, and; // lookup is retried.; // FIXME: This hurts our diagnostic quality, since we get errors like ""no; // type named 'Foo' in 'current_namespace'"" when the user didn't write any; // name specifiers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:118,depend,dependent,118,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,"['Depend', 'depend']","['DependentTypeName', 'dependent']"
Integrability,"// If we're adding a template to a dependent context, we may need to; // rebuilding some of the types used within the template parameter list,; // now that we know what the current instantiation is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,depend,dependent,35,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['depend'],['dependent']
Integrability,"// If we're allowed to find protocols and we have a protocol, accept it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:28,protocol,protocols,28,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['protocol'],"['protocol', 'protocols']"
Integrability,"// If we're building the type pattern to deduce against, don't wrap the; // substituted type in an AutoType. Certain template deduction rules; // apply only when a template type parameter appears directly (and not if; // the parameter is found through desugaring). For instance:; // auto &&lref = lvalue;; // must transform into ""rvalue reference to T"" not ""rvalue reference to; // auto type deduced as T"" in order for [temp.deduct.call]p3 to apply.; //; // FIXME: Is this still necessary?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:63,wrap,wrap,63,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['wrap'],['wrap']
Integrability,"// If we're collecting module dependencies, we need to share a collector; // between all of the module CompilerInstances. Other than that, we don't; // want to produce any dependency output from the module build.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:30,depend,dependencies,30,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,2,['depend'],"['dependencies', 'dependency']"
Integrability,"// If we're dealing with a decl but not a TagDecl, assume that; // whatever routines created it handled the friendship aspect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:76,rout,routines,76,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['rout'],['routines']
Integrability,"// If we're declaring or defining a tag in function prototype scope in C,; // note that this type can only be used within the function and add it to; // the list of decls to inject into the function definition scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:174,inject,inject,174,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['inject'],['inject']
Integrability,"// If we're generating a list for a protocol, skip optional / required ones; // when generating the other list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:36,protocol,protocol,36,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['protocol'],['protocol']
Integrability,"// If we're in Objective-C and we have an Objective-C class type followed; // by an identifier and then either ':' or ']', in a place where an; // expression is permitted, then this is probably a class message send; // missing the initial '['. In this case, we won't consider this to be; // the start of a declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:202,message,message,202,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['message'],['message']
Integrability,"// If we're in Objective-C++ and we have a bare '[', then this is more; // likely to be a message receiver.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:90,message,message,90,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['message'],['message']
Integrability,"// If we're in a context where we might have an expression (rather than a; // declaration), and what we've seen so far is an Objective-C type that could; // be a receiver of a class message, this may be a class message send with; // the initial opening bracket '[' missing. Add appropriate completions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:182,message,message,182,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,2,['message'],['message']
Integrability,"// If we're inside the same interface that owns the ivar, we're fine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:28,interface,interface,28,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['interface'],['interface']
Integrability,"// If we're left with value-dependent computed noexcept expressions, we're; // stuck. Before C++17, we can just drop the exception specification entirely,; // since it's not actually part of the canonical type. And this should never; // happen in C++17, because it would mean we were computing the composite; // pointer type of dependent types, which should never happen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:28,depend,dependent,28,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,2,['depend'],['dependent']
Integrability,"// If we're not in an interface, this ivar is inaccessible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:22,interface,interface,22,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['interface'],['interface']
Integrability,"// If we're not using the GPR result of the CR-setting instruction, we; // just need to and with zero/non-zero depending on the new immediate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:111,depend,depending,111,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['depend'],['depending']
Integrability,"// If we're optimizing an atomic within a pixel shader, we need to wrap the; // entire atomic operation in a helper-lane check. We do not want any helper; // lanes that are around only for the purposes of derivatives to take part; // in any cross-lane communication, and we use a branch on whether the lane is; // live to do this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp:67,wrap,wrap,67,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,1,['wrap'],['wrap']
Integrability,"// If we're parsing Thumb2, which form is legal depends on whether we're; // in an IT block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:48,depend,depends,48,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['depend'],['depends']
Integrability,"// If we're performing a partial argument substitution, allow any trailing; // pack expansions; they might be empty. This can happen even if; // PartialTemplateArgs is false (the list of arguments is complete but; // still dependent).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:223,depend,dependent,223,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,"// If we're performing qualified name lookup into a dependent class,; // then we are actually looking into a current instantiation. If we have any; // dependent base classes, then we either have to delay lookup until; // template instantiation time (at which point all bases will be available); // or we have to fail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:52,depend,dependent,52,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,2,['depend'],['dependent']
Integrability,"// If we're scheduling a lowered CALLSEQ_END, find the corresponding; // CALLSEQ_BEGIN. Inject an artificial physical register dependence between; // these nodes, to prevent other calls from being interscheduled with them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:88,Inject,Inject,88,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,2,"['Inject', 'depend']","['Inject', 'dependence']"
Integrability,"// If we're wrapping an @llvm.experimental.deoptimize in a statepoint, we; // transform the tail-call like structure to a call to a void function; // followed by unreachable to get better codegen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:12,wrap,wrapping,12,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['wrap'],['wrapping']
Integrability,"// If we've already decided this function is invalid, e.g. because; // we saw a `return` whose expression had an error, don't keep; // trying to deduce its return type.; // (Some return values may be needlessly wrapped in RecoveryExpr).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:211,wrap,wrapped,211,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['wrap'],['wrapped']
Integrability,"// If we've already pointed out a specific problem with this interface,; // don't bother issuing a general ""something's different"" diagnostic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:61,interface,interface,61,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['interface'],['interface']
Integrability,"// If we've already pointed out a specific problem with this protocol,; // don't bother issuing a general ""something's different"" diagnostic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:61,protocol,protocol,61,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['protocol'],['protocol']
Integrability,"// If we've past an instruction from a future iteration that may have; // side effects, and this instruction might also, then we can't reorder; // them, and this matching fails. As an exception, we allow the alias; // set tracker to handle regular (unordered) load/store dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:271,depend,dependencies,271,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,1,['depend'],['dependencies']
Integrability,"// If wrapPoint is > length of input, nothing is wrapped!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:6,wrap,wrapPoint,6,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,2,['wrap'],"['wrapPoint', 'wrapped']"
Integrability,"// If wrapping is allowed, then the addition flips the sign bit of LHS:; // X + (signmask) --> X ^ signmask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:6,wrap,wrapping,6,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['wrap'],['wrapping']
Integrability,"// If wrapping is not allowed, then the addition must set the sign bit:; // X + (signmask) --> X | signmask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:6,wrap,wrapping,6,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['wrap'],['wrapping']
Integrability,"// If yes, action depends on whether it matches exactly or not",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:18,depend,depends,18,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,2,['depend'],['depends']
Integrability,"// Iff the flag result is dead:; // (uaddo_carry (add|uaddo X, Y), 0, Carry) -> (uaddo_carry X, Y, Carry); // Don't do this if the Carry comes from the uaddo. It won't remove the uaddo; // or the dependency between the instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:196,depend,dependency,196,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['depend'],['dependency']
Integrability,"// Ignore ""wrap-around"" uses to PHIs of this loop's header.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:11,wrap,wrap-around,11,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,1,['wrap'],['wrap-around']
Integrability,"// Ignore CF references, which can be toll-free bridged.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp:48,bridg,bridged,48,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BasicObjCFoundationChecks.cpp,1,['bridg'],['bridged']
Integrability,// Ignore Input dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:16,depend,dependencies,16,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,2,['depend'],['dependencies']
Integrability,// Ignore KILL instructions (they form a group in ScanInstruction; // but don't cause any anti-dependence breaking themselves),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:95,depend,dependence,95,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,1,['depend'],['dependence']
Integrability,// Ignore Order dependences between unconditional direct branches; // and non-control-flow instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:16,depend,dependences,16,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['depend'],['dependences']
Integrability,// Ignore all dependences for jumps except for true and output; // dependences.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:14,depend,dependences,14,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,2,['depend'],['dependences']
Integrability,// Ignore any categories we find that have already been implemented by this; // interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:80,interface,interface,80,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['interface'],['interface']
Integrability,// Ignore dependencies from outside the current trace.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:10,depend,dependencies,10,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,1,['depend'],['dependencies']
Integrability,// Ignore dependencies other than data or strong ordering.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:10,depend,dependencies,10,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,1,['depend'],['dependencies']
Integrability,// Ignore dependencies outside the current trace.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:10,depend,dependencies,10,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,1,['depend'],['dependencies']
Integrability,"// Ignore dependent contexts. Also ignore unions, since their members never; // have destructors implicitly called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:10,depend,dependent,10,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['dependent']
Integrability,// Ignore dependent declarations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:10,depend,dependent,10,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['depend'],['dependent']
Integrability,// Ignore dependent types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:10,depend,dependent,10,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['depend'],['dependent']
Integrability,// Ignore overflow. LLVM allows address arithmetic to silently wrap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/WasmObjectWriter.cpp:63,wrap,wrap,63,interpreter/llvm-project/llvm/lib/MC/WasmObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/WasmObjectWriter.cpp,1,['wrap'],['wrap']
Integrability,"// Ignore parameters in the fit result that this RooAbsReal doesn't depend on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:68,depend,depend,68,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,2,['depend'],['depend']
Integrability,// Ignore protocol qualifiers when mangling at this level.; // @encode(class_name),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:10,protocol,protocol,10,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['protocol'],['protocol']
Integrability,// Ignore protocol qualifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:10,protocol,protocol,10,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['protocol'],['protocol']
Integrability,// Ignore protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:10,protocol,protocols,10,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,2,['protocol'],['protocols']
Integrability,"// Ignore scopes which have too many address ranges to represent in the; // current CodeView format or do not have a valid address range.; //; // For lexical scopes with multiple address ranges you may be tempted to; // construct a single range covering every instruction where the block is; // live and everything in between. Unfortunately, Visual Studio only; // displays variables from the first matching lexical block scope. If the; // first lexical block contains exception handling code or cold code which; // is moved to the bottom of the routine creating a single range covering; // nearly the entire routine, then it will hide all other lexical blocks; // and the variables they contain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:546,rout,routine,546,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,2,['rout'],['routine']
Integrability,// Ignore these dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:16,depend,dependencies,16,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['depend'],['dependencies']
Integrability,// Ignore value- or type-dependent expressions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:25,depend,dependent,25,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['depend'],['dependent']
Integrability,"// Ignores the implicit `CXXConstructExpr` for copy/move constructor calls; // generated by the compiler, as well as in implicit conversions like the one; // wrapping `1` in `X x = 1;`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:158,wrap,wrapping,158,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,1,['wrap'],['wrapping']
Integrability,// Implement the interface used by simplifyUsersOfIV.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:17,interface,interface,17,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['interface'],['interface']
Integrability,// Implementation details of the pass manager interfaces.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h:46,interface,interfaces,46,interpreter/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h,1,['interface'],['interfaces']
Integrability,"// Implementation notes:; // 1) LOCK prefix creates a full read/write reordering barrier for memory; // operations issued by the current processor. As such, the location; // referenced is not relevant for the ordering properties of the instruction.; // See: Intel 64 and IA-32 ArchitecturesSoftware Developers Manual,; // 8.2.3.9 Loads and Stores Are Not Reordered with Locked Instructions; // 2) Using an immediate operand appears to be the best encoding choice; // here since it doesn't require an extra register.; // 3) OR appears to be very slightly faster than ADD. (Though, the difference; // is small enough it might just be measurement noise.); // 4) When choosing offsets, there are several contributing factors:; // a) If there's no redzone, we default to TOS. (We could allocate a cache; // line aligned stack object to improve this case.); // b) To minimize our chances of introducing a false dependence, we prefer; // to offset the stack usage from TOS slightly.; // c) To minimize concerns about cross thread stack usage - in particular,; // the idiomatic MyThreadPool.run([&StackVars]() {...}) pattern which; // captures state in the TOS frame and accesses it from many threads -; // we want to use an offset such that the offset is in a distinct cache; // line from the TOS frame.; //; // For a general discussion of the tradeoffs and benchmark results, see:; // https://shipilev.net/blog/2014/on-the-fence-with-dependencies/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:907,depend,dependence,907,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['depend'],"['dependence', 'dependencies']"
Integrability,"// Implementation of FourierMotzkin elimination, with some tricks from the; // paper Pugh, William. ""The Omega test: a fast and practical integer; // programming algorithm for dependence; // analysis.""; // Supercomputing'91: Proceedings of the 1991 ACM/; // IEEE conference on Supercomputing. IEEE, 1991.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp:177,depend,dependence,177,interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp,1,['depend'],['dependence']
Integrability,// Implementation of indexes(). Produces iterators that wrap an index. Mostly; // to hide the awkwardness of unsigned wrapping when iterating over valid; // indexes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h:56,wrap,wrap,56,interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h,2,['wrap'],"['wrap', 'wrapping']"
Integrability,"// Implementation of interface for TMultiLayerPerceptron",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodTMlpANN.h:21,interface,interface,21,tmva/tmva/inc/TMVA/MethodTMlpANN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodTMlpANN.h,1,['interface'],['interface']
Integrability,// Implementation of the MCObjectWriter interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp:40,interface,interface,40,interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/GOFFObjectWriter.cpp,1,['interface'],['interface']
Integrability,// Implementation of the MCStreamer interface. We only care about; // instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp:36,interface,interface,36,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp,1,['interface'],['interface']
Integrability,// Implementation of the MCTargetAsmParser interface:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:43,interface,interface,43,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['interface'],['interface']
Integrability,"// Implementation of/for TStreamerInfo::GetStreamerInfo.; // This routine assumes the global lock has been taken.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:66,rout,routine,66,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['rout'],['routine']
Integrability,// Implementing VirtualIntegrator Interface; /** Set the desired relative Error. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GaussIntegrator.h:34,Interface,Interface,34,math/mathcore/inc/Math/GaussIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GaussIntegrator.h,1,['Interface'],['Interface']
Integrability,"// Implementing VirtualIntegratorOneDim Interface; /**; Returns Integral of function between a and b.; Based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to; \f[; I = \int^{b}_{a} f(x)dx; \f]; and define; \f[; r(a,b) = \frac{\left|g_{16}(a,b)-g_{8}(a,b)\right|}{1+\left|g_{16}(a,b)\right|}; \f]; Then,; \f[; G = \sum_{i=1}^{k}g_{16}(x_{i-1},x_{i}); \f]; where, starting with \f$x_{0} = A\f$ and finishing with \f$x_{k} = B\f$,; the subdivision points \f$x_{i}(i=1,2,...)\f$ are given by; \f[; x_{i} = x_{i-1} + \lambda(B-x_{i-1}); \f]; \f$\lambda\f$ is equal to the first member of the; sequence 1,1/2,1/4,... for which \f$r(x_{i-1}, x_{i}) < EPS\f$.; If, at any stage in the process of subdivision, the ratio; \f[; q = \left|\frac{x_{i}-x_{i-1}}{B-A}\right|; \f]; is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; The user provides absolute and relative error bounds (epsrel and epsabs) and the; algorithm will stop when the estimated error is less than the epsabs OR is less; than |I| * epsrel.; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if; \f[; I_{abs} = \int^{B}_{A} \left|f(x)\right|dx; \f]; then the relation; \f[; \frac{\left|G-I\right|}{I_{abs}+k} < EPS; \f]; will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GaussIntegrator.h:40,Interface,Interface,40,math/mathcore/inc/Math/GaussIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GaussIntegrator.h,2,"['Interface', 'rout']","['Interface', 'routine']"
Integrability,"// Implements the CValuePrinter interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValuePrinter.cpp:32,interface,interface,32,interpreter/cling/lib/Interpreter/ValuePrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValuePrinter.cpp,1,['interface'],['interface']
Integrability,"// Implicit conversion to a narrower type, but the expression is; // value-dependent so we can't tell whether it's actually narrowing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:75,depend,dependent,75,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['depend'],['dependent']
Integrability,"// Implicit conversions are disabled for enum class types, so unfortunately we; // need to create a DenseMapInfo wrapper around the specified underlying type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:113,wrap,wrapper,113,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['wrap'],['wrapper']
Integrability,// Implicit params are declared when Sema encounters the definition but this; // never happens when the method is imported. Manually declare the implicit; // params now that the MethodDecl knows its class interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:205,interface,interface,205,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['interface'],['interface']
Integrability,// Implicit property message sends are not 'implicit'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexBody.cpp:21,message,message,21,interpreter/llvm-project/clang/lib/Index/IndexBody.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexBody.cpp,1,['message'],['message']
Integrability,"// ImplicitThis may or may not be a pointer, depending on whether . or -> is; // used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:45,depend,depending,45,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['depend'],['depending']
Integrability,// Import all of the members of this protocol.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:37,protocol,protocol,37,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['protocol'],['protocol']
Integrability,"// Import categories. When the categories themselves are imported, they'll; // hook themselves into this interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:105,interface,interface,105,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['interface'],['interface']
Integrability,// Import protocols,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:10,protocol,protocols,10,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,3,['protocol'],['protocols']
Integrability,// Import the major distinguishing characteristics of a protocol.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:56,protocol,protocol,56,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['protocol'],['protocol']
Integrability,// Import the major distinguishing characteristics of an @interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:58,interface,interface,58,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['interface'],['interface']
Integrability,// Import this module's dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:24,depend,dependencies,24,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['depend'],['dependencies']
Integrability,"// Important: When the integrator samples x, caching of sub-tree values needs to be off.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx:23,integrat,integrator,23,roofit/roofitcore/src/RooBinSamplingPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx,2,['integrat'],['integrator']
Integrability,"// In ""AlwaysBreak"" or ""BlockIndent"" mode, enforce wrapping directly after the; // parenthesis by disallowing any further line breaks if there is no line; // break after the opening parenthesis. Don't break if it doesn't conserve; // columns.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:51,wrap,wrapping,51,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['wrap'],['wrapping']
Integrability,"// In 'socket.h' of some libc implementations with C99, sockaddr parameter; // is a transparent union of the underlying sockaddr_ family of pointers; // instead of being a pointer to struct sockaddr. In these cases, the; // standardized signature will not match, thus we try to match with another; // signature that has the joker Irrelevant type. We also remove those; // constraints which require pointer types for the sockaddr param.; // int socket(int domain, int type, int protocol);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:477,protocol,protocol,477,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,1,['protocol'],['protocol']
Integrability,"// In -verify mode, print DIEs without children in error messages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:57,message,messages,57,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,1,['message'],['messages']
Integrability,"// In .proto files, top-level options and package statements are very; // similar to import statements and should not be line-wrapped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:126,wrap,wrapped,126,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['wrap'],['wrapped']
Integrability,"// In 32-bit mode, large 32-bit quantities wrap around.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:43,wrap,wrap,43,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,1,['wrap'],['wrap']
Integrability,"// In ARC, check for message sends which are likely to introduce; // retain cycles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:21,message,message,21,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['message'],['message']
Integrability,"// In ARC, forbid the user from sending messages to; // retain/release/autorelease/dealloc/retainCount explicitly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:40,message,messages,40,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['message'],['messages']
Integrability,"// In ARC, we sometimes want to ""extend the lifetime""; // (i.e. retain+autorelease) of receivers of returns-inner-pointer; // messages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:126,message,messages,126,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['message'],['messages']
Integrability,"// In C++, it depends on whether the evaluation at the point of definition; // was evaluatable as a constant initializer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:14,depend,depends,14,interpreter/llvm-project/clang/lib/AST/Decl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp,1,['depend'],['depends']
Integrability,"// In C, find all the tag declarations from the prototype and move them; // into the function DeclContext. Remove them from the surrounding tag; // injection context of the function, which is typically but not always; // the TU.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:148,inject,injection,148,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['inject'],['injection']
Integrability,"// In CINT's version, the type name returns did *not* include any array; // information, ROOT's existing code depends on it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingDataMemberInfo.cxx:110,depend,depends,110,core/metacling/src/TClingDataMemberInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingDataMemberInfo.cxx,1,['depend'],['depends']
Integrability,"// In CINT's version, the type name returns did *not* include any array; // information, ROOT's existing code depends on it.; // This might become part of the implementation of GetNormalizedName.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingDataMemberInfo.cxx:110,depend,depends,110,core/metacling/src/TClingDataMemberInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingDataMemberInfo.cxx,1,['depend'],['depends']
Integrability,"// In CUDA/HIP device compilation with -fgpu-rdc, the mangled name of a; // static device variable depends on whether the variable is referenced by; // a host or device host function. Therefore the mangled name cannot be; // cached.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:99,depend,depends,99,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['depend'],['depends']
Integrability,"// In DWARF v5 there is a contribution header that immediately precedes; // the string offsets base (the location we have previously retrieved from; // the CU DIE's DW_AT_str_offsets attribute). The header is located either; // 8 or 16 bytes before the base, depending on the contribution's format.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp:259,depend,depending,259,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,1,['depend'],['depending']
Integrability,"// In JavaScript, `interface X { foo?(): bar; }` is an optional method; // on the interface, not a ternary expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:19,interface,interface,19,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,2,['interface'],['interface']
Integrability,"// In JavaScript/TypeScript, ""interface"" can be used as a standalone; // identifier, e.g. in `var interface = 1;`. If ""interface"" is; // followed by another identifier, it is very like to be an actual; // interface declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:30,interface,interface,30,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,4,['interface'],['interface']
Integrability,"// In LLVM's non-standard representation of phi nodes, it's possible to have; // phi nodes with cycles (IE dependent on other phis that are .... dependent; // on the original phi node), especially in weird CFG's where some arguments; // are unreachable, or uninitialized along certain paths. This can cause; // infinite loops during evaluation. We work around this by not trying to; // really evaluate them independently, but instead using a variable; // expression to say if one is equivalent to the other.; // We also special case undef/poison, so that if we have an undef, we can't; // use the common value unless it dominates the phi block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:107,depend,dependent,107,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,2,['depend'],['dependent']
Integrability,"// In Microsoft mode, don't perform typo correction in a template member; // function dependent context because it interferes with the ""lookup into; // dependent bases of class templates"" feature.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:86,depend,dependent,86,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,2,['depend'],['dependent']
Integrability,"// In Microsoft mode, if we are inside a template class member function; // then create a type dependent CallExpr. The goal is to postpone name; // lookup to instantiation time to be able to search into type dependent; // base classes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:95,depend,dependent,95,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,2,['depend'],['dependent']
Integrability,"// In Microsoft mode, if we are within a templated function and we can't; // resolve Identifier, then extend the SS with Identifier. This will have; // the effect of resolving Identifier during template instantiation.; // The goal is to be able to resolve a function call whose; // nested-name-specifier is located inside a dependent base class.; // Example:; //; // class C {; // public:; // static void foo2() { }; // };; // template <class T> class A { public: typedef C D; };; //; // template <class T> class B : public A<T> {; // public:; // void foo() { D::foo2(); }; // };",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:324,depend,dependent,324,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['depend'],['dependent']
Integrability,"// In MinGW, variables without DLLImport can still be automatically; // imported from a DLL by the linker; don't mark variables that; // potentially could come from another DLL as DSO local.; // With EmulatedTLS, TLS variables can be autoimported from other DLLs; // (and this actually happens in the public interface of libstdc++), so; // such variables can't be marked as DSO local. (Native TLS variables; // can't be dllimported at all, though.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:308,interface,interface,308,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['interface'],['interface']
Integrability,"// In Obj-C++11, we need to distinguish four situations:; // 1a) int x[[attr]]; C++11 attribute.; // 1b) [[attr]]; C++11 statement attribute.; // 2) int x[[obj](){ return 1; }()]; Lambda in array size/index.; // 3a) int x[[obj get]]; Message send in array size/index.; // 3b) [[Class alloc] init]; Message send in message send.; // 4) [[obj]{ return self; }() doStuff]; Lambda in message send.; // (1) is an attribute, (2) is ill-formed, and (3) and (4) are accepted.; // Check to see if this is a lambda-expression.; // FIXME: If this disambiguation is too slow, fold the tentative lambda parse; // into the tentative attribute parse below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:234,Message,Message,234,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,4,"['Message', 'message']","['Message', 'message']"
Integrability,"// In ObjC interfaces, nothing should be following the ""}"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:11,interface,interfaces,11,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['interface'],['interfaces']
Integrability,"// In Objective-C type declarations, avoid breaking after the category's; // open paren (we'll prefer breaking after the protocol list's opening; // angle bracket, if present).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:121,protocol,protocol,121,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['protocol'],['protocol']
Integrability,"// In Objective-C++, alternative operator tokens can be used as keyword args; // in message expressions. Unconsume the token so that it can reinterpreted; // as an identifier in ParseObjCMessageExpressionBody. i.e., we support:; // [foo meth:0 and:0];; // [foo not_eq];",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:84,message,message,84,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['message'],['message']
Integrability,"// In Objective-C, message sends can send interfaces. In Objective-C++,; // all types are available due to functional casts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:19,message,message,19,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,2,"['interface', 'message']","['interfaces', 'message']"
Integrability,"// In Objective-C, we might have a protocol-qualified type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:35,protocol,protocol-qualified,35,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['protocol'],['protocol-qualified']
Integrability,// In OpenCL captures for blocks called as lambda functions; // are located in the private address space. Blocks used in; // enqueue_kernel can be located in a different address space; // depending on a vendor implementation. Thus preventing; // taking an address of the capture to avoid invalid AS casts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:188,depend,depending,188,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['depend'],['depending']
Integrability,"// In SkippingRangeStateTy we are depending on SkipExcludedConditionalBlock(); // not getting called recursively by storing the RecordedSkippedRanges; // DenseMap lookup pointer (field SkipRangePtr). SkippingRangeStateTy expects; // that RecordedSkippedRanges won't get modified and SkipRangePtr won't be; // invalidated. If this changes and there is a need to call; // SkipExcludedConditionalBlock() recursively, SkippingRangeStateTy should; // change to do a second lookup in endLexPass function instead of reusing the; // lookup pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:34,depend,depending,34,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['depend'],['depending']
Integrability,"// In TypeScript, ""enum"" can also be used as property name, e.g. in interface; // declarations. An ""enum"" keyword followed by a colon would be a syntax; // error and thus assume it is just an identifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:68,interface,interface,68,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['interface'],['interface']
Integrability,"// In Verilog, all strings are quoted by double quotes, joined by commas,; // and wrapped in braces. The comma is always before the newline.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:82,wrap,wrapped,82,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,1,['wrap'],['wrapped']
Integrability,"// In Windows' libcmt.lib, there is a file which is linked in only if the; // symbol _fltused is referenced. Linking this in causes some; // side-effects:; //; // 1. For x86-32, it will set the x87 rounding mode to 53-bit instead of; // 64-bit mantissas at program start.; //; // 2. It links in support routines for floating-point in scanf and printf.; //; // MSVC emits an undefined reference to _fltused when there are any; // floating point operations in the program (including calls). A program; // that only has: `scanf(""%f"", &global_float);` may fail to trigger this,; // but oh well...that's a documented issue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:303,rout,routines,303,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,1,['rout'],['routines']
Integrability,"// In a class method, class messages to 'self' that return instancetype can; // be typed as the current class. We can safely do this in ARC because self; // can't be reassigned, and we do it unsafely outside of ARC because in; // practice people never reassign self in class methods and there's some; // virtue in not being aggressively pedantic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:28,message,messages,28,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['message'],['messages']
Integrability,// In a record describing a template the type should be an; // InjectedClassNameType (see Sema::CheckClassTemplate). Update the; // previously set type to the correct value here (ToDescribed is not; // available at record create).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:63,Inject,InjectedClassNameType,63,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['Inject'],['InjectedClassNameType']
Integrability,"// In an Objective-C method, if we have ""super"" followed by an identifier,; // the token sequence is ill-formed. However, if there's a ':' or ']' after; // that identifier, this is probably a message send with a missing open; // bracket. Treat it as such.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:192,message,message,192,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['message'],['message']
Integrability,"// In any cycle where we can't schedule any instructions, we must; // stall or emit a noop, depending on the target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:92,depend,depending,92,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['depend'],['depending']
Integrability,"// In auto-synthesis, protocol properties are not synthesized. So,; // a conforming protocol must have its required properties declared; // in class interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:22,protocol,protocol,22,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,3,"['interface', 'protocol']","['interface', 'protocol']"
Integrability,"// In case of VersionID<=0 write dummy streamer only calling; // its base class Streamer(s). If no base class(es) let Streamer; // print error message, i.e. this Streamer should never have been called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:143,message,message,143,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['message'],['message']
Integrability,"// In case of a comparison with two select instructions having the same; // condition, check whether one of the resulting branches can be simplified.; // If so, just compare the other branch and select the appropriate result.; // For example:; // %tmp1 = select i1 %cmp, i32 %y, i32 %x; // %tmp2 = select i1 %cmp, i32 %z, i32 %x; // %cmp2 = icmp slt i32 %tmp2, %tmp1; // The icmp will result false for the false value of selects and the result; // will depend upon the comparison of true values of selects if %cmp is; // true. Thus, transform this into:; // %cmp = icmp slt i32 %y, %z; // %sel = select i1 %cond, i1 %cmp, i1 false; // This handles similar cases to transform.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:453,depend,depend,453,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['depend'],['depend']
Integrability,"// In case of a memmove, the call to memmove will be executed instead; // of the loop, so we need to make sure that there is nothing else in; // the loop than the load, store and instructions that these two depend; // on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:207,depend,depend,207,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,1,['depend'],['depend']
Integrability,"// In case of a templated type, calling overloaded operators is not; // resolved and modelled as `binaryOperator` on a dependent type.; // Such instances are considered a modification, because they can modify; // in different instantiations of the template.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp:119,depend,dependent,119,interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,1,['depend'],['dependent']
Integrability,"// In case the callee has 'noreturn' attribute, We need to remove it, because; // we expect invoke wrappers to return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:99,wrap,wrappers,99,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,1,['wrap'],['wrappers']
Integrability,"// In case the user re-routes the error handler to not die when Fatal is called",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:23,rout,routes,23,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,30,['rout'],['routes']
Integrability,"// In case we exited early from the previous loop, there are other types to; // read from TypeStr. So we need to read them all to ensure we have the right; // number of arguments in TheCall and if it is not the case, to display a; // better error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:247,message,message,247,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['message'],['message']
Integrability,"// In case when we print non paren inits like int i = h->Draw();; // not int i(h->Draw()). This simplifies the LifetimeHandler's; // constructor, there we don't need to add parenthesis while; // wrapping the expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp:195,wrap,wrapping,195,interpreter/cling/lib/Interpreter/DynamicLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp,1,['wrap'],['wrapping']
Integrability,"// In categories look for overridden methods from protocols. A method from; // category is not ""overridden"" since it is considered as the ""same"" method; // (same USR) as the one from the interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:50,protocol,protocols,50,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,2,"['interface', 'protocol']","['interface', 'protocols']"
Integrability,"// In certain situations, we are allowed to lay out objects in the; // tail-padding of base classes. This is ABI-dependent.; // FIXME: this should be stored in the record layout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:113,depend,dependent,113,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['depend'],['dependent']
Integrability,"// In compiled files, consider the first #include to be the main #include of; // the file if it is not a system #include. This ensures that the header; // doesn't have hidden dependencies; // (http://llvm.org/docs/CodingStandards.html#include-style).; //; // FIXME: Do some validation, e.g. edit distance of the base name, to fix; // cases where the first #include is unlikely to be the main header.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:175,depend,dependencies,175,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,1,['depend'],['dependencies']
Integrability,"// In dependent contexts, function names may change.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:6,depend,dependent,6,interpreter/llvm-project/clang/lib/AST/Expr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp,1,['depend'],['dependent']
Integrability,"// In dependent contexts, we do ADL twice, and the first time around,; // the base type might be a dependent TemplateSpecializationType, or a; // TemplateTypeParmType. If that happens, simply ignore it.; // FIXME: If we want to support export, we probably need to add the; // namespace of the template in a TemplateSpecializationType, or even; // the classes and namespaces of known non-dependent arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:6,depend,dependent,6,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,3,['depend'],['dependent']
Integrability,// In friend declarations we can have template-ids which don't; // depend on the corresponding template parameter lists. But; // assume that empty parameter lists are supposed to match this; // template-id.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:67,depend,depend,67,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['depend']
Integrability,"// In general floating point reductions are a series of elementwise; // operations, with free extracts on each step. These are either in-order or; // treewise depending on whether that is allowed by the fast math flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:159,depend,depending,159,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,2,['depend'],['depending']
Integrability,"// In general, appending the expression wrapped by a CXXDefaultInitExpr; // may cause the same Expr to appear more than once in the CFG. Doing it; // here is safe because there's only one initializer per field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:40,wrap,wrapped,40,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['wrap'],['wrapped']
Integrability,"// In lambdas, the qualifiers of the type depends of where in; // the call operator `this` appear, and we do not have a good way to; // rebuild this information, so we transform the type.; //; // In other contexts, the type of `this` may be overrided; // for type deduction, so we need to recompute it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:42,depend,depends,42,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['depend'],['depends']
Integrability,"// In most cases the types of LHS and RHS will be the same, but in some; // crazy cases one or the other may be a pointer. ScalarEvolution doesn't; // depend on the type for correctness, but handling types carefully can; // avoid extra casts in the SCEVExpander. The LHS is more likely to be; // a pointer type than the RHS, so use the RHS' type here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:151,depend,depend,151,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,1,['depend'],['depend']
Integrability,"// In most cases, we walk from the beginning to the end of the block. But; // when the block is the same block as the copy is from, we will visit it; // twice. The first time we start from the copy and go to the end. The; // second time we start from the beginning and go to the copy. This lets; // us handle copies inside of cycles.; // FIXME: This loop is *super* confusing. This is at least in part; // a symptom of all of this routine needing to be refactored into; // documentable components. Once done, there may be a better way to write; // this loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:431,rout,routine,431,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,1,['rout'],['routine']
Integrability,"// In non-aggressive mode, only warn on use-after-move of local variables; // (or local rvalue references) and of STL objects. The former is possible; // because local variables (or local rvalue references) are not tempting; // their user to re-use the storage. The latter is possible because STL; // objects are known to end up in a valid but unspecified state after the; // move and their state-reset methods are also known, which allows us to; // predict precisely when use-after-move is invalid.; // Some STL objects are known to conform to additional contracts after move,; // so they are not tracked. However, smart pointers specifically are tracked; // because we can perform extra checking over them.; // In aggressive mode, warn on any use-after-move because the user has; // intentionally asked us to completely eliminate use-after-move; // in his code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:556,contract,contracts,556,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,1,['contract'],['contracts']
Integrability,"// In order to provide direct access to remote sqlite files through HTTP and HTTPS, this datasource provides a custom; // ""SQlite VFS module"" that uses Davix for data access. The SQlite VFS modules are roughly what TSystem is; // for ROOT -- an abstraction of the operating system interface.; //; // SQlite allows for registering custom VFS modules, which are a set of C callback functions that SQlite invokes when; // it needs to read from a file, write to a file, etc. More information is available under https://sqlite.org/vfs.html; //; // In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; // files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; // The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; ////////////////////////////////////////////////////////////////////////////; /// SQlite VFS modules are identified by string names. The name has to be unique for the entire application.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:281,interface,interface,281,tree/dataframe/src/RSqliteDS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx,1,['interface'],['interface']
Integrability,"// In other braced lists styles, the ""}"" can be wrapped to the new line.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.cpp:48,wrap,wrapped,48,interpreter/llvm-project/clang/lib/Format/FormatToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.cpp,1,['wrap'],['wrapped']
Integrability,"// In p2.2, PyHeapTypeObject is not yet part of the interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.h:52,interface,interface,52,bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.h,1,['interface'],['interface']
Integrability,"// In particular, we depend on it being the last arg in Args, and the; // objectsize bits depend on there only being one arg if !LeftToRight.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:21,depend,depend,21,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,2,['depend'],['depend']
Integrability,"// In pass through mode, the RooRealIntegral should have registered the; // function as a value server, because we directly depend on its value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:124,depend,depend,124,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['depend'],['depend']
Integrability,// In presence of dependent args we surface all possible signatures using the; // non-dependent args in the prefix. Afterwards we do a post filtering to make; // sure provided candidates satisfy parameter count restrictions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:18,depend,dependent,18,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,2,['depend'],['dependent']
Integrability,"// In presence of finite 'safelen', it may be unsafe to mark all; // the memory instructions parallel, because loop-carried; // dependences of 'safelen' iterations are possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:128,depend,dependences,128,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,2,['depend'],['dependences']
Integrability,"// In presence of finite 'safelen', it may be unsafe to mark all; // the memory instructions parallel, because loop-carried; // dependences of 'safelen' iterations are possible.; // If clause order(concurrent) is specified then the memory instructions; // are marked parallel even if 'safelen' is finite.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:128,depend,dependences,128,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['depend'],['dependences']
Integrability,"// In regular response files, we send all arguments to the response file.; // Wrapping all arguments in double quotes ensures that both Unix tools and; // Windows tools understand the response file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Job.cpp:78,Wrap,Wrapping,78,interpreter/llvm-project/clang/lib/Driver/Job.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Job.cpp,1,['Wrap'],['Wrapping']
Integrability,"// In the basic model we take into account GEP instructions only; // (although here can come alloca instruction, a value, constants and/or; // constant expressions, PHIs, bitcasts ... whatever allowed to be used as a; // pointer). Typically, if Base is a not a GEP-instruction and all the; // pointers are relative to the same base address, all the rest are; // either GEP instructions, PHIs, bitcasts or constants. When we have same; // base, we just calculate cost of each non-Base GEP as an ADD operation if; // any their index is a non-const.; // If no known dependecies between the pointers cost is calculated as a sum; // of costs of GEP instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:563,depend,dependecies,563,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,2,['depend'],['dependecies']
Integrability,"// In the beginning all features are either 'Any' or 'NotSupported',; // depending on global target features. This will cover empty modules.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp:73,depend,depending,73,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp,1,['depend'],['depending']
Integrability,"// In the case of a latency tie, prefer an anti-dependency edge over; // other types of edges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:48,depend,dependency,48,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,2,['depend'],['dependency']
Integrability,"// In the case of an aggregate type (class, struct, union, interface),; // get the aggregate size. As the original record is pointing to its; // reference, we have to update it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp:59,interface,interface,59,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,1,['interface'],['interface']
Integrability,"// In the case of multiple select instructions in the same group, the order; // of non-dependent instructions (instructions of different dependence; // slices) in the true/false blocks appears to affect performance.; // Interleaving the slices seems to experimentally be the optimal approach.; // This interleaving scheduling allows for more ILP (with a natural downside; // of increasing a bit register pressure) compared to a simple ordering of; // one whole chain after another. One would expect that this ordering would; // not matter since the scheduling in the backend of the compiler would; // take care of it, but apparently the scheduler fails to deliver optimal; // ILP with a naive ordering here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:87,depend,dependent,87,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,2,['depend'],"['dependence', 'dependent']"
Integrability,"// In the epilog, a map lookup is needed to get the value from the kernel,; // or previous epilog block. How is does this depends on if the; // instruction is scheduled in the previous block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:122,depend,depends,122,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['depend'],['depends']
Integrability,"// In the kernel, a dependent Phi uses the value from this Phi.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:20,depend,dependent,20,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['depend'],['dependent']
Integrability,"// In this case the function derivatives are provided; // by the user via this interface and there not calculated by Fumili.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumiliMinimizer.cxx:79,interface,interface,79,math/fumili/src/TFumiliMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumiliMinimizer.cxx,1,['interface'],['interface']
Integrability,"// In this case, the expression could be printed using a different; // specifier, but we've decided that the specifier is probably correct; // and we should cast instead. Just use the normal warning message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:199,message,message,199,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['message'],['message']
Integrability,"// In this context, property reference is a message call and is pr-value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:44,message,message,44,interpreter/llvm-project/clang/lib/AST/Expr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp,1,['message'],['message']
Integrability,"// In this namespace, common routines are defined for element packing and unpacking of ints and floats.; // The following conversions and encodings exist:; //; // - Byteswap: on big endian machines, ints and floats are byte-swapped to the little endian on-disk format; // - Cast: in-memory values can be stored in narrower on-disk columns. Currently without bounds checks.; // For instance, for Double32_t, an in-memory double value is stored as a float on disk.; // - Split: rearranges the bytes of an array of elements such that all the first bytes are stored first,; // followed by all the second bytes, etc. This often clusters similar values, e.g. all the zero bytes; // for arrays of small integers.; // - Delta: Delta encoding stores on disk the delta to the previous element. This is useful for offsets,; // because it transforms potentially large offset values into small deltas, which are then better; // suited for split encoding.; // - Zigzag: Zigzag encoding is used on signed integers only. It maps x to 2x if x is positive and to -(2x+1) if; // x is negative. For series of positive and negative values of small absolute value, it will produce; // a bit pattern that is favorable for split encoding.; //; // Encodings/conversions can be fused:; //; // - Delta/Zigzag + Splitting (there is no only-delta/zigzag encoding); // - (Delta/Zigzag + ) Splitting + Casting; // - Everything + Byteswap; /// \brief Copy and byteswap `count` elements of size `N` from `source` to `destination`.; ///; /// Used on big-endian architectures for packing/unpacking elements whose column type requires; /// a little-endian on-disk representation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:29,rout,routines,29,tree/ntuple/v7/src/RColumnElement.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx,1,['rout'],['routines']
Integrability,"// In-process LLJIT uses eh-frame section wrappers via EPC, so we need to force; // them to be linked in.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:42,wrap,wrappers,42,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,1,['wrap'],['wrappers']
Integrability,// In:; // struct X {; // X(int); // };; // X x = X(1);; // Ignores the implicit `CXXFunctionalCastExpr` that wraps; // `CXXConstructExpr X(1)`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:110,wrap,wraps,110,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,1,['wrap'],['wraps']
Integrability,// Include GetLastError() in a fatal error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Windows/WindowsSupport.h:43,message,message,43,interpreter/llvm-project/llvm/include/llvm/Support/Windows/WindowsSupport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Windows/WindowsSupport.h,1,['message'],['message']
Integrability,// Include StrError(errnum) in a fatal error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Unix/Unix.h:45,message,message,45,interpreter/llvm-project/llvm/lib/Support/Unix/Unix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Unix/Unix.h,1,['message'],['message']
Integrability,// Include truncated messages when counting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GraphWriter.h:21,message,messages,21,interpreter/llvm-project/llvm/include/llvm/Support/GraphWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GraphWriter.h,1,['message'],['messages']
Integrability,"// Includes an error, and depends on how it is resolved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:26,depend,depends,26,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,1,['depend'],['depends']
Integrability,// Incomplete type does not match a dependently-sized array type,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:36,depend,dependently-sized,36,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['depend'],['dependently-sized']
Integrability,"// Increment the expected index. If it wraps around, it may still be; // a VEXT but the source vectors must be swapped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:39,wrap,wraps,39,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['wrap'],['wraps']
Integrability,"// Increment the expected index. If it wraps around, just follow it; // back to index zero and keep going.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:39,wrap,wraps,39,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,3,['wrap'],['wraps']
Integrability,"// IndVar is of the form ""A + B * I"" (where ""I"" is the canonical induction; // variable, that may or may not exist as a real llvm::Value in the loop) and; // this inductive range check is a range check on the ""C + D * I"" (""C"" is; // getBegin() and ""D"" is getStep()). We rewrite the value being range; // checked to ""M + N * IndVar"" where ""N"" = ""D * B^(-1)"" and ""M"" = ""C - NA"".; //; // The actual inequalities we solve are of the form; //; // 0 <= M + 1 * IndVar < L given L >= 0 (i.e. N == 1); //; // Here L stands for upper limit of the safe iteration space.; // The inequality is satisfied by (0 - M) <= IndVar < (L - M). To avoid; // overflows when calculating (0 - M) and (L - M) we, depending on type of; // IV's iteration space, limit the calculations by borders of the iteration; // space. For example, if IndVar is unsigned, (0 - M) overflows for any M > 0.; // If we figured out that ""anything greater than (-M) is safe"", we strengthen; // this to ""everything greater than 0 is safe"", assuming that values between; // -M and 0 just do not exist in unsigned iteration space, and we don't want; // to deal with overflown values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:688,depend,depending,688,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,1,['depend'],['depending']
Integrability,"// Indent nested blocks relative to this column, unless in a very specific; // JavaScript special case where:; //; // var loooooong_name =; // function() {; // // code; // }; //; // is common and should be formatted like a free-standing function. The same; // goes for wrapping before the lambda return type arrow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:269,wrap,wrapping,269,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['wrap'],['wrapping']
Integrability,"// Index of the first element of the vector.; // PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:53,Interoperab,Interoperability,53,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,2,"['Interoperab', 'depend']","['Interoperability', 'depending']"
Integrability,"// IndexType is size_t, which depends on the bitness of the target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:30,depend,depends,30,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,2,['depend'],['depends']
Integrability,"// Indexed by PSet ID; // InitSetPressure takes into account the register pressure of live-in; // registers. It's not depend on how the loop is scheduled, so it's enough to; // calculate them once at the beginning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:118,depend,depend,118,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['depend']
Integrability,"// Indexing over an interface, as in ""NSString *P; P[4];""; // Emit the base pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:20,interface,interface,20,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['interface'],['interface']
Integrability,"// Indicate personality routine, if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCFIException.cpp:24,rout,routine,24,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCFIException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCFIException.cpp,1,['rout'],['routine']
Integrability,// Indicate we are linking with an allocator that supports hot/cold operator; // new interfaces.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:85,interface,interfaces,85,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['interface'],['interfaces']
Integrability,"// Indicate whether a new formula has been added since the last synchronization",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeFormulaManager.h:64,synchroniz,synchronization,64,tree/treeplayer/inc/TTreeFormulaManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeFormulaManager.h,1,['synchroniz'],['synchronization']
Integrability,// Indicates whether this instance has integrated backend using; // internal LLVM infrastructure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.h:39,integrat,integrated,39,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.h,1,['integrat'],['integrated']
Integrability,"// Inexact result means that it depends on rounding mode. If the requested; // mode is dynamic, the evaluation cannot be made in compile time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:32,depend,depends,32,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,2,['depend'],['depends']
Integrability,"// Infer as many types as possible. Don't worry about it if we don't infer; // all of them, some may depend on the inputs of the pattern. Also, don't; // validate type sets; validation may cause spurious failures e.g. if a; // fragment needs floating-point types but the current target does not have; // any (this is only an error if that fragment is ever used!).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:101,depend,depend,101,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['depend'],['depend']
Integrability,"// Infer members of T, given that the expression E (dependent on T) is true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:52,depend,dependent,52,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['depend'],['dependent']
Integrability,"// Info(""RunCollector"",""process counter %i"",fEndProcess);; // check if message has been received",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/mpi/src/TMPIFile.cxx:71,message,message,71,io/mpi/src/TMPIFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/mpi/src/TMPIFile.cxx,1,['message'],['message']
Integrability,// Information on REP string instructions that require manual mitigation can; // be found here:; // https://software.intel.com/security-software-guidance/insights/deep-dive-load-value-injection#specialinstructions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:184,inject,injection,184,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,1,['inject'],['injection']
Integrability,// Information on control-flow instructions that require manual mitigation can; // be found here:; // https://software.intel.com/security-software-guidance/insights/deep-dive-load-value-injection#specialinstructions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:186,inject,injection,186,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,1,['inject'],['injection']
Integrability,"// Inherit all of the target dependent attributes and white-listed; // target independent attributes.; // (e.g. If the extracted region contains a call to an x86.sse; // instruction we need to make sure that the extracted region has the; // ""target-features"" attribute allowing it to be lowered.; // FIXME: This should be changed to check to see if a specific; // attribute can not be inherited.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:29,depend,dependent,29,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,1,['depend'],['dependent']
Integrability,"// Init Session (get protocol, run authentication, ...); // type of authentication:; // 0 (new), 1 (existing), 2 (updated offset)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/DaemonUtils.cxx:21,protocol,protocol,21,net/rpdutils/src/DaemonUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/DaemonUtils.cxx,1,['protocol'],['protocol']
Integrability,"// Initial guess of the inflated message; // size. We double the memory when needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c:33,message,message,33,net/http/civetweb/civetweb.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/civetweb.c,1,['message'],['message']
Integrability,"// Initial plot range and number of bins from dependent variable; // setPlotRange(variable.getPlotMin()*_slope + _offset,; // variable.getPlotMax()*_slope + _offset) ;; // setPlotBins(variable.getPlotBins()) ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooLinearVar.cxx:46,depend,dependent,46,roofit/roofitcore/src/RooLinearVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooLinearVar.cxx,1,['depend'],['dependent']
Integrability,// Initialization Routines,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Rout,Routines,18,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['Rout'],['Routines']
Integrability,"// Initialization routine called from the constructor. This should NOT be made virtual.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:18,rout,routine,18,tree/tree/src/TBranch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx,1,['rout'],['routine']
Integrability,"// Initialize (un)weighted counters for signal & background; // Construct a list of event wrappers that point to the original data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DecisionTree.cxx:90,wrap,wrappers,90,tmva/tmva/src/DecisionTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DecisionTree.cxx,1,['wrap'],['wrappers']
Integrability,"// Initialize Operating System interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:31,interface,interface,31,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['interface'],['interface']
Integrability,"// Initialize TMinuit via generic fitter interface with a maximum of 5 params",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/minexam.cxx:41,interface,interface,41,test/minexam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/minexam.cxx,1,['interface'],['interface']
Integrability,"// Initialize a group for B if it has an allowable stride. Even if we don't; // create a group for B, we continue with the bottom-up algorithm to ensure; // we don't break any of B's dependences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:183,depend,dependences,183,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['depend'],['dependences']
Integrability,"// Initialize interface to CINT C++ interpreter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:14,interface,interface,14,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['interface'],['interface']
Integrability,"// Initialize the Huber Loss Function so that we can calculate the loss.; // The loss for each event depends on the other events in the group; // that define the cutoff quantile (fTransitionPoint).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/LossFunction.cxx:101,depend,depends,101,tmva/tmva/src/LossFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/LossFunction.cxx,2,['depend'],['depends']
Integrability,"// Initialize the constant string interface lazily. This assumes; // the NSString interface is seen in this translation unit. Note: We; // don't use NSConstantString, since the runtime team considers this; // interface private (even though it appears in the header files).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:34,interface,interface,34,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,3,['interface'],['interface']
Integrability,"// Initialize the fBegin and fEnd iterators.; // We can safely assume that the std::vector layout does not really depend on; // the content!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TVirtualCollectionIterators.h:114,depend,depend,114,io/io/inc/TVirtualCollectionIterators.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TVirtualCollectionIterators.h,1,['depend'],['depend']
Integrability,// Initialize the protocol qualifiers. The protocol storage is known; // after we set number of type arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:18,protocol,protocol,18,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,2,['protocol'],['protocol']
Integrability,// Initialize to true or false depending on whether it was; // active up to this point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:31,depend,depending,31,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,1,['depend'],['depending']
Integrability,"// Initialized at the start of each test to expect diagnostic messages from TestSupport",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx:62,message,messages,62,tree/ntuple/v7/test/ntuple_storage_daos.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage_daos.cxx,1,['message'],['messages']
Integrability,"// Initilization routine.; //TVirtualStreamerInfo::Class_Version MUST be the same as TStreamerInfo::Class_Version",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx:17,rout,routine,17,core/meta/src/TGenericClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx,1,['rout'],['routine']
Integrability,"// Inject - empty slots will be 0, 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp:3,Inject,Inject,3,interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,1,['Inject'],['Inject']
Integrability,"// Inject a number of symbols that may be in libc_nonshared.a where they are; // not found automatically. Before DefinitionGenerators in ORCv2, this used; // to be done by RTDyldMemoryManager::getSymbolAddressInProcess See also the; // upstream issue https://github.com/llvm/llvm-project/issues/61289.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp:3,Inject,Inject,3,interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,1,['Inject'],['Inject']
Integrability,"// Inject a special marker:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ForwardDeclPrinter.cpp:3,Inject,Inject,3,interpreter/cling/lib/Interpreter/ForwardDeclPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ForwardDeclPrinter.cpp,1,['Inject'],['Inject']
Integrability,"// Inject all lines of FileName.; // Intentionally ignore fMaxDepth",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/History.cpp:3,Inject,Inject,3,core/textinput/src/textinput/History.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/History.cpp,1,['Inject'],['Inject']
Integrability,// Inject byval arguments initialization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Inject,Inject,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['Inject'],['Inject']
Integrability,// Inject libfuzzer dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:3,Inject,Inject,3,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,2,"['Inject', 'depend']","['Inject', 'dependencies']"
Integrability,// Inject loads into all of the pred blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Inject,Inject,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['Inject'],['Inject']
Integrability,// Inject stylesheet if we haven't done that yet,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,Inject,Inject,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Inject'],['Inject']
Integrability,// Inject template fragments before class fragments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/ExtractAPIVisitor.h:3,Inject,Inject,3,interpreter/llvm-project/clang/include/clang/ExtractAPI/ExtractAPIVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/ExtractAPIVisitor.h,1,['Inject'],['Inject']
Integrability,// Inject template fragments before var fragments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/ExtractAPIVisitor.h:3,Inject,Inject,3,interpreter/llvm-project/clang/include/clang/ExtractAPI/ExtractAPIVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/ExtractAPIVisitor.h,1,['Inject'],['Inject']
Integrability,// Inject the VBPointer at the injection site.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:3,Inject,Inject,3,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,2,"['Inject', 'inject']","['Inject', 'injection']"
Integrability,// Inject the ending and a new line,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:3,Inject,Inject,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,1,['Inject'],['Inject']
Integrability,// Inject the members of the anonymous struct into the current; // context and into the identifier resolver chain for name lookup; // purposes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Inject,Inject,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Inject'],['Inject']
Integrability,// Inject the members of the anonymous struct/union into the owning; // context and into the identifier resolver chain for name lookup; // purposes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Inject,Inject,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Inject'],['Inject']
Integrability,// Injected class names are not considered nested records.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:3,Inject,Injected,3,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['Inject'],['Injected']
Integrability,// Inline asm may have a def in the middle of the operands. Our contract; // with inline asm register operands is to provide local indices as; // immediates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp:64,contract,contract,64,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp,1,['contract'],['contract']
Integrability,// Input dependencies.; // One entry per each implicit and explicit register use.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:9,depend,dependencies,9,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,1,['depend'],['dependencies']
Integrability,"// Input for TLimit routines",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TLimitDataSource.h:20,rout,routines,20,hist/hist/inc/TLimitDataSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TLimitDataSource.h,1,['rout'],['routines']
Integrability,"// Input handler for messages from TProofServ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h:21,message,messages,21,proof/proof/inc/TProof.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h,1,['message'],['messages']
Integrability,// Insert CHI args at each PDF to iterate on factored graph of; // control dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:75,depend,dependence,75,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['depend'],['dependence']
Integrability,// Insert DEALLOC_VGPR messages before previously identified S_ENDPGM; // instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:23,message,messages,23,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['message'],['messages']
Integrability,// Insert Phis for all conflicts; // TODO: adjust naming patterns to avoid this order of iteration dependency,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:99,depend,dependency,99,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['depend'],['dependency']
Integrability,"// Insert a node into the DAG at least before Pos. This will reposition; // the node as needed, and will assign it a node ID that is <= Pos's ID.; // Note that this does *not* preserve the uniqueness of node IDs!; // The selection DAG must no longer depend on their uniqueness when this; // function is used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:250,depend,depend,250,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['depend'],['depend']
Integrability,"// Insert a node into the DAG at least before the Pos node's position. This; // will reposition the node as needed, and will assign it a node ID that is <=; // the Pos node's ID. Note that this does *not* preserve the uniqueness of node; // IDs! The selection DAG must no longer depend on their uniqueness when this; // is used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:279,depend,depend,279,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['depend'],['depend']
Integrability,// Insert collected methods declarations into the @interface object.; // This passes in an invalid SourceLocation for AtEndLoc when EOF is hit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:51,interface,interface,51,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['interface'],['interface']
Integrability,// Insert instructions from the loop that we depend on.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:45,depend,depend,45,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,1,['depend'],['depend']
Integrability,// Insert map entries for specific devices with this compute; // capability. NVCC's choice of the libdevice library version is; // rather peculiar and depends on the CUDA version.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:151,depend,depends,151,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,1,['depend'],['depends']
Integrability,"// Insert the new code into the line just below the code; // that the user wrote.; // Note: When modifying this function, be very careful about what is a; // ""column"" (printed width, platform-dependent) and what is a; // ""byte offset"" (SourceManager ""column"").",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:192,depend,dependent,192,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,1,['depend'],['dependent']
Integrability,// Insert the protocol.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:14,protocol,protocol,14,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['protocol'],['protocol']
Integrability,"// Inserts the specified store SI with the given index Idx to the set of the; // stores. If the store with the same distance is found already - stop; // insertion, try to vectorize already found stores. If some stores from this; // sequence were not vectorized - try to vectorize them with the new store; // later. But this logic is applied only to the stores, that come before the; // previous store with the same distance.; // Example:; // 1. store x, %p; // 2. store y, %p+1; // 3. store z, %p+2; // 4. store a, %p; // 5. store b, %p+3; // - Scan this from the last to first store. The very first bunch of stores is; // {5, {{4, -3}, {2, -2}, {3, -1}, {5, 0}}} (the element in SortedStores; // vector).; // - The next store in the list - #1 - has the same distance from store #5 as; // the store #4.; // - Try to vectorize sequence of stores 4,2,3,5.; // - If all these stores are vectorized - just drop them.; // - If some of them are not vectorized (say, #3 and #5), do extra analysis.; // - Start new stores sequence.; // The new bunch of stores is {1, {1, 0}}.; // - Add the stores from previous sequence, that were not vectorized.; // Here we consider the stores in the reversed order, rather they are used in; // the IR (Stores are reversed already, see vectorizeStoreChains() function).; // Store #3 can be added -> comes after store #4 with the same distance as; // store #1.; // Store #5 cannot be added - comes before store #4.; // This logic allows to improve the compile time, we assume that the stores; // after previous store with the same distance most likely have memory; // dependencies and no need to waste compile time to try to vectorize them.; // - Try to vectorize the sequence {1, {1, 0}, {3, 2}}.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:1594,depend,dependencies,1594,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['depend'],['dependencies']
Integrability,"// Install a new wrapper around 'delete []'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx:17,wrap,wrapper,17,core/meta/src/TGenericClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx,1,['wrap'],['wrapper']
Integrability,"// Install a new wrapper around 'delete'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx:17,wrap,wrapper,17,core/meta/src/TGenericClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx,1,['wrap'],['wrapper']
Integrability,"// Install a new wrapper around 'new []'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx:17,wrap,wrapper,17,core/meta/src/TGenericClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx,1,['wrap'],['wrapper']
Integrability,"// Install a new wrapper around 'new'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx:17,wrap,wrapper,17,core/meta/src/TGenericClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx,1,['wrap'],['wrapper']
Integrability,"// Install a new wrapper around SetDirectoryAutoAdd.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx:17,wrap,wrapper,17,core/meta/src/TGenericClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx,1,['wrap'],['wrapper']
Integrability,"// Install a new wrapper around the Merge function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx:17,wrap,wrapper,17,core/meta/src/TGenericClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx,2,['wrap'],['wrapper']
Integrability,"// Install a new wrapper around the destructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx:17,wrap,wrapper,17,core/meta/src/TGenericClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx,1,['wrap'],['wrapper']
Integrability,"// Install argument in static data member to be accessed below through static CINT interface functions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx:83,interface,interface,83,roofit/roofitcore/src/RooFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx,1,['interface'],['interface']
Integrability,"// Install interrupt and message input handlers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx:25,message,message,25,net/net/src/TApplicationServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx,4,['message'],['message']
Integrability,// Install the declarator into the interface decl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:35,interface,interface,35,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['interface'],['interface']
Integrability,// Install the property declarator into interfaceDecl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:40,interface,interfaceDecl,40,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['interface'],['interfaceDecl']
Integrability,// Instance message: transform the receiver,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:12,message,message,12,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['message'],['message']
Integrability,"// Instantiate integrator for convolution integrand",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvolution.cxx:15,integrat,integrator,15,roofit/roofitcore/src/RooNumConvolution.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvolution.cxx,1,['integrat'],['integrator']
Integrability,"// Instruction Parsing. Each instruction parsing routine can return with a; // normal result, an error result, or return having eaten an extra comma.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h:49,rout,routine,49,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,1,['rout'],['routine']
Integrability,"// Instruction itineraries would set this field to the SchedClass ID.; // Otherwise, it defaults to the WriteResourceID from the MCWriteLatencyEntry; // element associated to this write.; // When computing read latencies, this value is matched against the; // ""ReadAdvance"" information. The hardware backend may implement; // dedicated forwarding paths to quickly propagate write results to dependent; // instructions waiting in the reservation station (effectively bypassing the; // write-back stage).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:391,depend,dependent,391,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,1,['depend'],['dependent']
Integrability,// Instruction selection routines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:25,rout,routines,25,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,2,['rout'],['routines']
Integrability,// Instruction supports Fast math; // contraction operations like fma.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:38,contract,contraction,38,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['contract'],['contraction']
Integrability,// Instruction supports binary operator; // no signed wrap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:54,wrap,wrap,54,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['wrap'],['wrap']
Integrability,// Instruction supports binary operator; // no unsigned wrap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:56,wrap,wrap,56,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['wrap'],['wrap']
Integrability,// Instructions could not be issued because of memory dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h:54,depend,dependencies,54,interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h,1,['depend'],['dependencies']
Integrability,// Instructions could not be issued because of register data dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h:61,depend,dependencies,61,interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h,1,['depend'],['dependencies']
Integrability,"// Instructions dispatched to the Scheduler are internally classified based on; // the instruction stage (see Instruction::InstrStage).; //; // An Instruction dispatched to the Scheduler is added to the WaitSet if not; // all its register operands are available, and at least one latency is; // unknown. By construction, the WaitSet only contains instructions that are; // in the IS_DISPATCHED stage.; //; // An Instruction transitions from the WaitSet to the PendingSet if the; // instruction is not ready yet, but the latency of every register read is; // known. Instructions in the PendingSet can only be in the IS_PENDING or; // IS_READY stage. Only IS_READY instructions that are waiting on memory; // dependencies can be added to the PendingSet.; //; // Instructions in the PendingSet are immediately dominated only by; // instructions that have already been issued to the underlying pipelines. In; // the presence of bottlenecks caused by data dependencies, the PendingSet can; // be inspected to identify problematic data dependencies between; // instructions.; //; // An instruction is moved to the ReadySet when all register operands become; // available, and all memory dependencies are met. Instructions that are; // moved from the PendingSet to the ReadySet must transition to the 'IS_READY'; // stage.; //; // On every cycle, the Scheduler checks if it can promote instructions from the; // PendingSet to the ReadySet.; //; // An Instruction is moved from the ReadySet to the `IssuedSet` when it starts; // exection. This event also causes an instruction state transition (i.e. from; // state IS_READY, to state IS_EXECUTING). An Instruction leaves the IssuedSet; // only when it reaches the write-back stage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:707,depend,dependencies,707,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,4,['depend'],['dependencies']
Integrability,"// Instructions in the original inner loop preheader may depend on values; // defined in the outer loop header. Move them there, because the original; // inner loop preheader will become the entry into the interchanged loop nest.; // Currently we move all instructions and rely on LICM to move invariant; // instructions outside the loop nest.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:57,depend,depend,57,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,1,['depend'],['depend']
Integrability,"// Instructions that are not allowed in a hard clause: SALU, export, branch,; // message, GDS, s_waitcnt and anything else not mentioned above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertHardClauses.cpp:81,message,message,81,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertHardClauses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertHardClauses.cpp,1,['message'],['message']
Integrability,"// Instructions that are pure loads, not loads and stores like memops are not; // dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:82,depend,dependent,82,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,1,['depend'],['dependent']
Integrability,// Instructions that feed a Phi have a distance of 1. Computing larger; // values for arrays requires data dependence information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:107,depend,dependence,107,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,1,['depend'],['dependence']
Integrability,// Instructions that have been issued during this cycle might have unblocked; // other dependent instructions. Dependent instructions may be issued during; // this same cycle if operands have ReadAdvance entries. Promote those; // instructions to the ReadySet and notify the caller that those are ready.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/Scheduler.cpp:87,depend,dependent,87,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/Scheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/Scheduler.cpp,2,"['Depend', 'depend']","['Dependent', 'dependent']"
Integrability,// Instrument atomic memory accesses in any case (they can be used to; // implement synchronization).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:84,synchroniz,synchronization,84,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,1,['synchroniz'],['synchronization']
Integrability,"// Instrument pclmul intrinsics.; // These intrinsics operate either on odd or on even elements of the input; // vectors, depending on the constant in the 3rd argument, ignoring the rest.; // Replace the unused elements with copies of the used ones, ex:; // (0, 1, 2, 3) -> (0, 0, 2, 2) (even case); // or; // (0, 1, 2, 3) -> (1, 1, 3, 3) (odd case); // and then apply the usual shadow combining logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:122,depend,depending,122,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['depend'],['depending']
Integrability,"// Integer a%b operator assumes rounding towards zero by /, so it; // ""misbehaves"" when a crosses 0 (the remainder also changes sign).; // Add WrapAt in an attempt to keep I+Dist non-negative.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:143,Wrap,WrapAt,143,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['Wrap'],['WrapAt']
Integrability,"// Integer binary math/logic instructions have a third source operand:; // the EFLAGS register. That operand must be both defined here and never; // used; ie, it must be dead. If the EFLAGS operand is live, then we can; // not change anything because rearranging the operands could affect other; // instructions that depend on the exact status flags (zero, sign, etc.); // that are set by using these particular operands with this operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:317,depend,depend,317,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['depend'],['depend']
Integrability,"// Integer to floating-point conversions.; // i64 conversions are done via library routines even when generating VFP; // instructions, so use the same ones.; // FIXME: There appears to be some naming inconsistency in ARM libgcc:; // e.g., __floatunsidf vs. __floatunssidfvfp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:83,rout,routines,83,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['rout'],['routines']
Integrability,// Integer wrapper that also holds information whether the user declared; // the integer to be long (by appending L to the end of the integer) or not.; // It allows to be implicitly cast from and to uint32_t in order; // to be compatible with the parts of code that don't care about the integers; // being marked long.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptStmt.h:11,wrap,wrapper,11,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptStmt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptStmt.h,1,['wrap'],['wrapper']
Integrability,"// Integrate function over this bin",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCurve.cxx:3,Integrat,Integrate,3,roofit/roofitcore/src/RooCurve.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCurve.cxx,1,['Integrat'],['Integrate']
Integrability,"// Integrate one of the basis functions. Takes a function that represents the; // indefinite integral, some parameters, and a flag that indicates whether the; // basis function is symmetric or antisymmetric. This information is used to; // evaluate the integrals for the ""Minus"" and ""Sum"" cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTruthModel.cxx:3,Integrat,Integrate,3,roofit/roofitcore/src/RooTruthModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTruthModel.cxx,1,['Integrat'],['Integrate']
Integrability,"// Integrate the third derivative of s(x)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:3,Integrat,Integrate,3,hist/hist/src/TSpline.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx,1,['Integrat'],['Integrate']
Integrability,"// Integrate with crash reporter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:3,Integrat,Integrate,3,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['Integrat'],['Integrate']
Integrability,"// Integrate with macOS crash reporter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TErrorDefaultHandler.cxx:3,Integrat,Integrate,3,core/base/src/TErrorDefaultHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TErrorDefaultHandler.cxx,1,['Integrat'],['Integrate']
Integrability,"// Integrating also over x, so both x and sigma should now be shape servers of the integral",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRealIntegral.cxx:3,Integrat,Integrating,3,roofit/roofitcore/test/testRooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRealIntegral.cxx,1,['Integrat'],['Integrating']
Integrability,"// Integration and derivation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx:3,Integrat,Integration,3,roofit/roofitcore/src/RooFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx,1,['Integrat'],['Integration']
Integrability,"// Integration over 'mixState'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooBMixDecay.cxx:3,Integrat,Integration,3,roofit/roofit/src/RooBMixDecay.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooBMixDecay.cxx,1,['Integrat'],['Integration']
Integrability,"// Integration over 'mixState' and 'tagFlav'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooBMixDecay.cxx:3,Integrat,Integration,3,roofit/roofit/src/RooBMixDecay.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooBMixDecay.cxx,1,['Integrat'],['Integration']
Integrability,"// Integration over 'rhoQ'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNonCPEigenDecay.cxx:3,Integrat,Integration,3,roofit/roofit/src/RooNonCPEigenDecay.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNonCPEigenDecay.cxx,1,['Integrat'],['Integration']
Integrability,"// Integration over 'tag'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooBCPEffDecay.cxx:3,Integrat,Integration,3,roofit/roofit/src/RooBCPEffDecay.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooBCPEffDecay.cxx,3,['Integrat'],['Integration']
Integrability,"// Integration over 'tag' and 'rhoQ'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNonCPEigenDecay.cxx:3,Integrat,Integration,3,roofit/roofit/src/RooNonCPEigenDecay.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNonCPEigenDecay.cxx,1,['Integrat'],['Integration']
Integrability,"// Integration over 'tagFlav'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooBMixDecay.cxx:3,Integrat,Integration,3,roofit/roofit/src/RooBMixDecay.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooBMixDecay.cxx,1,['Integrat'],['Integration']
Integrability,"// Interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/pythia8/inc/TPythia8.h:3,Interface,Interface,3,montecarlo/pythia8/inc/TPythia8.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/pythia8/inc/TPythia8.h,1,['Interface'],['Interface']
Integrability,"// Interface abstracting the model function and its related data (number of parameters, parameters, the model function; // itself...)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testGradient.cxx:3,Interface,Interface,3,math/mathcore/test/testGradient.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testGradient.cxx,1,['Interface'],['Interface']
Integrability,// Interface builder function for objects loaded from this archive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h:3,Interface,Interface,3,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h,1,['Interface'],['Interface']
Integrability,"// Interface class of Pythia8",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/pythia8/inc/TPythia8.h:3,Interface,Interface,3,montecarlo/pythia8/inc/TPythia8.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/pythia8/inc/TPythia8.h,1,['Interface'],['Interface']
Integrability,"// Interface conversion",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:3,Interface,Interface,3,tree/ntuple/v7/src/RNTupleMerger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx,1,['Interface'],['Interface']
Integrability,// Interface definitions; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:3,Interface,Interface,3,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,1,['Interface'],['Interface']
Integrability,"// Interface for Clermond-Ferrand artificial neural network",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodCFMlpANN.h:3,Interface,Interface,3,tmva/tmva/inc/TMVA/MethodCFMlpANN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodCFMlpANN.h,1,['Interface'],['Interface']
Integrability,"// Interface for Confidence Intervals",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/ConfInterval.h:3,Interface,Interface,3,roofit/roostats/inc/RooStats/ConfInterval.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/ConfInterval.h,1,['Interface'],['Interface']
Integrability,"// Interface for OpenGL manager",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TVirtualGL.h:3,Interface,Interface,3,core/base/inc/TVirtualGL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TVirtualGL.h,1,['Interface'],['Interface']
Integrability,"// Interface for OpenGL painter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TVirtualGL.h:3,Interface,Interface,3,core/base/inc/TVirtualGL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TVirtualGL.h,1,['Interface'],['Interface']
Integrability,"// Interface for PROOF monitoring",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TProofMonSender.h:3,Interface,Interface,3,proof/proofplayer/inc/TProofMonSender.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TProofMonSender.h,2,['Interface'],['Interface']
Integrability,"// Interface for TNeuron activation function classes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/TActivation.h:3,Interface,Interface,3,tmva/tmva/inc/TMVA/TActivation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/TActivation.h,1,['Interface'],['Interface']
Integrability,"// Interface for TNeuron input calculation classes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/TNeuronInput.h:3,Interface,Interface,3,tmva/tmva/inc/TMVA/TNeuronInput.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/TNeuronInput.h,1,['Interface'],['Interface']
Integrability,"// Interface for a TestStatistic",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/TestStatistic.h:3,Interface,Interface,3,roofit/roostats/inc/RooStats/TestStatistic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/TestStatistic.h,1,['Interface'],['Interface']
Integrability,"// Interface for printable objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooPrintable.h:3,Interface,Interface,3,roofit/roofitcore/inc/RooPrintable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooPrintable.h,1,['Interface'],['Interface']
Integrability,"// Interface for text-based TDirectory I/O",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h:3,Interface,Interface,3,io/io/inc/TFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h,1,['Interface'],['Interface']
Integrability,"// Interface for tools doing hypothesis tests",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestCalculator.h:3,Interface,Interface,3,roofit/roostats/inc/RooStats/HypoTestCalculator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestCalculator.h,1,['Interface'],['Interface']
Integrability,"// Interface for tools setting limits (producing confidence intervals)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/FeldmanCousins.h:3,Interface,Interface,3,roofit/roostats/inc/RooStats/FeldmanCousins.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/FeldmanCousins.h,3,['Interface'],['Interface']
Integrability,"// Interface function to indicate that this lvalue; // has a unit or constant jacobian terms with respect to; // the observable passed as argument. This default implementation; // always returns true (i.e. jacobian is constant)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsRealLValue.cxx:3,Interface,Interface,3,roofit/roofitcore/src/RooAbsRealLValue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsRealLValue.cxx,1,['Interface'],['Interface']
Integrability,"// Interface functions of this class map VOPD component operand indices; // to indices of operands in MachineInstr/MCInst or parsed operands array.; //; // Note that this class operates with 3 kinds of indices:; // - VOPD component operand indices (Component::DST, Component::SRC0, etc.);; // - MC operand indices (they refer operands in a MachineInstr/MCInst);; // - parsed operand indices (they refer operands in parsed operands array).; //; // For SINGLE components mapping between these indices is trivial.; // But things get more complicated for COMPONENT_X and; // COMPONENT_Y because these components share the same; // MachineInstr/MCInst and the same parsed operands array.; // Below is an example of component operand to parsed operand; // mapping for the following instruction:; //; // v_dual_add_f32 v255, v4, v5 :: v_dual_mov_b32 v6, v1; //; // PARSED COMPONENT PARSED; // COMPONENT OPERANDS OPERAND INDEX OPERAND INDEX; // -------------------------------------------------------------------; // ""v_dual_add_f32"" 0; // v_dual_add_f32 v255 0 (DST) --> 1; // v4 1 (SRC0) --> 2; // v5 2 (SRC1) --> 3; // ""::"" 4; // ""v_dual_mov_b32"" 5; // v_dual_mov_b32 v6 0 (DST) --> 6; // v1 1 (SRC0) --> 7; // -------------------------------------------------------------------; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h:3,Interface,Interface,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,1,['Interface'],['Interface']
Integrability,// Interface inherited from base classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h:3,Interface,Interface,3,interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,1,['Interface'],['Interface']
Integrability,// Interface member.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Interface,Interface,3,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['Interface'],['Interface']
Integrability,"// Interface methods to RooMCStudy objects,; // which are only functional after module has been attached to a RooMCStudy object; /// Refit model using original or specified data sample",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsMCStudyModule.h:3,Interface,Interface,3,roofit/roofitcore/inc/RooAbsMCStudyModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsMCStudyModule.h,1,['Interface'],['Interface']
Integrability,// Interface to CFGBlock - adding CFGElements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:3,Interface,Interface,3,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['Interface'],['Interface']
Integrability,// Interface to Intervals vector...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h:3,Interface,Interface,3,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,1,['Interface'],['Interface']
Integrability,"// Interface to basic system I/O routines",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h:3,Interface,Interface,3,io/io/inc/TFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h,4,"['Interface', 'rout']","['Interface', 'routines']"
Integrability,"// Interface to basic system I/O routines, suppressed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/sql/inc/TSQLFile.h:3,Interface,Interface,3,io/sql/inc/TSQLFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/sql/inc/TSQLFile.h,2,"['Interface', 'rout']","['Interface', 'routines']"
Integrability,"// Interface to cling function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:3,Interface,Interface,3,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['Interface'],['Interface']
Integrability,"// Interface to constant magnetic field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveTrackPropagator.h:3,Interface,Interface,3,graf3d/eve/inc/TEveTrackPropagator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveTrackPropagator.h,1,['Interface'],['Interface']
Integrability,"// Interface to data in a 2D array of Double_t",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGSimpleTableInterface.h:3,Interface,Interface,3,gui/gui/inc/TGSimpleTableInterface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGSimpleTableInterface.h,1,['Interface'],['Interface']
Integrability,"// Interface to data in a TTree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeTableInterface.h:3,Interface,Interface,3,tree/treeplayer/inc/TTreeTableInterface.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeTableInterface.h,1,['Interface'],['Interface']
Integrability,"// Interface to different separation criteria used in training algorithms",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/OptimizeConfigParameters.h:3,Interface,Interface,3,tmva/tmva/inc/TMVA/OptimizeConfigParameters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/OptimizeConfigParameters.h,4,['Interface'],['Interface']
Integrability,// Interface to eviction advisers,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:3,Interface,Interface,3,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,1,['Interface'],['Interface']
Integrability,"// Interface to force RooRealIntegral to offer given observable for internal integration; // even if this is deemed unsafe. This default implementation returns always false",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:3,Interface,Interface,3,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,2,"['Interface', 'integrat']","['Interface', 'integration']"
Integrability,"// Interface to magnetic field with two different values depending on radius.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveTrackPropagator.h:3,Interface,Interface,3,graf3d/eve/inc/TEveTrackPropagator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveTrackPropagator.h,2,"['Interface', 'depend']","['Interface', 'depending']"
Integrability,"// Interface to restore observables to saved values (if supported; // by binding implementation)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsFunc.h:3,Interface,Interface,3,roofit/roofitcore/inc/RooAbsFunc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsFunc.h,1,['Interface'],['Interface']
Integrability,"// Interface to retrieve constraint terms on this pdf. Default implementation returns null",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsPdf.h:3,Interface,Interface,3,roofit/roofitcore/inc/RooAbsPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsPdf.h,1,['Interface'],['Interface']
Integrability,"// Interface to save current values of observables (if supported by binding implementation)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsFunc.h:3,Interface,Interface,3,roofit/roofitcore/inc/RooAbsFunc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsFunc.h,1,['Interface'],['Interface']
Integrability,"// Interface to the Condor System",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TCondor.h:3,Interface,Interface,3,proof/proof/inc/TCondor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TCondor.h,1,['Interface'],['Interface']
Integrability,"// Interface to the data source",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGTable.h:3,Interface,Interface,3,gui/gui/inc/TGTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGTable.h,1,['Interface'],['Interface']
Integrability,"// Interface used by all the others for the minimization using the base MinimumBuilder class; // According to the contained type of MinimumBuilder the right type will be used",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/ModularFunctionMinimizer.cxx:3,Interface,Interface,3,math/minuit2/src/ModularFunctionMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/ModularFunctionMinimizer.cxx,1,['Interface'],['Interface']
Integrability,"// Interface versioning",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProxyGenerator.cxx:3,Interface,Interface,3,tree/treeplayer/src/TTreeProxyGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProxyGenerator.cxx,1,['Interface'],['Interface']
Integrability,"// Interface-like types cannot have a user declared constructor, destructor,; // friends, VBases, conversion functions, or fields. Additionally, lambdas; // cannot be interface types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:3,Interface,Interface-like,3,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,2,"['Interface', 'interface']","['Interface-like', 'interface']"
Integrability,"// Interface. <something> is parsed as a property reference expression.; // Just return ""unknown"" as a fall-through for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Interface,Interface,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Interface'],['Interface']
Integrability,// Interfaces implemented by this pass,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassInfo.h:3,Interface,Interfaces,3,interpreter/llvm-project/llvm/include/llvm/PassInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassInfo.h,1,['Interface'],['Interfaces']
Integrability,"// Interfaces of sparse n-dimensional histogram",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/THnSparse.h:3,Interface,Interfaces,3,hist/hist/inc/THnSparse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/THnSparse.h,1,['Interface'],['Interfaces']
Integrability,// Interfaces to query PSTATE.SM,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64SMEAttributes.h:3,Interface,Interfaces,3,interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64SMEAttributes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64SMEAttributes.h,1,['Interface'],['Interfaces']
Integrability,// Interfaces to query PSTATE.ZA,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64SMEAttributes.h:3,Interface,Interfaces,3,interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64SMEAttributes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64SMEAttributes.h,1,['Interface'],['Interfaces']
Integrability,// Interfaces to query ZT0 State,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64SMEAttributes.h:3,Interface,Interfaces,3,interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64SMEAttributes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64SMEAttributes.h,1,['Interface'],['Interfaces']
Integrability,// Interfaces to the major aspects of target machine information:; //; // -- Instruction opcode and operand information; // -- Pipelines and scheduling information; // -- Stack frame information; // -- Selection DAG lowering information; // -- Call lowering information; //; // N.B. These objects may change during compilation. It's not safe to cache; // them between functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:3,Interface,Interfaces,3,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,1,['Interface'],['Interfaces']
Integrability,// Internal Instruction wrapper that contains more information about the; // Instruction from prior analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:24,wrap,wrapper,24,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,1,['wrap'],['wrapper']
Integrability,"// Internal class used to manage the socket that may stay open between; // calls when HTTP/1.1 protocol is used",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx:95,protocol,protocol,95,net/net/src/TWebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx,1,['protocol'],['protocol']
Integrability,"// Internal class wrapping an histogram and managing its content.; // conveninet for dealing with histogram pointers in the; // HistFactory class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/inc/RooStats/HistFactory/HistRef.h:18,wrap,wrapping,18,roofit/histfactory/inc/RooStats/HistFactory/HistRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/inc/RooStats/HistFactory/HistRef.h,1,['wrap'],['wrapping']
Integrability,"// Internal function to get the normalization set for the integrated; // function. By default, we will take the normalization set from the function; // proxy, but _funcNormSet will be used if it is set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooRealIntegral.h:58,integrat,integrated,58,roofit/roofitcore/inc/RooRealIntegral.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooRealIntegral.h,1,['integrat'],['integrated']
Integrability,// Internal interface for testing purpose only.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfWriter.h:12,interface,interface,12,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfWriter.h,2,['interface'],['interface']
Integrability,"// Internal routine, no explicit lock needed here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClassTable.cxx:12,rout,routine,12,core/cont/src/TClassTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClassTable.cxx,1,['rout'],['routine']
Integrability,"// Internal routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClassTable.cxx:12,rout,routine,12,core/cont/src/TClassTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClassTable.cxx,1,['rout'],['routine']
Integrability,"// Internal toy generation. Since our _func is not a PDF (if it is, it doesn't make sense to use this wrapper),; // we cannot do anything.; /// Get specialised generator. Since the underlying function is not a PDF, this will always return zero.; // Int_t getGenerator(const RooArgSet& /*directVars*/, RooArgSet& /*generateVars*/,; // bool /*staticInitOK = true*/) const override { return 0; }; // void initGenerator(Int_t /*code*/) override { }; // void generateEvent(Int_t /*code*/) override { }; // bool isDirectGenSafe(const RooAbsArg& /*arg*/) const override { return false; }; // Hints for optimized brute-force sampling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooWrapperPdf.h:102,wrap,wrapper,102,roofit/roofitcore/inc/RooWrapperPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooWrapperPdf.h,1,['wrap'],['wrapper']
Integrability,"// Internalize non-exact functions; // TODO: for now we eagerly internalize functions without calculating the; // cost, we need a cost interface to determine whether internalizing; // a function is ""beneficial""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:135,interface,interface,135,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['interface'],['interface']
Integrability,"// Interrupt handlers don't save off the VFP regs automatically on ARM,; // so there's some risk when calling out to non-interrupt handler functions; // that the callee might not preserve them. This is easy to diagnose here,; // but can be very challenging to debug.; // Likewise, X86 interrupt handlers may only call routines with attribute; // no_caller_saved_registers since there is no efficient way to; // save and restore the non-GPR state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:318,rout,routines,318,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['rout'],['routines']
Integrability,// Interrupt service routines use different return instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp:21,rout,routines,21,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelLowering.cpp,2,['rout'],['routines']
Integrability,"// IntervalMap requires the value object to be very small, to the extent; // that we do not have enough room for an std::vector. Using a C-style array; // (with a unique_ptr wrapper for convenience) allows us to optimize for this; // specific case by packing the array size into only 6 bits (it is highly; // unlikely that any debug value will need 64+ locations).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:174,wrap,wrapper,174,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,1,['wrap'],['wrapper']
Integrability,"// Intrinsics are very delicate. Lowering sometimes depends the presence; // of certain attributes for correctness, but we may have also inferred; // additional ones in the abstract machine model which need stripped. This; // assumes that the attributes defined in Intrinsic.td are conservatively; // correct for both physical and abstract model.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:52,depend,depends,52,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['depend'],['depends']
Integrability,// Intrinsics or other instructions do not get funclet information from the; // front-end. Need to use the BlockColors that was computed by the routine; // colorEHFunclets to determine whether a funclet is needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:144,rout,routine,144,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,1,['rout'],['routine']
Integrability,"// Intrinsics, like any other synchronizing function, can make effects; // of other threads visible. Without nosync we know nothing really.; // Similarly, if `nocallback` is missing the function, or intrinsic,; // can call into the module arbitrarily. If both are set the function; // has an effect but will not interact with accesses of internal; // globals inside the module. We are conservative here for optnone; // functions, might not be necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:30,synchroniz,synchronizing,30,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,1,['synchroniz'],['synchronizing']
Integrability,"// Introduce the early-exit compare IV <= BTC to form header block mask.; // This is used instead of IV < TC because TC may wrap, unlike BTC. Start by; // constructing the desired canonical IV in the header block as its first; // non-phi instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:124,wrap,wrap,124,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['wrap'],['wrap']
Integrability,"// Invalid array specification.; // FIXME: We need an error message here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:60,message,message,60,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['message'],['message']
Integrability,// Invalidate the ScalarEvolution object whenever it isn't preserved or one; // of its dependencies is invalidated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:87,depend,dependencies,87,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['depend'],['dependencies']
Integrability,"// Inverse - This class is used as a little marker class to tell the graph; // iterator to iterate over the graph in a graph defined ""Inverse"" ordering.; // Not all graphs define an inverse ordering, and if they do, it depends on; // the graph exactly what that is. Here's an example of usage with the; // df_iterator:; //; // idf_iterator<Method*> I = idf_begin(M), E = idf_end(M);; // for (; I != E; ++I) { ... }; //; // Which is equivalent to:; // df_iterator<Inverse<Method*>> I = idf_begin(M), E = idf_end(M);; // for (; I != E; ++I) { ... }; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GraphTraits.h:219,depend,depends,219,interpreter/llvm-project/llvm/include/llvm/ADT/GraphTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GraphTraits.h,1,['depend'],['depends']
Integrability,// Invoke function wrapper in JavaScript,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:19,wrap,wrapper,19,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,1,['wrap'],['wrapper']
Integrability,"// Invoke through interpreter to avoid REve dependece on RGL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveText.cxx:44,depend,dependece,44,graf3d/eve7/src/REveText.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveText.cxx,1,['depend'],['dependece']
Integrability,// Invoke wrapped action's method.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp:10,wrap,wrapped,10,interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp,1,['wrap'],['wrapped']
Integrability,"// Is I an add or a sub, which isn't marked as nuw, but where a wrapping; // result won't affect the computation?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:64,wrap,wrapping,64,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,1,['wrap'],['wrapping']
Integrability,"// Is V an instruction thats result can trivially promoted, or has safe; // wrapping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:76,wrap,wrapping,76,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,1,['wrap'],['wrapping']
Integrability,// Is it a node without dependencies?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:24,depend,dependencies,24,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,1,['depend'],['dependencies']
Integrability,// Is it possible for RE to be a CXXBindTemporaryExpr wrapping; // a MemberCallExpr?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:54,wrap,wrapping,54,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,1,['wrap'],['wrapping']
Integrability,// Is the node an FMUL and contractable either due to global flags or; // SDNodeFlags.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:27,contract,contractable,27,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['contract'],['contractable']
Integrability,// Is this a C++20 module interface or a partition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h:26,interface,interface,26,interpreter/llvm-project/clang/include/clang/Basic/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h,1,['interface'],['interface']
Integrability,// Is this a virtual file (injected)?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h:27,inject,injected,27,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h,1,['inject'],['injected']
Integrability,"// Is this l-value object safe for use as integration observable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCategory.h:42,integrat,integration,42,roofit/roofitcore/inc/RooAbsCategory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCategory.h,1,['integrat'],['integration']
Integrability,"// Is value in range (dummy interface always returns true)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsArg.h:28,interface,interface,28,roofit/roofitcore/inc/RooAbsArg.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsArg.h,1,['interface'],['interface']
Integrability,"// Issue a diagnostic about a missing @-sign when implicit casting a cstring; // to 'NSString *', instead of falling through to report a ""bridge cast""; // diagnostic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:138,bridg,bridge,138,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['bridg'],['bridge']
Integrability,// Issue a message saying that the method was skipped.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:11,message,message,11,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,1,['message'],['message']
Integrability,"// Issue a message to select an Element",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSElementDlg.cxx:11,message,message,11,test/periodic/XSElementDlg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSElementDlg.cxx,1,['message'],['message']
Integrability,"// Issue a warning if property is 'assign' as default and its; // object, which is gc'able conforms to NSCopying protocol",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:113,protocol,protocol,113,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['protocol'],['protocol']
Integrability,"// Issue info message that we are about to do some rearranging",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimultaneous.cxx:14,message,message,14,roofit/roofitcore/src/RooSimultaneous.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimultaneous.cxx,1,['message'],['message']
Integrability,// It can be actually class methods called with Class object as a; // receiver. This type of messages is treated by the compiler as; // instance (not class).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:93,message,messages,93,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,1,['message'],['messages']
Integrability,"// It is an error to provide a -o option if we are making multiple output; // files. There are exceptions:; //; // IfsMergeJob: when generating interface stubs enabled we want to be able to; // generate the stub file at the same time that we generate the real; // library/a.out. So when a .o, .so, etc are the output, with clang interface; // stubs there will also be a .ifs and .ifso at the same location.; //; // CompileJob of type TY_IFS_CPP: when generating interface stubs is enabled; // and -c is passed, we still want to be able to generate a .ifs file while; // we are also generating .o files. So we allow more than one output file in; // this case as well.; //; // OffloadClass of type TY_Nothing: device-only output will place many outputs; // into a single offloading action. We should count all inputs to the action; // as outputs. Also ignore device-only outputs if we're compiling with; // -fsyntax-only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:144,interface,interface,144,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,3,['interface'],['interface']
Integrability,// It is beneficial to create MSKOR here instead of combiner to avoid; // artificial dependencies introduced by RMW,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp:85,depend,dependencies,85,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,1,['depend'],['dependencies']
Integrability,"// It is expected that the address of global optimized variable is on; // top of the stack. After optimization, value of that variable will; // be ether 0 for initial value or 1 for other value. The following; // expression should return constant integer value depending on the; // value at global object address:; // val * (ValOther - ValInit) + ValInit:; // DW_OP_deref DW_OP_constu <ValMinus>; // DW_OP_mul DW_OP_constu <ValInit> DW_OP_plus DW_OP_stack_value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:261,depend,depending,261,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['depend'],['depending']
Integrability,// It is illegal to typedef parameterized types inside an interface. Therefore; // an Objective-C type can only be dependent on a type parameter when the type; // parameter structurally present in the type itself.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:58,interface,interface,58,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,2,"['depend', 'interface']","['dependent', 'interface']"
Integrability,// It is invalid to disable an extension that there are other enabled; // extensions depend on it.; // TODO: Make use of RISCVISAInfo to handle this,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:85,depend,depend,85,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,1,['depend'],['depend']
Integrability,// It is not safe to move I1 and I2 into one combine if I2 has a true; // dependence on I1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:74,depend,dependence,74,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,1,['depend'],['dependence']
Integrability,"// It is possible that the default destination is the destination of; // some cases. We cannot perform difference for those cases.; // We know Condition != CaseValue in BBTo. In some cases we can use; // this to infer Val == f(Condition) is != f(CaseValue). For now, we; // only do this when f is identity (i.e. Val == Condition), but we; // should be able to do this for any injective f.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:376,inject,injective,376,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['inject'],['injective']
Integrability,"// It is unclear whether this is the correct cast if the type; // is dependent. Hence, For now, we do not expect SynthesizeCheck to; // be run on a function template. It should be run only on function; // instances.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/NullDerefProtectionTransformer.cpp:69,depend,dependent,69,interpreter/cling/lib/Interpreter/NullDerefProtectionTransformer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/NullDerefProtectionTransformer.cpp,1,['depend'],['dependent']
Integrability,"// It is unclear whether this is the correct cast if the type; // is dependent. Hence, For now, we do not expect SynthesizeCheck to; // be run on a function template. It should be run only on function; // instances.; // When this is actually insert in a function template, it seems that; // clang r272382 when instantiating the templates drops one of the part; // of the implicit cast chain.; // Namely in:; /*; `-ImplicitCastExpr 0x1010cea90 <col:4> 'const void *' <BitCast>; `-ImplicitCastExpr 0x1026e0bc0 <col:4> 'const class TAttMarker *'; <UncheckedDerivedToBase (TAttMarker)>; `-ImplicitCastExpr 0x1026e0b48 <col:4> 'class TGraph *' <LValueToRValue>; `-DeclRefExpr 0x1026e0b20 <col:4> 'class TGraph *' lvalue Var 0x1026e09c0; 'g5' 'class TGraph *'; */; // It drops the 2nd lines (ImplicitCastExpr UncheckedDerivedToBase); // clang r227800 seems to actually keep that lines during instantiation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/NullDerefProtectionTransformer.cpp:69,depend,dependent,69,interpreter/cling/lib/Interpreter/NullDerefProtectionTransformer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/NullDerefProtectionTransformer.cpp,1,['depend'],['dependent']
Integrability,// It is unsafe to contract this fsub into the PH multiply.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:19,contract,contract,19,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,2,['contract'],['contract']
Integrability,// It is useful to generate the make-format dependency output during; // the scanning for P1689. Otherwise the users need to scan again for; // it. We will generate the make-format dependency output if we find; // `-MF` in the command lines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:44,depend,dependency,44,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,2,['depend'],['dependency']
Integrability,"// It is very unlikely that a MIG callback will be called from anywhere; // within the project under analysis and the caller isn't itself a routine; // that follows the MIG calling convention. Therefore we're safe to believe; // that it's always the top frame that is of interest. There's a slight chance; // that the user would want to enforce the MIG calling convention upon; // a random routine in the middle of nowhere, but given that the convention is; // fairly weird and hard to follow in the first place, there's relatively; // little motivation to spread it this way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:140,rout,routine,140,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,2,['rout'],['routine']
Integrability,"// It may be necessary to drop nowrap flags on the incrementing instruction; // if either LFTR moves from a pre-inc check to a post-inc check (in which; // case the increment might have previously been poison on the last iteration; // only) or if LFTR switches to a different IV that was previously dynamically; // dead (and as such may be arbitrarily poison). We remove any nowrap flags; // that SCEV didn't infer for the post-inc addrec (even if we use a pre-inc; // check), because the pre-inc addrec flags may be adopted from the original; // instruction, while SCEV has to explicitly prove the post-inc nowrap flags.; // TODO: This handling is inaccurate for one case: If we switch to a; // dynamically dead IV that wraps on the first loop iteration only, which is; // not covered by the post-inc addrec. (If the new IV was not dynamically; // dead, it could not be poison on the first iteration in the first place.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:721,wrap,wraps,721,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['wrap'],['wraps']
Integrability,"// It may depend on tbb",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/test/TClingTests.cxx:10,depend,depend,10,core/metacling/test/TClingTests.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/test/TClingTests.cxx,1,['depend'],['depend']
Integrability,"// It may not be immediately possible to identify the MachineInstr that; // defines a VReg, it can depend for example on the order blocks are; // emitted in. When this happens, or when further analysis is needed later,; // produce an instruction like this:; //; // DBG_INSTR_REF !123, !456, %0:gr64; //; // i.e., point the instruction at the vreg, and patch it up later in; // MachineFunction::finalizeDebugInstrRefs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp:99,depend,depend,99,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp,1,['depend'],['depend']
Integrability,"// It would be better to use a std::uniform_int_distribution,; // but that would be stdlib dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:91,depend,dependent,91,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['depend'],['dependent']
Integrability,"// It wraps, so move up and reset WritePos:; //MoveUp();; //++WritePos.Line;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TerminalDisplayWin.cpp:6,wrap,wraps,6,core/textinput/src/textinput/TerminalDisplayWin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TerminalDisplayWin.cpp,1,['wrap'],['wraps']
Integrability,"// It's OK if we couldn't merge types if either type is dependent, for a; // block-scope variable. In other cases (static data members of class; // templates, variable templates, ...), we require the types to be; // equivalent.; // FIXME: The C++ standard doesn't say anything about this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:56,depend,dependent,56,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,// It's OK to compile a module interface as a normal translation unit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:31,interface,interface,31,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,1,['interface'],['interface']
Integrability,// It's a bit hacky: At this point we've raised an error but we want the; // rest of the compiler to continue somehow working. However almost; // everything we'll try to do with the class will depend on there being a; // destructor. So let's pretend the first one is selected and hope for the; // best.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:193,depend,depend,193,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['depend']
Integrability,"// It's a bit weird that aliased and unaliased arg share one index, but; // the index is mostly use as a memory optimization in render().; // Due to this, ArgList::getArgString(A->getIndex()) will return the spelling; // of the aliased arg always, while A->getSpelling() returns either the; // unaliased or the aliased arg, depending on which Arg object it's called on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Option/Option.cpp:324,depend,depending,324,interpreter/llvm-project/llvm/lib/Option/Option.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Option/Option.cpp,1,['depend'],['depending']
Integrability,"// It's ok if the branch is the integration variable itself",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:32,integrat,integration,32,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['integrat'],['integration']
Integrability,// It's okay for the result type to still be a forward declaration; // if we're checking an interface declaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:92,interface,interface,92,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['interface'],['interface']
Integrability,// It's okay to delete DependentStoredDeclsMaps via a StoredDeclsMap; // pointer because the subclass doesn't add anything that needs to; // be deleted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:23,Depend,DependentStoredDeclsMaps,23,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,1,['Depend'],['DependentStoredDeclsMaps']
Integrability,"// It's possible that the new minimum/maximum value will fall into the initial; // range (due to wrap around). This means that the expression can take any; // value in this bitwidth, and we have to return full range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:97,wrap,wrap,97,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,"// It's undefined behavior if this wraps around, so mark it that way.; // FIXME: Teach -fsanitize=undefined to trap this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:35,wrap,wraps,35,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['wrap'],['wraps']
Integrability,"// It's unsafe to duplicate convergent instructions in this context, so set; // BBI.CannotBeCopied to true if MI is convergent. To see why, consider the; // following CFG, which is subject to our ""simple"" transformation.; //; // BB0 // if (c1) goto BB1; else goto BB2;; // / \; // BB1 |; // | BB2 // if (c2) goto TBB; else goto FBB;; // | / |; // | / |; // TBB |; // | |; // | FBB; // |; // exit; //; // Suppose we want to move TBB's contents up into BB1 and BB2 (in BB1 they'd; // be unconditional, and in BB2, they'd be predicated upon c2), and suppose; // TBB contains a convergent instruction. This is safe iff doing so does; // not add a control-flow dependency to the convergent instruction -- i.e.,; // it's safe iff the set of control flows that leads us to the convergent; // instruction does not get smaller after the transformation.; //; // Originally we executed TBB if c1 || c2. After the transformation, there; // are two copies of TBB's instructions. We get to the first if c1, and we; // get to the second if !c1 && c2.; //; // There are clearly fewer ways to satisfy the condition ""c1"" than; // ""c1 || c2"". Since we've shrunk the set of control flows which lead to; // our convergent instruction, the transformation is unsafe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:656,depend,dependency,656,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,1,['depend'],['dependency']
Integrability,"// Itanium C++ ABI:; // If the operand of a sizeof or alignof operator is not; // instantiation-dependent it is encoded as an integer literal; // reflecting the result of the operator.; //; // If the result of the operator is implicitly converted to a known; // integer type, that type is used for the literal; otherwise, the type; // of std::size_t or std::ptrdiff_t is used.; //; // FIXME: We still include the operand in the profile in this case. This; // can lead to mangling collisions between function templates that we; // consider to be different.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:96,depend,dependent,96,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['depend'],['dependent']
Integrability,"// Iterate over IV uses (including transitive ones) looking for IV increments; // of the form 'add nsw %iv, <const>'. For each increment and each use of; // the increment calculate control-dependent range information basing on; // dominating conditions inside of the loop (e.g. a range check inside of the; // loop). Calculated ranges are stored in PostIncRangeInfos map.; //; // Control-dependent range information is later used to prove that a narrow; // definition is not negative (see pushNarrowIVUsers). It's difficult to do; // this on demand because when pushNarrowIVUsers needs this information some; // of the dominating conditions might be already widened.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:189,depend,dependent,189,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,2,['depend'],['dependent']
Integrability,// Iterate over each instruction that has been scheduled already. The start; // slot computation depends on whether the previously scheduled instruction; // is a predecessor or successor of the specified instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:97,depend,depends,97,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['depends']
Integrability,// Iterate through inline frameworks/libraries from interface file and find; // match based on install name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readtapi/DiffEngine.cpp:52,interface,interface,52,interpreter/llvm-project/llvm/tools/llvm-readtapi/DiffEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readtapi/DiffEngine.cpp,1,['interface'],['interface']
Integrability,"// Iterator interface; // TODO: Document that the iterator always iterates following the physical memory layout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RTensor.hxx:12,interface,interface,12,tmva/tmva/inc/TMVA/RTensor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RTensor.hxx,1,['interface'],['interface']
Integrability,"// Iterator wrapper",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerFile.cxx:12,wrap,wrapper,12,proof/proofplayer/src/TPacketizerFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerFile.cxx,1,['wrap'],['wrapper']
Integrability,"// Ivar's can only appear in interfaces, implementations (via synthesized; // properties), and class extensions (via direct declaration, or synthesized; // properties).; //; // FIXME: This should really be asserting this:; // (isa<ObjCCategoryDecl>(DC) &&; // cast<ObjCCategoryDecl>(DC)->IsClassExtension())); // but unfortunately we sometimes place ivars into non-class extension; // categories on error. This breaks an AST invariant, and should not be; // fixed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:29,interface,interfaces,29,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,1,['interface'],['interfaces']
Integrability,// Ivy Bridge EP,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp:7,Bridg,Bridge,7,interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,1,['Bridg'],['Bridge']
Integrability,// Ivy Bridge microarchitecture based processors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/X86TargetParser.cpp:7,Bridg,Bridge,7,interpreter/llvm-project/llvm/lib/TargetParser/X86TargetParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/X86TargetParser.cpp,1,['Bridg'],['Bridge']
Integrability,// JITLink debug support plugins put information about JITed code in this GDB; // JIT Interface global from OrcTargetProcess.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:86,Interface,Interface,86,interpreter/llvm-project/llvm/tools/lli/lli.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp,2,['Interface'],['Interface']
Integrability,"// JSONNode interface implementation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/jsoninterface/src/RYMLParser.cxx:12,interface,interface,12,roofit/jsoninterface/src/RYMLParser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/jsoninterface/src/RYMLParser.cxx,1,['interface'],['interface']
Integrability,"// JSONTree interface implementation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/jsoninterface/src/RYMLParser.cxx:12,interface,interface,12,roofit/jsoninterface/src/RYMLParser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/jsoninterface/src/RYMLParser.cxx,1,['interface'],['interface']
Integrability,// Jobs and Actions look very different depending on whether the Clang tool; // injected -fsyntax-only or not. Try to handle both cases here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:40,depend,depending,40,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,2,"['depend', 'inject']","['depending', 'injected']"
Integrability,// Just a boring constructor to allow us to initialize the sizes. Always use; // the `create` routine above.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:94,rout,routine,94,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['rout'],['routine']
Integrability,// Just return null for empty protocol lists,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:30,protocol,protocol,30,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,2,['protocol'],['protocol']
Integrability,"// Just send the message one level up",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:17,message,message,17,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['message'],['message']
Integrability,// Just wraps a StringLiteral child.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:8,wrap,wraps,8,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,1,['wrap'],['wraps']
Integrability,"// KNL does not recognize dependency-breaking idioms for mask registers,; // so kxnor %k1, %k1, %k2 has a RAW dependence on %k1.; // Using %k0 as the undef input register is a performance heuristic based; // on the assumption that %k0 is used less frequently than the other mask; // registers, since it is not usable as a write mask.; // FIXME: A more advanced approach would be to choose the best input mask; // register based on context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:26,depend,dependency-breaking,26,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,2,['depend'],"['dependence', 'dependency-breaking']"
Integrability,// Keep containers that hold InterfaceFileRefs in sorted order and uniqued.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h:29,Interface,InterfaceFileRefs,29,interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h,1,['Interface'],['InterfaceFileRefs']
Integrability,"// Keep the PathDiagnostic with the shorter path.; // Note, the enclosing routine is called in deterministic order, so the; // results will be consistent between runs (no reason to break ties if the; // size is the same).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp:74,rout,routine,74,interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp,1,['rout'],['routine']
Integrability,"// Keep the removed qualifiers in sync with; // CreateQualifiedType(const FunctionPrototype*, DIFile *Unit); // On a 'real' member function type, these qualifiers are carried on the type; // of the first parameter, not as separate DW_TAG_const_type (etc) decorator; // tags around them. (But, in the raw function types with qualifiers, they have; // to use wrapper types.); // Add ""this"" pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:357,wrap,wrapper,357,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['wrap'],['wrapper']
Integrability,"// Keep these ""kind"" numbers in sync with the %select statements in the; // various diagnostics emitted by this routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:112,rout,routine,112,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['rout'],['routine']
Integrability,"// Keep track if the method overrides any method in the class's base classes,; // its protocols, or its categories' protocols; we will keep that info; // in the ObjCMethodDecl.; // For this info, a method in an implementation is not considered as; // overriding the same method in the interface or its categories.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:86,protocol,protocols,86,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,3,"['interface', 'protocol']","['interface', 'protocols']"
Integrability,// Keep track of all interface declarations seen.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:21,interface,interface,21,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['interface'],['interface']
Integrability,"// Keep track of physreg data dependencies by recording each live register unit.; // Associate each regunit with an instruction operand. Depending on the; // direction instructions are scanned, it could be the operand that defined the; // regunit, or the highest operand to read the regunit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:30,depend,dependencies,30,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,2,"['Depend', 'depend']","['Depending', 'dependencies']"
Integrability,"// Keeping the iterator straight is a pain, so we let the merge routine tell; // us what the next instruction is after it's done mucking about.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp:64,rout,routine,64,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,2,['rout'],['routine']
Integrability,"// Keeps track of the starting position of the location; // information (e.g., ""foo.c:10:4:"") that precedes the error; // message. We use this information to determine how long the; // file+line+column number prefix is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp:122,message,message,122,interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp,1,['message'],['message']
Integrability,"// Kirch's algorithm, from; //; // Optimizing Supercompilers for Supercomputers; // Michael Wolfe; // MIT Press, 1989; //; // Program 2.1, page 29.; // Computes the GCD of AM and BM.; // Also finds a solution to the equation ax - by = gcd(a, b).; // Returns true if dependence disproved; i.e., gcd does not divide Delta.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:266,depend,dependence,266,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// Known bits are automatically intersected across demanded elements of a; // vector. So for example, if a bit is computed as known zero, it must be; // zero across all demanded elements of the vector.; //; // For this bitcast, each demanded element of the output is sub-divided; // across a set of smaller vector elements in the source vector. To get; // the known bits for an entire element of the output, compute the known; // bits for each sub-element sequentially. This is done by shifting the; // one-set-bit demanded elements parameter across the sub-elements for; // consecutive calls to computeKnownBits. We are using the demanded; // elements parameter as a mask operator.; //; // The known bits of each sub-element are then inserted into place; // (dependent on endian) to form the full result of known bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:760,depend,dependent,760,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['depend'],['dependent']
Integrability,"// L and R might be equivalent, this could depend on not yet processed; // basic blocks, so we cannot decide here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:43,depend,depend,43,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,1,['depend'],['depend']
Integrability,"// LANDAU quantile : algorithm from CERNLIB G110 ranlan; // with scale parameter xi; // Converted by Rene Brun from CERNLIB routine ranlan(G110),; // Moved and adapted to QuantFuncMathCore by B. List 29.4.2010",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/QuantFuncMathCore.cxx:124,rout,routine,124,math/mathcore/src/QuantFuncMathCore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/QuantFuncMathCore.cxx,1,['rout'],['routine']
Integrability,// LASX depends on 64-bit FPU and LSX.; // -mno-lsx conflicts with -mlasx.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp:8,depend,depends,8,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp,1,['depend'],['depends']
Integrability,// LD has only 1 chain use so they are no indirect dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,depend,dependencies,51,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['depend'],['dependencies']
Integrability,"// LIKELIHOOD ROUTINE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TRolke.h:14,ROUT,ROUTINE,14,math/physics/inc/TRolke.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TRolke.h,1,['ROUT'],['ROUTINE']
Integrability,// LLVM Dependent Library Specifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:8,Depend,Dependent,8,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['Depend'],['Dependent']
Integrability,"// LLVM register Num, which has kind Kind. In some ways it might be; // easier for this class to have a register bank (general, floating-point; // or access) and a raw register number (0-15). This would postpone the; // interpretation of the operand to the add*() methods and avoid the need; // for context-dependent parsing. However, we do things the current way; // because of the virtual getReg() method, which needs to distinguish; // between (say) %r0 used as a single register and %r0 used as a pair.; // Context-dependent parsing can also give us slightly better error; // messages when invalid pairs like %r1 are used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:307,depend,dependent,307,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,3,"['depend', 'message']","['dependent', 'messages']"
Integrability,"// LM: fConditionalMLEsAlt must be nuisance parameters otherwise an error message will be printed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/FrequentistCalculator.cxx:74,message,message,74,roofit/roostats/src/FrequentistCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/FrequentistCalculator.cxx,1,['message'],['message']
Integrability,"// LM: fConditionalMLEsNull must be nuisance parameters otherwise an error message will be printed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/FrequentistCalculator.cxx:75,message,message,75,roofit/roostats/src/FrequentistCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/FrequentistCalculator.cxx,1,['message'],['message']
Integrability,"// LSE has a 128-bit compare and swap (CASP), but i128 is not a legal type,; // so lower it here, wrapped in REG_SEQUENCE and EXTRACT_SUBREG.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:98,wrap,wrapped,98,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['wrap'],['wrapped']
Integrability,// LSX depends on 64-bit FPU.; // -m*-float and -mfpu=none/0/32 conflict with -mlsx.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp:7,depend,depends,7,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp,1,['depend'],['depends']
Integrability,"// Lanai shifts of larger than register sizes are wrapped rather than; // clamped, so we can't just emit ""lo << b"" if b is too big.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:50,wrap,wrapped,50,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,1,['wrap'],['wrapped']
Integrability,// Last case is if the expression is value dependent then it must delay; // arguments unless the corresponding argument is able to hold the; // expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:43,depend,dependent,43,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['depend'],['dependent']
Integrability,"// Last message and entry before exceptions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:8,message,message,8,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['message'],['message']
Integrability,"// Last, and definitely not least, parse a protocol declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:43,protocol,protocol,43,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['protocol'],['protocol']
Integrability,// Late eliminate the LEGALAVL wrapper,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelDAGToDAG.cpp:31,wrap,wrapper,31,interpreter/llvm-project/llvm/lib/Target/VE/VEISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelDAGToDAG.cpp,1,['wrap'],['wrapper']
Integrability,// Launch of run loop occurs before the message-sent expression is seen.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RunLoopAutoreleaseLeakChecker.cpp:40,message,message-sent,40,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RunLoopAutoreleaseLeakChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RunLoopAutoreleaseLeakChecker.cpp,1,['message'],['message-sent']
Integrability,// Layout routines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp:10,rout,routines,10,interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,1,['rout'],['routines']
Integrability,"// Lazily construct a set of all the properties in the @interface; // of the class, without looking at the superclass. We cannot; // use the call to CollectImmediateProperties() above as that; // utilizes information from the super class's properties as well; // as scans the adopted protocols. This work only triggers for protocols; // with the attribute, which is very rare, and only occurs when; // analyzing the @implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:56,interface,interface,56,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,3,"['interface', 'protocol']","['interface', 'protocols']"
Integrability,"// Lazily create the Buffer for ContentCaches that wrap files. If we already; // computed it, just return what we have.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:51,wrap,wrap,51,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,1,['wrap'],['wrap']
Integrability,// Lazily retrieves the set of control dependencies to \p A.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/Dominators.h:39,depend,dependencies,39,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/Dominators.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/Dominators.h,1,['depend'],['dependencies']
Integrability,"// Legacy case of @implementation with no corresponding @interface.; // Build, chain & install the interface decl into the identifier.; // FIXME: Do we support attributes on the @implementation? If so we should; // copy them over.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:57,interface,interface,57,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['interface'],['interface']
Integrability,"// Legacy interface, we have no way to know the user's buffer size ....",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx:10,interface,interface,10,tree/tree/src/TBufferSQL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBufferSQL.cxx,1,['interface'],['interface']
Integrability,"// Let M be the minimum representable signed value. Then (-1)*RHS; // signed-wraps if and only if RHS is M. That can happen even for; // a NSW subtraction because e.g. (-1)*M signed-wraps even though; // -1 - M does not. So to transfer NSW from LHS - RHS to LHS +; // (-1)*RHS, we need to prove that RHS != M.; //; // If LHS is non-negative and we know that LHS - RHS does not; // signed-wrap, then RHS cannot be M. So we can rule out signed-wrap; // either by proving that RHS > M or that LHS >= 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:77,wrap,wraps,77,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,4,['wrap'],"['wrap', 'wraps']"
Integrability,"// Let the linker choose between libunwind.so and libunwind.a; // depending on what's available, and depending on the -static flag",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:66,depend,depending,66,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,2,['depend'],['depending']
Integrability,"// Let's inject it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp:9,inject,inject,9,interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,1,['inject'],['inject']
Integrability,"// Let's make sure that we can prove that we do not self-wrap during; // MaxBECount iterations. We need this because MaxBECount is a maximum; // iteration count estimate, and we might infer nw from some exit for which we; // do not know max exit count (or any other side reasoning).; // TODO: Turn into assert at some point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:57,wrap,wrap,57,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,// Levarge the 32-bit discriminator field of debug data to store the ID; // and type of a callsite probe. This gets rid of the dependency on; // plumbing a customized metadata through the codegen pipeline.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp:127,depend,dependency,127,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,1,['depend'],['dependency']
Integrability,// Lex tokens at the end of the message and include them in the message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:32,message,message,32,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,2,['message'],['message']
Integrability,"// Lexically forward.; //; // FIXME: If we only have loop-independent forward dependences (e.g. a; // read and write of A[i]), LAA will locally deem the dependence ""safe""; // without querying the MemoryDepChecker. Therefore we can miss; // enumerating loop-independent forward dependences in; // getDependences. Note that as soon as there are different; // indices used to access the same array, the MemoryDepChecker *is*; // queried and the dependence list is complete.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:78,depend,dependences,78,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,4,['depend'],"['dependence', 'dependences']"
Integrability,// Libraries that are always linked depending on the language,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:36,depend,depending,36,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,1,['depend'],['depending']
Integrability,"// Library dependencies",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/inc/THtml.h:11,depend,dependencies,11,html/inc/THtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/inc/THtml.h,1,['depend'],['dependencies']
Integrability,// Lift some types from the dependent base class into this class for; // simplicity of referring to them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:28,depend,dependent,28,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,2,['depend'],['dependent']
Integrability,"// Lightweight interface adaptor that binds a RooAbsPdf to TFOAM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFoamGenerator.cxx:15,interface,interface,15,roofit/roofitcore/src/RooFoamGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFoamGenerator.cxx,1,['interface'],['interface']
Integrability,"// Lightweight interface adaptors (caller takes ownership)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:15,interface,interface,15,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,1,['interface'],['interface']
Integrability,"// Like RooAbsLTest.SubEventSections, but here we can also check behavior; // for when component likelihoods of a top-level RooSumL have a different; // number (less) of events than the RooSumL itself. Moreover, this more; // complex likelihood has an extended term and a subsidiary component; // which also depend on section so will also be checked here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/TestStatistics/testRooAbsL.cxx:308,depend,depend,308,roofit/roofitcore/test/TestStatistics/testRooAbsL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/TestStatistics/testRooAbsL.cxx,1,['depend'],['depend']
Integrability,// Like SourceMgr::printMessage() we need to print the include stack if any; // before printing the message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:100,message,message,100,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,2,['message'],['message']
Integrability,"// Like assumes, invariant.start intrinsics were also marked as arbitrarily; // writing so that proper control dependencies are maintained but they never; // mod any particular memory location visible to the IR.; // *Unlike* assumes (which are now modeled as NoModRef), invariant.start; // intrinsic is now modeled as reading memory. This prevents hoisting the; // invariant.start intrinsic over stores. Consider:; // *ptr = 40;; // *ptr = 50;; // invariant_start(ptr); // int val = *ptr;; // print(val);; //; // This cannot be transformed to:; //; // *ptr = 40;; // invariant_start(ptr); // *ptr = 50;; // int val = *ptr;; // print(val);; //; // The transformation will cause the second store to be ignored (based on; // rules of invariant.start) and print 40, while the first program always; // prints 50.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:111,depend,dependencies,111,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['depend'],['dependencies']
Integrability,// Like replaceAllUsesWith except it does not handle constants or basic blocks.; // This routine leaves uses within BB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:89,rout,routine,89,interpreter/llvm-project/llvm/lib/IR/Value.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp,1,['rout'],['routine']
Integrability,// Limit MaxScalableVF by the maximum safe dependence distance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:43,depend,dependence,43,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['depend'],['dependence']
Integrability,// Limit this to after legalization if the add has wrap flags,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,wrap,wrap,51,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['wrap'],['wrap']
Integrability,"// Linearizing the control flow by placing TRY / END_TRY markers can create; // mismatches in unwind destinations for throwing instructions, such as calls.; //; // We use the 'delegate' instruction to fix the unwind mismatches. 'delegate'; // instruction delegates an exception to an outer 'catch'. It can target not; // only 'catch' but all block-like structures including another 'delegate',; // but with slightly different semantics than branches. When it targets a; // 'catch', it will delegate the exception to that catch. It is being; // discussed how to define the semantics when 'delegate''s target is a non-try; // block: it will either be a validation failure or it will target the next; // outer try-catch. But anyway our LLVM backend currently does not generate; // such code. The example below illustrates where the 'delegate' instruction; // in the middle will delegate the exception to, depending on the value of N.; // try; // try; // block; // try; // try; // call @foo; // delegate N ;; Where will this delegate to?; // catch ;; N == 0; // end; // end ;; N == 1 (invalid; will not be generated); // delegate ;; N == 2; // catch ;; N == 3; // end; // ;; N == 4 (to caller); // 1. When an instruction may throw, but the EH pad it will unwind to can be; // different from the original CFG.; //; // Example: we have the following CFG:; // bb0:; // call @foo ; if it throws, unwind to bb2; // bb1:; // call @bar ; if it throws, unwind to bb3; // bb2 (ehpad):; // catch; // ...; // bb3 (ehpad); // catch; // ...; //; // And the CFG is sorted in this order. Then after placing TRY markers, it; // will look like: (BB markers are omitted); // try; // try; // call @foo; // call @bar ;; if it throws, unwind to bb3; // catch ;; ehpad (bb2); // ...; // end_try; // catch ;; ehpad (bb3); // ...; // end_try; //; // Now if bar() throws, it is going to end up ip in bb2, not bb3, where it; // is supposed to end up. We solve this problem by wrapping the mismatching; // call with an inner try-del",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:902,depend,depending,902,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,1,['depend'],['depending']
Integrability,// Link and wrap the device images extracted from the linker input.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:12,wrap,wrap,12,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,1,['wrap'],['wrap']
Integrability,// Link the type of the injected-class-name to that of the outer class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:24,inject,injected-class-name,24,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['inject'],['injected-class-name']
Integrability,"// LinkModeAuto will link with the default link mode for the installation,; // which is dependent on the value of LLVM_LINK_LLVM_DYLIB, and fall back; // to the alternative if the required libraries are not available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:88,depend,dependent,88,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,1,['depend'],['dependent']
Integrability,"// List internally integrated observables and factorizing observables as analytically integrated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:19,integrat,integrated,19,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,2,['integrat'],['integrated']
Integrability,"// List numerically integrated and summed observables as numerically integrated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:20,integrat,integrated,20,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,2,['integrat'],['integrated']
Integrability,"// List of all term dependents: normalization and imported",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:20,depend,dependents,20,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['depend'],['dependents']
Integrability,// List of dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:11,depend,dependencies,11,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['depend'],['dependencies']
Integrability,"// List of passes explicitly substituted by this target. Normally this is; // empty, but it is a convenient way to suppress or replace specific passes; // that are part of a standard pass pipeline without overridding the entire; // pipeline. This mechanism allows target options to inherit a standard pass's; // user interface. For example, a target may disable a standard pass by; // default by substituting a pass ID of zero, and the user may still enable; // that standard pass with an explicit command line option.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:317,interface,interface,317,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,1,['interface'],['interface']
Integrability,// List the dependent libraries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:12,depend,dependent,12,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,1,['depend'],['dependent']
Integrability,"// Lists that keep the information for each dependency. All the lists are; // meant to be updated in sync. We are adopting separate lists instead of a; // list of structs, because that simplifies forwarding the actions list to; // initialize the inputs of the base Action class.; /// The dependence actions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Action.h:44,depend,dependency,44,interpreter/llvm-project/clang/include/clang/Driver/Action.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Action.h,2,['depend'],"['dependence', 'dependency']"
Integrability,"// LiveVariables currently requires pure SSA form.; //; // FIXME: Once TwoAddressInstruction pass no longer uses kill flags,; // LiveVariables can be removed completely, and LiveIntervals can be directly; // computed. (We still either need to regenerate kill flags after regalloc, or; // preferably fix the scavenger to not depend on them).; // FIXME: UnreachableMachineBlockElim is a dependant pass of LiveVariables.; // When LiveVariables is removed this has to be removed/moved either.; // Explicit addition of UnreachableMachineBlockElim allows stopping before or; // after it with -stop-before/-stop-after.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:324,depend,depend,324,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,2,['depend'],"['depend', 'dependant']"
Integrability,"// LoCmp = lo(op1) < lo(op2) // Always unsigned comparison; // HiCmp = hi(op1) < hi(op2) // Signedness depends on operands; // dest = hi(op1) == hi(op2) ? LoCmp : HiCmp;; // NOTE: on targets without efficient SELECT of bools, we can always use; // this identity: (B1 ? B2 : B3) --> (B1 & B2)|(!B1&B3)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:103,depend,depends,103,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['depend'],['depends']
Integrability,// Load Value Injection (LVI) Mitigations for machine code,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:14,Inject,Injection,14,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,1,['Inject'],['Injection']
Integrability,"// Load automatically RooFitMore library that automatically will register the; // integrator classes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooFitMoreLib.cxx:82,integrat,integrator,82,roofit/roofitmore/src/RooFitMoreLib.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooFitMoreLib.cxx,1,['integrat'],['integrator']
Integrability,"// Load one or more archive buffers, depending on whether we're dealing with; // a fat binary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:37,depend,depending,37,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,1,['depend'],['depending']
Integrability,"// Load one or more object buffers, depending on whether we're dealing with a; // fat binary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:36,depend,depending,36,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,1,['depend'],['depending']
Integrability,// Load the function to call from the message ref table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:38,message,message,38,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['message'],['message']
Integrability,// Load the integer value into an FPR. The kind of load used depends; // on a number of conditions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:61,depend,depends,61,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['depend'],['depends']
Integrability,// Loader section related interfaces.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h:26,interface,interfaces,26,interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,1,['interface'],['interfaces']
Integrability,"// Loading/storing mask pairs requires two kmov operations. The second one of; // these needs a 2 byte displacement relative to the specified address (with; // 32 bit spill size). The pairs of 1bit masks up to 16 bit masks all use the; // same spill size, they all are stored using MASKPAIR16STORE, loaded using; // MASKPAIR16LOAD.; //; // The displacement value might wrap around in theory, thus the asserts in; // both cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:369,wrap,wrap,369,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,1,['wrap'],['wrap']
Integrability,// Loads the libopagent library and initializes this wrapper if the oprofile; // daemon is running,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/OProfileWrapper.h:53,wrap,wrapper,53,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/OProfileWrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/OProfileWrapper.h,1,['wrap'],['wrapper']
Integrability,// Local function that updates the declaration specifiers with; // protocol information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:67,protocol,protocol,67,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['protocol'],['protocol']
Integrability,"// Local function to ""flush"" the protocol identifiers, turning them into; // type parameters.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:33,protocol,protocol,33,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['protocol'],['protocol']
Integrability,// Local variables/inlined routines are purposely omitted here. The point of; // marking this as a thunk is so Visual Studio will NOT stop in this routine.; // Emit S_PROC_ID_END,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:27,rout,routines,27,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,2,['rout'],"['routine', 'routines']"
Integrability,"// Locate and escape Parent's frame_pointer.addr alloca; // Depending on target, should be 1st/2nd one in LocalDeclMap.; // Let's just scan for ImplicitParamDecl with VoidPtrTy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:60,Depend,Depending,60,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,1,['Depend'],['Depending']
Integrability,// Location to use for error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:29,message,messages,29,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['message'],['messages']
Integrability,"// Log messages to syslog i.o. stderr; //; // type of service",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/res/rpddefs.h:7,message,messages,7,net/rpdutils/res/rpddefs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/res/rpddefs.h,1,['message'],['messages']
Integrability,// Longest register dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:20,depend,dependency,20,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,1,['depend'],['dependency']
Integrability,// Look at dependencies between current members of the packet and; // predicate defining instruction MI. Make sure that dependency is; // on the exact register we care about.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:11,depend,dependencies,11,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,2,['depend'],"['dependencies', 'dependency']"
Integrability,"// Look for a shuffle with the mask u,0,1,2,3,4,5,6 or 1,2,3,4,5,6,7,u; // depending on the InsIndex.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:75,depend,depending,75,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['depend'],['depending']
Integrability,// Look for a suitable register to use to break the anti-dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:57,depend,dependence,57,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,1,['depend'],['dependence']
Integrability,"// Look for a suitable register to use to break the anti-dependence.; //; // TODO: Instead of picking the first free register, consider which might; // be the best.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:57,depend,dependence,57,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,1,['depend'],['dependence']
Integrability,// Look for an ``autorelease'' instruction that is a predecessor of Ret and; // dependent on Arg such that there are no instructions dependent on Arg; // that need a positive ref count in between the autorelease and Ret.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:80,depend,dependent,80,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,2,['depend'],['dependent']
Integrability,// Look for an existing interface with the same name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:24,interface,interface,24,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['interface'],['interface']
Integrability,"// Look for any other declaration of this method anywhere we can see in this; // compilation unit.; //; // We do not use IDecl->lookupMethod() because we have specific needs:; //; // - we absolutely do not need to walk protocols, because; // diag::err_objc_direct_on_protocol has already been emitted; // during parsing if there's a conflict,; //; // - when we do not find a match in a given @interface container,; // we need to attempt looking it up in the @implementation block if the; // translation unit sees it to find more clashes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:219,protocol,protocols,219,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,"['interface', 'protocol']","['interface', 'protocols']"
Integrability,// Look for expensive instructions in the cold operand's (if any) dependence; // slice of any of the selects in the group.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:66,depend,dependence,66,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,1,['depend'],['dependence']
Integrability,"// Look for literals such as Objective-C CFStrings refs, Selector refs,; // Message refs and Class refs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp:76,Message,Message,76,interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,1,['Message'],['Message']
Integrability,// Look for one of the two cases with InjectedClassNameTypes; // and check whether it's the same template.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:38,Inject,InjectedClassNameTypes,38,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['Inject'],['InjectedClassNameTypes']
Integrability,"// Look for situation like this:; // %reg101 = MOV %reg100; // %reg102 = ...; // %reg103 = ADD %reg102, %reg101; // ... = %reg103 ...; // %reg100 = MOV %reg103; // If there is a reversed copy chain from reg101 to reg103, commute the ADD; // to eliminate an otherwise unavoidable copy.; // FIXME:; // We can extend the logic further: If an pair of operands in an insn has; // been merged, the insn could be regarded as a virtual copy, and the virtual; // copy could also be used to construct a copy chain.; // To more generally minimize register copies, ideally the logic of two addr; // instruction pass should be integrated with register allocation pass where; // interference graph is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:614,integrat,integrated,614,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,1,['integrat'],['integrated']
Integrability,"// Look for store-to-load forwarding cases across the; // backedge. E.g.:; //; // loop:; // %x = load %gep_i; // = ... %x; // store %y, %gep_i_plus_1; //; // =>; //; // ph:; // %x.initial = load %gep_0; // loop:; // %x.storeforward = phi [%x.initial, %ph] [%y, %loop]; // %x = load %gep_i <---- now dead; // = ... %x.storeforward; // store %y, %gep_i_plus_1; // First start with store->load dependences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:391,depend,dependences,391,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,1,['depend'],['dependences']
Integrability,// Look for the cmp instruction to determine if we can get a useful trip; // count. The trip count can be either a register or an immediate. The; // location of the value depends upon the type (reg or imm).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:171,depend,depends,171,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,1,['depend'],['depends']
Integrability,// Look for this property declaration in the @implementation's @interface,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:64,interface,interface,64,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['interface'],['interface']
Integrability,// Look for type decls in dependent base classes that have known primary; // templates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:26,depend,dependent,26,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['depend'],['dependent']
Integrability,// Look for vector wrapped in a struct. e.g. { <16 x i8> }.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:19,wrap,wrapped,19,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['wrap'],['wrapped']
Integrability,// Look in qualified interfaces.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:21,interface,interfaces,21,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['interface'],['interfaces']
Integrability,"// Look it up in the main interface (and categories, etc.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:26,interface,interface,26,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['interface'],['interface']
Integrability,// Look one step prior in a dependent name type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:28,depend,dependent,28,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,// Look one step prior in a dependent template specialization type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:28,depend,dependent,28,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,// Look through a metadata wrapper.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/verify-uselistorder/verify-uselistorder.cpp:27,wrap,wrapper,27,interpreter/llvm-project/llvm/tools/verify-uselistorder/verify-uselistorder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/verify-uselistorder/verify-uselistorder.cpp,2,['wrap'],['wrapper']
Integrability,// Look through all of the protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:27,protocol,protocols,27,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['protocol'],['protocols']
Integrability,"// Look through argument promotions for our error message's reported type.; // This includes the integral and floating promotions, but excludes array; // and function pointer decay (seeing that an argument intended to be a; // string has type 'char [6]' is probably more confusing than 'char *') and; // certain bitfield promotions (bitfields can be 'demoted' to a lesser type).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:50,message,message,50,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['message'],['message']
Integrability,// Look through protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:16,protocol,protocols,16,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,5,['protocol'],['protocols']
Integrability,"// Look up the analysis usage from the pass instance (different instances; // of the same pass can produce different results), but unique the; // resulting object to reduce memory usage. This helps to greatly reduce; // memory usage when we have many instances of only a few pass types; // (e.g. instcombine, simplifycfg, etc...) which tend to share a fixed set; // of dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:369,depend,dependencies,369,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,1,['depend'],['dependencies']
Integrability,"// Looking at the diagnostic output is the only way to determine if a loop; // was vectorized (other than looking at the IR or machine code), so it; // is important to generate an optimization remark for each loop. Most of; // these messages are generated as OptimizationRemarkAnalysis. Remarks; // generated as OptimizationRemark and OptimizationRemarkMissed are; // less verbose reporting vectorized loops and unvectorized loops that may; // benefit from vectorization, respectively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:233,message,messages,233,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['message'],['messages']
Integrability,"// Looking for method with a type bound requires the correct context exists.; // We need to insert a method into the list if the context is different.; // If the method's declaration matches the list; // a> the method belongs to a different context: we need to insert it, in; // order to emit the availability message, we need to prioritize over; // availability among the methods with the same declaration.; // b> the method belongs to the same context: there is no need to insert a; // new entry.; // If the method's declaration does not match the list, we insert it to the; // end.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:310,message,message,310,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['message'],['message']
Integrability,"// Lookup a method. First, we search locally. If a method isn't; // found, we search referenced protocols and class categories.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:96,protocol,protocols,96,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,2,['protocol'],['protocols']
Integrability,"// Lookup cudaLaunchKernel/hipLaunchKernel function.; // HIP kernel launching API name depends on -fgpu-default-stream option. For; // the default value 'legacy', it is hipLaunchKernel. For 'per-thread',; // it is hipLaunchKernel_spt.; // cudaError_t cudaLaunchKernel(const void *func, dim3 gridDim, dim3 blockDim,; // void **args, size_t sharedMem,; // cudaStream_t stream);; // hipError_t hipLaunchKernel[_spt](const void *func, dim3 gridDim,; // dim3 blockDim, void **args,; // size_t sharedMem, hipStream_t stream);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:87,depend,depends,87,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,1,['depend'],['depends']
Integrability,// Lookup of an unqualified type name has failed in MSVC compatibility mode.; // Give Sema a chance to recover if we are in a template with dependent base; // classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:140,depend,dependent,140,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['depend'],['dependent']
Integrability,"// Lookup the abstract attribute of type AAType. If found, return it after; // registering a dependence of QueryingAA on the one returned attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:93,depend,dependence,93,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['depend'],['dependence']
Integrability,"// Lookup the bits for this element, wrapping around the immediate every; // 8-bits. Elements are grouped into sets of 2 or 4 elements so we need; // to offset by the first index of each group.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:37,wrap,wrapping,37,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,1,['wrap'],['wrapping']
Integrability,"// Loop going while iv is ""greater"" with the iv value going up. Must wrap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:69,wrap,wrap,69,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,1,['wrap'],['wrap']
Integrability,"// Loop going while iv is ""less"" with the iv value going down. Must wrap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:68,wrap,wrap,68,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,1,['wrap'],['wrap']
Integrability,"// Loop over all basic blocks and remove KILL pseudo-instructions; // These instructions confuse the dependence analysis. Consider:; // D0 = ... (Insn 0); // R0 = KILL R0, D0 (Insn 1); // R0 = ... (Insn 2); // Here, Insn 1 will result in the dependence graph not emitting an output; // dependence between Insn 0 and Insn 2. This can lead to incorrect; // packetization",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:101,depend,dependence,101,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,3,['depend'],['dependence']
Integrability,"// Loop over all instructions in all blocks, from bottom to top, so that it's; // more likely that chains of dependent but ultimately dead instructions will; // be cleaned up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp:109,depend,dependent,109,interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DeadMachineInstructionElim.cpp,1,['depend'],['dependent']
Integrability,"// Loop over all integrated observables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:17,integrat,integrated,17,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['integrat'],['integrated']
Integrability,// Loop over all of the things that depend on the instruction we're removing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:36,depend,depend,36,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['depend']
Integrability,"// Loops containing convergent instructions cannot use runtime unrolling,; // as the prologue/epilogue may add additional control-dependencies to; // convergent operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:130,depend,dependencies,130,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,1,['depend'],['dependencies']
Integrability,// Lower VECTOR_SHUFFLE into one of a number of instructions depending on the; // indices in the shuffle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:61,depend,depending,61,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['depend'],['depending']
Integrability,"// Lower constant mask BUILD_VECTORs via an integer vector type, in; // scalar integer chunks whose bit-width depends on the number of mask; // bits and XLEN.; // First, determine the most appropriate scalar integer type to use. This; // is at most XLenVT, but may be shrunk to a smaller vector element type; // according to the size of the final vector - use i8 chunks rather than; // XLenVT if we're producing a v8i1. This results in more consistent; // codegen across RV32 and RV64.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:110,depend,depends,110,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['depend'],['depends']
Integrability,// Lower direct calls to global addresses and external symbols. Setting; // ForCall to true here has the effect of removing WrapperRIP when possible; // to allow direct calls to be selected without first materializing the; // address into a register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:124,Wrap,WrapperRIP,124,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['Wrap'],['WrapperRIP']
Integrability,// Lower generic MASSV routines to PowerPC subtarget-specific entries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:23,rout,routines,23,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,1,['rout'],['routines']
Integrability,"// Lower interleaved load(s) into target specific instructions/; // intrinsics. Lowering sequence varies depending on the vector-types, factor,; // number of shuffles and ISA.; // Currently, lowering is supported for 4x64 bits with Factor = 4 on AVX.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:105,depend,depending,105,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,1,['depend'],['depending']
Integrability,"// M a k e M C p r o j e c t i o n o f p d f w i t h s a m e L L r a t i o c u t; // ---------------------------------------------------------------------------------------------; // Generate large number of events for MC integration of pdf projection",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:222,integrat,integration,222,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['integrat'],['integration']
Integrability,// MCInstrInfo initialization routine.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/InstrInfoEmitter.cpp:30,rout,routine,30,interpreter/llvm-project/llvm/utils/TableGen/InstrInfoEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/InstrInfoEmitter.cpp,2,['rout'],['routine']
Integrability,// MCObjectWriter interface implementation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/WinCOFFObjectWriter.cpp:18,interface,interface,18,interpreter/llvm-project/llvm/lib/MC/WinCOFFObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/WinCOFFObjectWriter.cpp,1,['interface'],['interface']
Integrability,"// MD5 version of NamesInProfile. Either NamesInProfile or GUIDsInProfile is; // populated, depends on whether the profile uses MD5. Because the name table; // generally contains several magnitude more entries than the number of; // functions, we do not want to convert all names from one form to another.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:92,depend,depends,92,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['depend'],['depends']
Integrability,"// MI didn't have the interface such as MI.setOperand(i) though; // it has MI.getOperand(i). To repalce the ZERO MachineOperand with; // ImmMO, we need to remove ZERO operand and all the operands behind it,; // and, add the ImmMO, then, move back all the operands behind ZERO.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:22,interface,interface,22,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['interface'],['interface']
Integrability,// MI has an unwanted D-register dependency.; // Avoid defs in the previous N instructrions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:33,depend,dependency,33,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['depend'],['dependency']
Integrability,"// MI is a three-operand RIE-style pseudo instruction. Replace it with; // LowOpcodeK if the registers are both low GR32s, otherwise use a move; // followed by HighOpcode or LowOpcode, depending on whether the target; // is a high or low GR32.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:185,depend,depending,185,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,1,['depend'],['depending']
Integrability,"// MSB variable wrapped, no more unique combinations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h:16,wrap,wrapped,16,interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CombinationGenerator.h,1,['wrap'],['wrapped']
Integrability,// MSVC allows explicit template specialization at class scope:; // 2 CXXMethodDecls referring to the same function will be injected.; // We don't want a redeclaration error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:124,inject,injected,124,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['inject'],['injected']
Integrability,"// MUBUF / MTBUF instructions have a 12-bit unsigned byte offset, and; // additionally can do r + r + i with addr64. 32-bit has more addressing; // mode options. Depending on the resource constant, it can also do; // (i64 r0) + (i32 r1) * (i14 i).; //; // Private arrays end up using a scratch buffer most of the time, so also; // assume those use MUBUF instructions. Scratch loads / stores are currently; // implemented as mubuf instructions with offen bit set, so slightly; // different than the normal addr64.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:162,Depend,Depending,162,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Depend'],['Depending']
Integrability,// MVI matching routines used by SystemZOperands.td.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:16,rout,routines,16,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['rout'],['routines']
Integrability,"// MacOSXAPIChecker.h - Checks proper use of various MacOS X APIs --*- C++ -*-//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines MacOSXAPIChecker, which is an assortment of checks on calls; // to various, widely used Apple APIs.; //; // FIXME: What's currently in BasicObjCFoundationChecks.cpp should be migrated; // to here, using the new Checker interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp:615,interface,interface,615,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSXAPIChecker.cpp,1,['interface'],['interface']
Integrability,"// Machine dependent values fiXME!!; // But don't set min=max=0 if param is unlimited",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx:11,depend,dependent,11,math/fumili/src/TFumili.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx,1,['depend'],['dependent']
Integrability,"// Macro indicating the version of the Collection Proxy interface followed; // by this ROOT build (See also Reflex/Builder/CollectionProxy.h).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TVirtualCollectionProxy.h:56,interface,interface,56,core/cont/inc/TVirtualCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TVirtualCollectionProxy.h,1,['interface'],['interface']
Integrability,"// Main interface of this class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/Scanner.h:8,interface,interface,8,core/dictgen/res/Scanner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/Scanner.h,1,['interface'],['interface']
Integrability,// Main interface to build the plain CFG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp:8,interface,interface,8,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp,1,['interface'],['interface']
Integrability,"// Main interface to evaluate the test statistic on a dataset",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/MinNLLTestStat.h:8,interface,interface,8,roofit/roostats/inc/RooStats/MinNLLTestStat.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/MinNLLTestStat.h,2,['interface'],['interface']
Integrability,"// Main interface to textinput library.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TextInput.h:8,interface,interface,8,core/textinput/src/textinput/TextInput.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TextInput.h,1,['interface'],['interface']
Integrability,"// Main message loop:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/Win32Splash.cxx:8,message,message,8,core/winnt/src/Win32Splash.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/Win32Splash.cxx,1,['message'],['message']
Integrability,// Make a conservative assumption for dependent nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:38,depend,dependent,38,interpreter/llvm-project/clang/lib/AST/Expr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp,1,['depend'],['dependent']
Integrability,"// Make a histogram for this node; // Do some horrible things to prevent some really; // annoying messages from being printed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistFactoryNavigation.cxx:98,message,messages,98,roofit/histfactory/src/HistFactoryNavigation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistFactoryNavigation.cxx,1,['message'],['messages']
Integrability,// Make all other vector elements depend on this store,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp:34,depend,depend,34,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,1,['depend'],['depend']
Integrability,"// Make another DFS pass over all other nodes to find the; // reverse-unreachable blocks, and find the furthest paths we'll be able; // to make.; // Note that this looks N^2, but it's really 2N worst case, if every node; // is unreachable. This is because we are still going to only visit each; // unreachable node once, we may just visit it in two directions,; // depending on how lucky we get.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h:365,depend,depending,365,interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,1,['depend'],['depending']
Integrability,// Make data dependencies from the FirstSU also dependent on the SecondSU to; // prevent them from being scheduled between the FirstSU and the SecondSU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:13,depend,dependencies,13,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,2,['depend'],"['dependencies', 'dependent']"
Integrability,"// Make full list of dependents (generated & proto)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdGenContext.cxx:21,depend,dependents,21,roofit/roofitcore/src/RooProdGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdGenContext.cxx,1,['depend'],['dependents']
Integrability,"// Make integration observable x_prime for each observable x as well as an x_lowbound",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:8,integrat,integration,8,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['integrat'],['integration']
Integrability,"// Make list of all dependents of this PDF",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:20,depend,dependents,20,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['depend'],['dependents']
Integrability,"// Make list of imported dependents that occur in any term",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:25,depend,dependents,25,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['depend'],['dependents']
Integrability,"// Make list of integrated dependents that occur in any term",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:16,integrat,integrated,16,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,2,"['depend', 'integrat']","['dependents', 'integrated']"
Integrability,"// Make list of wholly imported dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:32,depend,dependents,32,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['depend'],['dependents']
Integrability,"// Make lists of; // a) integrated observables with fixed ranges,; // b) integrated observables with parameterized ranges depending on other integrated observables; // c) integrated observables used in definition of any parameterized ranges of integrated observables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:24,integrat,integrated,24,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,6,"['depend', 'integrat']","['depending', 'integrated']"
Integrability,"// Make projection of decay(dt|dterr) on dt.; //; // Instead of integrating out dterr, make a weighted average of curves; // at values dterr_i as given in the external dataset.; // (The true argument bins the data before projection to speed up the process)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:64,integrat,integrating,64,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['integrat'],['integrating']
Integrability,// Make sure Save and Restore are suitable for shrink-wrapping:; // 1. all path from Save needs to lead to Restore before exiting.; // 2. all path to Restore needs to go through Save from Entry.; // We achieve that by making sure that:; // A. Save dominates Restore.; // B. Restore post-dominates Save.; // C. Save and Restore are in the same loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:54,wrap,wrapping,54,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,1,['wrap'],['wrapping']
Integrability,"// Make sure if the new restore point is valid as an epilogue, depending on; // targets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:63,depend,depending,63,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,1,['depend'],['depending']
Integrability,"// Make sure it is not smaller then the cache, if the info is available and the size; // synchronization is required. But apply the cache-packet size synchronization only if there; // are enough left files to process and the files are all of similar sizes. Otherwise we risk; // to not exploit optimally all potentially active workers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx:89,synchroniz,synchronization,89,proof/proofplayer/src/TPacketizerAdaptive.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx,2,['synchroniz'],['synchronization']
Integrability,"// Make sure libProof and dependents are loaded and TProof can be created,; // dependents are loaded via the information in the [system].rootmap file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:26,depend,dependents,26,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['depend'],['dependents']
Integrability,"// Make sure that RooFit realizes that Gaussian(x, mu, sigma(x)) needs to be; // integrated analytically.; // Covers GitHub issue #14320.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRealIntegral.cxx:81,integrat,integrated,81,roofit/roofitcore/test/testRooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRealIntegral.cxx,1,['integrat'],['integrated']
Integrability,"// Make sure that the dependences do not restrict adding MI to the packet.; // That is, ignore anti dependences, and make sure the only data dependence; // involves the specific register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:22,depend,dependences,22,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,3,['depend'],"['dependence', 'dependences']"
Integrability,"// Make sure that we don't alias with any instruction in the alias set; // tracker. If we do, then we depend on a future iteration, and we; // can't reroll.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:102,depend,depend,102,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,1,['depend'],['depend']
Integrability,"// Make sure that we don't have circular inheritance among our dependent; // bases. For non-dependent bases, the check for completeness below handles; // this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:63,depend,dependent,63,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,2,['depend'],['dependent']
Integrability,"// Make sure that we don't make an ill-formed AST where the type of the; // Class is non-dependent and its attached base class specifier is an; // dependent type, which violates invariants in many clang code paths (e.g.; // constexpr evaluator). If this case happens (in errory-recovery mode), we; // explicitly mark the Class decl invalid. The diagnostic was already; // emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:89,depend,dependent,89,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,2,['depend'],['dependent']
Integrability,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:85,Depend,Dependency,85,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,2,"['Depend', 'depend']","['Dependency', 'dependencies']"
Integrability,"// Make sure that, even if the multiplication below would wrap as an; // uint64_t, we still do the right thing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:58,wrap,wrap,58,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['wrap'],['wrap']
Integrability,"// Make sure the LoopIndependent flag is set correctly.; // All directions must include equal, otherwise no; // loop-independent dependence is possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:129,depend,dependence,129,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,// Make sure the image we're wrapping around is aligned as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/OffloadBinary.cpp:29,wrap,wrapping,29,interpreter/llvm-project/llvm/lib/Object/OffloadBinary.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/OffloadBinary.cpp,1,['wrap'],['wrapping']
Integrability,// Make sure the linker consider all object files from the static lib.; // This is necessary because instrumented dlls need access to all the; // interface exported by the static lib in the main executable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp:146,interface,interface,146,interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,1,['interface'],['interface']
Integrability,// Make sure there is dependency and can be new value'd.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:22,depend,dependency,22,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['depend'],['dependency']
Integrability,// Make sure there's a type source info. This isn't really much; // of a waste; most dependent types should have type source info; // attached already.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:85,depend,dependent,85,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,// Make sure to remember that new things depend on NewDepInst.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:41,depend,depend,41,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['depend']
Integrability,// Make sure we are not parsing something; // that looks like a label or an expression but is not.; // This will improve error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:127,message,messages,127,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,1,['message'],['messages']
Integrability,// Make sure we have a use dependency all the way through this; // sequence of instructions. We can't have the other bits in the CR; // modified in between the mfocrf and the mtocrf.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:27,depend,dependency,27,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,1,['depend'],['dependency']
Integrability,// Make sure we keep track of the fact that the implementation implements; // the interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassRegistry.cpp:82,interface,interface,82,interpreter/llvm-project/llvm/lib/IR/PassRegistry.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassRegistry.cpp,1,['interface'],['interface']
Integrability,// Make sure we visit all dependents first,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:26,depend,dependents,26,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,1,['depend'],['dependents']
Integrability,"// Make sure window-system dependent part of GL-util is initialized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLWidget.cxx:27,depend,dependent,27,graf3d/gl/src/TGLWidget.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLWidget.cxx,1,['depend'],['dependent']
Integrability,// Make the FirstSU also dependent on the dependencies of the SecondSU to; // prevent them from being scheduled between the FirstSU and the SecondSU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:25,depend,dependent,25,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,2,['depend'],"['dependencies', 'dependent']"
Integrability,"// Make the SVE types available. Note that this deliberately doesn't; // depend on SveMode, since in principle it should be possible to turn; // SVE on and off within a translation unit. It should also be possible; // to compile the global declaration:; //; // __SVInt8_t *ptr;; //; // even without SVE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:73,depend,depend,73,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,1,['depend'],['depend']
Integrability,// Make the fixed object stored to mutable so that the load instructions; // referencing it have their memory dependencies added.; // Set the frame object as isAliased which clears the underlying objects; // vector in ScheduleDAGInstrs::buildSchedGraph() resulting in addition of all; // stores as dependencies for loads referencing this fixed object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:110,depend,dependencies,110,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,2,['depend'],['dependencies']
Integrability,// Make the import decl for the interface in the impl module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:32,interface,interface,32,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,1,['interface'],['interface']
Integrability,"// Make the message box non-resizable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TProofProgressDialog.cxx:12,message,message,12,gui/sessionviewer/src/TProofProgressDialog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TProofProgressDialog.cxx,1,['message'],['message']
Integrability,"// Make the wrapper name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingBaseClassInfo.cxx:12,wrap,wrapper,12,core/metacling/src/TClingBaseClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingBaseClassInfo.cxx,1,['wrap'],['wrapper']
Integrability,"// ManagedStatic must be initialized to zero, and it must *not* have a dynamic; // initializer because managed statics are often created while running other; // dynamic initializers. In standard C++11, the best way to accomplish this is; // with a constexpr default constructor. However, different versions of the; // Visual C++ compiler have had bugs where, even though the constructor may be; // constexpr, a dynamic initializer may be emitted depending on optimization; // settings. For the affected versions of MSVC, use the old linker; // initialization pattern of not providing a constructor and leaving the fields; // uninitialized. See http://llvm.org/PR41367 for details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ManagedStatic.h:446,depend,depending,446,interpreter/llvm-project/llvm/include/llvm/Support/ManagedStatic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ManagedStatic.h,1,['depend'],['depending']
Integrability,"// Mangle injected class name types as if the user had written the; // specialization out fully. It may not actually be possible to see; // this mangling, though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:10,inject,injected,10,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['inject'],['injected']
Integrability,"// Mangle instantiation-dependent exception-specification, if present,; // per cxx-abi-dev proposal on 2016-10-11.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:24,depend,dependent,24,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['depend'],['dependent']
Integrability,// Mangle protocol qualifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:10,protocol,protocol,10,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['protocol'],['protocol']
Integrability,// Mangle the name for the thread_local wrapper function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:40,wrap,wrapper,40,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['wrap'],['wrapper']
Integrability,// Manually open up the bundle to avoid introducing additional dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp:63,depend,dependencies,63,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp,1,['depend'],['dependencies']
Integrability,"// Map of <function signature string, invoke_ wrappers>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:46,wrap,wrappers,46,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,1,['wrap'],['wrappers']
Integrability,"// Map the driver type to the frontend type. This is mostly an identity; // mapping, except that the distinction between module interface units; // and other source files does not exist at the frontend layer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:128,interface,interface,128,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['interface'],['interface']
Integrability,"// Map to own RAII objects that manage the file opening and releasing; // interfaces with gold. This is needed only for ThinLTO mode, since; // unlike regular LTO, where addModule will result in the opened file; // being merged into a new combined module, we need to keep these files open; // through Lto->run().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:74,interface,interfaces,74,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,1,['interface'],['interfaces']
Integrability,// Map unknown synchronization scopes to system.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:15,synchroniz,synchronization,15,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['synchroniz'],['synchronization']
Integrability,"// MapReduce; //; // We need to reimplement the MapReduce interfaces to allow for parallel reduction, defined in; // this class but not in the base class.; //; // the late return types also check at compile-time whether redfunc is compatible with func,; // other than checking that func is compatible with the type of arguments.; // a static_assert check in TThreadExecutor::Reduce is used to check that redfunc is compatible with the type returned by func",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TThreadExecutor.hxx:58,interface,interfaces,58,core/imt/inc/ROOT/TThreadExecutor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TThreadExecutor.hxx,1,['interface'],['interfaces']
Integrability,// Maps an Objective-C interface to its ObjCCompatibleAliasDecls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:23,interface,interface,23,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,1,['interface'],['interface']
Integrability,"// Maps of asm register numbers to LLVM register numbers, with 0 indicating; // an invalid register. In principle we could use 32-bit and 64-bit register; // classes directly, provided that we relegated the GPR allocation order; // in SystemZRegisterInfo.td to an AltOrder and left the default order; // as %r0-%r15. It seems better to provide the same interface for; // all classes though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZMCTargetDesc.h:353,interface,interface,353,interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZMCTargetDesc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/MCTargetDesc/SystemZMCTargetDesc.h,1,['interface'],['interface']
Integrability,// Maps the MCSection representation to its corresponding XCOFFSection; // wrapper. Needed for finding the XCOFFSection to insert an MCSymbol into; // from its containing MCSectionXCOFF.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/XCOFFObjectWriter.cpp:75,wrap,wrapper,75,interpreter/llvm-project/llvm/lib/MC/XCOFFObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/XCOFFObjectWriter.cpp,1,['wrap'],['wrapper']
Integrability,"// Mare all analytically integrated observables as such",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx:25,integrat,integrated,25,roofit/roofitcore/src/RooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx,1,['integrat'],['integrated']
Integrability,"// Marginizalization of multi-dimensional p.d.f.s through integration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:58,integrat,integration,58,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['integrat'],['integration']
Integrability,"// Mark all nodes to be imported for renaming following conflict resolution protocol",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx:76,protocol,protocol,76,roofit/roofitcore/src/RooWorkspace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx,1,['protocol'],['protocol']
Integrability,"// Mark all projected dependents as such",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx:22,depend,dependents,22,roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,2,['depend'],['dependents']
Integrability,// Mark any compiler-generated routines with the implicit code_seg attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:31,rout,routines,31,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['rout'],['routines']
Integrability,"// Mark size as unknown, if the location is not guaranteed to be; // loop-invariant for any possible loop in the function. Setting the size; // to unknown guarantees that any memory accesses that access locations; // after the pointer are considered as clobbers, which is important to; // catch loop carried dependences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:308,depend,dependences,308,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,1,['depend'],['dependences']
Integrability,"// Mark the interface as being completed, even if it was just as; // @class ....;; // declaration; the user cannot reopen it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:12,interface,interface,12,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['interface'],['interface']
Integrability,// Mark this protocol as having been generated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:13,protocol,protocol,13,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['protocol'],['protocol']
Integrability,// Marker for routines always inlined and thus lacking a convention,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/CodeView.h:14,rout,routines,14,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/CodeView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/CodeView.h,1,['rout'],['routines']
Integrability,"// Match ClangAs and other derived assemblers of Tool. ClangAs uses a; // longer ShortName ""clang integrated assembler"" while other assemblers just; // use ""assembler"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:98,integrat,integrated,98,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['integrat'],['integrated']
Integrability,"// Match on a call to a known method, but the call itself is type; // dependent (e.g. `vector<T> v; v.push(T{});` in a templated function).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp:70,depend,dependent,70,interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,1,['depend'],['dependent']
Integrability,// Matched: select +++ ? R : R ^ T; // select +++ ? R ^ T : R; // depending on TrueIfZero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:66,depend,depending,66,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,1,['depend'],['depending']
Integrability,"// MaterializeTemporaryExpr may appear out of place, after a few field and; // base-class accesses have been made to the object, even though semantically; // it is the whole object that gets materialized and lifetime-extended.; //; // For example:; //; // `-MaterializeTemporaryExpr; // `-MemberExpr; // `-CXXTemporaryObjectExpr; //; // instead of the more natural; //; // `-MemberExpr; // `-MaterializeTemporaryExpr; // `-CXXTemporaryObjectExpr; //; // Use the usual methods for obtaining the expression of the base object,; // and record the adjustments that we need to make to obtain the sub-object; // that the whole expression 'Ex' refers to. This trick is usual,; // in the sense that CodeGen takes a similar route.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:715,rout,route,715,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,1,['rout'],['route']
Integrability,"// Max file entries to avg allowed ratio for cache-to-packet synchronization; // (applies only if fCachePacketSync is true; -1. disables the bound)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx:61,synchroniz,synchronization,61,proof/proofplayer/src/TPacketizerAdaptive.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx,1,['synchroniz'],['synchronization']
Integrability,"// Max message size",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:7,message,message,7,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['message'],['message']
Integrability,"// May happen on auto types which resolve to dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp:45,depend,dependent,45,interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp,1,['depend'],['dependent']
Integrability,"// Medium checking now performed only if replacement is an assembly and old volume a real one.; // Check result is dependent on positioning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:115,depend,dependent,115,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,1,['depend'],['dependent']
Integrability,// Member pointers with dependent class types don't get special treatment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:24,depend,dependent,24,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,1,['depend'],['dependent']
Integrability,// Members of categories extending an interface are serialized as members of; // the interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:38,interface,interface,38,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,2,['interface'],['interface']
Integrability,"// Members present:; //; // static const SCEV::NoWrapFlags WrapType;; //; // static const ExtendOpTraitsBase::GetExtendExprTy GetExtendExpr;; //; // static const SCEV *getOverflowLimitForStep(const SCEV *Step,; // ICmpInst::Predicate *Pred,; // ScalarEvolution *SE);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:59,Wrap,WrapType,59,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Wrap'],['WrapType']
Integrability,// Memory dependency possible,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:10,depend,dependency,10,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['depend'],['dependency']
Integrability,// Memory synchronization,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/cl_common_defines.h:10,synchroniz,synchronization,10,interpreter/llvm-project/llvm/lib/Target/NVPTX/cl_common_defines.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/cl_common_defines.h,1,['synchroniz'],['synchronization']
Integrability,"// MemoryBuffer is a thin wrapper around the actual memory, so it's OK; // to create a temporary object here and delete it after the call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:26,wrap,wrapper,26,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,1,['wrap'],['wrapper']
Integrability,"// Menu button messages are handled by the main frame (i.e. ""this""); // ProcessMessage() method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/guitest.cxx:15,message,messages,15,test/guitest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/guitest.cxx,2,['message'],['messages']
Integrability,"// Merge Constant loads that have all their users into another group to the group.; // (TODO: else if all their users depend on the same group, put them there)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h:118,depend,depend,118,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.h,1,['depend'],['depend']
Integrability,// Merge ProtocolRefs into class's protocol list;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:9,Protocol,ProtocolRefs,9,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,2,"['Protocol', 'protocol']","['ProtocolRefs', 'protocol']"
Integrability,"// Merge groups with overlapping dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx:33,depend,dependents,33,roofit/roofitcore/src/RooProduct.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx,1,['depend'],['dependents']
Integrability,// Merge information from the @interface declaration into the; // @implementation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:31,interface,interface,31,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['interface'],['interface']
Integrability,// Merge protocol lists and construct ObjCObjectType.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:9,protocol,protocol,9,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['protocol'],['protocol']
Integrability,// Message,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:3,Message,Message,3,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['Message'],['Message']
Integrability,"// Message ID, width(4) [3:0].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIDefines.h:3,Message,Message,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIDefines.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIDefines.h,1,['Message'],['Message']
Integrability,"// Message buffer class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TMessage.h:3,Message,Message,3,net/net/inc/TMessage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TMessage.h,1,['Message'],['Message']
Integrability,"// Message compression",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:3,Message,Message,3,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['Message'],['Message']
Integrability,"// Message cracking routines",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/WidgetMessageTypes.h:3,Message,Message,3,gui/gui/inc/WidgetMessageTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/WidgetMessageTypes.h,2,"['Message', 'rout']","['Message', 'routines']"
Integrability,"// Message expressions unlike calls, could not be direct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:3,Message,Message,3,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,1,['Message'],['Message']
Integrability,"// Message for notification",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:3,Message,Message,3,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['Message'],['Message']
Integrability,"// Message for the client",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:3,Message,Message,3,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,4,['Message'],['Message']
Integrability,"// Message from given object instead of ""this""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMsgService.h:3,Message,Message,3,roofit/roofitcore/inc/RooMsgService.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMsgService.h,1,['Message'],['Message']
Integrability,"// Message from given object instead of ""this"" and skip message prefix",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMsgService.h:3,Message,Message,3,roofit/roofitcore/inc/RooMsgService.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMsgService.h,2,"['Message', 'message']","['Message', 'message']"
Integrability,"// Message logger",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/PDEFoamKernelBase.h:3,Message,Message,3,tmva/tmva/inc/TMVA/PDEFoamKernelBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/PDEFoamKernelBase.h,1,['Message'],['Message']
Integrability,"// Message sends are expected to return a zero value when the; // receiver is nil. At one point, this was only guaranteed for; // simple integer and pointer types, but expectations have grown; // over time.; //; // Given a nil receiver, the GNU runtime's message lookup will; // return a stub function that simply sets various return-value; // registers to zero and then returns. That's good enough for us; // if and only if (1) the calling conventions of that stub are; // compatible with the signature we're using and (2) the registers; // it sets are sufficient to produce a zero value of the return type.; // Rather than doing a whole target-specific analysis, we assume it; // only works for void, integer, and pointer types, and in all; // other cases we do an explicit nil check is emitted code. In; // addition to ensuring we produce a zero value for other types, this; // sidesteps the few outright CC incompatibilities we know about that; // could otherwise lead to crashes, like when a method is expected to; // return on the x87 floating point stack or adjust the stack pointer; // because of an indirect return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:3,Message,Message,3,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,2,"['Message', 'message']","['Message', 'message']"
Integrability,"// Message sent to 'super' in a class method defined in a category; // implementation requires an odd treatment.; // If we are in a class method, we must retrieve the; // _metaclass_ for the current class, pointed at by; // the class's ""isa"" pointer. The following assumes that; // isa"" is the first ivar in a class (which it must be).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:3,Message,Message,3,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['Message'],['Message']
Integrability,"// Message sub-type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:3,Message,Message,3,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['Message'],['Message']
Integrability,"// Message to be sent over",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TVirtualPacketizer.cxx:3,Message,Message,3,proof/proof/src/TVirtualPacketizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TVirtualPacketizer.cxx,1,['Message'],['Message']
Integrability,"// Message type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TMessage.h:3,Message,Message,3,net/net/inc/TMessage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TMessage.h,2,['Message'],['Message']
Integrability,"// Message type (positive; -1 for undef)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/res/rpdconn.h:3,Message,Message,3,net/rpdutils/res/rpdconn.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/res/rpdconn.h,1,['Message'],['Message']
Integrability,"// Message types",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/RRemoteProtocol.h:3,Message,Message,3,net/net/inc/RRemoteProtocol.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/RRemoteProtocol.h,1,['Message'],['Message']
Integrability,// MessageRefCPtrTy - clang type for struct _message_ref_t*,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:3,Message,MessageRefCPtrTy,3,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['Message'],['MessageRefCPtrTy']
Integrability,// MessageRefCTy - clang type for struct _message_ref_t,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:3,Message,MessageRefCTy,3,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['Message'],['MessageRefCTy']
Integrability,// MessageRefPtrTy - LLVM for struct _message_ref_t*,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:3,Message,MessageRefPtrTy,3,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,2,['Message'],['MessageRefPtrTy']
Integrability,// MessageRefTy - LLVM for:; // struct _message_ref_t {; // IMP messenger;; // SEL name;; // };; // First the clang type for struct _message_ref_t,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:3,Message,MessageRefTy,3,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['Message'],['MessageRefTy']
Integrability,"// Messages from master to queue",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/res/RooFit/MultiProcess/Messenger_decl.h:3,Message,Messages,3,roofit/multiprocess/res/RooFit/MultiProcess/Messenger_decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/res/RooFit/MultiProcess/Messenger_decl.h,1,['Message'],['Messages']
Integrability,"// Messages from queue to worker",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/res/RooFit/MultiProcess/Messenger_decl.h:3,Message,Messages,3,roofit/multiprocess/res/RooFit/MultiProcess/Messenger_decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/res/RooFit/MultiProcess/Messenger_decl.h,1,['Message'],['Messages']
Integrability,"// Messages from worker to queue",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/res/RooFit/MultiProcess/Messenger_decl.h:3,Message,Messages,3,roofit/multiprocess/res/RooFit/MultiProcess/Messenger_decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/res/RooFit/MultiProcess/Messenger_decl.h,1,['Message'],['Messages']
Integrability,"// Metadata can be dependent on conditions we are hoisting above.; // Conservatively strip all metadata on the instruction unless we were; // guaranteed to execute I if we entered the loop, in which case the metadata; // is valid in the loop preheader.; // Similarly, If I is a call and it is not guaranteed to execute in the loop,; // then moving to the preheader means we should strip attributes on the call; // that can cause UB since we may be hoisting above conditions that allowed; // inferring those attributes. They may not be valid at the preheader.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:19,depend,dependent,19,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['depend'],['dependent']
Integrability,"// Metadata can be dependent on the condition we are hoisting above.; // Strip all UB-implying metadata on the instruction. Drop the debug loc; // to avoid making it appear as if the condition is a constant, which would; // be misleading while debugging.; // Similarly strip attributes that maybe dependent on condition we are; // hoisting above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:19,depend,dependent,19,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,2,['depend'],['dependent']
Integrability,"// Method Interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/IMethod.h:10,Interface,Interface,10,tmva/tmva/inc/TMVA/IMethod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/IMethod.h,1,['Interface'],['Interface']
Integrability,"// Method called via Callbacks->FileNotFound(Filename); // in Preprocessor::HandleIncludeDirective(), initially allowing to; // change the include path, and allowing us to compile code via ACLiC; // when specifying #include ""myfile.C+"", and suppressing the preprocessor; // error message:; // input_line_23:1:10: fatal error: 'myfile.C+' file not found",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:280,message,message,280,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,1,['message'],['message']
Integrability,"// MethodArgInfo interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TInterpreter.h:17,interface,interface,17,core/meta/inc/TInterpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TInterpreter.h,2,['interface'],['interface']
Integrability,"// MethodInfo interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TInterpreter.h:14,interface,interface,14,core/meta/inc/TInterpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TInterpreter.h,2,['interface'],['interface']
Integrability,// Methods cannot return interface types. All ObjC objects are; // passed by reference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:25,interface,interface,25,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,2,['interface'],['interface']
Integrability,// Methods for handling the Extended-type case in functions above.; // These are all out-of-line to prevent users of this header file; // from having a dependency on Type.h.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:152,depend,dependency,152,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,1,['depend'],['dependency']
Integrability,// Methods to access block successors -- dereferencing to our wrapper class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:62,wrap,wrapper,62,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['wrap'],['wrapper']
Integrability,"// Middle aged versions expect client protocol now",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TRootAuth.cxx:38,protocol,protocol,38,net/auth/src/TRootAuth.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TRootAuth.cxx,1,['protocol'],['protocol']
Integrability,"// Might be case 2.; // For unsigned cases, we don't want C1 to wrap back to UINT64_MAX; // when C0 is zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:64,wrap,wrap,64,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,1,['wrap'],['wrap']
Integrability,// Might be wrapped in a macro qualified type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:12,wrap,wrapped,12,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['wrap'],['wrapped']
Integrability,"// Minimize using Fumili. Case of interface is a function with gradient.; // Normally other method is used - probably this could be removed (t.b.i.); // need MnUserFcn",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/FumiliMinimizer.cxx:34,interface,interface,34,math/minuit2/src/FumiliMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/FumiliMinimizer.cxx,1,['interface'],['interface']
Integrability,// Misc wrap up to maintain the consistency of the Function representation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp:8,wrap,wrap,8,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp,1,['wrap'],['wrap']
Integrability,// Misc. AST transformation routines. Sometimes they end up calling; // rewriting routines on the new ASTs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:28,rout,routines,28,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,4,['rout'],['routines']
Integrability,// Misc. helper routines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:16,rout,routines,16,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['rout'],['routines']
Integrability,// Miscellaneous inspection routines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h:28,rout,routines,28,interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,1,['rout'],['routines']
Integrability,// Mismatch of non-dependent template parameter to argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:19,depend,dependent,19,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['depend'],['dependent']
Integrability,"// Missing interface:; // fDeclFileLine = gInterpreter->ClassInfo_FileLine( fClassInfo );; // But really do not want to set ImplFileLine as it is currently the; // marker of being 'loaded' or not (reminder loaded == has a TClass bootstrap).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:11,interface,interface,11,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['interface'],['interface']
Integrability,"// ModRefC1 indicates what Call1 might do to Call2ArgLoc, and we use; // above ArgMask to update dependence info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:97,depend,dependence,97,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,1,['depend'],['dependence']
Integrability,// Model data dependencies between instructions being scheduled and the; // ExitSU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:14,depend,dependencies,14,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['depend'],['dependencies']
Integrability,// Model the case with a call to a templated function whose definition; // encloses the call and whose return type contains a placeholder type as if; // the UnresolvedLookupExpr was type-dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:187,depend,dependent,187,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['depend'],['dependent']
Integrability,"// Modeling of un-inlined AssertionResult constructors; //; // The gtest unit testing API provides macros for assertions that expand; // into an if statement that calls a series of constructors and returns; // when the ""assertion"" is false.; //; // For example,; //; // ASSERT_TRUE(a == b); //; // expands into:; //; // switch (0); // case 0:; // default:; // if (const ::testing::AssertionResult gtest_ar_ =; // ::testing::AssertionResult((a == b))); // ;; // else; // return ::testing::internal::AssertHelper(; // ::testing::TestPartResult::kFatalFailure,; // ""<path to project>"",; // <line number>,; // ::testing::internal::GetBoolAssertionFailureMessage(; // gtest_ar_, ""a == b"", ""false"", ""true""); // .c_str()) = ::testing::Message();; //; // where AssertionResult is defined similarly to; //; // class AssertionResult {; // public:; // AssertionResult(const AssertionResult& other);; // explicit AssertionResult(bool success) : success_(success) {}; // operator bool() const { return success_; }; // ...; // private:; // bool success_;; // };; //; // In order for the analyzer to correctly handle this assertion, it needs to; // know that the boolean value of the expression ""a == b"" is stored the; // 'success_' field of the original AssertionResult temporary and propagated; // (via the copy constructor) into the 'success_' field of the object stored; // in 'gtest_ar_'. That boolean value will then be returned from the bool; // conversion method in the if statement. This guarantees that the assertion; // holds when the return path is not taken.; //; // If the success value is not properly propagated, then the eager case split; // on evaluating the expression can cause pernicious false positives; // on the non-return path:; //; // ASSERT(ptr != NULL); // *ptr = 7; // False positive null pointer dereference here; //; // Unfortunately, the bool constructor cannot be inlined (because its; // implementation is not present in the headers) and the copy constructor is; // not inlined (bec",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp:728,Message,Message,728,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GTestChecker.cpp,1,['Message'],['Message']
Integrability,"// Modify the CC from the wrapped function type, wrap it all back, and then; // wrap the whole thing in an AttributedType as written. The modified type; // might have a different CC if we ignored the attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:26,wrap,wrapped,26,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,3,['wrap'],"['wrap', 'wrapped']"
Integrability,// Module macros are listed in reverse dependency order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:39,depend,dependency,39,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['depend'],['dependency']
Integrability,"// More possible optimizations:; // Avoid call the virtual version of TBuffer::ReadInt and co.; // Merge the Reading of the version and the looking up or the StreamerInfo; // Avoid if (bytecnt) inside the CheckByteCount routines and avoid multiple (mostly useless nested calls); // Try to avoid if statement on onfile class being set (TBufferFile::ReadClassBuffer).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:220,rout,routines,220,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,1,['rout'],['routines']
Integrability,"// More testing of observable clones as integration variables. This time; // hitting the more general case where the algorithm also needs to find clients; // of the original variable correctly (""xShifted"" in this test).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRealIntegral.cxx:40,integrat,integration,40,roofit/roofitcore/test/testRooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRealIntegral.cxx,1,['integrat'],['integration']
Integrability,"// Most PIC code sequences that assume that a symbol is local cannot produce a; // 0 if it turns out the symbol is undefined. While this is ABI and relocation; // depended, it seems worth it to handle it here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:163,depend,depended,163,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['depend'],['depended']
Integrability,"// Most of the ObjectFile interfaces return an Expected<T>, so make it easy; // to ignore errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp:26,interface,interfaces,26,interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp,1,['interface'],['interfaces']
Integrability,"// Most of the public interface is provided via LoopInfoBase.; /// Update LoopInfo after removing the last backedge from a loop. This updates; /// the loop forest and parent loops for each block so that \c L is no longer; /// referenced, but does not actually delete \c L immediately. The pointer; /// will remain valid until this LoopInfo's memory is released.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:22,interface,interface,22,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,1,['interface'],['interface']
Integrability,"// Most of these wrappers support being invoked 3 ways:; // `distcc g++ file.c` This is the mode we're trying to match.; // We need to drop `distcc`.; // `distcc file.c` This acts like compiler is cc or similar.; // Clang's driver can handle this, no change needed.; // `g++ file.c` g++ is a symlink to distcc.; // We don't even notice this case, and all is well.; //; // We need to distinguish between the first and second case.; // The wrappers themselves don't take flags, so Args[1] is a compiler flag,; // an input file, or a compiler. Inputs have extensions, compilers don't.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp:17,wrap,wrappers,17,interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/JSONCompilationDatabase.cpp,2,['wrap'],['wrappers']
Integrability,"// Mostly, when a code-generation operation has a dependency on prior; // operations, it's because it uses the output values of those operations as; // inputs. But there's one exception, which is the use of 'seq' in Tablegen; // to indicate that operations have to be performed in sequence regardless of; // whether they use each others' output values.; //; // So, the actual generation of code is done by depth-first search, using the; // prerequisites() method to get a list of all the other Results that have to; // be computed before this one. That method divides into the 'predecessor',; // set by setPredecessor() while processing a 'seq' dag node, and the list; // returned by 'morePrerequisites', which each subclass implements to return; // a list of the Results it uses as input to whatever its own computation is; // doing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:50,depend,dependency,50,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,1,['depend'],['dependency']
Integrability,// Move In and its upward dependencies to before To.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:26,depend,dependencies,26,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['depend'],['dependencies']
Integrability,// Move all dependants to the error state and disconnect from them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:12,depend,dependants,12,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['depend'],['dependants']
Integrability,"// Move all memory accesses from `From` to `To` starting at `Start`.; // Restrictions apply, see public wrappers of this method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:104,wrap,wrappers,104,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,1,['wrap'],['wrappers']
Integrability,"// Move all the loads (and dependencies) to where the first load is.; // Clone all deps to before Where, keeping order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:27,depend,dependencies,27,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['depend'],['dependencies']
Integrability,// Move the COMDAT section to the wrapper.; // TODO: Check if we need to keep it for F as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:34,wrap,wrapper,34,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['wrap'],['wrapper']
Integrability,// Move the symbol into the error state.; // Note that this may be redundant: The symbol might already have been; // moved to this state in response to the failure of a dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:169,depend,dependence,169,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['depend'],['dependence']
Integrability,"// Move this over to the 'main' typeloc tree. Note that this is a; // move -- we pretend that we were really looking at the unqualified; // typeloc all along -- rather than a recursion, so we don't follow; // the normal CRTP plan of going through; // getDerived().TraverseTypeLoc. If we did, we'd be traversing; // twice for the same type (once as a QualifiedTypeLoc version of; // the type, once as an UnqualifiedTypeLoc version of the type),; // which in effect means we'd call VisitTypeLoc twice with the; // 'same' type. This solves that problem, at the cost of never; // seeing the qualified version of the type (unless the client; // subclasses TraverseQualifiedTypeLoc themselves). It's not a; // perfect solution. A perfect solution probably requires making; // QualifiedTypeLoc a wrapper around TypeLoc -- like QualType is a; // wrapper around Type* -- rather than being its own class in the; // type hierarchy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h:789,wrap,wrapper,789,interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h,2,['wrap'],['wrapper']
Integrability,// Moves COPY instructions on which depends; // the low latency instructions too.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:36,depend,depends,36,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['depend'],['depends']
Integrability,"// Multi-dimensional p.d.f.s through composition, e.g. substituting a; // p.d.f parameter with a function that depends on other observables; //; // pdf = gauss(x,f(y),s) with f(y) = a0 + a1*y",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:111,depend,depends,111,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['depend'],['depends']
Integrability,"// Multiplication is signedness-independent. However different ranges can be; // obtained depending on how the input ranges are treated. These different; // ranges are all conservatively correct, but one might be better than the; // other. We calculate two ranges; one treating the inputs as unsigned; // and the other signed, then return the smallest of these ranges.; // Unsigned range first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:90,depend,depending,90,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,1,['depend'],['depending']
Integrability,"// Multiply answer with integration ranges of factorized variables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:24,integrat,integration,24,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['integrat'],['integration']
Integrability,"// Multiply by fit range for 'real' dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:36,depend,dependents,36,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['depend'],['dependents']
Integrability,"// Multiply by number of states for category dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:45,depend,dependents,45,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['depend'],['dependents']
Integrability,"// Must depend on asymCat",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:8,depend,depend,8,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['depend'],['depend']
Integrability,"// Must return -1 if this is smaller than obj, 0 if objects are equal; // and 1 if this is larger than obj.; // smaller means more needing a new worker.; // Two cases are considered depending on; // relation between harddrive speed and network bandwidth.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx:182,depend,depending,182,proof/proofplayer/src/TPacketizerAdaptive.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx,1,['depend'],['depending']
Integrability,// Must set ivar's DeclContext to its enclosing interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,interface,interface,48,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['interface'],['interface']
Integrability,"// Must write out all protocol definitions in current qualifier list,; // and in their nested qualifiers before writing out current definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:22,protocol,protocol,22,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,3,['protocol'],['protocol']
Integrability,"// Mutexes to synchronize installing error handlers and calling error handlers.; // Do not use ManagedStatic, or that may allocate memory while attempting to; // report an OOM.; //; // This usage of std::mutex has to be conditionalized behind ifdefs because; // of this script:; // compiler-rt/lib/sanitizer_common/symbolizer/scripts/build_symbolizer.sh; // That script attempts to statically link the LLVM symbolizer library with the; // STL and hide all of its symbols with 'opt -internalize'. To reduce size, it; // cuts out the threading portions of the hermetic copy of libc++ that it; // builds. We can remove these ifdefs if that script goes away.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp:14,synchroniz,synchronize,14,interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,1,['synchroniz'],['synchronize']
Integrability,// N.B.: There is a dependency loop between the size of the TTBase uleb128; // here and the amount of padding before the aligned type table. The; // assembler must sometimes pad this uleb128 or insert extra padding; // before the type table. See PR35809 or GNU as bug 4029.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp:20,depend,dependency,20,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/EHStreamer.cpp,1,['depend'],['dependency']
Integrability,"// NAVIGATOR_TABLES; //----------------------------------------------------------------------; // Messages generated by the HTML widget; /*; class TGHtmlMessage : public OWidgetMessage {; public:; TGHtmlMessage(int t, int a, int i, const char *u, int rx, int ry) :; OWidgetMessage(t, a, i) {; uri = u;; x_root = rx;; y_root = ry;; }. public:; const char *uri;; //ORectangle bbox;; int x_root, y_root;; };; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h:98,Message,Messages,98,gui/guihtml/inc/TGHtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h,1,['Message'],['Messages']
Integrability,"// NN definition depends on individual methods. Important to have NO #ifndef if several BDT methods compile together; //fout << ""#endif"" << std::endl; commented out on purpose see previous line",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx:17,depend,depends,17,tmva/tmva/src/MethodBDT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx,1,['depend'],['depends']
Integrability,// NOTE: A co_await expression is dependent on the coroutines promise; // type and may be dependent even when the `Op` expression is not.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:34,depend,dependent,34,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,2,['depend'],['dependent']
Integrability,"// NOTE: EH_SJLJ_SETJMP/_LONGJMP supported here is NOT intended to support; // SjLj exception handling but a light-weight setjmp/longjmp replacement to; // support continuation, user-level threading, and etc.. As a result, no; // other SjLj exception interfaces are implemented and please don't build; // your own exception handling based on them.; // LLVM/Clang supports zero-cost DWARF exception handling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:251,interface,interfaces,251,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['interface'],['interfaces']
Integrability,// NOTE: This list has been synchronized with gcc-avr 5.4.0 and avr-libc 2.0.0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AVR.cpp:28,synchroniz,synchronized,28,interpreter/llvm-project/clang/lib/Basic/Targets/AVR.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AVR.cpp,1,['synchroniz'],['synchronized']
Integrability,// NOTE: This list has been synchronized with gcc-avr 7.3.0 and avr-libc 2.0.0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AVR.cpp:28,synchroniz,synchronized,28,interpreter/llvm-project/clang/lib/Driver/ToolChains/AVR.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AVR.cpp,1,['synchroniz'],['synchronized']
Integrability,"// NOTE: We use AfterClass (whereas AfterStruct exists) for both classes; // and structs, but it seems that wrapping is still handled correctly; // elsewhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:108,wrap,wrapping,108,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,1,['wrap'],['wrapping']
Integrability,"// NOTE: routine and part_id fields are initialized by __kmpc_omp_task_alloc(); // libcall.; // Build kmp_int32 __kmpc_omp_task_with_deps(ident_t *, kmp_int32 gtid,; // kmp_task_t *new_task, kmp_int32 ndeps, kmp_depend_info_t *dep_list,; // kmp_int32 ndeps_noalias, kmp_depend_info_t *noalias_dep_list) if dependence; // list is not empty",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:9,rout,routine,9,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,2,"['depend', 'rout']","['dependence', 'routine']"
Integrability,"// NOTE: routine and part_id fields are initialized by __kmpc_omp_task_alloc(); // libcall.; // Call to void __kmpc_taskloop(ident_t *loc, int gtid, kmp_task_t *task, int; // if_val, kmp_uint64 *lb, kmp_uint64 *ub, kmp_int64 st, int nogroup, int; // sched, kmp_uint64 grainsize, void *task_dup);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:9,rout,routine,9,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['rout'],['routine']
Integrability,"// NOTE: should probably just skip isysroot for dependency analysis.; // (And will, in the future - once we rely on compiler-generated .d files.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:48,depend,dependency,48,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['depend'],['dependency']
Integrability,"// NOTE: this uses the conversion-to-void* operator of; // zmq::socket_t, which returns the wrapped object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/src/ZeroMQPoller.cpp:92,wrap,wrapped,92,roofit/roofitZMQ/src/ZeroMQPoller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/src/ZeroMQPoller.cpp,2,['wrap'],['wrapped']
Integrability,"// NOTE: using MOs instead of regs to get rid of MF dependency to be able; // to use flat data structure.; // NOTE: replacing DenseMap with MapVector doesn't affect overall correctness; // but makes LITs more stable, should prefer DenseMap still due to; // significant perf difference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h:52,depend,dependency,52,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h,1,['depend'],['dependency']
Integrability,"// Name lookup did not find anything. However, if the; // nested-name-specifier refers to the current instantiation,; // and that current instantiation has any dependent base; // classes, we might find something at instantiation time: treat; // this as a dependent elaborated-type-specifier.; // But this only makes any sense for reference-like lookups.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:160,depend,dependent,160,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['depend'],['dependent']
Integrability,"// Name mismatch. We need a redirect. First grab the actual entry we want; // to return.; //; // This redirection logic intentionally leaks the external name of a; // redirected file that uses 'use-external-name' in \a; // vfs::RedirectionFileSystem. This allows clang to report the external; // name to users (in diagnostics) and to tools that don't have access to; // the VFS (in debug info and dependency '.d' files).; //; // FIXME: This is pretty complex and has some very complicated interactions; // with the rest of clang. It's also inconsistent with how ""real""; // filesystems behave and confuses parts of clang expect to see the; // name-as-accessed on the \a FileEntryRef.; //; // A potential plan to remove this is as follows -; // - Update callers such as `HeaderSearch::findUsableModuleForHeader()`; // to explicitly use the `getNameAsRequested()` rather than just using; // `getName()`.; // - Add a `FileManager::getExternalPath` API for explicitly getting the; // remapped external filename when there is one available. Adopt it in; // callers like diagnostics/deps reporting instead of calling; // `getName()` directly.; // - Switch the meaning of `FileEntryRef::getName()` to get the requested; // name, not the external name. Once that sticks, revert callers that; // want the requested name back to calling `getName()`.; // - Update the VFS to always return the requested name. This could also; // return the external name, or just have an API to request it; // lazily. The latter has the benefit of making accesses of the; // external path easily tracked, but may also require extra work than; // just returning up front.; // - (Optionally) Add an API to VFS to get the external filename lazily; // and update `FileManager::getExternalPath()` to use it instead. This; // has the benefit of making such accesses easily tracked, though isn't; // necessarily required (and could cause extra work than just adding to; // eg. `vfs::Status` up front).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:397,depend,dependency,397,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,1,['depend'],['dependency']
Integrability,// NameDecl is either a TemplateDecl or a UsingShadowDecl depending on the; // NameKind.; // !! There is no free low bits in 32-bit builds to discriminate more than 4; // pointer types in PointerUnion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateName.h:58,depend,depending,58,interpreter/llvm-project/clang/include/clang/AST/TemplateName.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateName.h,1,['depend'],['depending']
Integrability,"// Nasty workaround - The base computation code in the main algorithm doesn't; // consider the fact that a GEP can be used to convert a scalar to a vector.; // The right fix for this is to integrate GEPs into the base rewriting; // algorithm properly, this is just a short term workaround to prevent; // crashes by canonicalizing such GEPs into fully vector GEPs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:189,integrat,integrate,189,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['integrat'],['integrate']
Integrability,"// Need TNormalizedCtxt otherwise...; // Note: should we really be issuing a message here? Shouldn't; // the caller check and issue the message?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingBaseClassInfo.cxx:77,message,message,77,core/metacling/src/TClingBaseClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingBaseClassInfo.cxx,2,['message'],['message']
Integrability,"// Need accesses with constant stride. We don't want to vectorize; // ""A[B[i]] += ..."" and similar code or pointer arithmetic that could wrap; // in the address space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:137,wrap,wrap,137,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['wrap'],['wrap']
Integrability,"// Need to check for protocol refs (id <P>, Foo <P> *) in variable decls; // and cast exprs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:21,protocol,protocol,21,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['protocol'],['protocol']
Integrability,"// Need to compute max possible elements in address space, since that; // is included in diag message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:94,message,message,94,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['message'],['message']
Integrability,"// Need to convert argument into bits of control word:; // 0 Round to 0 -> 11; // 1 Round to nearest -> 00; // 2 Round to +inf -> 10; // 3 Round to -inf -> 01; // The 2-bit value needs then to be shifted so that it occupies bits 11:10.; // To make the conversion, put all these values into a value 0xc9 and shift; // it left depending on the rounding mode:; // (0xc9 << 4) & 0xc00 = X86::rmTowardZero; // (0xc9 << 6) & 0xc00 = X86::rmToNearest; // ...; // (0xc9 << (2 * NewRM + 4)) & 0xc00",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:325,depend,depending,325,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['depend'],['depending']
Integrability,"// Need to manually select the nodes that are dominated by the ISEL. Other; // nodes are reachable from the rest of the DAG, and so will be selected; // by the DAG selection routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:174,rout,routine,174,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['rout'],['routine']
Integrability,"// Need to remember the block before and after scan directive; // to dispatch them correctly depending on the clause used in; // this directive, inclusive or exclusive. For inclusive scan the natural; // order of the blocks is used, for exclusive clause the blocks must be; // executed in reverse order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:93,depend,depending,93,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['depend'],['depending']
Integrability,"// Need to wrap the value in an optional here as the value has to be default; // constructible, and std::unique_ptr doesn't like DarwinSDKInfo being; // Optional as Optional is trying to copy it in emplace.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DarwinSDKInfo.h:11,wrap,wrap,11,interpreter/llvm-project/clang/include/clang/Basic/DarwinSDKInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DarwinSDKInfo.h,1,['wrap'],['wrap']
Integrability,"// Needed for interface of base class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/FumiliGradientCalculator.cxx:14,interface,interface,14,math/minuit2/src/FumiliGradientCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/FumiliGradientCalculator.cxx,1,['interface'],['interface']
Integrability,// Negation preserves a recurrence's no self-wrap property.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:45,wrap,wrap,45,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,// Negative distances are not plausible dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:40,depend,dependencies,40,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['dependencies']
Integrability,"// Negative memlogfreq disable checks.; // If 0 is passed we try to have 100 messages about memory; // Otherwise we use the frequency passed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:77,message,messages,77,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,2,['message'],['messages']
Integrability,// Neither a type parameter list nor a list of protocol references is; // permitted here. Parse and diagnose them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:47,protocol,protocol,47,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['protocol'],['protocol']
Integrability,"// Nested-name-specifiers are intended to contain minimally-qualified; // types. An actual ElaboratedType will not occur, since we'll store; // just the type that is referred to in the nested-name-specifier (e.g.,; // a TypedefType, TagType, etc.). However, when we are dealing with; // dependent template-id types (e.g., Outer<T>::template Inner<U>),; // the type requires its own nested-name-specifier for uniqueness, so we; // suppress that nested-name-specifier during printing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp:287,depend,dependent,287,interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp,1,['depend'],['dependent']
Integrability,"// Neutral element for fminimum is Inf or FLT_MAX, depending on FMF.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:51,depend,depending,51,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['depend'],['depending']
Integrability,"// Neutral element for fminnum is NaN, Inf or FLT_MAX, depending on FMF.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:55,depend,depending,55,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,2,['depend'],['depending']
Integrability,"// Never outline calls to mcount. There isn't any rule that would require; // this, but the Linux kernel's ""ftrace"" feature depends on it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:124,depend,depends,124,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['depend'],['depends']
Integrability,// Never try to use the integrated assembler with CUDA; always fork out to; // ptxas.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:24,integrat,integrated,24,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,1,['integrat'],['integrated']
Integrability,// Never type-dependent (C++ [temp.dep.expr]p3).; // Value-dependent if the argument is type-dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:14,depend,dependent,14,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,3,['depend'],['dependent']
Integrability,// Never type-dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:14,depend,dependent,14,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,1,['depend'],['dependent']
Integrability,// New types for nonfragile abi messaging.; // MessageRefTy - LLVM for:; // struct _message_ref_t {; // IMP messenger;; // SEL name;; // };,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:47,Message,MessageRefTy,47,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['Message'],['MessageRefTy']
Integrability,"// NewMI may have dead implicit defs (E.g. EFLAGS for MOV<bits>r0 on X86).; // We need to remember these so we can add intervals once we insert; // NewMI into SlotIndexes.; //; // We also expect to have tied implicit-defs of super registers originating; // from SUBREG_TO_REG, such as:; // $edi = MOV32r0 implicit-def dead $eflags, implicit-def $rdi; // undef %0.sub_32bit = MOV32r0 implicit-def dead $eflags, implicit-def %0; //; // The implicit-def of the super register may have been reduced to; // subregisters depending on the uses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:515,depend,depending,515,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['depend'],['depending']
Integrability,"// Next solve u'*x = b, overwriting b with x.; //; // k is the main loop index, increasing from 0 to n-1 in steps of; // 1 or 2, depending on the size of the diagonal blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompBK.cxx:129,depend,depending,129,math/matrix/src/TDecompBK.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompBK.cxx,2,['depend'],['depending']
Integrability,"// Next test direct dependence",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:20,depend,dependence,20,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['depend'],['dependence']
Integrability,"// Next we query fast, specialized alias analyses that wrap IR-embedded; // information about aliasing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:55,wrap,wrap,55,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['wrap'],['wrap']
Integrability,"// Next, check for those instructions we can look through.; // Assuming the mask does not wrap around, then the higher-order bits are; // taken directly from the first operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:90,wrap,wrap,90,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['wrap'],['wrap']
Integrability,"// Next, check to see if the file is wrapped with #ifndef guards. If so, and; // if the macro that guards it is defined, we know the #include has no effect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:37,wrap,wrapped,37,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,1,['wrap'],['wrapped']
Integrability,"// Next, emit the actual diagnostic message and caret.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:36,message,message,36,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,1,['message'],['message']
Integrability,"// Next, we need to check for any protocol references.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:34,protocol,protocol,34,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,2,['protocol'],['protocol']
Integrability,"// Next, we want to figure out all of the sets to which we might belong.; // We might belong to a set if the noalias argument is in the set of; // underlying objects. If there is some non-noalias argument in our list; // of underlying objects, then we cannot add a scope because the fact; // that some access does not alias with any set of our noalias arguments; // cannot itself guarantee that it does not alias with this access; // (because there is some pointer of unknown origin involved and the; // other access might also depend on this pointer). We also cannot add; // scopes to arbitrary functions unless we know they don't access any; // non-parameter pointer-values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:528,depend,depend,528,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['depend'],['depend']
Integrability,// NextCallIndex has wrapped around.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:21,wrap,wrapped,21,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['wrap'],['wrapped']
Integrability,"// No DBG messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/TThreadPool.h:10,message,messages,10,core/thread/inc/TThreadPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/TThreadPool.h,1,['message'],['messages']
Integrability,"// No Merge interface, return copy of individual objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:12,interface,interface,12,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['interface'],['interface']
Integrability,"// No Merge interface, return individual objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:12,interface,interface,12,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['interface'],['interface']
Integrability,"// No deep copy required for the types of extra info set.; //; // FIXME: Investigate if other types of extra info also need deep copy. This; // depends on the types of nodes they can be attached to: if some extra info; // is only ever attached to nodes where a replacement To node is always the; // node where later use and propagation of the extra info has the intended; // semantics, no deep copy is required.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:144,depend,depends,144,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['depend'],['depends']
Integrability,"// No dependence found. If this is the entry block of the function, it is; // a clobber, otherwise it is unknown.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:6,depend,dependence,6,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// No dependence found. If this is the entry block of the function, it is; // unknown, otherwise it is non-local.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:6,depend,dependence,6,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,3,['depend'],['dependence']
Integrability,"// No dependence if the scaled distance is not multiple of the stride.; // E.g.; // for (i = 0; i < 1024 ; i += 4); // A[i+2] = A[i] + 1;; //; // Two accesses in memory (scaled distance is 2, stride is 4):; // | A[0] | | | | A[4] | | | |; // | | | A[2] | | | | A[6] | |; //; // E.g.; // for (i = 0; i < 1024 ; i += 3); // A[i+4] = A[i] + 1;; //; // Two accesses in memory (scaled distance is 4, stride is 3):; // | A[0] | | | A[3] | | | A[6] | | |; // | | | | | A[4] | | | A[7] | |",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:6,depend,dependence,6,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// No dependence, Delta < 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:6,depend,dependence,6,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// No dependence, newDelta < 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:6,depend,dependence,6,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,2,['depend'],['dependence']
Integrability,// No dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:6,depend,dependence,6,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['depend'],['dependence']
Integrability,// No dependencies between each other,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:6,depend,dependencies,6,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['depend'],['dependencies']
Integrability,"// No dependencies, so these calls cannot fail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp:6,depend,dependencies,6,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/IndirectionUtils.cpp,1,['depend'],['dependencies']
Integrability,// No idea what this is; we couldn't parse it as a lambda-introducer.; // Might still be an attribute-specifier or a message send.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:117,message,message,117,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['message'],['message']
Integrability,"// No integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooBCPEffDecay.cxx:6,integrat,integration,6,roofit/roofit/src/RooBCPEffDecay.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooBCPEffDecay.cxx,4,['integrat'],['integration']
Integrability,"// No integration performed, where the function is a direct value server",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:6,integrat,integration,6,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['integrat'],['integration']
Integrability,"// No integration scenario",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx:6,integrat,integration,6,roofit/roofitcore/src/RooAddModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx,3,['integrat'],['integration']
Integrability,// No interface-like type can have a method with a definition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:6,interface,interface-like,6,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,1,['interface'],['interface-like']
Integrability,// No jumps required if the message-send was noreturn.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:28,message,message-send,28,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['message'],['message-send']
Integrability,"// No need to byte swap here, since none of the math was endian-dependent.; // This number will be byte-swapped as required on endianness transitions,; // so we will see the same value on the other side.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp:64,depend,dependent,64,interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,1,['depend'],['dependent']
Integrability,// No need to check satisfaction for dependent constraint expressions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:37,depend,dependent,37,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,1,['depend'],['dependent']
Integrability,"// No need to do a handleReference for the objc method, because there will; // be a message expr as part of PseudoObjectExpr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexBody.cpp:84,message,message,84,interpreter/llvm-project/clang/lib/Index/IndexBody.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexBody.cpp,1,['message'],['message']
Integrability,"// No need to rebuild this clause, no template-dependent parameters.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:47,depend,dependent,47,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,17,['depend'],['dependent']
Integrability,"// No physical registers are allocated for instructions that are optimized; // in hardware. For example, zero-latency data-dependency breaking; // instructions don't consume physical registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp:123,depend,dependency,123,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,1,['depend'],['dependency']
Integrability,// No predecessor at the beginning of a trace. Ignore dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp:54,depend,dependencies,54,interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineTraceMetrics.cpp,1,['depend'],['dependencies']
Integrability,// No read-after-write dependency. The narrowing will add false dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:23,depend,dependency,23,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,2,['depend'],['dependency']
Integrability,"// No redeclaration check is needed here; in non-member contexts we; // diagnosed all possible conflicts with other using-declarations when; // building the template:; //; // For a dependent non-type using declaration, the only valid case is; // if we instantiate to a single enumerator. We check for conflicts; // between shadow declarations we introduce, and we check in the template; // definition for conflicts between a non-type using declaration and any; // other declaration, which together covers all cases.; //; // A dependent typename using declaration will never successfully; // instantiate, since it will always name a class member, so we reject; // that in the template definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:181,depend,dependent,181,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,2,['depend'],['dependent']
Integrability,"// No registered dependencies, so these calls cannot fail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LazyReexports.cpp:17,depend,dependencies,17,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LazyReexports.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LazyReexports.cpp,1,['depend'],['dependencies']
Integrability,// No self-wrap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:11,wrap,wrap,11,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['wrap'],['wrap']
Integrability,"// No sequencing is specified between the true and false expression.; // However since exactly one of both is going to be evaluated we can; // consider them to be sequenced. This is needed to avoid warning on; // something like ""x ? y+= 1 : y += 2;"" in the case where we will visit; // both the true and false expressions because we can't evaluate x.; // This will still allow us to detect an expression like (pre C++17); // ""(x ? y += 1 : y += 2) = y"".; //; // We don't wrap the visitation of the true and false expression with; // SequencedSubexpression because we don't want to downgrade modifications; // as side effect in the true and false expressions after the visition; // is done. (for example in the expression ""(x ? y++ : y++) + y"" we should; // not warn between the two ""y++"", but we should warn between the ""y++""; // and the ""y"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:471,wrap,wrap,471,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['wrap'],['wrap']
Integrability,// No signed with signed increment wrap; // (equivalent with SCEV::NSW),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:35,wrap,wrap,35,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['wrap'],['wrap']
Integrability,// No signed wrap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:13,wrap,wrap,13,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['wrap'],['wrap']
Integrability,"// No streamer info, give up.; // FIXME: We should have an error message here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:65,message,message,65,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['message'],['message']
Integrability,"// No such dataset: not an error, but don't send message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:49,message,message,49,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['message'],['message']
Integrability,// No summaries. Wrap up.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:17,Wrap,Wrap,17,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['Wrap'],['Wrap']
Integrability,// No unsigned with signed increment wrap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:37,wrap,wrap,37,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['wrap'],['wrap']
Integrability,// No unsigned wrap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:15,wrap,wrap,15,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['wrap'],['wrap']
Integrability,"// No viable function; fall through to handling this as a; // built-in operator, which will produce an error message for us.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:109,message,message,109,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['message'],['message']
Integrability,"// No way to inform linker though preprocessor :-(; // We could even inform the user:; /*; # define R__LOAD_LIBRARY(LIBRARY) \; _R_PragmaStr(message ""Compiler cannot handle linking against "" #LIBRARY \; "". Use -L and -l instead.""); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/Rtypes.h:141,message,message,141,core/base/inc/Rtypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/Rtypes.h,1,['message'],['message']
Integrability,"// No wrap",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValuePrinter.cpp:6,wrap,wrap,6,interpreter/cling/lib/Interpreter/ValuePrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValuePrinter.cpp,1,['wrap'],['wrap']
Integrability,"// No-one ever wants a using-declaration to name an injected-class-name; // of a base class, unless they're declaring an inheriting constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:52,inject,injected-class-name,52,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['inject'],['injected-class-name']
Integrability,"// No-op for RDefinePerSample: it never depends on systematic variations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefinePerSample.hxx:40,depend,depends,40,tree/dataframe/inc/ROOT/RDF/RDefinePerSample.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RDefinePerSample.hxx,1,['depend'],['depends']
Integrability,// No-wrap propagates only when all ops have no-wrap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:6,wrap,wrap,6,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,2,['wrap'],['wrap']
Integrability,// Non-clang command. Just pass through to the dependency; // consumer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:47,depend,dependency,47,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,1,['depend'],['dependency']
Integrability,"// Non-dependent member, but dependent template arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:7,depend,dependent,7,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,2,['depend'],['dependent']
Integrability,// Non-dependent types have nothing deducible,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:7,depend,dependent,7,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['depend'],['dependent']
Integrability,"// Non-generated observable dependent shift for partial generations; // mubar = mu1 + S12 S22Inv ( x2 - mu2)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx:28,depend,dependent,28,roofit/roofitcore/src/RooMultiVarGaussian.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx,1,['depend'],['dependent']
Integrability,"// Non-header phi nodes that have outside uses can be vectorized. Add; // them to the list of allowed exits.; // Unsafe cyclic dependencies with header phis are identified during; // legalization for reduction, induction and fixed order; // recurrences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:127,depend,dependencies,127,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['depend'],['dependencies']
Integrability,// Non-inbounds geps can wrap; wasm's offsets can't.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp:25,wrap,wrap,25,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFastISel.cpp,1,['wrap'],['wrap']
Integrability,// Non-instantiation-dependent traits are an <expr-primary> integer literal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:21,depend,dependent,21,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['depend'],['dependent']
Integrability,"// Non-instrumented alias of an instrumented function, or vice versa.; // Replace the alias with a native-ABI wrapper of the aliasee. The pass; // below will take care of instrumenting it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:110,wrap,wrapper,110,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,1,['wrap'],['wrapper']
Integrability,"// Non-local invariant group dependency indicates there is non local Def; // (it only returns nonLocal if it finds nonLocal def), which is better than; // local clobber and everything else.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:29,depend,dependency,29,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['dependency']
Integrability,// Non-type template parameters are either l-values or r-values; // depending on the type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:68,depend,depending,68,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['depend'],['depending']
Integrability,"// Non-type template parameters can be restricted by the value type, e.g.; // template <enum X> class A { ... };; // We have to be careful here, though, because we can be dealing with; // dependent types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:188,depend,dependent,188,interpreter/llvm-project/clang/lib/AST/Decl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp,1,['depend'],['dependent']
Integrability,"// None of the clients of this transformation can occur where; // there are dependent types, so skip dependent types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:76,depend,dependent,76,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,2,['depend'],['dependent']
Integrability,"// Nonsense to ""hide"" certain members of ObjCObjectType within this; // class. People asking for protocols on an ObjCInterfaceType are; // not going to get what they want: ObjCInterfaceTypes are; // guaranteed to have no protocols.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:97,protocol,protocols,97,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,2,['protocol'],['protocols']
Integrability,// Normalize the mask value depending on whether it's V1 or V2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:28,depend,depending,28,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['depend'],['depending']
Integrability,"// Normally we want to write to a side-car file ending in "".ifso"" so for; // example if `clang -emit-interface-stubs -shared -o libhello.so` were; // invoked then we would like to get libhello.so and libhello.ifso. If the; // stdout stream is given as the output file (ie `-o -`), that is the one; // exception where we will just append to the same filestream as the normal; // output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.cpp:101,interface,interface-stubs,101,interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/InterfaceStubs.cpp,1,['interface'],['interface-stubs']
Integrability,"// Normally whether or not a break before T is possible is calculated and; // stored in T.CanBreakBefore. Braces, array initializers and text proto; // messages like `key: < ... >` are an exception: a break is possible; // before a closing brace R if a break was inserted after the corresponding; // opening brace. The information about whether or not a break is needed; // before a closing brace R is stored in the ParenState field; // S.BreakBeforeClosingBrace where S is the state that R closes.; //; // In order to decide whether there can be a break before encountered right; // braces, this implementation iterates over the sequence of tokens and over; // the paren stack in lockstep, keeping track of the stack level which visited; // right braces correspond to in MatchingStackIndex.; //; // For example, consider:; // L. <- line number; // 1. {; // 2. {1},; // 3. {2},; // 4. {{3}}}; // ^ where we call this method with this token.; // The paren stack at this point contains 3 brace levels:; // 0. { at line 1, BreakBeforeClosingBrace: true; // 1. first { at line 4, BreakBeforeClosingBrace: false; // 2. second { at line 4, BreakBeforeClosingBrace: false,; // where there might be fake parens levels in-between these levels.; // The algorithm will start at the first } on line 4, which is the matching; // brace of the initial left brace and at level 2 of the stack. Then,; // examining BreakBeforeClosingBrace: false at level 2, it will continue to; // the second } on line 4, and will traverse the stack downwards until it; // finds the matching { on level 1. Then, examining BreakBeforeClosingBrace:; // false at level 1, it will continue to the third } on line 4 and will; // traverse the stack downwards until it finds the matching { on level 0.; // Then, examining BreakBeforeClosingBrace: true at level 0, the algorithm; // will stop and will use the second } on line 4 to determine the length to; // return, as in this example the range will include the tokens: {3}}; //; // The algo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:152,message,messages,152,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['message'],['messages']
Integrability,"// Not a lambda-introducer, might be a message send.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:39,message,message,39,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['message'],['message']
Integrability,"// Not a part of TFile interface; provide a forward declaration instead of #include.; // #ifndef R__LESS_INCLUDES; // #include ""TMap.h""; // #endif",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h:23,interface,interface,23,io/io/inc/TFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h,1,['interface'],['interface']
Integrability,"// Not all the recorded events are replayed.; // Some of them are generated automatically in ROOT; // as a consequence of other events.; //; // RETURN VALUE:; // - kTRUE = passed TRecGuiEvent *e should be filtered; // (should not be replayed); // - kFALSE = passed TRecGuiEvent *e should not be filtered; // (should be replayed); // We do not replay any client messages except closing of windows",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/src/TRecorder.cxx:361,message,messages,361,gui/recorder/src/TRecorder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/src/TRecorder.cxx,1,['message'],['messages']
Integrability,"// Not always safe to do this translation.; // DAG Builder attempts to reduce dependence edges using transitive; // nature of dependencies. Here is an example:; //; // r0 = tfr_pt ... (1); // r0 = tfr_pf ... (2); // r0 = tfr_pt ... (3); //; // There will be an output dependence between (1)->(2) and (2)->(3).; // However, there is no dependence edge between (1)->(3). This results; // in all 3 instructions going in the same packet. We ignore dependce; // only once to avoid this situation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:78,depend,dependence,78,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,5,['depend'],"['dependce', 'dependence', 'dependencies']"
Integrability,"// Not an architecture, nothing more to do.; // Disabling an architecture feature does not affect dependent features",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:98,depend,dependent,98,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,1,['depend'],['dependent']
Integrability,"// Not captured if the callee is readonly, doesn't return a copy through; // its return value and doesn't unwind (a readonly function can leak bits; // by throwing an exception or not depending on the input value).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:184,depend,depending,184,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,1,['depend'],['depending']
Integrability,"// Not found, or check that matching pdf observable is an l-value dependent on histogram observable fails",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHistFunc.cxx:66,depend,dependent,66,roofit/roofitcore/src/RooHistFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHistFunc.cxx,1,['depend'],['dependent']
Integrability,// Not to analyze dependent decl,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:18,depend,dependent,18,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,2,['depend'],['dependent']
Integrability,// Not to analyze dependent decl; // `FunctionDecl->hasBody()` returns true if the function has a body; // somewhere defined. But we want to know if this `Node` has a body; // child. So we use `doesThisDeclarationHaveABody`:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:18,depend,dependent,18,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['depend'],['dependent']
Integrability,// Not used. The function type depends on the active suspend.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h:31,depend,depends,31,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,1,['depend'],['depends']
Integrability,"// Not using the error logger, as there routine is meant to be called; // during library initialization/loading.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx:40,rout,routine,40,core/base/src/TObject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx,1,['rout'],['routine']
Integrability,// Note TableGen depends on the order above. Do not add or change the order; // without adding related code to TableGen/ClangAttrEmitter.cpp.; /// Context-sensitive version of a keyword attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/AttributeCommonInfo.h:17,depend,depends,17,interpreter/llvm-project/clang/include/clang/Basic/AttributeCommonInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/AttributeCommonInfo.h,1,['depend'],['depends']
Integrability,"// Note in previous implementation every time gDirectory was lookup in; // a thread, if it was set to nullptr it would be reset to gROOT. This; // was unexpected and this routine is not re-introducing this issue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TDirectory.cxx:171,rout,routine,171,core/base/src/TDirectory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TDirectory.cxx,1,['rout'],['routine']
Integrability,"// Note that 'i' here is actually the field index inside RD of Field,; // although this dependency is hidden.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:88,depend,dependency,88,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['depend'],['dependency']
Integrability,"// Note that Apple's kernel linker doesn't support symbol; // coalescing, so we need to avoid linkonce and weak linkages there.; // Normally, this means we just map to internal, but for explicit; // instantiations we'll map to external.; // In C++, the compiler has to emit a definition in every translation unit; // that references the function. We should use linkonce_odr because; // a) if all references in this translation unit are optimized away, we; // don't need to codegen it. b) if the function persists, it needs to be; // merged with other definitions. c) C++ has the ODR, so we know the; // definition is dependable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:617,depend,dependable,617,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['depend'],['dependable']
Integrability,// Note that Fuchsia never needs to link in sanitizer runtime deps. Any; // sanitizer runtimes with system dependencies use the `.deplibs` feature; // instead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp:107,depend,dependencies,107,interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp,1,['depend'],['dependencies']
Integrability,// Note that LHS might be a scalar because the routine calls not only in; // OpenCL case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:47,rout,routine,47,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['rout'],['routine']
Integrability,"// Note that `[]` wrapped input indicates a full context string, otherwise; // it's treated as context-less function name only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h:18,wrap,wrapped,18,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,1,['wrap'],['wrapped']
Integrability,"// Note that both field index and field length are 8-bit quantities.; // Since variables 'Index' and 'Length' are unsigned values; // obtained from zero-extending field index and field length; // respectively, their sum should never wrap around.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:233,wrap,wrap,233,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,2,['wrap'],['wrap']
Integrability,// Note that explicitly checking for `[[` and `]]` allows to fail as; // expected in the case of the Objective-C message send syntax.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:113,message,message,113,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['message'],['message']
Integrability,"// Note that this category has been deserialized. We do this before; // deserializing the interface declaration, so that it will consider this; /// category.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:90,interface,interface,90,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['interface'],['interface']
Integrability,"// Note that this function computes CanDoRT and MayNeedRTCheck; // independently. For example CanDoRT=false, MayNeedRTCheck=false means that; // we have a pointer for which we couldn't find the bounds but we don't; // actually need to emit any checks so it does not matter.; //; // We need runtime checks for this alias set, if there are at least 2; // dependence sets (in which case RunningDepId > 2) or if we need to re-try; // any bound checks (because in that case the number of dependence sets is; // incomplete).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:353,depend,dependence,353,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,2,['depend'],['dependence']
Integrability,// Note that we allow but don't require nullability on dependent types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:55,depend,dependent,55,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['depend'],['dependent']
Integrability,// Note that we can return a VariableArrayType here in the case where; // the element type was a dependent VariableArrayType.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:97,depend,dependent,97,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['depend'],['dependent']
Integrability,// Note that we do extended encoding of protocol qualifier list; // Only when doing ivar or property encoding.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:40,protocol,protocol,40,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['protocol'],['protocol']
Integrability,// Note that we don't wrap the expression with ExprWithCleanups here; // because that might interfere with tailcall contract (e.g. inserting; // clean up instructions in-between tailcall and return). Instead; // ExprWithCleanups is wrapped within maybeTailCall() prior to the resume; // call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:22,wrap,wrap,22,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,3,"['contract', 'wrap']","['contract', 'wrap', 'wrapped']"
Integrability,"// Note that, before C++17, a dependent exception specification does; // *not* make a type dependent; it's not even part of the C++ type; // system.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:30,depend,dependent,30,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,2,['depend'],['dependent']
Integrability,"// Note the optimization here of leaving row1 as the unrotated row, rather than; // row0. All the message loads below are adjusted to compensate for this. See; // discussion at https://github.com/sneves/blake2-avx2/pull/4",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_avx512.c:98,message,message,98,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_avx512.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_avx512.c,3,['message'],['message']
Integrability,"// Note this is called after the initial constructor of the; // MachineFunctionInfo based on the MachineFunction, which may depend on the; // IR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp:124,depend,depend,124,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIRParser.cpp,1,['depend'],['depend']
Integrability,"// Note we can't use the STRICT_FMA/STRICT_FMUL for the non-strict FDIV; // lowering. The chain dependence is insufficient, and we need glue. We do; // not need the glue variants in a strictfp function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:96,depend,dependence,96,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['depend'],['dependence']
Integrability,"// Note we could protect the arrays more by introducing a class TArrayWrapper<class T> which somehow knows; // its internal dimensions and check for them ...; // template <class T> TArrayWrapper {; // public:; // TArrayWrapper(void *where, int dim1);; // const T operator[](int i) {; // if (i>=dim1) return 0;; // return where[i];; // };; // };; // 2D array would actually be a wrapper of a wrapper i.e. has a method TArrayWrapper<T> operator[](int i);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TBranchProxy.h:378,wrap,wrapper,378,tree/treeplayer/inc/TBranchProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TBranchProxy.h,2,['wrap'],['wrapper']
Integrability,"// Note, IsDependent is always false here: we implicitly convert an 'auto'; // which has been deduced to a dependent type into an undeduced 'auto', so; // that we'll retry deduction after the transformation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:107,depend,dependent,107,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['depend'],['dependent']
Integrability,"// Note, essentially every kind of metadata should be preserved here! This; // routine is supposed to clone a load instruction changing *only its type*.; // The only metadata it makes sense to drop is metadata which is invalidated; // when the pointer type changes. This should essentially never be the case; // in LLVM, but we explicitly switch over only known metadata to be; // conservatively correct. If you are adding metadata to LLVM which pertains; // to loads, you almost certainly want to add it here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:79,rout,routine,79,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['rout'],['routine']
Integrability,"// Note, essentially every kind of metadata should be preserved here! This; // routine is supposed to clone a store instruction changing *only its; // type*. The only metadata it makes sense to drop is metadata which is; // invalidated when the pointer type changes. This should essentially; // never be the case in LLVM, but we explicitly switch over only known; // metadata to be conservatively correct. If you are adding metadata to; // LLVM which pertains to stores, you almost certainly want to add it; // here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:79,rout,routine,79,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['rout'],['routine']
Integrability,"// Note, in C89, this production uses the constant-expr production instead; // of assignment-expr. The only difference is that assignment-expr allows; // things like '=' and '*='. Sema rejects these in C89 mode because they; // are not i-c-e's, so we don't need to distinguish between the two here.; // Parse the constant-expression or assignment-expression now (depending; // on dialect).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:363,depend,depending,363,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['depend'],['depending']
Integrability,"// Note, the properties declared only in class extensions are still copied; // into the main @interface's property list, and therefore we don't; // explicitly, have to search class extension properties.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:94,interface,interface,94,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,1,['interface'],['interface']
Integrability,"// Note, we need to check for DependentSizedArrayType explicitly here; // because we use a DependentSizedArrayType with no size expression as the; // type of a dependent array of unknown bound with a dependent braced; // initializer:; //; // template<int ...N> int arr[] = {N...};",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:30,Depend,DependentSizedArrayType,30,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,4,"['Depend', 'depend']","['DependentSizedArrayType', 'dependent']"
Integrability,"// Note. We do not pass any format to DWARFExpression, even if the; // corresponding unit is known. For now, there is only one operation,; // DW_OP_call_ref, which depends on the format; it is rarely used, and; // is unexpected in location tables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLoc.cpp:164,depend,depends,164,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLoc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLoc.cpp,1,['depend'],['depends']
Integrability,"// Note. We do not pass the DWARF format to DWARFExpression, because; // DW_OP_call_ref, the only operation which depends on the format, is; // prohibited in call frame instructions, see sec. 6.4.2 in DWARFv5.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugFrame.cpp:114,depend,depends,114,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugFrame.cpp,2,['depend'],['depends']
Integrability,// Note: An empty range is implicitly converted to unknown or undef depending; // on MayIncludeUndef internally.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:68,depend,depending,68,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['depend'],['depending']
Integrability,"// Note: No fusion-preventing memory dependencies are expected in either; // region. Such dependencies should be rejected during earlier dependence; // checks, which guarantee accesses can be re-ordered for vectorization.; //; // Move recipes to the successor region.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:37,depend,dependencies,37,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,3,['depend'],"['dependence', 'dependencies']"
Integrability,"// Note: Removability is highly dependent on the source language. For; // example, recent C++ requires direct calls to the global allocation; // [basic.stc.dynamic.allocation] to be observable unless part of a new; // expression [expr.new paragraph 13].; // Historically we've treated the C family allocation routines and operator; // new as removable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:32,depend,dependent,32,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,2,"['depend', 'rout']","['dependent', 'routines']"
Integrability,// Note: The logic here must be synchronized with the code in the; // branch-selection pass which sets the offset of the first block in the; // function. This matters because it affects the alignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:32,synchroniz,synchronized,32,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,1,['synchroniz'],['synchronized']
Integrability,"// Note: This dereference operator returns a value instead of a reference; // and does not strictly conform to the C++17's definition of forward; // iterator. However, it satisfies all the forward_iterator requirements; // that the `zip_common` depends on and fully conforms to the C++20; // definition of forward iterator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:245,depend,depends,245,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['depend'],['depends']
Integrability,// Note: This routine is implemented here because we need both NamedDecl; // and Redeclarable to be defined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:14,rout,routine,14,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['rout'],['routine']
Integrability,"// Note: We always create a new anonymous root here. This is true regardless; // of the linkage of the callee because the aliasing ""scope"" is not just a; // property of the callee, but also all control dependencies in the caller.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:202,depend,dependencies,202,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['depend'],['dependencies']
Integrability,"// Note: if the NNS has a prefix and ClsType is a nondependent; // TemplateSpecializationType, then the NNS prefix is NOT included; // in ClsType; hence we wrap ClsType into an ElaboratedType.; // NOTE: in particular, no wrap occurs if ClsType already is an; // Elaborated, DependentName, or DependentTemplateSpecialization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:156,wrap,wrap,156,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,4,"['Depend', 'wrap']","['DependentName', 'DependentTemplateSpecialization', 'wrap']"
Integrability,"// Note: it's often necessary to strip `Dependent` from qualifiers.; // If V<T>:: refers to the current instantiation, NNS is considered dependent; // but the containing V<T>::foo likely isn't.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:40,Depend,Dependent,40,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,2,"['Depend', 'depend']","['Dependent', 'dependent']"
Integrability,"// Note: semantic analysis depends on Objective-C lifetime types to be; // considered scalar types. However, such types do not actually behave; // like scalar types at run time (since they may require retain/release; // operations), so we report them as non-scalar.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:27,depend,depends,27,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['depend'],['depends']
Integrability,"// Note: this adds pointers to the hash using sizes and endianness that; // depend on the host. It doesn't matter, however, because hashing on; // pointer values is inherently unstable. Nothing should depend on the; // ordering of nodes in the folding set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:76,depend,depend,76,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,2,['depend'],['depend']
Integrability,"// Note: this writes out all references even for a dependent AST. But it is; // very tricky to fix, and given that @selector shouldn't really appear in; // headers, probably not worth it. It's not a correctness issue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:51,depend,dependent,51,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['depend'],['dependent']
Integrability,"// Note: we don't know the offset at the start of the entry block since the; // prologue hasn't been inserted yet, and how much that will adjust the stack; // pointer depends on register spills, which have not been computed yet.; // Compute the reverse post-order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp:167,depend,depends,167,interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp,1,['depend'],['depends']
Integrability,// Note: we treat a statement-expression in a dependent context as always; // being value- and instantiation-dependent. This matches the behavior of; // lambda-expressions and GCC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:46,depend,dependent,46,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,2,['depend'],['dependent']
Integrability,"// Nothing can be done if empty message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:32,message,message,32,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['message'],['message']
Integrability,"// Notification message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:16,message,message,16,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,2,['message'],['message']
Integrability,// Notify any writes that are in a false dependency with this write.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Instruction.cpp:41,depend,dependency,41,interpreter/llvm-project/llvm/lib/MCA/Instruction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Instruction.cpp,1,['depend'],['dependency']
Integrability,// Notify data dependent successors that this group has finished execution.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:15,depend,dependent,15,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,1,['depend'],['dependent']
Integrability,"// Now action depends on method ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:14,depend,depends,14,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['depend'],['depends']
Integrability,"// Now add each dependency in the order it was seen, but avoiding; // duplicates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:16,depend,dependency,16,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,1,['depend'],['dependency']
Integrability,"// Now apply the information from the collected conditions to RewriteMap.; // Conditions are processed in reverse order, so the earliest conditions is; // processed first. This ensures the SCEVs with the shortest dependency chains; // are constructed first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:213,depend,dependency,213,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['depend'],['dependency']
Integrability,"// Now find direct integrator for relevant components ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:19,integrat,integrator,19,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['integrat'],['integrator']
Integrability,"// Now integrate PDF in each bin:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx:7,integrat,integrate,7,roofit/roofitcore/src/RooBinSamplingPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx,1,['integrat'],['integrate']
Integrability,"// Now iteratively merge groups that should be (partially) integrated together",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:59,integrat,integrated,59,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['integrat'],['integrated']
Integrability,"// Now modify the original list to represent the final order that; // we want. The order will depend on whether we're going to access them; // from the stack pointer or the frame pointer. For SP, the list should; // end up with the END containing objects that we want with smaller offsets.; // For FP, it should be flipped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:94,depend,depend,94,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['depend'],['depend']
Integrability,"// Now need to have in ASIMOV the data sets also the global observables; // Their values must be the one satisfying the constraint.; // to do it make a nuisance pdf with all product of constraints and then; // assign to each constraint a glob observable value = to the current fitted nuisance parameter value; // IN general one should solve in general the system of equations f( gobs| nuispar ) = 0 where f are the; // derivatives of the constraint with respect the nuisance parameter and they are evaluated at the best fit nuisance; // parameter points; // As simple solution assume that constrain has a direct dependence on the nuisance parameter, i.e.; // Constraint (gobs, func( nuispar) ) and the condition is satisfied for; // gobs = func( nuispar) where nunispar is at the MLE value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/AsymptoticCalculator.cxx:612,depend,dependence,612,roofit/roostats/src/AsymptoticCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/AsymptoticCalculator.cxx,1,['depend'],['dependence']
Integrability,"// Now read the client protocol",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:23,protocol,protocol,23,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['protocol'],['protocol']
Integrability,"// Now retrieve codes for integration over common set of analytically integrable observables for each component",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx:26,integrat,integration,26,roofit/roofitcore/src/RooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx,1,['integrat'],['integration']
Integrability,// Now see if there are no other dependencies to instructions already; // in the packet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:33,depend,dependencies,33,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,1,['depend'],['dependencies']
Integrability,// Now see if there are no other dependencies; // to instructions already in the packet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp:33,depend,dependencies,33,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,1,['depend'],['dependencies']
Integrability,"// Now select between End and null, depending on whether the character; // was found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp:36,depend,depending,36,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSelectionDAGInfo.cpp,1,['depend'],['depending']
Integrability,// Now select the specific element. By adding HalfLaneElts bits from; // the immediate. Wrapping around the immediate every 8-bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:88,Wrap,Wrapping,88,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,1,['Wrap'],['Wrapping']
Integrability,"// Now substitute the dependent function parameter types given defaultTemplateArgs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx:22,depend,dependent,22,core/metacling/src/TClingMethodInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx,1,['depend'],['dependent']
Integrability,"// Now that all TClass-es know how to set them up we can update; // existing TClasses, which might cause the creation of e.g. TBaseClass; // objects which in turn requires the creation of TClasses, that could; // come from the PCH, but maybe later in the loop. Instead of resolving; // a dependency graph the addition to the TClassTable above allows us; // to create these dependent TClasses as needed below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:288,depend,dependency,288,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,2,['depend'],"['dependency', 'dependent']"
Integrability,"// Now that the element types match, get the shuffle mask and RHS of the; // shuffle to use, which depends on whether we're increasing or decreasing the; // size of the input.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:99,depend,depends,99,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['depend'],['depends']
Integrability,"// Now that we are sorted by complexity, group elements of the same; // complexity. Note that this is, at worst, N^2, but the vector is likely to; // be extremely short in practice. Note that we take this approach because we; // do not want to depend on the addresses of the objects we are grouping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:244,depend,depend,244,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['depend'],['depend']
Integrability,"// Now that we have all the results generated, select the one that should be; // returned for the current depending action.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:106,depend,depending,106,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['depend'],['depending']
Integrability,"// Now that we have the final set of dependents, call checkObservables(); // WVE take out conditional observables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:37,depend,dependents,37,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['depend'],['dependents']
Integrability,"// Now that we've computed the total offset, add it to the base pointer (with; // wrapping semantics).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:82,wrap,wrapping,82,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['wrap'],['wrapping']
Integrability,// Now try assuming that any undefined bits between the first and; // last defined set bits are set. This increases the chances of; // using a non-wraparound mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:147,wrap,wraparound,147,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['wrap'],['wraparound']
Integrability,"// Now try to schedule the new bundle or (if no bundle) just calculate; // dependencies. As soon as the bundle is ""ready"" it means that there are no; // cyclic dependencies and we can schedule it. Note that's important that we; // don't ""schedule"" the bundle yet (see cancelScheduling).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:75,depend,dependencies,75,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['depend'],['dependencies']
Integrability,// Now walk the functions in this SCC and invalidate any function analysis; // results that might have outer dependencies on an SCC analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:109,depend,dependencies,109,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,1,['depend'],['dependencies']
Integrability,"// Now we are certain that the module and all modules it depends on are; // up-to-date. For implicitly-built module files, ensure the corresponding; // timestamp files are up-to-date in this build session.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:57,depend,depends,57,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['depend'],['depends']
Integrability,"// Now we error out, first checking if we did not get a more specific; // error message from SearchBranchWithCompositeName. If not, we go with; // a generic message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx:80,message,message,80,tree/treeplayer/src/TTreeReaderValue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx,2,['message'],['message']
Integrability,// Now we fix the mismatches by wrapping calls with inner try-delegates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:32,wrap,wrapping,32,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,1,['wrap'],['wrapping']
Integrability,"// Now we have the active view as IVsTextView, but the text interfaces we need; // are in the IWpfTextView.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/Vsix.cs:60,interface,interfaces,60,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/Vsix.cs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/Vsix.cs,1,['interface'],['interfaces']
Integrability,"// Now we know that the input and output vectors are both integer vectors; // of the same size, and that their #elements is not the same. Do the; // conversion here, which depends on whether the input or output has; // more elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:172,depend,depends,172,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['depend'],['depends']
Integrability,"// Now we need to emit a pair of load and stores for each of the types we've; // collected. I.e. for each type, generate a load from the source pointer of; // that type width, and then generate a corresponding store to the dest buffer; // of that value loaded. This can result in a sequence of loads and stores; // mixed types, depending on what the target specifies as good types to use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:328,depend,depending,328,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['depend'],['depending']
Integrability,"// Now we've got the correct types on both sides, check their compatibility.; // This means that the source of the conversion can only throw a subset of; // the exceptions of the target, and any exception specs on arguments or; // return types must be equivalent.; //; // FIXME: If there is a nested dependent exception specification, we should; // not be checking it here. This is fine:; // template<typename T> void f() {; // void (*p)(void (*) throw(T));; // void (*q)(void (*) throw(int)) = p;; // }; // ... because it might be instantiated with T=int.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:300,depend,dependent,300,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,1,['depend'],['dependent']
Integrability,"// Now, work out if the instruction causes a SPR->DPR dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp:54,depend,dependency,54,interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp,1,['depend'],['dependency']
Integrability,"// Null-ness for function memptrs only depends on the first field, which is; // the function pointer. The rest don't matter, so we can zero initialize.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:39,depend,depends,39,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['depend'],['depends']
Integrability,// Nullability inference depends on the type and declarator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:25,depend,depends,25,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['depend'],['depends']
Integrability,// Nullable `Class` expressions cannot be messaged with a direct method; // so the only reason why the receive can be null would be because; // of weak linking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:42,message,messaged,42,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,2,['message'],['messaged']
Integrability,"// Number entry for Rout",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geombuilder/inc/TGeoHypeEditor.h:20,Rout,Rout,20,geom/geombuilder/inc/TGeoHypeEditor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geombuilder/inc/TGeoHypeEditor.h,2,['Rout'],['Rout']
Integrability,// Number of cycles left before RegisterID can be read. This value depends on; // the latency of all the dependent writes. It defaults to UNKNOWN_CYCLES.; // It gets set to the value of field TotalCycles only when the 'CyclesLeft' of; // every dependent write is known.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:67,depend,depends,67,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,3,['depend'],"['dependent', 'depends']"
Integrability,"// Number of writes that contribute to the definition of RegisterID.; // In the absence of partial register updates, the number of DependentWrites; // cannot be more than one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:131,Depend,DependentWrites,131,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,1,['Depend'],['DependentWrites']
Integrability,"// Numeric Integrator configuration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooNumIntConfig.h:11,Integrat,Integrator,11,roofit/roofitcore/inc/RooNumIntConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooNumIntConfig.h,1,['Integrat'],['Integrator']
Integrability,"// Numeric Integrator factory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooNumIntFactory.h:11,Integrat,Integrator,11,roofit/roofitcore/inc/RooNumIntFactory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooNumIntFactory.h,1,['Integrat'],['Integrator']
Integrability,"// Numeric built-ins; // BuiltinSymbolMap[""@cpu""] = BI_CPU;; // BuiltinSymbolMap[""@interface""] = BI_INTERFACE;; // BuiltinSymbolMap[""@wordsize""] = BI_WORDSIZE;; // BuiltinSymbolMap[""@codesize""] = BI_CODESIZE;; // BuiltinSymbolMap[""@datasize""] = BI_DATASIZE;; // BuiltinSymbolMap[""@model""] = BI_MODEL;; // Text built-ins; // BuiltinSymbolMap[""@code""] = BI_CODE;; // BuiltinSymbolMap[""@data""] = BI_DATA;; // BuiltinSymbolMap[""@fardata?""] = BI_FARDATA;; // BuiltinSymbolMap[""@stack""] = BI_STACK;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp:83,interface,interface,83,interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,1,['interface'],['interface']
Integrability,"// Numeric integrator configuration specific for this object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:11,integrat,integrator,11,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,1,['integrat'],['integrator']
Integrability,"// Numerical and optional Analytical integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:37,integrat,integration,37,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['integrat'],['integration']
Integrability,"// Numerical integrator workspace",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinIntegrator.h:13,integrat,integrator,13,roofit/roofitcore/src/RooBinIntegrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinIntegrator.h,1,['integrat'],['integrator']
Integrability,"// OK if conversion of LHS to SuperClass results in narrowing of types; // ; i.e., SuperClass may implement at least one of the protocols; // in LHS's protocol list. Example, SuperObj<P1> = lhs<P1,P2> is ok.; // But not SuperObj<P1,P2,P3> = lhs<P1,P2>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:128,protocol,protocols,128,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,2,['protocol'],"['protocol', 'protocols']"
Integrability,"// OOB message inline",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TSystem.h:7,message,message,7,core/base/inc/TSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TSystem.h,1,['message'],['message']
Integrability,// ObjC Messages handles in a different callback.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:8,Message,Messages,8,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,1,['Message'],['Messages']
Integrability,"// ObjC interfaces are incomplete if they are @class, not @interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:8,interface,interfaces,8,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,2,['interface'],"['interface', 'interfaces']"
Integrability,// ObjC interfaces have structs underlying them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:8,interface,interfaces,8,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,1,['interface'],['interfaces']
Integrability,"// ObjC keyword ('protocol' in '@protocol') or builtin (__builtin_inf).; // First NUM_OBJC_KEYWORDS values are for Objective-C,; // the remaining values are for builtins.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h:18,protocol,protocol,18,interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,2,['protocol'],['protocol']
Integrability,// ObjC message is an rvalue,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:8,message,message,8,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['message'],['message']
Integrability,"// ObjC message send. We assume nobody will use : in a C++11 attribute; // specifier parameter, although this is technically valid:; // [[foo(:)]].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:8,message,message,8,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['message'],['message']
Integrability,"// ObjC message sends are effectively function calls, if the target function; // is known.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:8,message,message,8,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,1,['message'],['message']
Integrability,"// ObjC message sends are like function calls, but never have exception; // specs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:8,message,message,8,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,1,['message'],['message']
Integrability,"// ObjC2 allows prefix attributes on class interfaces and protocols.; // FIXME: This still needs better diagnostics. We should only accept; // attributes here, no types, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:43,interface,interfaces,43,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,2,"['interface', 'protocol']","['interfaces', 'protocols']"
Integrability,"// ObjCForCollectionStmts are processed in two places. This method; // handles the case where an ObjCForCollectionStmt* occurs as one of the; // statements within a basic block. This transfer function does two things:; //; // (1) binds the next container value to 'element'. This creates a new; // node in the ExplodedGraph.; //; // (2) note whether the collection has any more elements (or in other words,; // whether the loop has more iterations). This will be tested in; // processBranch.; //; // FIXME: Eventually this logic should actually do dispatches to; // 'countByEnumeratingWithState:objects:count:' (NSFastEnumeration).; // This will require simulating a temporary NSFastEnumerationState, either; // through an SVal or through the use of MemRegions. This value can; // be affixed to the ObjCForCollectionStmt* instead of 0/1; when the loop; // terminates we reclaim the temporary (it goes out of scope) and we; // we can test if the SVal is 0 or if the MemRegion is null (depending; // on what approach we take).; //; // For now: simulate (1) by assigning either a symbol or nil if the; // container is empty. Thus this transfer function will by default; // result in state splitting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:984,depend,depending,984,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,1,['depend'],['depending']
Integrability,// ObjCInterfaceType is never dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:30,depend,dependent,30,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['depend'],['dependent']
Integrability,"// ObjCObjectType.NumTypeArgs - the number of type arguments stored; // after the ObjCObjectPointerType node.; // ObjCObjectType.NumProtocols - the number of protocols stored; // after the type arguments of ObjCObjectPointerType node.; //; // These protocols are those written directly on the type. If; // protocol qualifiers ever become additive, the iterators will need; // to get kindof complicated.; //; // In the canonical object type, these are sorted alphabetically; // and uniqued.; /// Either a BuiltinType or an InterfaceType or sugar for either.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:158,protocol,protocols,158,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,4,"['Interface', 'protocol']","['InterfaceType', 'protocol', 'protocols']"
Integrability,// ObjCSubscript build stuff.; //; /// objective-c subscripting-specific behavior for doing lvalue-to-rvalue; /// conversion.; /// FIXME. Remove this routine if it is proven that no additional; /// specifity is needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:150,rout,routine,150,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,1,['rout'],['routine']
Integrability,"// Object to manage the fitter depending on the options used",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx:31,depend,depending,31,test/stressHistoFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx,1,['depend'],['depending']
Integrability,// Objective-C classes and protocols with the same name always match.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:27,protocol,protocols,27,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['protocol'],['protocols']
Integrability,"// Objective-C doesn't allow an @interface for a class after its; // @implementation. So if Method is not defined and there already is; // an entry for this type signature, Method has to be for a different; // class than PrevObjCMethod.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:33,interface,interface,33,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['interface'],['interface']
Integrability,"// Objective-C interfaces are always opaque (outside of the; // runtime, which can do whatever it likes); we never refine; // these.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp:15,interface,interfaces,15,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp,1,['interface'],['interfaces']
Integrability,// Objective-C interfaces can be used in a class property expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:15,interface,interfaces,15,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,1,['interface'],['interfaces']
Integrability,// Objective-C interfaces names are not filtered by this method because they; // can be used in a class property expression. We can still filter out; // @class declarations though.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:15,interface,interfaces,15,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['interface'],['interfaces']
Integrability,"// Objective-C++: If one interface is more specific than the; // other, it is the better one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:25,interface,interface,25,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['interface'],['interface']
Integrability,"// Objective-C++:; // After a '.' in a member access expression, treat the keyword; // 'class' as if it were an identifier.; //; // This hack allows property access to the 'class' method because it is; // such a common method name. For other C++ keywords that are; // Objective-C method names, one must use the message send syntax.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:311,message,message,311,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['message'],['message']
Integrability,"// Observables that cannot be integrated analytically by this component are dropped from the common list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx:30,integrat,integrated,30,roofit/roofitcore/src/RooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx,1,['integrat'],['integrated']
Integrability,"// Obtain mutual exclusive dependence by iterative reduction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:27,depend,dependence,27,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['depend'],['dependence']
Integrability,"// Of the 4 Store Operands:; // * Chain (Op 0) -> We have already considered these; // in candidate selection, but only by following the; // chain dependencies. We could still have a chain; // dependency to a load, that has a non-chain dep to; // another load, that depends on a store, etc. So it is; // possible to have dependencies that consist of a mix; // of chain and non-chain deps, and we need to include; // chain operands in the analysis here..; // * Value (Op 1) -> Cycles may happen (e.g. through load chains); // * Address (Op 2) -> Merged addresses may only vary by a fixed constant,; // but aren't necessarily fromt the same base node, so; // cycles possible (e.g. via indexed store).; // * (Op 3) -> Represents the pre or post-indexing offset (or undef for; // non-indexed stores). Not constant on all targets (e.g. ARM); // and so can participate in a cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:147,depend,dependencies,147,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,4,['depend'],"['dependencies', 'dependency', 'depends']"
Integrability,// Offer a Copy fix even if the type is dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:40,depend,dependent,40,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['depend'],['dependent']
Integrability,// Offload action set its own kinds on their dependences.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Action.cpp:45,depend,dependences,45,interpreter/llvm-project/clang/lib/Driver/Action.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Action.cpp,2,['depend'],['dependences']
Integrability,// Offset carried by the traversal routines when dealing with streams.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp:35,rout,routines,35,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,1,['rout'],['routines']
Integrability,"// Offset will hold the offset from the stack pointer at function entry to the; // object.; // We need to factor in additional offsets applied during the prologue to the; // frame, base, and stack pointer depending on which is used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:205,depend,depending,205,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,2,['depend'],['depending']
Integrability,"// Ok, this is a two entry PHI node. Check to see if this is a simple ""if; // statement"", which has a very simple dominance structure. Basically, we; // are trying to find the condition that is being branched on, which; // subsequently causes this merge to happen. We really want control; // dependence information for this check, but simplifycfg can't keep it up; // to date, and this catches most of the cases we care about anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:292,depend,dependence,292,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['depend'],['dependence']
Integrability,"// Okay, we have an unused result. Depending on what the base expression is,; // we might want to make a more specific diagnostic. Check for one of these; // cases now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:35,Depend,Depending,35,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['Depend'],['Depending']
Integrability,"// Okay, we're done with the designator sequence. We know that there must be; // at least one designator, because the only case we can get into this method; // without a designator is when we have an objc message send. That case is; // handled and returned from above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:205,message,message,205,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,1,['message'],['message']
Integrability,"// Okay, we've found the binding. Emit an appropriate message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:54,message,message,54,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,2,['message'],['message']
Integrability,"// Okay: this is some kind of implicit downcast of Objective-C; // interfaces, which is permitted. However, we're going to; // complain about it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:67,interface,interfaces,67,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['interface'],['interfaces']
Integrability,// Okay: we'll build a dependent expression type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:23,depend,dependent,23,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['depend'],['dependent']
Integrability,"// Old Protocol; // Send username",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:7,Protocol,Protocol,7,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['Protocol'],['Protocol']
Integrability,// Omit if the constant has more than 2 uses. This a conservative; // decision. Whether it is a win depends on the HW microarchitecture.; // However it should always be better for 1 and 2 uses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:100,depend,depends,100,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['depend'],['depends']
Integrability,"// On AIX, except if constinit and also neither of class type or of; // (possibly multi-dimensional) array of class type, thread_local vars; // will have init routines regardless of whether they are; // const-initialized. Since the routine is guaranteed to exist, we can; // unconditionally call it without testing for its existance. This; // avoids potentially unresolved weak symbols which the AIX linker; // isn't happy with.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:159,rout,routines,159,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,2,['rout'],"['routine', 'routines']"
Integrability,"// On AIX, we have a region handle (symbol@m) and the variable offset; // (symbol@{gd|ie|le}) for TLS variables, depending on the TLS model.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp:113,depend,depending,113,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCMCTargetDesc.cpp,1,['depend'],['depending']
Integrability,"// On Darwin platforms, wrap the expanded sequence in a bundle to prevent; // later optimizations from breaking up the sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:24,wrap,wrap,24,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,1,['wrap'],['wrap']
Integrability,"// On Darwin, unlike other Itanium C++ ABI platforms, the thread-wrapper; // function is only defined alongside the variable, not also alongside; // callers. Normally, all accesses to a thread_local go through the; // thread-wrapper in order to ensure initialization has occurred, underlying; // variable will never be used other than the thread-wrapper, so it can be; // converted to internal linkage.; //; // However, if the variable has the 'constinit' attribute, it _can_ be; // referenced directly, without calling the thread-wrapper, so the linkage; // must not be changed.; //; // Additionally, if the variable isn't plain external linkage, e.g. if it's; // weak or linkonce, the de-duplication semantics are important to preserve,; // so we don't change the linkage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:65,wrap,wrapper,65,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,4,['wrap'],['wrapper']
Integrability,"// On ELF we pass the dependent library specifiers directly to the linker; // without manipulating them. This is in contrast to other platforms where; // they are mapped to a specific linker option by the compiler. This; // difference is a result of the greater variety of ELF linkers and the fact; // that ELF linkers tend to handle libraries in a more complicated fashion; // than on other platforms. This forces us to defer handling the dependent; // libs to the linker.; //; // CUDA/HIP device and host libraries are different. Currently there is no; // way to differentiate dependent libraries for host or device. Existing; // usage of #pragma comment(lib, *) is intended for host libraries on; // Windows. Therefore emit llvm.dependent-libraries only for host.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:22,depend,dependent,22,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,4,['depend'],"['dependent', 'dependent-libraries']"
Integrability,"// On FreeBSD, wchar_t contains the number of the code point as; // used by the character set of the locale. These character sets are; // not necessarily a superset of ASCII.; //; // FIXME: This is wrong; the macro refers to the numerical values; // of wchar_t *literals*, which are not locale-dependent. However,; // FreeBSD systems apparently depend on us getting this wrong, and; // setting this to 1 is conforming even if all the basic source; // character literals have the same encoding as char and wchar_t.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.h:294,depend,dependent,294,interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.h,2,['depend'],"['depend', 'dependent']"
Integrability,// On MacOSX real actions may end up being wrapped in BindArchAction,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CreateInvocationFromCommandLine.cpp:43,wrap,wrapped,43,interpreter/llvm-project/clang/lib/Frontend/CreateInvocationFromCommandLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CreateInvocationFromCommandLine.cpp,2,['wrap'],['wrapped']
Integrability,// On MacOSX real actions may end up being wrapped in; // BindArchAction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:43,wrap,wrapped,43,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,1,['wrap'],['wrapped']
Integrability,"// On PowerPC target, we have two kinds of patterns related to FMA:; // 1: Improve ILP.; // Try to reassociate FMA chains like below:; //; // Pattern 1:; // A = FADD X, Y (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMA X, M21, M22; // B = FMA Y, M31, M32; // C = FADD A, B; //; // Pattern 2:; // A = FMA X, M11, M12 (Leaf); // B = FMA A, M21, M22 (Prev); // C = FMA B, M31, M32 (Root); // -->; // A = FMUL M11, M12; // B = FMA X, M21, M22; // D = FMA A, M31, M32; // C = FADD B, D; //; // breaking the dependency between A and B, allowing FMA to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; //; // 2: Reduce register pressure.; // Try to reassociate FMA with FSUB and a constant like below:; // C is a floating point const.; //; // Pattern 1:; // A = FSUB X, Y (Leaf); // D = FMA B, C, A (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Pattern 2:; // A = FSUB X, Y (Leaf); // D = FMA B, A, C (Root); // -->; // A = FMA B, Y, -C; // D = FMA A, X, C; //; // Before the transformation, A must be assigned with different hardware; // register with D. After the transformation, A and D must be assigned with; // same hardware register due to TIE attribute of FMA instructions.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:543,depend,dependency,543,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,2,['depend'],"['dependency', 'depending']"
Integrability,// On `wasip2` the default linker is `wasm-component-ld` which wraps the; // execution of `wasm-ld`. Find `wasm-ld` and pass it as an argument of where; // to find it to avoid it needing to hunt and rediscover or search `PATH` for; // where it is.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp:63,wrap,wraps,63,interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp,1,['wrap'],['wraps']
Integrability,"// On every cycle, update CyclesLeft and notify dependent users.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:48,depend,dependent,48,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,1,['depend'],['dependent']
Integrability,"// On mingw, global dtors should not call exit().; // report_fatal_error() invokes exit(). We know report_fatal_error(); // might not write messages to stderr when any errors were detected; // on FD == 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp:140,message,messages,140,interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,1,['message'],['messages']
Integrability,"// On some 'newer' platform (Fedora Core 17+, Ubuntu 12), the; // initialization order is (by default?) is 'wrong' and so we can't; // delete the interpreter now .. because any of the static in the; // interpreter's library have already been deleted.; // On the link line, we must list the most dependent .o file; // and end with the least dependent (LLVM libraries), unfortunately,; // Fedora Core 17+ or Ubuntu 12 will also execute the initialization; // in the same order (hence doing libCore's before LLVM's and; // vice et versa for both the destructor. We worked around the; // initialization order by delay the TROOT creation until first use.; // We can not do the same for destruction as we have no way of knowing; // the last access ...; // So for now, let's avoid delete TCling except in the special build; // checking the completeness of the termination deletion.; // TODO: Should we do more cleanup here than just call delete?; // Segfaults rootcling in some cases, debug and uncomment:; //; // delete fInterpreter;; // We cannot delete fCleanups because of the logic in atexit which needs it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:295,depend,dependent,295,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,2,['depend'],['dependent']
Integrability,"// On some targets such as PowerPC, some of the builtins are defined with custom; // type descriptors for target-dependent types. These descriptors are decoded in; // other functions, but it may be useful to be able to fall back to default; // descriptor decoding to define builtins mixing target-dependent and target-; // independent types. This function allows decoding one type descriptor with; // default decoding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:113,depend,dependent,113,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,2,['depend'],['dependent']
Integrability,"// On targets that don't support half, fp16 or bfloat, they are expanded; // into float, and we don't want the ABI to depend on whether or not they; // are supported in hardware. Thus return false to coerce vectors of these; // types into integer vectors.; // We do not depend on hasLegalHalfType for bfloat as it is a; // separate IR type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/ARM.cpp:118,depend,depend,118,interpreter/llvm-project/clang/lib/CodeGen/Targets/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/ARM.cpp,2,['depend'],['depend']
Integrability,"// On the other hand, if all directions are equal and there's no; // loop-independent dependence possible, then no dependence exists.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:86,depend,dependence,86,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,2,['depend'],['dependence']
Integrability,"// Once the bits are split out into bytes of UTF8, this is a mask OR-ed; // into the first byte, depending on how many bytes follow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:97,depend,depending,97,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,1,['depend'],['depending']
Integrability,"// Once we've seen a bound, we know this is not a list of protocol; // references.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:58,protocol,protocol,58,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['protocol'],['protocol']
Integrability,"// Once we've seen a variance specific , we know this is not a; // list of protocol references.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:75,protocol,protocol,75,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['protocol'],['protocol']
Integrability,"// One corner case deals with the following scenario:; // Trying to add; // a) %r24 = A2_tfrt %p0, %r25; // to this packet:; // {; // b) %r25 = A2_tfrf %p0, %r24; // c) %p0 = C2_cmpeqi %r26, 1; // }; //; // On general check a) and b) are complements, but presence of c) will; // convert a) to .new form, and then it is not a complement.; // We attempt to detect it by analyzing existing dependencies in the packet.; // Analyze relationships between all existing members of the packet.; // Look for Anti dependecy on the same predicate reg as used in the; // candidate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:387,depend,dependencies,387,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,2,['depend'],"['dependecy', 'dependencies']"
Integrability,"// Only attempt to remove from the map the items that are already; // registered (because they are associated with a TProcessID with index; // greater than 255. Attempting to remove an item that is not in the map; // issues a Warning message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TProcessID.cxx:234,message,message,234,core/base/src/TProcessID.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TProcessID.cxx,1,['message'],['message']
Integrability,// Only check for dependence if there are resources available to; // schedule this instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:18,depend,dependence,18,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,1,['depend'],['dependence']
Integrability,// Only consider anti-dependence edges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:22,depend,dependence,22,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,1,['depend'],['dependence']
Integrability,// Only create a back-edge on the first and last nodes of a dependence; // chain. This records any chains and adds them later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:60,depend,dependence,60,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['dependence']
Integrability,// Only deal with ranges that do not wrap (i.e. RangeMin < RangeMax).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:37,wrap,wrap,37,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,"// Only enable CGProfilePass when using integrated assembler, since; // non-integrated assemblers don't recognize .cgprofile section.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:40,integrat,integrated,40,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,4,['integrat'],['integrated']
Integrability,// Only if we were successful collection all potential copies we record; // dependences (on non-fix AAPointerInfo AAs). We also only then modify the; // given PotentialCopies container.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:76,depend,dependences,76,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['depend'],['dependences']
Integrability,// Only look at use operands.; // We do not need to check for MO.readsReg() here because subsequent; // subregister defs will get output dependence edges and need no; // additional use dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:137,depend,dependence,137,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,2,['depend'],"['dependence', 'dependencies']"
Integrability,"// Only make use of no-wrap flags if we failed to compute the sign bit; // directly. This matters if the multiplication always overflows, in; // which case we prefer to follow the result of the direct computation,; // though as the program is invoking undefined behaviour we can choose; // whatever we like here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:23,wrap,wrap,23,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['wrap'],['wrap']
Integrability,"// Only need normalization set in innermost integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:44,integrat,integration,44,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['integrat'],['integration']
Integrability,// Only need to check pointers between two different dependency sets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:53,depend,dependency,53,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,2,['depend'],['dependency']
Integrability,"// Only one argument, so don't wrap in sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:31,wrap,wrap,31,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,1,['wrap'],['wrap']
Integrability,// Only preserve search paths that were used during the dependency scan.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:56,depend,dependency,56,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,1,['depend'],['dependency']
Integrability,// Only print a message at the interesting return statement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:16,message,message,16,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,1,['message'],['message']
Integrability,// Only print the check message if we're actually checking it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:24,message,message,24,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,1,['message'],['message']
Integrability,// Only report direct dependencies that were successfully handled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:22,depend,dependencies,22,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,1,['depend'],['dependencies']
Integrability,"// Only the bottom lanes from Qm (Op1) and either the top or bottom lanes from; // Qd (Op0) are demanded from a VMOVN, depending on whether we are inserting; // into the top or bottom lanes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:119,depend,depending,119,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['depend'],['depending']
Integrability,"// Only the top level interface is shown, at the begining.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx:22,interface,interface,22,gui/ged/src/TStyleManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx,1,['interface'],['interface']
Integrability,"// Only these library routines return their argument. In particular,; // objc_retainBlock does not necessarily return its argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:22,rout,routines,22,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,1,['rout'],['routines']
Integrability,// Only track dependence if we are going to use the assumed info.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:14,depend,dependence,14,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['depend'],['dependence']
Integrability,// Only trust annotations for system headers for non-protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp:53,protocol,protocols,53,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TrustNonnullChecker.cpp,1,['protocol'],['protocols']
Integrability,// Only try to recover from lookup into dependent bases in static methods or; // contexts where 'this' is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:40,depend,dependent,40,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['depend'],['dependent']
Integrability,// Only updates the real output file if there are any differences.; // This prevents recompilation of all the files depending on it if there; // aren't any.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/Main.cpp:116,depend,depending,116,interpreter/llvm-project/llvm/lib/TableGen/Main.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/Main.cpp,1,['depend'],['depending']
Integrability,// Opaque data used to interface with OS-specific dynamic library handling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h:23,interface,interface,23,interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,1,['interface'],['interface']
Integrability,"// Open a message box to allow the user to create a new style.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx:10,message,message,10,gui/ged/src/TStyleManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx,1,['message'],['message']
Integrability,// OpenACC has an optional paren-wrapped 'wait-argument'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:33,wrap,wrapped,33,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,1,['wrap'],['wrapped']
Integrability,"// OpenCL kernels are called via an explicit runtime API with arguments; // set with clSetKernelArg(), not as normal sub-functions.; // Return SPIR_KERNEL by default as the kernel calling convention to; // ensure the fingerprint is fixed such way that each OpenCL argument; // gets one matching argument in the produced kernel function argument; // list to enable feasible implementation of clSetKernelArg() with; // aggregates etc. In case we would use the default C calling conv here,; // clSetKernelArg() might break depending on the target-specific; // conventions; different targets might split structs passed as values; // to multiple function arguments etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.cpp:520,depend,depending,520,interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.cpp,1,['depend'],['depending']
Integrability,"// OpenCL v1.1 s6.11.8, v1.2 s6.12.8, v2.0 s6.13.8 - Synchronization Functions; // Flag type and values for barrier, mem_fence, read_mem_fence, write_mem_fence",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h:53,Synchroniz,Synchronization,53,interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/opencl-c-base.h,1,['Synchroniz'],['Synchronization']
Integrability,"// OpenMP 5.0 [2.17.11, Restrictions]; // List items used in depend clauses cannot be zero-length array; // sections.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:61,depend,depend,61,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['depend'],['depend']
Integrability,"// OpenMP 5.0, 2.17.11 depend Clause, Restrictions, C/C++; // List items used in depend clauses with the depobj dependence type; // must be expressions of the omp_depend_t type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:23,depend,depend,23,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,3,['depend'],"['depend', 'dependence']"
Integrability,"// OpenMP 5.0, 2.17.11 depend Clause, Restrictions, C/C++; // List items used in depend clauses with the in, out, inout,; // inoutset, or mutexinoutset dependence types cannot be; // expressions of the omp_depend_t type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:23,depend,depend,23,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,3,['depend'],"['depend', 'dependence']"
Integrability,"// OpenMP 5.0, 2.17.9, ordered Construct, Restrictions.; // During execution of an iteration of a worksharing-loop or a loop nest; // within a worksharing-loop, simd, or worksharing-loop SIMD region, a thread; // must not execute more than one ordered region corresponding to an ordered; // construct without a depend clause.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:311,depend,depend,311,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['depend'],['depend']
Integrability,"// OpenMP 5.1 [2.15.1, interop Construct, Restrictions]; // A depend clause can only appear on the directive if a targetsync; // interop-type is present or the interop-var was initialized with; // the targetsync interop-type.; // If there is any 'init' clause diagnose if there is no 'init' clause with; // interop-type of 'targetsync'. Cases involving other directives cannot be; // diagnosed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:62,depend,depend,62,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['depend'],['depend']
Integrability,"// OpenMP [2.13.9, Summary]; // depend(dependence-type : vec), where dependence-type is:; // 'sink' and where vec is the iteration vector, which has the form:; // x1 [+- d1], x2 [+- d2 ], . . . , xn [+- dn]; // where n is the value specified by the ordered clause in the loop; // directive, xi denotes the loop iteration variable of the i-th nested; // loop associated with the loop directive, and di is a constant; // non-negative integer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:32,depend,depend,32,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,3,['depend'],"['depend', 'dependence-type']"
Integrability,"// OpenMP [2.16, Nesting of Regions]; // OpenMP constructs may not be nested inside a simd region.; // OpenMP [2.8.1,simd Construct, Restrictions]; // An ordered construct with the simd clause is the only OpenMP; // construct that can appear in the simd region.; // Allowing a SIMD construct nested in another SIMD construct is an; // extension. The OpenMP 4.5 spec does not allow it. Issue a warning; // message.; // OpenMP 5.0 [2.9.3.1, simd Construct, Restrictions]; // The only OpenMP constructs that can be encountered during execution of; // a simd region are the atomic construct, the loop construct, the simd; // construct and the ordered construct with the simd clause.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:405,message,message,405,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['message'],['message']
Integrability,"// OpenMP [2.5, Restrictions]; // At most one num_threads clause can appear on the directive.; // OpenMP [2.8.1, simd construct, Restrictions]; // Only one safelen clause can appear on a simd directive.; // Only one simdlen clause can appear on a simd directive.; // Only one collapse clause can appear on a simd directive.; // OpenMP [2.11.1, task Construct, Restrictions]; // At most one if clause can appear on the directive.; // At most one final clause can appear on the directive.; // OpenMP [teams Construct, Restrictions]; // At most one num_teams clause can appear on the directive.; // At most one thread_limit clause can appear on the directive.; // OpenMP [2.9.1, task Construct, Restrictions]; // At most one priority clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one grainsize clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one num_tasks clause can appear on the directive.; // OpenMP [2.11.3, allocate Directive, Restrictions]; // At most one allocator clause can appear on the directive.; // OpenMP 5.0, 2.10.1 task Construct, Restrictions.; // At most one detach clause can appear on the directive.; // OpenMP 5.1, 2.3.6 dispatch Construct, Restrictions.; // At most one novariants clause can appear on a dispatch directive.; // At most one nocontext clause can appear on a dispatch directive.; // OpenMP [5.1, error directive, Restrictions]; // At most one message clause can appear on the directive",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:1484,message,message,1484,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,1,['message'],['message']
Integrability,"// OpenMP [2.9.1.1, Data-sharing Attribute Rules for Variables Referenced; // in a region but not in construct]; // File-scope or namespace-scope variables referenced in called routines; // in the region are shared unless they appear in a threadprivate; // directive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:177,rout,routines,177,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['rout'],['routines']
Integrability,"// OpenMP [2.9.1.2, Data-sharing Attribute Rules for Variables Referenced; // in a region but not in construct]; // Variables with static storage duration that are declared in called; // routines in the region are shared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:187,rout,routines,187,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['rout'],['routines']
Integrability,// OpenMP offloading has a dependency on the host compile action to; // identify which declarations need to be emitted. This shouldn't be; // collapsed with any other actions so we can use it in the device.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:27,depend,dependency,27,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['depend'],['dependency']
Integrability,"// OpenMP, 2.9.1 Canonical Loop Form, Restrictions.; // The type of the loop iterator on which we depend may not have a random; // access iterator type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:98,depend,depend,98,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['depend'],['depend']
Integrability,// Operations that do not operate floating-point numbers and do not depend on; // FP environment can be folded even in strictfp functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:68,depend,depend,68,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['depend'],['depend']
Integrability,"// Optimistically assume that an unresolved using decl will; // overload; if it doesn't, we'll have to diagnose during; // template instantiation.; //; // Exception: if the scope is dependent and this is not a class; // member, the using declaration can only introduce an enumerator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:182,depend,dependent,182,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['depend'],['dependent']
Integrability,// Optimistically assume that the delayed and dependent cases; // will work out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:46,depend,dependent,46,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,1,['depend'],['dependent']
Integrability,// Optimization for reserved registers like ESP. We can only merge with a; // reserved physreg if RHS has a single value that is a copy of DstReg.; // The live range of the reserved register will look like a set of dead defs; // - we don't properly track the live range of reserved registers.; // Deny any overlapping intervals. This depends on all the reserved; // register live ranges to look like dead defs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:334,depend,depends,334,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['depend'],['depends']
Integrability,"// Optimize the special case where the source is a constant integer; // induction variable. Notice that we can only optimize the 'trunc' case; // because (a) FP conversions lose precision, (b) sext/zext may wrap, and; // (c) other casts depend on pointer size.; // Determine whether \p K is a truncation based on an induction variable that; // can be optimized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:207,wrap,wrap,207,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,"['depend', 'wrap']","['depend', 'wrap']"
Integrability,"// Optimize; // 1) (icmp eq/ne (and X, C0), (shift X, C1)); // or; // 2) (icmp eq/ne X, (rotate X, C1)); // If C0 is a mask or shifted mask and the shift amt (C1) isolates the; // remaining bits (i.e something like `(x64 & UINT32_MAX) == (x64 >> 32)`); // Then:; // If C1 is a power of 2, then the rotate and shift+and versions are; // equivilent, so we can interchange them depending on target preference.; // Otherwise, if we have the shift+and version we can interchange srl/shl; // which inturn affects the constant C0. We can use this to get better; // constants again determined by target preference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:375,depend,depending,375,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['depend'],['depending']
Integrability,"// Optimized with two rldicl's as follows:; // Add missing bits on left to the mask and check that the mask is a; // wrapped run of ones, i.e.; // Change pattern |0001111100000011111111|; // to |1111111100000011111111|.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:117,wrap,wrapped,117,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['wrap'],['wrapped']
Integrability,"// Option prefer-predicate-over-epilogue indicates that an epilogue is undesired,; // that predication is preferred, and this lists all options. I.e., the; // vectorizer will try to fold the tail-loop (epilogue) into the vector body; // and predicate the instructions accordingly. If tail-folding fails, there are; // different fallback strategies depending on these values:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:348,depend,depending,348,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['depend'],['depending']
Integrability,// Optional synchronization scope.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:12,synchroniz,synchronization,12,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,1,['synchroniz'],['synchronization']
Integrability,// OptionalDef handling routines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:24,rout,routines,24,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,1,['rout'],['routines']
Integrability,// Optionally add output and anti dependencies. For anti; // dependencies we use a latency of 0 because for a multi-issue; // target we want to allow the defining instruction to issue; // in the same cycle as the using instruction.; // TODO: Using a latency of 1 here for output dependencies assumes; // there's no cost for reusing registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:34,depend,dependencies,34,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,3,['depend'],['dependencies']
Integrability,// Optionally have the thin link print message for each devirtualized; // function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:39,message,message,39,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['message'],['message']
Integrability,// Options only used by the linker wrapper.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:35,wrap,wrapper,35,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,1,['wrap'],['wrapper']
Integrability,"// Order DPValue users in reverse-creation order. Normal dbg.value users; // of MetadataAsValues are ordered by their UseList, i.e. reverse order of; // when they were added: we need to replicate that here. The structure of; // debug-info output depends on the ordering of intrinsics, thus we need; // to keep them consistent for comparisons sake.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:246,depend,depends,246,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,1,['depend'],['depends']
Integrability,// OrderAfterDef takes precedences over OrderBeforeDef. The latter is due; // to a loop-carried dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:96,depend,dependence,96,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['dependence']
Integrability,"// Ordinary function, not a template specialization.; // Note: This might be ok, the body might be defined; // in a library, and all we have seen is the; // header file.; //::Error(""TClingCallFunc::make_wrapper"",; // ""Cannot make wrapper for a function which is ""; // ""declared but not defined!"");; // return 0;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx:230,wrap,wrapper,230,core/metacling/src/TClingCallFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx,1,['wrap'],['wrapper']
Integrability,// Other helper routines,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:16,rout,routines,16,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,1,['rout'],['routines']
Integrability,"// Otherwise default to creating a SimpleCompiler, or ConcurrentIRCompiler,; // depending on the number of threads requested.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:80,depend,depending,80,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,1,['depend'],['depending']
Integrability,// Otherwise emit an appropriate error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp:39,message,message,39,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,1,['message'],['message']
Integrability,"// Otherwise give the wrapper the same linkage as the original main; // function, so that it can be called from the same places.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:22,wrap,wrapper,22,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,1,['wrap'],['wrapper']
Integrability,// Otherwise inject just the new row at the end of the range.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:13,inject,inject,13,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,1,['inject'],['inject']
Integrability,"// Otherwise the insertion point is just the current or next; // instruction depending on Before. I.e., there is nothing to do; // here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:77,depend,depending,77,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['depend'],['depending']
Integrability,// Otherwise try to use VLREP or VLVGP to start the sequence in order to; // avoid a false dependency on any previous contents of the vector; // register.; // Use a VLREP if at least one element is a load. Make sure to replicate; // the load with the most elements having its value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:91,depend,dependency,91,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['depend'],['dependency']
Integrability,// Otherwise update dependencies and move to the emitted state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:20,depend,dependencies,20,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['depend'],['dependencies']
Integrability,// Otherwise use an AVL of 1 to avoid depending on previous vl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:38,depend,depending,38,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,1,['depend'],['depending']
Integrability,"// Otherwise, check whether the static type does not require; // retaining. This currently only triggers for Class (possibly; // protocol-qualifed, and arrays thereof).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:129,protocol,protocol-qualifed,129,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['protocol'],['protocol-qualifed']
Integrability,"// Otherwise, it's a dependent match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:21,depend,dependent,21,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['depend'],['dependent']
Integrability,"// Otherwise, just convert the temporary to an r-value using the; // normal conversion routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:87,rout,routine,87,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,1,['rout'],['routine']
Integrability,"// Otherwise, let this name decide whether we'll be correcting; // toward types or protocols.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:83,protocol,protocols,83,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['protocol'],['protocols']
Integrability,"// Otherwise, make an elaborated type wrapping a non-dependent; // specialization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:38,wrap,wrapping,38,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,"['depend', 'wrap']","['dependent', 'wrapping']"
Integrability,"// Otherwise, print the message with a prefix based on the severity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp:24,message,message,24,interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContext.cpp,1,['message'],['message']
Integrability,"// Otherwise, the match failed, try to produce a decent error message.; // If we had multiple suffix matches, then identify this as an ambiguous; // match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:62,message,message,62,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,1,['message'],['message']
Integrability,"// Otherwise, there is a potential dependence. Return a clobber.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:35,depend,dependence,35,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// Otherwise, this is target-dependent and based on the size and; // alignment of the ivar.; // If the size of the ivar is not a power of two, give up. We don't; // want to get into the business of doing compare-and-swaps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:29,depend,dependent,29,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['depend'],['dependent']
Integrability,"// Otherwise, visit all the dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:28,depend,dependencies,28,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,1,['depend'],['dependencies']
Integrability,"// Otherwise, we have the normal case, of more than one block to inline or; // multiple return sites.; // We want to clone the entire callee function into the hole between the; // ""starter"" and ""ender"" blocks. How we accomplish this depends on whether; // this is an invoke instruction or a call instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:233,depend,depends,233,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['depend'],['depends']
Integrability,"// Otherwise, we mark this parameter as escaped, which can be; // interpreted both as called or not called depending on the context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:107,depend,depending,107,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,1,['depend'],['depending']
Integrability,"// Otherwise, we need a thread wrapper unless we know that every; // translation unit will emit the value as a constant. We rely on the; // variable being constant-initialized in every translation unit if it's; // constant-initialized in any translation unit, which isn't actually; // guaranteed by the standard but is necessary for sanity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp:31,wrap,wrapper,31,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp,1,['wrap'],['wrapper']
Integrability,"// Otherwise, we need to compute a new section name. Low priorities should; // run earlier. The linker will sort sections ASCII-betically, and we need a; // string that sorts between .CRT$XCA and .CRT$XCU. In the general case, we; // make a name like "".CRT$XCT12345"", since that runs before .CRT$XCU. Really; // low priorities need to sort before 'L', since the CRT uses that; // internally, so we use "".CRT$XCA00001"" for them. We have a contract with; // the frontend that ""init_seg(compiler)"" corresponds to priority 200 and; // ""init_seg(lib)"" corresponds to priority 400, and those respectively use; // 'C' and 'L' without the priority suffix. Priorities between 200 and 400; // use 'C' with the priority as a suffix.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:438,contract,contract,438,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,1,['contract'],['contract']
Integrability,"// Otherwise, we only need module macros if we're actually compiling a module; // interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:82,interface,interface,82,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,1,['interface'],['interface']
Integrability,"// Otherwise, when ignoring qualifiers, the types not having the same; // unqualified type does not mean they do not match, so in this case we; // must keep going and analyze with a non-dependent parameter type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:186,depend,dependent,186,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['depend'],['dependent']
Integrability,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:55,depend,dependences,55,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,5,['depend'],"['dependences', 'dependent']"
Integrability,// Our contract with inline asm register operands is to provide local; // indices as immediates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp:7,contract,contract,7,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExplicitLocals.cpp,1,['contract'],['contract']
Integrability,// Our demo module is now complete. Wrap it and our ThreadSafeContext in a; // ThreadSafeModule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsBasicUsage/OrcV2CBindingsBasicUsage.c:36,Wrap,Wrap,36,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsBasicUsage/OrcV2CBindingsBasicUsage.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsBasicUsage/OrcV2CBindingsBasicUsage.c,3,['Wrap'],['Wrap']
Integrability,"// Our error handler depends on the Diagnostics object, which we're; // potentially about to delete. Uninstall the handler now so that any; // later errors use the default handling behavior instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:21,depend,depends,21,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,2,['depend'],['depends']
Integrability,"// Our main concern here is re-establishing invariants like ""a; // variable's type is either dependent or complete"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:93,depend,dependent,93,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,// Our module is now complete. Wrap it and our ThreadSafeContext in a; // ThreadSafeModule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c:31,Wrap,Wrap,31,interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/OrcV2CBindingsLazy/OrcV2CBindingsLazy.c,2,['Wrap'],['Wrap']
Integrability,// Our result depends on both our and other thread's arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:14,depend,depends,14,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['depend'],['depends']
Integrability,// Out and InOut dependencies must use the same code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:17,depend,dependencies,17,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['depend'],['dependencies']
Integrability,// Out of process mode using SimpleRemoteEPC depends on threads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:45,depend,depends,45,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,2,['depend'],['depends']
Integrability,"// Out-of-order processor can dispatch WAW dependencies in the same cycle.; // Treat predication as a data dependency for out-of-order cpus. In-order; // cpus do not need to treat predicated writes specially.; //; // TODO: The following hack exists because predication passes do not; // correctly append imp-use operands, and readsReg() strangely returns false; // for predicated defs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp:43,depend,dependencies,43,interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetSchedule.cpp,2,['depend'],"['dependencies', 'dependency']"
Integrability,// Output OpEntryPoints adding interface args to all of them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp:31,interface,interface,31,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVAsmPrinter.cpp,1,['interface'],['interface']
Integrability,// Output class methods declared in this protocol.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:41,protocol,protocol,41,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,1,['protocol'],['protocol']
Integrability,// Output dependencies.; // One entry per each implicit and explicit register definition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:10,depend,dependencies,10,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,1,['depend'],['dependencies']
Integrability,// Output instance methods declared in this protocol.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:44,protocol,protocol,44,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,2,['protocol'],['protocol']
Integrability,"// Output the input to the current pass to a bitcode file, emit a message; // telling the user how to reproduce it: opt -foo blah.bc; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:66,message,message,66,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,1,['message'],['message']
Integrability,// Output the message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:14,message,message,14,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['message'],['message']
Integrability,// Output the top lovel protocol meta-data for the class.; /* struct _objc_protocol_list {; struct _objc_protocol_list *next;; int protocol_count;; struct _objc_protocol *class_protocols[];; }; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:24,protocol,protocol,24,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,1,['protocol'],['protocol']
Integrability,"// Overload TFile interfaces.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TMemFile.h:18,interface,interfaces,18,io/io/inc/TMemFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TMemFile.h,1,['interface'],['interfaces']
Integrability,"// Overload for C-style arrays. It's not possible to make an overload of the; // RRangeCast constructor itself, because when the C-style array is forwarded; // it might decay depending on the compiler version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RRangeCast.hxx:175,depend,depending,175,core/foundation/inc/ROOT/RRangeCast.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RRangeCast.hxx,2,['depend'],['depending']
Integrability,"// Overridden virtual methods of non-primary bases need to adjust the incoming; // 'this' pointer in the prologue. In this hierarchy, C::b will subtract; // sizeof(void*) to adjust from B* to C*:; // struct A { virtual void a(); };; // struct B { virtual void b(); };; // struct C : A, B { virtual void b(); };; //; // Leave the value stored in the 'this' alloca unadjusted, so that the; // debugger sees the unadjusted value. Microsoft debuggers require this, and; // will apply the ThisAdjustment in the method type information.; // FIXME: Do something better for DWARF debuggers, which won't expect this,; // without making our codegen depend on debug info settings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:639,depend,depend,639,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['depend'],['depend']
Integrability,"// Override the helper symbols injected by GenericLLVMIRPlatformSupport,; // before anything can be emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:31,inject,injected,31,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,1,['inject'],['injected']
Integrability,"// OverrideSearch will return as ""overridden"" the same method in the; // interface. For hasOverriddenMethodsInBaseOrProtocol, we need to; // check whether a category of a base class introduced a method with the; // same selector, after the interface method declaration.; // To avoid unnecessary lookups in the majority of cases, we use the; // extra info bits in GlobalMethodPool to check whether there were any; // category methods with this selector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:73,interface,interface,73,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['interface'],['interface']
Integrability,// Overwrite for improved diagnostic messages,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/FileCheck/FileCheck.cpp:37,message,messages,37,interpreter/llvm-project/llvm/utils/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/FileCheck/FileCheck.cpp,1,['message'],['messages']
Integrability,"// P l o t f u l l d e c a y d i s t r i b u t i o n; // ----------------------------------------------------------; // Create frame, plot data and pdf projection (integrated over tagFlav and mixState)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:164,integrat,integrated,164,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['integrat'],['integrated']
Integrability,"// P.d.f class that wraps another p.d.f and caches its output",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCachedPdf.h:20,wrap,wraps,20,roofit/roofitcore/inc/RooCachedPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCachedPdf.h,2,['wrap'],['wraps']
Integrability,// PC-relative address matching routines used by SystemZOperands.td.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:32,rout,routines,32,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['rout'],['routines']
Integrability,// PDB does not support the Binary interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/Binary.cpp:35,interface,interface,35,interpreter/llvm-project/llvm/lib/Object/Binary.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/Binary.cpp,1,['interface'],['interface']
Integrability,"// PDEFoam event density interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/PDEFoamDensityBase.h:25,interface,interface,25,tmva/tmva/inc/TMVA/PDEFoamDensityBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/PDEFoamDensityBase.h,1,['interface'],['interface']
Integrability,"// PDEFoam kernel interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/PDEFoamKernelBase.h:18,interface,interface,18,tmva/tmva/inc/TMVA/PDEFoamKernelBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/PDEFoamKernelBase.h,1,['interface'],['interface']
Integrability,"// PDF should be added to existing term if; // 1) It has overlapping normalization dependents with any other PDF in existing term; // 2) It has overlapping dependents of any class for which integration is requested; // 3) If normalization happens over multiple ranges, and those ranges are both defined; // in either observable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:83,depend,dependents,83,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,3,"['depend', 'integrat']","['dependents', 'integration']"
Integrability,"// PDF wrapper for histograms",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/PDF.h:7,wrap,wrapper,7,tmva/tmva/inc/TMVA/PDF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/PDF.h,1,['wrap'],['wrapper']
Integrability,"// PPC_FP128 is really the sum of two consecutive doubles, where the first; // double is always stored first in memory, regardless of the target; // endianness. The memory layout of i128, however, depends on the target; // endianness, and so we can't fold this without target endianness; // information. This should instead be handled by; // Analysis/ConstantFolding.cpp",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:197,depend,depends,197,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['depend'],['depends']
Integrability,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:7,Interoperab,Interoperability,7,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,2,"['Interoperab', 'depend']","['Interoperability', 'depending']"
Integrability,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter; // than 32-bits are sign extended or zero extended, depending on; // whether they are signed or unsigned types. This case applies; // only to scalar parameters and not to aggregate values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:7,Interoperab,Interoperability,7,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,2,"['Interoperab', 'depend']","['Interoperability', 'depending']"
Integrability,"// PTX Interoperability section 2.2: ""For a vector with an even number of; // elements, its alignment is set to number of elements times the alignment; // of its member: n*alignof(t).""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:7,Interoperab,Interoperability,7,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['Interoperab'],['Interoperability']
Integrability,"// Package manager interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TPackMgr.h:19,interface,interface,19,proof/proof/inc/TPackMgr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TPackMgr.h,1,['interface'],['interface']
Integrability,"// PadPaint wrapper for calls from TGLViewer:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLScenePad.h:12,wrap,wrapper,12,graf3d/gl/inc/TGLScenePad.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLScenePad.h,1,['wrap'],['wrapper']
Integrability,"// PageSinkBuf wraps a concrete page source",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage.cxx:15,wrap,wraps,15,tree/ntuple/v7/test/ntuple_storage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_storage.cxx,1,['wrap'],['wraps']
Integrability,"// Param has ByVal attribute; // Return MoveParam(param symbol).; // Ideally, the param symbol can be returned directly,; // but when SDNode builder decides to use it in a CopyToReg(),; // machine instruction fails because TargetExternalSymbol; // (not lowered) is target dependent, and CopyToReg assumes; // the source is lowered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:272,depend,dependent,272,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['depend'],['dependent']
Integrability,"// ParamFwdReg was described by the non-callee saved register; // RegLoc. Mark that the call site values for the parameters are; // dependent on that register instead of ParamFwdReg. Since RegLoc; // may be a register that will be handled in this iteration, we; // postpone adding the items to the worklist, and instead keep them; // in a temporary container.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:132,depend,dependent,132,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,1,['depend'],['dependent']
Integrability,// Parameter declarators cannot be interface types. All ObjC objects are; // passed by reference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,interface,interface,35,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['interface'],['interface']
Integrability,// Parse a class interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:17,interface,interface,17,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['interface'],['interface']
Integrability,"// Parse analytical integration expression if provided; // Expected form is observable:expression,observable,observable:expression;[...]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooClassFactory.cxx:20,integrat,integration,20,roofit/roofitcore/src/RooClassFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooClassFactory.cxx,1,['integrat'],['integration']
Integrability,"// Parse input message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:15,message,message,15,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['message'],['message']
Integrability,// Parse just the blocks needed for building the index out of the module.; // At the end of this routine the module Index is populated with a map; // from global value id to GlobalValueSummary objects.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:97,rout,routine,97,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['rout'],['routine']
Integrability,"// Parse message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx:9,message,message,9,net/net/src/TApplicationServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx,2,['message'],['message']
Integrability,"// Parse protocol name, for PROOF, send message with server role",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSocket.cxx:9,protocol,protocol,9,net/net/src/TSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSocket.cxx,2,"['message', 'protocol']","['message', 'protocol']"
Integrability,"// Parse protocol, if any",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSocket.cxx:9,protocol,protocol,9,net/net/src/TSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSocket.cxx,1,['protocol'],['protocol']
Integrability,// Parse the message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:13,message,message,13,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,1,['message'],['message']
Integrability,// Parse the name of the personality routine,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:37,rout,routine,37,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['rout'],['routine']
Integrability,"// Parse the objc-type-parameter-list or objc-protocol-refs. For the latter; // case, LAngleLoc will be valid and ProtocolIdents will capture the; // protocol references (that have not yet been resolved).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:46,protocol,protocol-refs,46,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,3,"['Protocol', 'protocol']","['ProtocolIdents', 'protocol', 'protocol-refs']"
Integrability,// Parse type arguments and protocol qualifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:28,protocol,protocol,28,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,2,['protocol'],['protocol']
Integrability,"// Parsing a type within macro ""offsetof"", defined in __buitin_offsetof; // To improve our diagnostic message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:102,message,message,102,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['message'],['message']
Integrability,"// Parsing depends on the key",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManager.cxx:11,depend,depends,11,proof/proof/src/TDataSetManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManager.cxx,1,['depend'],['depends']
Integrability,// Parsing depends on the shader kind,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/DXContainer.h:11,depend,depends,11,interpreter/llvm-project/llvm/include/llvm/Object/DXContainer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/DXContainer.h,1,['depend'],['depends']
Integrability,// Part of public interface to class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:18,interface,interface,18,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,1,['interface'],['interface']
Integrability,"// Partial integration scenario, retrieve set of variables, calculate partial; // sum, figure out integration ranges (if needed)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHistPdf.cxx:11,integrat,integration,11,roofit/roofitcore/src/RooHistPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHistPdf.cxx,2,['integrat'],['integration']
Integrability,"// Partial integration scenarios",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx:11,integrat,integration,11,roofit/roofitcore/src/RooAddModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx,1,['integrat'],['integration']
Integrability,"// Partial integration scenarios, rangeName already encoded in 'code'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimultaneous.cxx:11,integrat,integration,11,roofit/roofitcore/src/RooSimultaneous.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimultaneous.cxx,1,['integrat'],['integration']
Integrability,// Partially superseded by IndentExternBlock; /// Wrap before ``catch``.; /// \code; /// true:; /// try {; /// foo();; /// }; /// catch () {; /// }; ///; /// false:; /// try {; /// foo();; /// } catch () {; /// }; /// \endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:50,Wrap,Wrap,50,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['Wrap'],['Wrap']
Integrability,"// Partition the list of shuffling instructions into instruction groups,; // where each group has to be moved as a whole (i.e. a group is a chain of; // dependent instructions). A group produces a single live output register,; // which is meant to be the input of the loop phi node (although this is; // not checked here yet). It also uses a single register as its input,; // which is some value produced in the loop body. After moving the group; // to the beginning of the loop, that input register would need to be; // the loop-carried register (through a phi node) instead of the (currently; // loop-carried) output register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:153,depend,dependent,153,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,1,['depend'],['dependent']
Integrability,// Parts of bitcode parsing depend on the datalayout. Make sure we; // finalize the datalayout before we run any of that code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:28,depend,depend,28,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['depend'],['depend']
Integrability,// Pass BeginSourceFile message onto DiagClient on first call.; // The corresponding EndSourceFile call will be made from an; // explicit call to FinishCapture.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp:24,message,message,24,interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp,1,['message'],['message']
Integrability,"// Pass on any declaration. This is usually used to record dependency.; // Since rootcint see C++ compliant header files, we can assume that; // if a forward declaration or declaration has been inserted, the; // classes for which we are creating a dictionary will be using; // them either directly or indirectly. Any false positive can be; // resolved by removing the spurrious dependency in the (user) header; // files.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/Scanner.cxx:59,depend,dependency,59,core/dictgen/src/Scanner.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/Scanner.cxx,2,['depend'],['dependency']
Integrability,// Pass the CUDA path to the linker wrapper tool.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:36,wrap,wrapper,36,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['wrap'],['wrapper']
Integrability,"// Pass through DAG gathering a list of exports and removing barrier edges; // creating dependencies on exports. Freeing exports of successor edges; // allows more scheduling freedom, and nothing should be order dependent; // on exports. Edges will be added later to order the exports.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUExportClustering.cpp:88,depend,dependencies,88,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUExportClustering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUExportClustering.cpp,2,['depend'],"['dependencies', 'dependent']"
Integrability,"// Pass to a subfield of any wrapper records. We don't expect more than one; // of these: immediate operands are used as plain numbers rather than as; // llvm::Value, so it's meaningless to promote their type anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:29,wrap,wrapper,29,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,1,['wrap'],['wrapper']
Integrability,"// Pattern depends on endian because we expect lower index is inserted first.; // Big endian:; // inselt (inselt BaseVec, (trunc (lshr X, BW/2), Index0), (trunc X), Index1; // Little endian:; // inselt (inselt BaseVec, (trunc X), Index0), (trunc (lshr X, BW/2)), Index1; // Note: It is not safe to do this transform with an arbitrary base vector; // because the bitcast of that vector to fewer/larger elements could; // allow poison to spill into an element that was not poison before.; // TODO: Detect smaller fractions of the scalar.; // TODO: One-use checks are conservative.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:11,depend,depends,11,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['depend'],['depends']
Integrability,// Peek the build ids to print a helpful error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp:47,message,message,47,interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,1,['message'],['message']
Integrability,// Peeling the first iteration will break dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:42,depend,dependence,42,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,1,['depend'],['dependence']
Integrability,// Peeling the last iteration will break the dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:45,depend,dependence,45,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,1,['depend'],['dependence']
Integrability,"// Pending: do something more intelligent here; // but at least get a message in the log file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx:70,message,message,70,net/net/src/TApplicationServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx,2,['message'],['message']
Integrability,// PendingEvents and ScoreUB need to be update regardless if this event; // changes the score of a register or not.; // Examples including vm_cnt when buffer-store or lgkm_cnt when send-message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:186,message,message,186,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['message'],['message']
Integrability,"// Per C++ [class.qual]p2, if the template-id was an injected-class-name,; // it's not actually allowed to be used as a type in most cases. Because; // we annotate it before we know whether it's valid, we have to check for; // this case here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:53,inject,injected-class-name,53,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['inject'],['injected-class-name']
Integrability,"// Per C++11 [over.literal]p2, literal operators can only be declared at; // namespace scope. Therefore, this unqualified-id cannot name anything.; // Reject it early, because we have no AST representation for this in the; // case where the scope is dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:250,depend,dependent,250,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['depend'],['dependent']
Integrability,"// Per [class.qual]p2, this names the constructors of SS, not the; // injected-class-name. We don't have a classification for that.; // There's not much point caching this result, since the parser; // will reject it later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:70,inject,injected-class-name,70,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['inject'],['injected-class-name']
Integrability,"// Perform a system based diff between \p Before and \p After, using \p; // OldLineFormat, \p NewLineFormat, and \p UnchangedLineFormat to control the; // formatting of the output. Return an error message for any failures instead; // of the diff.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PrintPasses.h:197,message,message,197,interpreter/llvm-project/llvm/include/llvm/IR/PrintPasses.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PrintPasses.h,1,['message'],['message']
Integrability,// Perform any dependent diagnostics from the pattern.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:15,depend,dependent,15,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['depend'],['dependent']
Integrability,// Perform argument dependent lookup.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:20,depend,dependent,20,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['depend'],['dependent']
Integrability,"// Perform global clip-plane-check in UpdateSceneInfo(); // Interface to other components",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLSceneBase.h:60,Interface,Interface,60,graf3d/gl/inc/TGLSceneBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLSceneBase.h,1,['Interface'],['Interface']
Integrability,// Perform initialization before packetizing an instruction. This; // function is supposed to be overrided by the target dependent packetizer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:121,depend,dependent,121,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,1,['depend'],['dependent']
Integrability,"// Perform numeric integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx:19,integrat,integration,19,roofit/roofitcore/src/RooNumRunningInt.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx,1,['integrat'],['integration']
Integrability,"// Perform target-specific adjustments to the latency of a schedule; // dependency.; // If a pair of operands is associated with the schedule dependency, DefOpIdx; // and UseOpIdx are the indices of the operands in Def and Use, respectively.; // Otherwise, either may be -1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:72,depend,dependency,72,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,2,['depend'],['dependency']
Integrability,// Personality routine.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp:15,rout,routine,15,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp,1,['rout'],['routine']
Integrability,// Phase 2a: Loop carried dependency with V_PERM; // Schedule VPerm & DS_WRITE as closely as possible to the VMEM_READ they; // depend on. Interleave MFMA to keep XDL unit busy throughout.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:26,depend,dependency,26,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,2,['depend'],"['depend', 'dependency']"
Integrability,// Phase 2b: Loop carried dependency without V_PERM; // Schedule DS_WRITE as closely as possible to the VMEM_READ they depend on.; // Interleave MFMA to keep XDL unit busy throughout.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:26,depend,dependency,26,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,2,['depend'],"['depend', 'dependency']"
Integrability,"// Phase 2c: Loop carried dependency with V_PERM, VMEM_READs are; // ultimately used by two DS_WRITE; // Schedule VPerm & DS_WRITE as closely as possible to the VMEM_READ they; // depend on. Interleave MFMA to keep XDL unit busy throughout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:26,depend,dependency,26,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,2,['depend'],"['depend', 'dependency']"
Integrability,"// Pick the max count from the non-gap, region entry segments and the; // wrapped count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp:74,wrap,wrapped,74,interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp,1,['wrap'],['wrapped']
Integrability,"// Pick upper or lower error bar depending on sign of external error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooXYChi2Var.cxx:33,depend,depending,33,roofit/roofitcore/src/RooXYChi2Var.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooXYChi2Var.cxx,1,['depend'],['depending']
Integrability,"// Place to collect all of the edges. Once they are all in the vector,; // the vector will not reallocate so then we can use pointers to them,; // which are required by the graph writing routines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp:187,rout,routines,187,interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp,1,['rout'],['routines']
Integrability,"// Placeholder type for type-dependent expressions whose type is; // completely unknown. No code should ever check a type against; // DependentTy and users should never see it; however, it is here to; // help diagnose failures to properly check for type-dependent; // expressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:29,depend,dependent,29,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,3,"['Depend', 'depend']","['DependentTy', 'dependent']"
Integrability,// Plain 'char' is named Char_S or Char_U depending on the target ABI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:42,depend,depending,42,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['depend'],['depending']
Integrability,"// Plot ""physics"" slice of simultaneous pdf.; // NBL You _must_ project the sample index category with data using ProjWData; // as a RooSimultaneous makes no prediction on the shape in the index category; // and can thus not be integrated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:228,integrat,integrated,228,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['integrat'],['integrated']
Integrability,"// Plot likelihood in m0 in range that includes problematic values; // In this configuration no messages are printed for likelihood evaluation errors,; // but if an likelihood value evaluates with error, the corresponding value; // on the curve will be set to the value given in EvalErrorValue().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:96,message,messages,96,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['message'],['messages']
Integrability,"// Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))); //; // Plot asymmetry of ourselves, defined as; //; // asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ); //; // on frame. If frame contains a histogram, all dimensions of the plotted; // asymmetry function that occur in the previously plotted dataset are projected via partial integration.; // Otherwise no projections are performed,; //; // The asymmetry function can be multiplied with an optional scale factor. The default projection; // behaviour can be overridden by supplying an optional set of dependents to project.; // Sanity checks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:400,integrat,integration,400,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,2,"['depend', 'integrat']","['dependents', 'integration']"
Integrability,"// PoD protocol string",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:7,protocol,protocol,7,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['protocol'],['protocol']
Integrability,// Pointer to an interface that can provide function bodies for; // declarations from external source.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/AnalysisDeclContext.h:17,interface,interface,17,interpreter/llvm-project/clang/include/clang/Analysis/AnalysisDeclContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/AnalysisDeclContext.h,1,['interface'],['interface']
Integrability,"// Pop-up pieces needs the index of the last reported piece and its count; // how many times we report to handle multiple reports on the same range.; // This marks the variable, adds the </table> end tag and the message; // (list element) as a row. The <table> start tag will be added after the; // rows has been written out. Note: It stores every different range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:212,message,message,212,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,1,['message'],['message']
Integrability,"// Portions of the ModR/M byte; // These fields determine the allowable values for the ModR/M fields, which; // depend on operand and address widths.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86DisassemblerDecoder.h:112,depend,depend,112,interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86DisassemblerDecoder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86DisassemblerDecoder.h,1,['depend'],['depend']
Integrability,"// Position dependent, so check twice for swap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:12,depend,dependent,12,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,1,['depend'],['dependent']
Integrability,"// Position interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveTrans.h:12,interface,interface,12,graf3d/eve/inc/TEveTrans.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveTrans.h,2,['interface'],['interface']
Integrability,"// Position of fBufCur when message was compressed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TMessage.h:28,message,message,28,net/net/inc/TMessage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TMessage.h,1,['message'],['message']
Integrability,"// Position slice in mixState at ""mixed"" and plot slice of pdf in mixstate over data (integrated over tagFlav)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:86,integrat,integrated,86,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['integrat'],['integrated']
Integrability,"// Position slice in mixState at ""unmixed"" and plot slice of pdf in mixstate over data (integrated over tagFlav)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:88,integrat,integrated,88,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['integrat'],['integrated']
Integrability,"// Positive distance bigger than max vectorization factor.; // FIXME: Should use max factor instead of max distance in bytes, which could; // not handle different types.; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // void foo (int *A, char *B) {; // for (unsigned i = 0; i < 1024; i++) {; // A[i+2] = A[i] + 1;; // B[i+2] = B[i] + 1;; // }; // }; //; // This case is currently unsafe according to the max safe distance. If we; // analyze the two accesses on array B, the max safe dependence distance; // is 2. Then we analyze the accesses on array A, the minimum distance needed; // is 8, which is less than 2 and forbidden vectorization, But actually; // both A and B could be vectorized by 2 iterations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:506,depend,dependence,506,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['dependence']
Integrability,// Possibly throwing calls are usually wrapped by EH_LABEL; // instructions. We don't want to split them and the call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:39,wrap,wrapped,39,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,1,['wrap'],['wrapped']
Integrability,// PostIncNormalization effectively simplifies the expression under; // pre-increment assumptions. Those assumptions (no wrapping) might not; // hold for the post-inc value. Catch such cases by making sure the; // transformation is invertible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:121,wrap,wrapping,121,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,1,['wrap'],['wrapping']
Integrability,// Postpone analysis in dependent contexts for ranged for loops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:24,depend,dependent,24,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['depend'],['dependent']
Integrability,// Postpone emission of PHIs operands to avoid cyclic dependencies issues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:54,depend,dependencies,54,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['depend'],['dependencies']
Integrability,// Postprocess the DAG to add platform-specific artificial dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:59,depend,dependencies,59,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,1,['depend'],['dependencies']
Integrability,// Potentially wrap the base FE action in an ARC Migrate Tool action.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp:15,wrap,wrap,15,interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp,1,['wrap'],['wrap']
Integrability,// Pre opaque pointers we have a constant expression wrapping the constant; // string.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp:53,wrap,wrapping,53,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp,1,['wrap'],['wrapping']
Integrability,"// Precalculate whether this is a friend function template with a constraint; // that depends on an enclosing template, per [temp.friend]p9.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:86,depend,depends,86,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['depends']
Integrability,// Prefer 'super' when we're completing in a message-receiver; // context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:45,message,message-receiver,45,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['message'],['message-receiver']
Integrability,// Prefer a non-wrapping signed range here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:16,wrap,wrapping,16,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,1,['wrap'],['wrapping']
Integrability,// Prefer an expression error over a generic invalid argument message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:62,message,message,62,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['message'],['message']
Integrability,"// Prefix quoted wrap",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValuePrinter.cpp:17,wrap,wrap,17,interpreter/cling/lib/Interpreter/ValuePrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValuePrinter.cpp,1,['wrap'],['wrap']
Integrability,"// Prefix to be prepended to messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TApplicationServer.h:29,message,messages,29,net/net/inc/TApplicationServer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TApplicationServer.h,2,['message'],['messages']
Integrability,"// Prepare for recursion, next integral should integrate last integrand",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:47,integrat,integrate,47,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['integrat'],['integrate']
Integrability,"// Prepare the list of candidates first.; // Algorithm depends on random option.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:55,depend,depends,55,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['depend'],['depends']
Integrability,// Prepare to assign register arguments. Every argument uses up a; // GPR protocol register even if it's passed in a floating-point; // register (unless we're using the fast calling convention).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:74,protocol,protocol,74,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['protocol'],['protocol']
Integrability,// Present a minimal LLVM-like casting interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Address.h:39,interface,interface,39,interpreter/llvm-project/clang/lib/CodeGen/Address.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Address.h,1,['interface'],['interface']
Integrability,// Preserve any contraction performed by the front-end. (Strict performs; // splitting of the muladd intrinsic in the backend.),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:16,contract,contraction,16,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,1,['contract'],['contraction']
Integrability,"// Preserve some flags which should not be dropped when setting flags.; // Also, preserve anything OS/processor dependant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObjcopy.cpp:112,depend,dependant,112,interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObjcopy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObjcopy.cpp,1,['depend'],['dependant']
Integrability,"// Preserve the lexical DeclContext if it is not the surrounding tag; // injection context of the FD. In this example, the semantic context of; // E will be f and the lexical context will be S, while both the; // semantic and lexical contexts of S will be f:; // void f(struct S { enum E { a } f; } s);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:73,inject,injection,73,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['inject'],['injection']
Integrability,"// Pretend that we exit the ""top-level"" include file.; // Note that in case of an error (e.g. control stack imbalance); // the routine will issue a fatal error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp:127,rout,routine,127,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,1,['rout'],['routine']
Integrability,// Pretend the variable template specializations are class template; // specializations and form a fake injected class name type for comparison.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:104,inject,injected,104,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['inject'],['injected']
Integrability,"// Prevent CSE-ing non-local convergent instructions.; // LLVM's current definition of `isConvergent` does not necessarily prove; // that non-local CSE is illegal. The following check extends the definition; // of `isConvergent` to assume a convergent instruction is dependent not; // only on additional conditions, but also on fewer conditions. LLVM does; // not have a MachineInstr attribute which expresses this extended; // definition, so it's necessary to use `isConvergent` to prevent illegally; // CSE-ing the subset of `isConvergent` instructions which do fall into this; // extended definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:267,depend,dependent,267,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['depend'],['dependent']
Integrability,"// Prevent redundant register copies due to reads and writes of physical; // registers. The original motivation for this was the code generated; // between two calls, which are caused both the return value and the; // argument for the next call being in %r0.; // Example:; // 1: <call1>; // 2: %vreg = COPY %r0; // 3: <use of %vreg>; // 4: %r0 = ...; // 5: <call2>; // The scheduler would often swap 3 and 4, so an additional register is; // needed. This code inserts a Barrier dependence between 3 & 4 to prevent; // this.; // The code below checks for all the physical registers, not just R0/D0/V0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:478,depend,dependence,478,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['depend'],['dependence']
Integrability,"// Prevent the search from reaching this container again. This is; // important with categories, which override methods from the; // interface and each other.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:133,interface,interface,133,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['interface'],['interface']
Integrability,// Previous False Positive in the following Code:; // `template <typename T> void f() { int i = 42; new Type<T>(i); }`; // Where the constructor of `Type` takes its argument as reference.; // The AST does not resolve in a `cxxConstructExpr` because it is; // type-dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp:264,depend,dependent,264,interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,1,['depend'],['dependent']
Integrability,// Primary pass pipeline description parsing routine for a \c CGSCCPassManager,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp:45,rout,routine,45,interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,1,['rout'],['routine']
Integrability,// Primary pass pipeline description parsing routine for a \c LoopPassManager,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp:45,rout,routine,45,interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,1,['rout'],['routine']
Integrability,// Primary pass pipeline description parsing routine for a \c ModulePassManager; // FIXME: Should this routine accept a TargetMachine or require the caller to; // pre-populate the analysis managers with target-specific stuff?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp:45,rout,routine,45,interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,2,['rout'],['routine']
Integrability,// Primary pass pipeline description parsing routine for a \c; // FunctionPassManager,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp:45,rout,routine,45,interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,1,['rout'],['routine']
Integrability,// Print SYSTEM_LIBS after --libs.; // FIXME: Each LLVM component may have its dependent system libs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:79,depend,dependent,79,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,1,['depend'],['dependent']
Integrability,"// Print a happy message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:17,message,message,17,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['message'],['message']
Integrability,// Print a message here so that we know addModule() did not abort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:11,message,message,11,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,1,['message'],['message']
Integrability,// Print a warning along with its fix-it message at the given range.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:41,message,message,41,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['message'],['message']
Integrability,// Print an error message if unrecognized character.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp:18,message,message,18,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp,1,['message'],['message']
Integrability,// Print error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:15,message,messages,15,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['message'],['messages']
Integrability,"// Print header info for extra headers, pretending they were discovered by; // the regular preprocessor. The primary use case is to support proper; // generation of Make / Ninja file dependencies for implicit includes, such; // as sanitizer ignorelists. It's only important for cl.exe compatibility,; // the GNU way to generate rules is -M / -MM / -MD / -MMD.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp:183,depend,dependencies,183,interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp,1,['depend'],['dependencies']
Integrability,"// Print help message and exit if ""--help""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/src/ReadSpeedCLI.cxx:14,message,message,14,tree/readspeed/src/ReadSpeedCLI.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/src/ReadSpeedCLI.cxx,1,['message'],['message']
Integrability,"// Print level support for RooFit-related messages that are not routed through RooMsgService (such as Minuit printouts)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMsgService.h:42,message,messages,42,roofit/roofitcore/inc/RooMsgService.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMsgService.h,2,"['message', 'rout']","['messages', 'routed']"
Integrability,// Print message so mismatches with eraseInstrs() can be diagnosed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:9,message,message,9,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['message'],['message']
Integrability,"// Print nothing if there are no dependencies",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:33,depend,dependencies,33,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['depend'],['dependencies']
Integrability,"// Print out the IR after passes, similar to -print-after-all except that it; // only prints the IR after passes that change the IR. Those passes that do not; // make changes to the IR are reported as not making any changes. In addition,; // the initial IR is also reported. Other hidden options affect the output from; // this option. -filter-passes will limit the output to the named passes that; // actually change the IR and other passes are reported as filtered out. The; // specified passes will either be reported as making no changes (with no IR; // reported) or the changed IR will be reported. Also, the -filter-print-funcs; // and -print-module-scope options will do similar filtering based on function; // name, reporting changed IRs as functions(or modules if -print-module-scope is; // specified) for a particular function or indicating that the IR has been; // filtered out. The extra options can be combined, allowing only changed IRs; // for certain passes on certain functions to be reported in different formats,; // with the rest being reported as filtered out. The -print-before-changed; // option will print the IR as it was before each pass that changed it. The; // optional value of quiet will only report when the IR changes, suppressing all; // other messages, including the initial IR. The values ""diff"" and ""diff-quiet""; // will present the changes in a form similar to a patch, in either verbose or; // quiet mode, respectively. The lines that are removed and added are prefixed; // with '-' and '+', respectively. The -filter-print-funcs and -filter-passes; // can be used to filter the output. This reporter relies on the linux diff; // utility to do comparisons and insert the prefixes. For systems that do not; // have the necessary facilities, the error message will be shown in place of; // the expected output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PrintPasses.cpp:1277,message,messages,1277,interpreter/llvm-project/llvm/lib/IR/PrintPasses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PrintPasses.cpp,2,['message'],"['message', 'messages']"
Integrability,// Print out the dependency results to STDOUT by default.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:17,depend,dependency,17,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,1,['depend'],['dependency']
Integrability,"// Print primary diagnostic messages in bold and without color, to visually; // indicate the transition from continuation notes and other output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:28,message,messages,28,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,1,['message'],['messages']
Integrability,// Print routines used by debug-pass,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h:9,rout,routines,9,interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,1,['rout'],['routines']
Integrability,// Print some info about passes added to the wrapper. This is however; // incomplete as InlineAdvisorAnalysis part isn't included (which also depends; // on Params and Mode).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:45,wrap,wrapper,45,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,2,"['depend', 'wrap']","['depends', 'wrapper']"
Integrability,"// Print the bug report message that would be printed if we did actually; // crash, but only if we're crashing due to FORCE_CLANG_DIAGNOSTICS_CRASH.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:24,message,message,24,interpreter/llvm-project/clang/tools/driver/driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp,1,['message'],['message']
Integrability,"// Print the current values for all the options, after the dependencies; // has been resolved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVOptions.cpp:59,depend,dependencies,59,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVOptions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVOptions.cpp,1,['depend'],['dependencies']
Integrability,"// Print the interface ID operands, skipping the name's string; // literal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVInstPrinter.cpp:13,interface,interface,13,interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVInstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVInstPrinter.cpp,1,['interface'],['interface']
Integrability,"// Printing interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsBinning.h:12,interface,interface,12,roofit/roofitcore/inc/RooAbsBinning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsBinning.h,7,['interface'],['interface']
Integrability,"// Printing interface (human readable)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/Roo1DTable.h:12,interface,interface,12,roofit/roofitcore/inc/Roo1DTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/Roo1DTable.h,21,['interface'],['interface']
Integrability,// Prints a bottleneck message to OS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:23,message,message,23,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,1,['message'],['message']
Integrability,"// Prints additional information for an object, depending on its kind; // (class attributes, debug ranges, files, directories, etc).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVObject.h:48,depend,depending,48,interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVObject.h,1,['depend'],['depending']
Integrability,"// Prints content of all cells; // Message logger",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/PDEFoam.h:35,Message,Message,35,tmva/tmva/inc/TMVA/PDEFoam.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/PDEFoam.h,1,['Message'],['Message']
Integrability,// Prints option name followed by message. Always returns true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h:34,message,message,34,interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,1,['message'],['message']
Integrability,"// Prints summary of MC integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/inc/TFoam.h:24,integrat,integration,24,math/foam/inc/TFoam.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/inc/TFoam.h,1,['integrat'],['integration']
Integrability,"// Prints the same analysis as dump(), but its definition is not dependent; // on the build.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:65,depend,dependent,65,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['depend'],['dependent']
Integrability,"// Prior behavior was to return getFileOffset, which was only used as an; // in a test against std::string::npos. By returning 0 we preserve prior; // behavior to pass the test against std::string::npos and wrap everything",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp:207,wrap,wrap,207,interpreter/cling/lib/Utils/SourceNormalization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp,1,['wrap'],['wrap']
Integrability,// Proceed with evaluate the message expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:29,message,message,29,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,1,['message'],['message']
Integrability,"// Process integration over remaining integration variables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:11,integrat,integration,11,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,2,['integrat'],['integration']
Integrability,// Process list of dependences.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:19,depend,dependences,19,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['depend'],['dependences']
Integrability,// Process list of dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:19,depend,dependencies,19,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,2,['depend'],['dependencies']
Integrability,"// Process message to replay when adding new workers dynamically",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TProofPlayer.h:11,message,message,11,proof/proofplayer/inc/TProofPlayer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TProofPlayer.h,1,['message'],['message']
Integrability,"// Process messages coming from widgets associated with the dialog.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/guitest.cxx:11,message,messages,11,test/guitest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/guitest.cxx,1,['message'],['messages']
Integrability,"// Process messages sent to this dialog.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/guitest.cxx:11,message,messages,11,test/guitest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/guitest.cxx,2,['message'],['messages']
Integrability,"// Process pattern as an exact string match, depending on the case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVOptions.cpp:45,depend,depending,45,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVOptions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVOptions.cpp,1,['depend'],['depending']
Integrability,"// Process slider messages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/guitest.cxx:18,message,messages,18,test/guitest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/guitest.cxx,2,['message'],['messages']
Integrability,"// Process target and dependent features. This is done in two loops collecting; // them into UpdatedFeaturesVec: first to add dependent '+'features, second to; // add target '+/-'features that can later disable some of features added on; // the first loop. Function Multi Versioning features begin with '?'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:22,depend,dependent,22,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,2,['depend'],['dependent']
Integrability,// Process the attributes before looking at protocols to ensure that the; // availability attribute is attached to the category to provide availability; // checking for protocol uses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:44,protocol,protocols,44,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['protocol'],"['protocol', 'protocols']"
Integrability,"// Process the message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:15,message,message,15,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['message'],['message']
Integrability,// Produce a placeholder value if the specialization is dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:56,depend,dependent,56,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,"// Produce files forward compatible with (unpatched) version older than; // v6.30 by recording the internal bits kIsOnHeap and kNotDeleted; Older; // releases were not explicitly setting those bits to the correct value; // but instead used verbatim the value stored in the file.; // Note that to avoid a circular dependency, this value is used; // hard coded in TObject.cxx.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h:313,depend,dependency,313,io/io/inc/TFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h,1,['depend'],['dependency']
Integrability,"// Profile tracker that manages profiles and its associated context. It; // provides interfaces used by sample profile loader to query context profile or; // base profile for given function or location; it also manages context tree; // manipulation that is needed to accommodate inline decisions so we have; // accurate post-inline profile for functions. Internally context profiles; // are organized in a trie, with each node representing profile for specific; // calling context and the context is identified by path from root to the node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleContextTracker.h:85,interface,interfaces,85,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleContextTracker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleContextTracker.h,1,['interface'],['interfaces']
Integrability,"// Program is loading user32.dll, in the applications we are testing,; // this only happens if an assert has fired. By now the message has; // already been printed, so simply close the program.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp:127,message,message,127,interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp,1,['message'],['message']
Integrability,"// Program to check a TGeo geometry; // The first time you run this program, the geometry files will be taken; // from http://root.cern/files; //; // How the program works; // If the file <geom_name>_ref.root does not exist, it is generated. The file; // contains a TTree with Npoints (default=100000) obtained with the following; // algorithm:; // -a point is generated with a uniform distribution x,y,z in the master volume; // -a direction theta, phi is generated uniformly in -2pi<phi<2pi and 0<theta<pi; // -gGeoManager finds the geometry path for the point; // -the number of boundaries (nbound), total length (length), safety distance; // from the starting point (safe) and number of radiation lengths (rad) from x,y,z; // is calculated to the exit of the detector. The total number of crossings, detector; // weight and total number of radiation lengths for all tracks are stored as user info in the tree.; //; // Using the file <geom_name>_ref.root (generated typically with a previous version; // of the TGeo classes), the Npoints in the Tree are used to perform the; // same operation with the new version.; // In case of a disagreement, an error message is reported.; //; // The ReadRef case is also used as a benchmark; // The ROOTMARKS reported are relative to a Linux/P IV 2.8 GHz gcc3.2.3 machine; // normalized at 800 ROOTMARKS when running with CINT.; //; // To run this script, do; // stressGeometry; // or stressGeometry *; // or stressGeometry alice; // or from the ROOT command line; // root > .L stressGeometry.cxx or .L stressGeometry.cxx+; // root > stressGeometry(exp_name); // where exp_name is the geometry file name without .root; // OR simply: stressGeometry(); to run tests for a set of geometries; //; // Authors: Rene Brun, Andrei Gheata, 22 march 2005",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressGeometry.cxx:1158,message,message,1158,test/stressGeometry.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressGeometry.cxx,1,['message'],['message']
Integrability,"// Project model on x, integrating projected observables (y,z) only in ""sigRegion""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:23,integrat,integrating,23,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['integrat'],['integrating']
Integrability,"// Project model on x, integrating projected observables (y,z) with Monte Carlo technique; // on set of events with the same llratio cut as was applied to data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:23,integrat,integrating,23,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['integrat'],['integrating']
Integrability,"// Promote the load. Keeping the iterator straight is a; // pain, so we let the merge routine tell us what the next instruction; // is after it's done mucking about.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp:86,rout,routine,86,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,1,['rout'],['routine']
Integrability,"// Promoted i16. tzcntw has a false dependency on Intel CPUs. For BSF, we emit; // a REP prefix to encode it as TZCNT for modern CPUs so it makes sense to; // promote that too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,depend,dependency,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['depend'],['dependency']
Integrability,// Propagate block-level dependencies through the block-dependence graph.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:25,depend,dependencies,25,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,2,['depend'],"['dependence', 'dependencies']"
Integrability,// Propagate dependence of the result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:13,depend,dependence,13,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,1,['depend'],['dependence']
Integrability,// Propagate info to the dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Action.cpp:25,depend,dependencies,25,interpreter/llvm-project/clang/lib/Driver/Action.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Action.cpp,1,['depend'],['dependencies']
Integrability,// Propagate liveness from collected Global Values through the computed; // dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:76,depend,dependencies,76,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,1,['depend'],['dependencies']
Integrability,// Propagate the extra dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:23,depend,dependencies,23,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['depend'],['dependencies']
Integrability,// Property accessor stubs sometimes do not correspond to any property decl; // in the current interface (but in a superclass). They still have a; // corresponding property impl decl in this case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp:95,interface,interface,95,interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,1,['interface'],['interface']
Integrability,"// Property metadata: name, attributes, isSynthesized, setter name, setter; // types, getter name, getter types.; // The isSynthesized value is always set to 0 in a protocol. It exists to; // simplify the runtime library by allowing it to use the same data; // structures for protocol metadata everywhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:165,protocol,protocol,165,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,2,['protocol'],['protocol']
Integrability,"// Proposal by cxx-abi-dev, 2014-03-26; // <class-enum-type> ::= <name> # non-dependent or dependent type name or; // # dependent elaborated type specifier using; // # 'typename'; // ::= Ts <name> # dependent elaborated type specifier using; // # 'struct' or 'class'; // ::= Tu <name> # dependent elaborated type specifier using; // # 'union'; // ::= Te <name> # dependent elaborated type specifier using; // # 'enum'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:78,depend,dependent,78,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,6,['depend'],['dependent']
Integrability,// Protect the check so that it's not performed on dependent types and; // dependent alignments (we can't determine the alignment in that case).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,depend,dependent,51,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['depend'],['dependent']
Integrability,"// Protocol and Host",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:3,Protocol,Protocol,3,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['Protocol'],['Protocol']
Integrability,// Protocol description structures; // struct _objc_protocol_extension {; // uint32_t size; // sizeof(struct _objc_protocol_extension); // struct _objc_method_description_list *optional_instance_methods;; // struct _objc_method_description_list *optional_class_methods;; // struct _objc_property_list *instance_properties;; // const char ** extendedMethodTypes;; // struct _objc_property_list *class_properties;; // },MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:3,Protocol,Protocol,3,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['Protocol'],['Protocol']
Integrability,"// Protocol error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:3,Protocol,Protocol,3,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,2,['Protocol'],['Protocol']
Integrability,// Protocol list,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:3,Protocol,Protocol,3,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,2,['Protocol'],['Protocol']
Integrability,"// Protocol methods have no implementation. So, this entry is always NULL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:3,Protocol,Protocol,3,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['Protocol'],['Protocol']
Integrability,"// Protocol number run by the daemon server",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProofMgr.h:3,Protocol,Protocol,3,proof/proof/inc/TProofMgr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProofMgr.h,1,['Protocol'],['Protocol']
Integrability,// Protocol qualifier information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Protocol,Protocol,3,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,2,['Protocol'],['Protocol']
Integrability,"// Protocol run by the client",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx:3,Protocol,Protocol,3,net/net/src/TApplicationServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx,1,['Protocol'],['Protocol']
Integrability,"// Protocol used fro a successful authentication",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:3,Protocol,Protocol,3,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['Protocol'],['Protocol']
Integrability,"// Protocol version used by the server.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TParallelMergingFile.h:3,Protocol,Protocol,3,net/net/inc/TParallelMergingFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TParallelMergingFile.h,1,['Protocol'],['Protocol']
Integrability,"// Protocol version we run; // 1 Initial version",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/RRemoteProtocol.h:3,Protocol,Protocol,3,net/net/inc/RRemoteProtocol.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/RRemoteProtocol.h,1,['Protocol'],['Protocol']
Integrability,// Protocol's property metadata.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Protocol,Protocol,3,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,3,['Protocol'],['Protocol']
Integrability,// Protocol's super protocol list,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Protocol,Protocol,3,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,"['Protocol', 'protocol']","['Protocol', 'protocol']"
Integrability,// ProtocolListnfABIPtrTy - LLVM for struct _objc_protocol_list*,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:3,Protocol,ProtocolListnfABIPtrTy,3,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['Protocol'],['ProtocolListnfABIPtrTy']
Integrability,// ProtocolListnfABITy - LLVM for struct _objc_protocol_list,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:3,Protocol,ProtocolListnfABITy,3,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['Protocol'],['ProtocolListnfABITy']
Integrability,// ProtocolnfABIPtrTy = LLVM for struct _protocol_t*,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:3,Protocol,ProtocolnfABIPtrTy,3,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['Protocol'],['ProtocolnfABIPtrTy']
Integrability,// ProtocolnfABITy = LLVM for struct _protocol_t,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:3,Protocol,ProtocolnfABITy,3,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['Protocol'],['ProtocolnfABITy']
Integrability,// Protocols are in distinct namespaces from everything else.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:3,Protocol,Protocols,3,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,2,['Protocol'],['Protocols']
Integrability,// Protocols are objects containing lists of the methods implemented and; // protocols adopted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:3,Protocol,Protocols,3,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,2,"['Protocol', 'protocol']","['Protocols', 'protocols']"
Integrability,// Protocols are objects containing lists of the methods implemented and; // protocols adopted.; // The isa pointer must be set to a magic number so the runtime knows it's; // the correct layout.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:3,Protocol,Protocols,3,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,2,"['Protocol', 'protocol']","['Protocols', 'protocols']"
Integrability,// Protocols in the class extension belong to the class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:3,Protocol,Protocols,3,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['Protocol'],['Protocols']
Integrability,// Protocols referenced in class declaration?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Protocol,Protocols,3,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,1,['Protocol'],['Protocols']
Integrability,// Protocols referenced in class declaration?; // Null CDecl is case of a category implementation with no category interface,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:3,Protocol,Protocols,3,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,2,"['Protocol', 'interface']","['Protocols', 'interface']"
Integrability,// Protocols referenced in class declaration?; // Protocol's super protocol list,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Protocol,Protocols,3,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,6,"['Protocol', 'protocol']","['Protocol', 'Protocols', 'protocol']"
Integrability,// Protocols?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:3,Protocol,Protocols,3,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,2,['Protocol'],['Protocols']
Integrability,"// Provide PointerLikeTypeTraits for clang::Expr*, this default one requires a; // full definition of Expr, but this file only sees a forward del because of; // the dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h:165,depend,dependency,165,interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h,1,['depend'],['dependency']
Integrability,"// Provide a completion for a lambda introducer here. Except; // in Objective-C, where this is Almost Surely meant to be a message; // send. In that case, fail here and let the ObjC message; // expression parser perform the completion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:123,message,message,123,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,2,['message'],['message']
Integrability,// Provide better error message about types missing a trait specialization,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:24,message,message,24,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,2,['message'],['message']
Integrability,// Provides a very limited vector-like interface for lazily accessing one; // component of a scattered vector or vector pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:39,interface,interface,39,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,1,['interface'],['interface']
Integrability,"// Prune out non-type-dependent expressions if requested. This can; // sometimes result in us failing to find a template parameter reference; // (if a value-dependent expression creates a dependent type), but this; // mode is best-effort only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:22,depend,dependent,22,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,3,['depend'],['dependent']
Integrability,"// Public Interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.h:10,Interface,Interface,10,core/metacling/src/TCling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.h,1,['Interface'],['Interface']
Integrability,// Public Interface To the LowerInvoke pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerInvoke.cpp:10,Interface,Interface,10,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerInvoke.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerInvoke.cpp,1,['Interface'],['Interface']
Integrability,// Public Interface To the SjLjEHPrepare pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:10,Interface,Interface,10,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,1,['Interface'],['Interface']
Integrability,"// Public Interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchElement.h:10,Interface,Interface,10,tree/tree/inc/TBranchElement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchElement.h,1,['Interface'],['Interface']
Integrability,// Public interface to build a H-CFG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp:10,interface,interface,10,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp,1,['interface'],['interface']
Integrability,// Public interface to the CFGSimplification pass,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:10,interface,interface,10,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,1,['interface'],['interface']
Integrability,// Public interface to the FlattenCFG pass,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/FlattenCFGPass.cpp:10,interface,interface,10,interpreter/llvm-project/llvm/lib/Transforms/Scalar/FlattenCFGPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/FlattenCFGPass.cpp,1,['interface'],['interface']
Integrability,// Public interface to the Reassociate pass,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:10,interface,interface,10,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['interface'],['interface']
Integrability,// Public interface to the TailCallElimination pass,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:10,interface,interface,10,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,1,['interface'],['interface']
Integrability,// Public interface to the simplify instructions pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp:10,interface,interface,10,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,1,['interface'],['interface']
Integrability,// Public query interface.; /// Determine whether the specified value comparison with a constant is; /// known to be true or false on the specified CFG edge. Pred is a CmpInst; /// predicate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h:16,interface,interface,16,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,1,['interface'],['interface']
Integrability,// Publicly exposed interface to pass...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:20,interface,interface,20,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,3,['interface'],['interface']
Integrability,"// Publish the message to the separate window (if the latter is missing; // the message will just get lost)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:15,message,message,15,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['message'],['message']
Integrability,"// Purely analytical integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:21,integrat,integration,21,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['integrat'],['integration']
Integrability,"// Purely to help out MSVC which fails to disable the below specialization,; // explicitly enable using the result type's invalidate routine if we can; // successfully call that routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h:133,rout,routine,133,interpreter/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h,2,['rout'],['routine']
Integrability,"// Push dependencies and this node onto the worklist, so that this node is; // visited again after all of its dependencies are handled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:8,depend,dependencies,8,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,2,['depend'],['dependencies']
Integrability,"// Push the current module to the build stack so that clang knows when; // we have a cyclic dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp:92,depend,dependency,92,interpreter/cling/lib/Interpreter/CIFactory.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp,1,['depend'],['dependency']
Integrability,"// Put any constant offset in an addend. Offsets can be negative, and; // LLVM expects wrapping, in contrast to wasm's immediates which can't; // be negative and don't wrap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/WasmObjectWriter.cpp:87,wrap,wrapping,87,interpreter/llvm-project/llvm/lib/MC/WasmObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/WasmObjectWriter.cpp,2,['wrap'],"['wrap', 'wrapping']"
Integrability,// Put out the directory and file tables. The formats vary depending on; // the version.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:59,depend,depending,59,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,1,['depend'],['depending']
Integrability,// Put the basic blocks in program order for correct dependence; // directions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp:53,depend,dependence,53,interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,2,['depend'],['dependence']
Integrability,// Put the biased selects in Unhoistables because they should stay where they; // are and constant-folded after CHR (in case one biased select or a branch; // can depend on another biased select.),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:163,depend,depend,163,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,1,['depend'],['depend']
Integrability,"// Put the character in the output stream in place of the ""&#000;"".; // How we do this depends on whether or not we are using UTF-8.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx:87,depend,depends,87,gui/guihtml/src/TGHtmlParse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx,1,['depend'],['depends']
Integrability,"// Put the loads/stores without dependency into the same group with some; // heuristic if the DAG is too complex to avoid compiling time blow up.; // Notice that, some fusion pair could be lost with this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:32,depend,dependency,32,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['depend'],['dependency']
Integrability,"// Put the pointer to the callee as first argument, so it can be called; // within the invoke wrapper later",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:94,wrap,wrapper,94,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,1,['wrap'],['wrapper']
Integrability,"// Put the wrapper after its declarations. (Nice when AST dumping)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp:11,wrap,wrapper,11,interpreter/cling/lib/Interpreter/DeclExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp,1,['wrap'],['wrapper']
Integrability,"// Python iterator protocol __next__ for STL forward iterators.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx:19,protocol,protocol,19,bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,1,['protocol'],['protocol']
Integrability,"// Python will iterate over __getitem__ using integers, but C++ operator[] will never raise; // a StopIteration. A checked getitem (raising IndexError if beyond size()) works in some; // cases but would mess up if operator[] is meant to implement an associative container. So,; // this has to be implemented as an iterator protocol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx:323,protocol,protocol,323,bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,1,['protocol'],['protocol']
Integrability,"// QualType Opaque Ptr interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TInterpreter.h:23,interface,interface,23,core/meta/inc/TInterpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TInterpreter.h,2,['interface'],['interface']
Integrability,"// Quick check whether the def has already been encountered in the same block.; // PHI nodes are not checked to prevent accepting preceding PHIs, because PHI; // uses are defined to happen on the incoming edge, not at the instruction.; //; // FIXME: If this operand is a MetadataAsValue (wrapping a LocalAsMetadata); // wrapping an SSA value, assert that we've already encountered it. See; // related FIXME in Mapper::mapLocalAsMetadata in ValueMapper.cpp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:288,wrap,wrapping,288,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,2,['wrap'],['wrapping']
Integrability,"// Quoted wrap",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValuePrinter.cpp:10,wrap,wrap,10,interpreter/cling/lib/Interpreter/ValuePrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValuePrinter.cpp,1,['wrap'],['wrap']
Integrability,// RC injects completely into SubRC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:6,inject,injects,6,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['inject'],['injects']
Integrability,"// RColumnElement concrete implementations; //; // Note that this file is in the src directory and not in the inc directory because we need the ability; // to override R__LITTLE_ENDIAN for testing purposes.; // This is not a particularly clean or correct solution, as the tests that do this will end up with two different; // definitions of some RColumnElements, so we might want to change this mechanism in the future. In any case, these; // definitions are implementation details and should not be exposed to a public interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:520,interface,interface,520,tree/ntuple/v7/src/RColumnElement.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx,1,['interface'],['interface']
Integrability,"// RD can be struct, union, class, interface or enum.; // For now, we only handle struct and class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp:35,interface,interface,35,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp,1,['interface'],['interface']
Integrability,"// RDataFrame's generic Fill method supports two possible signatures for Merge.; // Templated to create a dependent type to SFINAE on - in reality, `U` will always be `T`.; // This overload handles Merge(TCollection*)...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx:106,depend,dependent,106,tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RMergeableValue.hxx,1,['depend'],['dependent']
Integrability,"// RDataFrame.AsNumpy helpers; // NOTE: This is a workaround for the missing Take action in the PyROOT interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/PyROOTHelpers.hxx:103,interface,interface,103,tree/dataframe/inc/ROOT/RDF/PyROOTHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/PyROOTHelpers.hxx,1,['interface'],['interface']
Integrability,"// REPL_EXTERNAL_VISIBILITY are symbols that we need to be able to locate; // at runtime. On Windows, this requires them to be exported from any of the; // modules loaded at runtime. Marking them as dllexport achieves this; both; // for DLLs (that normally export symbols as part of their interface) and for; // EXEs (that normally don't export anything).; // For a build with libclang-cpp.dll, this doesn't make any difference - the; // functions would have been exported anyway. But for cases when these are; // statically linked into an EXE, it makes sure that they're exported.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Interpreter/Value.h:289,interface,interface,289,interpreter/llvm-project/clang/include/clang/Interpreter/Value.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Interpreter/Value.h,1,['interface'],['interface']
Integrability,"// REveVectorF wrappers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/inc/ROOT/REveTrackPropagator.hxx:15,wrap,wrappers,15,graf3d/eve7/inc/ROOT/REveTrackPropagator.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/inc/ROOT/REveTrackPropagator.hxx,1,['wrap'],['wrappers']
Integrability,"// ROOT I/O interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TString.h:12,interface,interface,12,core/base/inc/TString.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TString.h,2,['interface'],['interface']
Integrability,"// ROOT TFile interface to SQL database",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/sql/inc/TSQLFile.h:14,interface,interface,14,io/sql/inc/TSQLFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/sql/inc/TSQLFile.h,1,['interface'],['interface']
Integrability,"// ROOT integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/mathtext/src/fontembed.cxx:8,integrat,integration,8,graf2d/mathtext/src/fontembed.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/mathtext/src/fontembed.cxx,2,['integrat'],['integration']
Integrability,"// ROOT namespace; /// Print debugging message to stderr and, on Windows, to the system debugger.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TErrorDefaultHandler.cxx:39,message,message,39,core/base/src/TErrorDefaultHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TErrorDefaultHandler.cxx,1,['message'],['message']
Integrability,"// Raise a warning when trying to use implicit auto injection feature.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:52,inject,injection,52,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,1,['inject'],['injection']
Integrability,// Random may-alias loads don't depend on each other without a; // dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:32,depend,depend,32,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,2,['depend'],"['depend', 'dependence']"
Integrability,"// Random number generator interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooRandom.h:27,interface,interface,27,roofit/roofitcore/inc/RooRandom.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooRandom.h,1,['interface'],['interface']
Integrability,// Range of intructions to be wrapped in a new nested try/catch. A range; // exists in a single BB and does not span multiple BBs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:30,wrap,wrapped,30,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,1,['wrap'],['wrapped']
Integrability,// Range wrappers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h:9,wrap,wrappers,9,interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h,1,['wrap'],['wrappers']
Integrability,"// Range() could change the size of the pad pixmap and therefore should; // be called before the other paint routines",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TFrame.cxx:109,rout,routines,109,graf2d/graf/src/TFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TFrame.cxx,6,['rout'],['routines']
Integrability,"// Rare case where the diagnostics depend on which side is evaluated; // Note that if we get here, CondResult is 0, and at least one of; // TrueResult and FalseResult is non-zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:35,depend,depend,35,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['depend'],['depend']
Integrability,"// Re-exported linkage, record is defined in external interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/Record.h:54,interface,interface,54,interpreter/llvm-project/llvm/include/llvm/TextAPI/Record.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/Record.h,1,['interface'],['interface']
Integrability,"// Re-position at the beginning of the file, if requested.; // This is used by the dialog when it re-opens the log window to; // provide all the session messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:153,message,messages,153,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['message'],['messages']
Integrability,// Re-set the member to trigger a recomputation of the dependence bits; // for the expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:55,depend,dependence,55,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['depend'],['dependence']
Integrability,"// Re-wrap single element structs if necessary. Otherwise, leave any single; // element constant of the right size alone even if it has the wrong type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp:6,wrap,wrap,6,interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp,1,['wrap'],['wrap']
Integrability,"// Reached EOF before seeing a non-preproc token.; // Nothing to wrap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp:65,wrap,wrap,65,interpreter/cling/lib/Utils/SourceNormalization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp,1,['wrap'],['wrap']
Integrability,"// Read a non-empty list of strings and/or ints, each; // possibly preceded by a comma. Unfortunately, the tool behavior depends; // on them existing or not, so we need to memorize where we found them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.cpp:121,depend,depends,121,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.cpp,1,['depend'],['depends']
Integrability,// Read a record. The record format depends on whether this; // is a per-module index or a combined index file. In the per-module; // case the records contain the associated value's ID for correlation; // with VST entries. In the combined index the correlation is done; // via the bitcode offset of the summary records (which were saved; // in the combined index VST entries). The records also contain; // information used for ThinLTO renaming and importing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:36,depend,depends,36,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['depend'],['depends']
Integrability,"// Read file back and send it via message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:34,message,message,34,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['message'],['message']
Integrability,"// Read interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TextInput.h:8,interface,interface,8,core/textinput/src/textinput/TextInput.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TextInput.h,1,['interface'],['interface']
Integrability,"// Read message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdconn.cxx:8,message,message,8,net/rpdutils/src/rpdconn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdconn.cxx,1,['message'],['message']
Integrability,"// Read message len",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdconn.cxx:8,message,message,8,net/rpdutils/src/rpdconn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdconn.cxx,1,['message'],['message']
Integrability,"// Read message type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdconn.cxx:8,message,message,8,net/rpdutils/src/rpdconn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdconn.cxx,1,['message'],['message']
Integrability,"// Read output objec(s) from the received message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:42,message,message,42,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['message'],['message']
Integrability,// Read the directly referenced protocols and their SourceLocations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:32,protocol,protocols,32,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['protocol'],['protocols']
Integrability,// Read the specified bitcode file in and return it. This routine searches the; // link path for the specified file to try to find it...; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:58,rout,routine,58,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,1,['rout'],['routine']
Integrability,// Read the transitive closure of protocols referenced by this class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:34,protocol,protocols,34,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['protocol'],['protocols']
Integrability,"// Reader interface for STL",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderArray.cxx:10,interface,interface,10,tree/treeplayer/src/TTreeReaderArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderArray.cxx,1,['interface'],['interface']
Integrability,"// Reader interface for clones arrays",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderArray.cxx:10,interface,interface,10,tree/treeplayer/src/TTreeReaderArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderArray.cxx,1,['interface'],['interface']
Integrability,"// Reader interface for fixed size arrays",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderArray.cxx:10,interface,interface,10,tree/treeplayer/src/TTreeReaderArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderArray.cxx,1,['interface'],['interface']
Integrability,"// Reader interface for leaf list; // SEE TTreeProxyGenerator.cxx:1319: '//We have a top level raw type'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderArray.cxx:10,interface,interface,10,tree/treeplayer/src/TTreeReaderArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderArray.cxx,1,['interface'],['interface']
Integrability,"// Readonly properties from protocols can be implemented as ""readwrite""; // with a custom setter name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:28,protocol,protocols,28,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['protocol'],['protocols']
Integrability,"// Reads and returns a single resource definition, or error message if any; // occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.h:60,message,message,60,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptParser.h,1,['message'],['message']
Integrability,"// Real-time notification of messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx:29,message,messages,29,net/net/src/TApplicationServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx,4,['message'],['messages']
Integrability,"// Rearrage observables so that all non-integrated observables; // go first (preserving relative order) and all integrated observables; // go last (preserving relative order)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx:40,integrat,integrated,40,roofit/roofitcore/src/RooMultiVarGaussian.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx,2,['integrat'],['integrated']
Integrability,"// Reassign the latency for the previous bests, which requires setting; // the dependence edge in both directions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:79,depend,dependence,79,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['depend'],['dependence']
Integrability,// Reassociate fsub/fadd sequences to create more fadd instructions and; // reduce dependency chains:; // ((X - Y) + Z) - Op1 --> (X + Z) - (Y + Op1),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:83,depend,dependency,83,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['depend'],['dependency']
Integrability,// Reassociate sub/add sequences to create more add instructions and; // reduce dependency chains:; // ((X - Y) + Z) - Op1 --> (X + Z) - (Y + Op1),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:80,depend,dependency,80,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['depend'],['dependency']
Integrability,"// Receive length of message with encode client public key",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:21,message,message,21,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['message'],['message']
Integrability,"// Receive the protocol version run remotely",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:15,protocol,protocol,15,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,2,['protocol'],['protocol']
Integrability,"// Receive the startup message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:23,message,message,23,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,1,['message'],['message']
Integrability,"// Reclaim the special call resource dependence, if this is the beginning; // of a call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:37,depend,dependence,37,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['depend'],['dependence']
Integrability,"// Recomputes the Block Mask of Instr, a VPT or VPST instruction.; // This rebuilds the block mask of the instruction depending on the predicates; // of the instructions following it. This should only be used after the; // MVEVPTBlockInsertion pass has run, and should be used whenever a predicated; // instruction is added to/removed from the block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.h:118,depend,depending,118,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.h,1,['depend'],['depending']
Integrability,// Record any interfaces we find.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:14,interface,interfaces,14,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['interface'],['interfaces']
Integrability,// Record any protocols we find.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:14,protocol,protocols,14,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['protocol'],['protocols']
Integrability,// Record dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:10,depend,dependencies,10,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,1,['depend'],['dependencies']
Integrability,// Record that Record conforms to Protocol.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:34,Protocol,Protocol,34,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,1,['Protocol'],['Protocol']
Integrability,// Record the dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:14,depend,dependency,14,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,1,['depend'],['dependency']
Integrability,"// Record the index of the entry node. At this point, we can build up; // vectors of pointers that are required by the graph routines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp:125,rout,routines,125,interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp,1,['rout'],['routines']
Integrability,// Record this interface -> category map.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:15,interface,interface,15,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['interface'],['interface']
Integrability,"// Recover from arrow accesses to records, e.g.:; // struct MyRecord foo;; // foo->bar; // This is actually well-formed in C++ if MyRecord has an; // overloaded operator->, but that should have been dealt with; // by now--or a diagnostic message already issued if a problem; // was encountered while looking for the overloaded operator->.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:238,message,message,238,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['message'],['message']
Integrability,"// Recovery from invalid cases (e.g. D is an invalid Decl).; // We use the dependent type for the RecoveryExpr to prevent bogus follow-up; // diagnostics, as invalid decls use int as a fallback type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:75,depend,dependent,75,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['depend'],['dependent']
Integrability,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:38,depend,dependent,38,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,6,['depend'],['dependent']
Integrability,// Recurse back into this routine to re-compute state now that this isn't; // a 3 and 1 problem.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:26,rout,routine,26,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['rout'],['routine']
Integrability,// Recurse into protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:16,protocol,protocols,16,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,2,['protocol'],['protocols']
Integrability,"// Recurse over Decls; they might need transformations, too; e.g. in; // void wrapper() { struct X { void f() { ++dynScope; } }; }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp:78,wrap,wrapper,78,interpreter/cling/lib/Interpreter/DynamicLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp,1,['wrap'],['wrapper']
Integrability,// Recursively disable all features that depends on this one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/AArch64TargetParser.cpp:41,depend,depends,41,interpreter/llvm-project/llvm/lib/TargetParser/AArch64TargetParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/AArch64TargetParser.cpp,1,['depend'],['depends']
Integrability,"// Recursively enable all features that this one depends on. This handles all; // of the simple cases, where the behaviour doesn't depend on the base; // architecture version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/AArch64TargetParser.cpp:49,depend,depends,49,interpreter/llvm-project/llvm/lib/TargetParser/AArch64TargetParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/AArch64TargetParser.cpp,2,['depend'],"['depend', 'depends']"
Integrability,"// Recursively merge the two given manifest trees, depending on which elements; // are of a mergeable type, and choose namespaces according to which have; // higher priority.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:51,depend,depending,51,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,1,['depend'],['depending']
Integrability,"// Recursively walk the AST for the @synchronized object expr, it is; // evaluated in the normal scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:37,synchroniz,synchronized,37,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,1,['synchroniz'],['synchronized']
Integrability,"// Recursively walk the AST for the @synchronized part, protected by a new; // scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:37,synchroniz,synchronized,37,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,1,['synchroniz'],['synchronized']
Integrability,"// Redetermine explicit list of dependents if intPdf is being replaced",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProjectedPdf.cxx:32,depend,dependents,32,roofit/roofitcore/src/RooProjectedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProjectedPdf.cxx,1,['depend'],['dependents']
Integrability,"// Reduce exclLVBranches to only those depending exclusively on exclLVservers; // Attention: counting loop, since erasing from container",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:39,depend,depending,39,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['depend'],['depending']
Integrability,// Reduce false anti-dependencies to let the target's out-of-order execution; // engine do its thing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:21,depend,dependencies,21,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['depend'],['dependencies']
Integrability,"// Reduce iset/nset to actual dependents of this PDF",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddHelpers.cxx:30,depend,dependents,30,roofit/roofitcore/src/RooAddHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddHelpers.cxx,1,['depend'],['dependents']
Integrability,"// Reduce pdfNSet to actual dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:28,depend,dependents,28,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['depend'],['dependents']
Integrability,// Reduction operations depend on whether the input operand is SGPR or VGPR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:24,depend,depend,24,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['depend'],['depend']
Integrability,"// Reevaluate whether ObjC message arguments fit into one line.; // If a receiver spans multiple lines, e.g.:; // [[object block:^{; // return 42;; // }] a:42 b:42];; // BreakBeforeParameter is calculated based on an incorrect assumption; // (it is checked whether the whole expression fits into one line without; // considering a line break inside a message receiver).; // We check whether arguments fit after receiver scope closer (into the same; // line).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:27,message,message,27,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,2,['message'],['message']
Integrability,"// References:; //; // 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; // An adaptive algorithm for numerical integration over; // an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; // 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; // integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217.; //to be changed later",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx:117,integrat,integration,117,math/mathcore/src/AdaptiveIntegratorMultiDim.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx,2,['integrat'],['integration']
Integrability,"// Refine MinAbsVarIndex, if abs(Scale*V) >= abs(Scale) holds in the; // presence of potentially wrapping math.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:97,wrap,wrapping,97,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['wrap'],['wrapping']
Integrability,"// Refresh the warning message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleDialog.cxx:23,message,message,23,gui/ged/src/TStyleDialog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleDialog.cxx,1,['message'],['message']
Integrability,"// Region 1 y-dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TMath.cxx:14,depend,dependents,14,math/mathcore/src/TMath.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TMath.cxx,1,['depend'],['dependents']
Integrability,"// Region 2 y-dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TMath.cxx:14,depend,dependents,14,math/mathcore/src/TMath.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TMath.cxx,1,['depend'],['dependents']
Integrability,"// Region 3 y-dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TMath.cxx:14,depend,dependents,14,math/mathcore/src/TMath.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TMath.cxx,1,['depend'],['dependents']
Integrability,"// Register debug object, return error message or null for success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp:39,message,message,39,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp,1,['message'],['message']
Integrability,// Register dependencies for all symbols contained in this set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.cpp:12,depend,dependencies,12,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.cpp,1,['depend'],['dependencies']
Integrability,"// Register dependencies, record whether any depenendency is in the error; // state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:12,depend,dependencies,12,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['depend'],['dependencies']
Integrability,"// Register integrator for appropriate dimensionalities",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumGenConfig.cxx:12,integrat,integrator,12,roofit/roofitcore/src/RooNumGenConfig.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumGenConfig.cxx,2,['integrat'],['integrator']
Integrability,// Register must be incremental (with a wraparound at last register).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:40,wrap,wraparound,40,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,1,['wrap'],['wraparound']
Integrability,"// Register the checker that checks for direct accesses in all functions,; // except for the initialization and copy routines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp:117,rout,routines,117,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp,1,['rout'],['routines']
Integrability,"// Register the factory interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooLagrangianMorphFunc.cxx:24,interface,interface,24,roofit/roofit/src/RooLagrangianMorphFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooLagrangianMorphFunc.cxx,1,['interface'],['interface']
Integrability,// Register the support for object-file-wrapped Clang modules.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp:40,wrap,wrapped,40,interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/c-index-test/core_main.cpp,2,['wrap'],['wrapped']
Integrability,// Register the support for object-file-wrapped Clang modules.; // FIXME: Clang should register these container operations automatically.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:40,wrap,wrapped,40,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,1,['wrap'],['wrapped']
Integrability,"// Register this class with RooNumIntConfig; ////////////////////////////////////////////////////////////////////////////////; /// Register RooAdaptiveIntegratorND, its parameters, dependencies and capabilities with RooNumIntFactory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAdaptiveIntegratorND.cxx:181,depend,dependencies,181,roofit/roofitcore/src/RooAdaptiveIntegratorND.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAdaptiveIntegratorND.cxx,1,['depend'],['dependencies']
Integrability,"// RegisterMapping objects are mainly used to track physical register; // definitions and resolve data dependencies.; //; // Every register declared by the Target is associated with an instance of; // RegisterMapping. RegisterMapping objects keep track of writes to a logical; // register. That information is used by class RegisterFile to resolve data; // dependencies, and correctly set latencies for register uses.; //; // This implementation does not allow overlapping register files. The only; // register file that is allowed to overlap with other register files is; // register file #0. If we exclude register #0, every register is ""owned"" by; // at most one register file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h:103,depend,dependencies,103,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RegisterFile.h,2,['depend'],['dependencies']
Integrability,"// Registry for analytical integration codes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAICRegistry.h:27,integrat,integration,27,roofit/roofitcore/inc/RooAICRegistry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAICRegistry.h,1,['integrat'],['integration']
Integrability,"// Regmasks are not accounted for in the scheduling graph, so we need; // to explicitly check for dependencies caused by them. They should only; // appear on calls, so it's not too pessimistic to reject all regmask; // dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:98,depend,dependencies,98,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,2,['depend'],['dependencies']
Integrability,"// Reinitialize embedded integrators, will automatically propagate new limits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooImproperIntegrator1D.cxx:25,integrat,integrators,25,roofit/roofitcore/src/RooImproperIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooImproperIntegrator1D.cxx,1,['integrat'],['integrators']
Integrability,"// Reject -static-libgcc for now, we can deal with this when and if someone; // cares. This is useful in situations where someone wants to statically link; // something like libstdc++, and needs its runtime support routines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:215,rout,routines,215,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['rout'],['routines']
Integrability,// Reject a protocol-unqualified id.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:12,protocol,protocol-unqualified,12,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['protocol'],['protocol-unqualified']
Integrability,// Reject even if the type is dependent; an operator delete function is; // required to have a non-dependent result type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:30,depend,dependent,30,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,2,['depend'],['dependent']
Integrability,// Reject sizeof(interface) and sizeof(interface<proto>) if the; // runtime doesn't allow it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:17,interface,interface,17,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['interface'],['interface']
Integrability,// Related to \@optional/\@required declared in \@protocol,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:50,protocol,protocol,50,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['protocol'],['protocol']
Integrability,// Related to protocols declared in \@protocol,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:14,protocol,protocols,14,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,2,['protocol'],"['protocol', 'protocols']"
Integrability,// Relax the rule and look into class's implementation for a synthesize; // or dynamic declaration. Class is implementing a property coming from; // another protocol. This still makes the target protocol as conforming.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:157,protocol,protocol,157,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,2,['protocol'],['protocol']
Integrability,// Release dependent instructions for scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:11,depend,dependent,11,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['depend'],['dependent']
Integrability,// Release the order dependency with this group.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:21,depend,dependency,21,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,1,['depend'],['dependency']
Integrability,"// Release the special call resource dependence, if this is the beginning; // of a call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:37,depend,dependence,37,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['depend'],['dependence']
Integrability,"// Release the special call resource dependence, if this is the end; // of a call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:37,depend,dependence,37,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['depend'],['dependence']
Integrability,// Relocation-related interfaces.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h:22,interface,interfaces,22,interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,1,['interface'],['interfaces']
Integrability,// RemInst can't be the terminator if it has local stuff depending on it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:57,depend,depending,57,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['depending']
Integrability,"// Remaining cases assume at least that B and D are constant, and depend on; // their actual values. This isn't strictly necessary, just a ""handle the; // easy cases for now"" decision.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:66,depend,depend,66,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['depend'],['depend']
Integrability,"// Remember all explicit private FieldDecls that have a name, no side; // effects and are not part of a dependent type declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:104,depend,dependent,104,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['dependent']
Integrability,// Remember all the @protocol(<expr>) expressions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:21,protocol,protocol,21,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['protocol'],['protocol']
Integrability,"// Remember dominators of blocks we might reach through exits to change them; // later. Immediate dominator of such block might change, because we add more; // routes which can lead to the exit: we can reach it from the peeled; // iterations too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:160,rout,routes,160,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,1,['rout'],['routes']
Integrability,// Remember that this was shadowed so we can either warn about its; // modification or its existence depending on warning settings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:101,depend,depending,101,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['depending']
Integrability,// Remember the use. Data dependencies will be added when we find the def.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:26,depend,dependencies,26,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['depend'],['dependencies']
Integrability,"// Remote port: the default should be 1094 because we are here; // only if the protocol is ""root://""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TNetFile.cxx:79,protocol,protocol,79,net/net/src/TNetFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TNetFile.cxx,1,['protocol'],['protocol']
Integrability,"// Remove PDF dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddHelpers.cxx:14,depend,dependents,14,roofit/roofitcore/src/RooAddHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddHelpers.cxx,1,['depend'],['dependents']
Integrability,"// Remove all interfaces this pass implements, for which it is also; // listed as the available implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:14,interface,interfaces,14,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,1,['interface'],['interfaces']
Integrability,// Remove all the types built while building this type.; // This is pessimistic as some of these types might not be dependent on; // the type that used an address.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:116,depend,dependent,116,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,1,['depend'],['dependent']
Integrability,"// Remove already integrated observables from to-do list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:18,integrat,integrated,18,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['integrat'],['integrated']
Integrability,"// Remove analytically integratable observables from numeric integration list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenProdProj.cxx:23,integrat,integratable,23,roofit/roofitcore/src/RooGenProdProj.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenProdProj.cxx,2,['integrat'],"['integratable', 'integration']"
Integrability,"// Remove any dependents of found, replace by dependents of LV node",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:14,depend,dependents,14,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,2,['depend'],['dependents']
Integrability,// Remove any implied protocols from the list of inherited protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:22,protocol,protocols,22,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,2,['protocol'],['protocols']
Integrability,"// Remove coef dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddHelpers.cxx:15,depend,dependents,15,roofit/roofitcore/src/RooAddHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddHelpers.cxx,1,['depend'],['dependents']
Integrability,// Remove early-clobber and exec dependency from simple SGPR copies.; // This allows some to be eliminated during/post RA.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:33,depend,dependency,33,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['depend'],['dependency']
Integrability,"// Remove from m_sockets; // Can't search by the key of m_sockets, as that is the wrapped; // object, but have to use the pointer to the wrapper; // (zmq::socket_t)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/src/ZeroMQPoller.cpp:82,wrap,wrapped,82,roofit/roofitZMQ/src/ZeroMQPoller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/src/ZeroMQPoller.cpp,2,['wrap'],"['wrapped', 'wrapper']"
Integrability,"// Remove interleaved groups with gaps whose memory; // accesses may wrap around. We have to revisit the getPtrStride analysis,; // this time with ShouldCheckWrap=true, since collectConstStrideAccesses does; // not check wrapping (see documentation there).; // FORNOW we use Assume=false;; // TODO: Change to Assume=true but making sure we don't exceed the threshold; // of runtime SCEV assumptions checks (thereby potentially failing to; // vectorize altogether).; // Additional optional optimizations:; // TODO: If we are peeling the loop and we know that the first pointer doesn't; // wrap then we can deduce that all pointers in the group don't wrap.; // This means that we can forcefully peel the loop in order to only have to; // check the first pointer for no-wrap. When we'll change to use Assume=true; // we'll only need at most one runtime check per interleaved group.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:69,wrap,wrap,69,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,5,['wrap'],"['wrap', 'wrapping']"
Integrability,"// Remove messages that are basically the same, and edges that may not; // make sense.; // We have to do this after edge optimization in the Extensive mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:10,message,messages,10,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['message'],['messages']
Integrability,// Remove order dependences from an unrelated Phi.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:16,depend,dependences,16,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['dependences']
Integrability,"// Remove our current module as an impediment to visiting the; // module we depend on. If we were the last unvisited module; // that depends on this particular module, push it into the; // queue to be visited.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:76,depend,depend,76,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,2,['depend'],"['depend', 'depends']"
Integrability,"// Remove outer integration dependents from termISet",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:16,integrat,integration,16,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,2,"['depend', 'integrat']","['dependents', 'integration']"
Integrability,"// Remove spill-reload like copy chains. For example; // r0 = COPY r1; // r1 = COPY r2; // r2 = COPY r3; // r3 = COPY r4; // <def-use r4>; // r4 = COPY r3; // r3 = COPY r2; // r2 = COPY r1; // r1 = COPY r0; // will be folded into; // r0 = COPY r1; // r1 = COPY r4; // <def-use r4>; // r4 = COPY r1; // r1 = COPY r0; // TODO: Currently we don't track usage of r0 outside the chain, so we; // conservatively keep its value as it was before the rewrite.; //; // The algorithm is trying to keep; // property#1: No Def of spill COPY in the chain is used or defined until the; // paired reload COPY in the chain uses the Def.; //; // property#2: NO Source of COPY in the chain is used or defined until the next; // COPY in the chain defines the Source, except the innermost spill-reload; // pair.; //; // The algorithm is conducted by checking every COPY inside the MBB, assuming; // the COPY is a reload COPY, then try to find paired spill COPY by searching; // the COPY defines the Src of the reload COPY backward. If such pair is found,; // it either belongs to an existing chain or a new chain depends on; // last available COPY uses the Def of the reload COPY.; // Implementation notes, we use CopyTracker::findLastDefCopy(Reg, ...) to find; // out last COPY that defines Reg; we use CopyTracker::findLastUseCopy(Reg, ...); // to find out last COPY that uses Reg. When we are encountered with a Non-COPY; // instruction, we check registers in the operands of this instruction. If this; // Reg is defined by a COPY, we untrack this Reg via; // CopyTracker::clobberRegister(Reg, ...).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:1092,depend,depends,1092,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,1,['depend'],['depends']
Integrability,// Remove the chain dependence between the instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:20,depend,dependence,20,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['dependence']
Integrability,// Remove the conditional branch dependent on the null check.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:33,depend,dependent,33,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,1,['depend'],['dependent']
Integrability,// Remove the dependant's dependency on this node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:14,depend,dependant,14,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,2,['depend'],"['dependant', 'dependency']"
Integrability,// Remove the dependence. The value now depends on a prior iteration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:14,depend,dependence,14,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,2,['depend'],"['dependence', 'depends']"
Integrability,// Remove the setter message if RHS is null,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransZeroOutPropsInDealloc.cpp:21,message,message,21,interpreter/llvm-project/clang/lib/ARCMigrate/TransZeroOutPropsInDealloc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransZeroOutPropsInDealloc.cpp,1,['message'],['message']
Integrability,"// Remove the wrapper when the call target is a function, an external; // symbol (which will be lowered to a library function), or an alias of; // a function. If the target is not a function/external symbol, we; // shouldn't remove the wrapper, because we cannot call it directly and; // instead we want it to be loaded with a CONST instruction and called; // with a call_indirect later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp:14,wrap,wrapper,14,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp,2,['wrap'],['wrapper']
Integrability,// Remove this anti dependency and add one in the reverse direction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:20,depend,dependency,20,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['dependency']
Integrability,// Remove this local dependency info.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:21,depend,dependency,21,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['dependency']
Integrability,// Remove typedefs one by one until we reach a typedef; // for a size dependent type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:70,depend,dependent,70,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,// Render the diagnostic message into a temporary buffer eagerly. We'll use; // this later as we add the diagnostic to the SARIF object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp:25,message,message,25,interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp,1,['message'],['message']
Integrability,// Render the diagnostic message into a temporary buffer eagerly. We'll use; // this later as we print out the diagnostic to the terminal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp:25,message,message,25,interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnosticPrinter.cpp,1,['message'],['message']
Integrability,"// Reorder cached elements. First constant nodes, then tracked nodes in order of dependence; // Step 1 - split in constant and tracked",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooVectorDataStore.cxx:81,depend,dependence,81,roofit/roofitcore/src/RooVectorDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooVectorDataStore.cxx,1,['depend'],['dependence']
Integrability,// Replace ICI (which is used by the PHI for the default value) with true or; // false depending on if it is EQ or NE.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:87,depend,depending,87,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['depend'],['depending']
Integrability,"// Replace exclusive lvalue branch servers with lvalue branches; // WVE Don't do this for binned distributions - deal with this using numeric integration with transformed bin boundaroes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:142,integrat,integration,142,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['integrat'],['integration']
Integrability,// Replace the chain to avoid dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,depend,dependency,30,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['depend'],['dependency']
Integrability,// Replace the chain to void dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:29,depend,dependency,29,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['depend'],['dependency']
Integrability,// Replace the executable and arguments of the link job with the; // wrapper.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:69,wrap,wrapper,69,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['wrap'],['wrapper']
Integrability,"// Replicate subregister to other half.; // Annotation as a wrapper. LEGALAVL(VL) means that VL refers to 64bit of; // data, whereas the raw EVL coming in from VP nodes always refers to number; // of elements, regardless of their size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h:60,wrap,wrapper,60,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h,1,['wrap'],['wrapper']
Integrability,// Report the backend message using the usual diagnostic mechanism.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp:22,message,message,22,interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp,1,['message'],['message']
Integrability,// Report the message with the diagnostic handler if present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SourceMgr.cpp:14,message,message,14,interpreter/llvm-project/llvm/lib/Support/SourceMgr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SourceMgr.cpp,1,['message'],['message']
Integrability,"// Represents a dependency between two architecture extensions. Later is the; // feature which was added to the architecture after Earlier, and expands the; // functionality provided by it. If Later is enabled, then Earlier will also be; // enabled. If Earlier is disabled, then Later will also be disabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/AArch64TargetParser.h:16,depend,dependency,16,interpreter/llvm-project/llvm/include/llvm/TargetParser/AArch64TargetParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/AArch64TargetParser.h,1,['depend'],['dependency']
Integrability,// Represents a property from another protocol that conflicts with the; // selected declaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:38,protocol,protocol,38,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['protocol'],['protocol']
Integrability,"// Request PassInstrumentation from analysis manager, will use it to run; // instrumenting callbacks for the passes later.; // Here we use std::tuple wrapper over getResult which helps to extract; // AnalysisManager's arguments out of the whole Args set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:150,wrap,wrapper,150,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['wrap'],['wrapper']
Integrability,"// Request PassInstrumentation from analysis manager, will use it to run; // instrumenting callbacks for the passes later.; // Here we use std::tuple wrapper over getResult which helps to extract; // AnalysisManager's arguments out of the whole ExtraArgs set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:150,wrap,wrapper,150,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['wrap'],['wrapper']
Integrability,// Request to infer nofree attribute for all the functions in the SCC if; // every callsite within the SCC does not directly or indirectly free; // memory (except for calls to functions within the SCC). Note that nofree; // attribute suffers from derefinement - results may change depending on; // how functions are optimized. Thus it can be inferred only from exact; // definitions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:281,depend,depending,281,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['depend'],['depending']
Integrability,// Request to infer nounwind attribute for all the functions in the SCC if; // every callsite within the SCC is not throwing (except for calls to; // functions within the SCC). Note that nounwind attribute suffers from; // derefinement - results may change depending on how functions are; // optimized. Thus it can be inferred only from exact definitions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:257,depend,depending,257,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['depend'],['depending']
Integrability,"// Require match of protocol, user, password, host and port",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/netxng/src/TNetXNGSystem.cxx:20,protocol,protocol,20,net/netxng/src/TNetXNGSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/netxng/src/TNetXNGSystem.cxx,1,['protocol'],['protocol']
Integrability,"// Require that class meets technical criteria to be persistable (i.e it has a default constructor); // (We also need a default constructor of abstract classes, but cannot check that through is interface; // as TClass::HasDefaultCtor only returns true for callable default constructors)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx:194,interface,interface,194,roofit/roofitcore/src/RooWorkspace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx,1,['interface'],['interface']
Integrability,"// Rerun the compiler, capturing any error messages to print them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:43,message,messages,43,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,1,['message'],['messages']
Integrability,// Reserved slots for DS.; // Artificial register slots to track LDS writes into specific LDS locations; // if a location is known. When slots are exhausted or location is; // unknown use the first slot. The first slot is also always updated in; // addition to known location's slot to properly generate waits if dependent; // instruction's location is unknown.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:313,depend,dependent,313,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['depend'],['dependent']
Integrability,"// Reset abstract arguments not settled in a sound fixpoint by now. This; // happens when we stopped the fixpoint iteration early. Note that only the; // ones marked as ""changed"" *and* the ones transitively depending on them; // need to be reverted to a pessimistic state. Others might not be in a; // fixpoint state but we can use the optimistic results for them anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:207,depend,depending,207,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['depend'],['depending']
Integrability,// Reset interference dependent info.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:22,depend,dependent,22,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,1,['depend'],['dependent']
Integrability,"// Reset major view-dependant cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx:20,depend,dependant,20,graf3d/gl/src/TGLViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx,1,['depend'],['dependant']
Integrability,"// Reset the bit so that:; // obj = myClonesArray[i];; // ! obj->IsDestructed(); // will behave correctly.; // TObject::kNotDeleted is one of the higher bit that is not settable via the public; // interface. But luckily we are its friend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClonesArray.cxx:197,interface,interface,197,core/cont/src/TClonesArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClonesArray.cxx,1,['interface'],['interface']
Integrability,// Reset the inner alloca insertion as it will be used for loading the values; // wrapped into pointers before passing them into the to-be-outlined region.; // Configure it to insert immediately after the fake use of zero address so; // that they are available in the generated body and so that the; // OpenMP-related values (thread ID and zero address pointers) remain leading; // in the argument list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:82,wrap,wrapped,82,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['wrap'],['wrapped']
Integrability,"// Reset the message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:13,message,message,13,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['message'],['message']
Integrability,"// Reset the status flag and clear the messages in the list, if any",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:39,message,messages,39,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['message'],['messages']
Integrability,// Reset the work list and repopulate with the changed abstract attributes.; // Note that dependent ones are added above.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:90,depend,dependent,90,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['depend'],['dependent']
Integrability,"// Reset whether spaces or a line break are required before this token, as; // that is context dependent, and that context may change when formatting; // the macro call. For example, given M(x) -> 2 * x, and the macro call; // M(var), the token 'var' will have SpacesRequiredBefore = 1 after being; // formatted as part of the expanded macro, but SpacesRequiredBefore = 0; // for its position within the macro call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:95,depend,dependent,95,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,1,['depend'],['dependent']
Integrability,"// Residual from training sample versus. dependent variable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:41,depend,dependent,41,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['depend'],['dependent']
Integrability,"// Resolve any options dependencies (ie. --print=all should set other; // print options, etc.).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp:23,depend,dependencies,23,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp,1,['depend'],['dependencies']
Integrability,"// Resolve url; if empty the actions depend of the default",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofMgr.cxx:37,depend,depend,37,proof/proof/src/TProofMgr.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofMgr.cxx,1,['depend'],['depend']
Integrability,"// Restore integral dependent values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:20,depend,dependent,20,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['depend'],['dependent']
Integrability,// Result is dependent. Carry on to build an UnresolvedLookupEpxr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:13,depend,dependent,13,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,// Result might be dependent or not.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:19,depend,dependent,19,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,3,['depend'],['dependent']
Integrability,"// Result subclass for an integer literal appearing in Tablegen. This may need; // to be turned into an llvm::Result by means of llvm::ConstantInt::get(), or; // it may be used directly as an integer, depending on which IRBuilder method; // it's being passed to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:201,depend,depending,201,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,1,['depend'],['depending']
Integrability,"// Retrieve analytical integration subCodes and set of observabels integrated over",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx:23,integrat,integration,23,roofit/roofitcore/src/RooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx,2,['integrat'],"['integrated', 'integration']"
Integrability,"// Retrieve file names through ROOT TClass interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx:43,interface,interface,43,roofit/roofitcore/src/RooWorkspace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx,1,['interface'],['interface']
Integrability,"// Retrieve proto integrator and return clone configured for the requested integration task",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumGenFactory.cxx:18,integrat,integrator,18,roofit/roofitcore/src/RooNumGenFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumGenFactory.cxx,4,['integrat'],"['integration', 'integrator']"
Integrability,"// Retrieve the index of the next lambda appearing in this context, which is; // used for deduplicating lambdas across modules. Note that this is a simple; // sequence number and is not ABI-dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/MangleNumberingContext.h:190,depend,dependent,190,interpreter/llvm-project/clang/include/clang/AST/MangleNumberingContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/MangleNumberingContext.h,1,['depend'],['dependent']
Integrability,"// Return C++ ostream associated with given message configuration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMsgService.cxx:44,message,message,44,roofit/roofitcore/src/RooMsgService.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMsgService.cxx,2,['message'],['message']
Integrability,// Return an OverflowResult dependant on if overflow of the multiplication of; // InnerTripCount and OuterTripCount can be assumed not to happen.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:28,depend,dependant,28,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,1,['depend'],['dependant']
Integrability,"// Return code of the command execution (available only; // after closing the pipe); ////////////////////////////////////////////////////////////////////////////////; /// Execute 'cmd' in a pipe and handle output messages from the related file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:213,message,messages,213,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['message'],['messages']
Integrability,"// Return early if first alignment expression is dependent (since we don't; // know what the effective size will be), and skip the loop entirely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp:49,depend,dependent,49,interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,1,['depend'],['dependent']
Integrability,// Return false if the class has a dependent base or if it or one; // of its bases is present in the base set of the current context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:35,depend,dependent,35,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['dependent']
Integrability,// Return getLogicalNumberOfSymbolTableEntries32 or; // getNumberOfSymbolTableEntries64 depending on the object mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h:88,depend,depending,88,interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,1,['depend'],['depending']
Integrability,"// Return how many elements can fit in getRegisterBitwidth. This is the; // same routine as used in LoopVectorizer. We should probably be; // accounting for whether we actually have instructions with the right; // lane type, but we don't have enough information to do that without; // some additional plumbing which hasn't been justified yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:81,rout,routine,81,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,1,['rout'],['routine']
Integrability,"// Return index of next dependency or -1 if none (or no more); // If reset is kTRUE, reset the internal counter before acting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:24,depend,dependency,24,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,1,['depend'],['dependency']
Integrability,// Return sanitizers which don't require runtime support and are not; // platform dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp:82,depend,dependent,82,interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp,1,['depend'],['dependent']
Integrability,"// Return selected integration techniques for 1,2,N dimensional integrals",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooNumGenConfig.h:19,integrat,integration,19,roofit/roofitcore/inc/RooNumGenConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooNumGenConfig.h,2,['integrat'],['integration']
Integrability,"// Return selected integration techniques for 1,2,N dimensional open-ended integrals",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooNumIntConfig.h:19,integrat,integration,19,roofit/roofitcore/inc/RooNumIntConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooNumIntConfig.h,1,['integrat'],['integration']
Integrability,"// Return the base type index if there aren't any modifiers. For example, the; // metadata could contain restrict wrappers around non-pointer types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:114,wrap,wrappers,114,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['wrap'],['wrappers']
Integrability,// Return the specific clause record wrapped in the Clause class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h:37,wrap,wrapped,37,interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h,1,['wrap'],['wrapped']
Integrability,"// Return the value in the inclusive range [Lo,Hi] that is aligned to the; // highest power of two. Note that the result is well defined for all inputs; // including corner cases like:; // - if Lo == Hi, return that value; // - if Lo == 0, return 0 (even though the ""- 1"" below underflows; // - if Lo > Hi, return 0 (as if the range wrapped around)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp:333,wrap,wrapped,333,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,1,['wrap'],['wrapped']
Integrability,"// Return true if the inner loop \p Lp is uniform with regard to the outer loop; // \p OuterLp (i.e., if the outer loop is vectorized, all the vector lanes; // executing the inner loop will execute the same iterations). This check is; // very constrained for now but it will be relaxed in the future. \p Lp is; // considered uniform if it meets all the following conditions:; // 1) it has a canonical IV (starting from 0 and with stride 1),; // 2) its latch terminator is a conditional branch and,; // 3) its latch condition is a compare instruction whose operands are the; // canonical IV and an OuterLp invariant.; // This check doesn't take into account the uniformity of other conditions not; // related to the loop latch because they don't affect the loop uniformity.; //; // NOTE: We decided to keep all these checks and its associated documentation; // together so that we can easily have a picture of the current supported loop; // nests. However, some of the current checks don't depend on \p OuterLp and; // would be redundantly executed for each \p Lp if we invoked this function for; // different candidate outer loops. This is not the case for now because we; // don't currently have the infrastructure to evaluate multiple candidate outer; // loops and \p OuterLp will be a fixed parameter while we only support explicit; // outer loop vectorization. It's also very likely that these checks go away; // before introducing the aforementioned infrastructure. However, if this is not; // the case, we should move the \p OuterLp independent checks to a separate; // function that is only executed once for each \p Lp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:989,depend,depend,989,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['depend'],['depend']
Integrability,"// Return true if these are the best two instructions to schedule; // together with a zero latency. Only one dependence should have a zero; // latency. If there are multiple choices, choose the best, and change; // the others, if needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:109,depend,dependence,109,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['depend'],['dependence']
Integrability,"// Return true if this is an atomic which has an ordering stronger than; // unordered. Note that this is different than the predicate we use in; // Attributor. Here we chose to be conservative and consider monotonic; // operations potentially synchronizing. We generally don't do much with; // monotonic operations, so this is simply risk reduction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:243,synchroniz,synchronizing,243,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['synchroniz'],['synchronizing']
Integrability,// Return true iff the given array filler may depend on the element index.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:46,depend,depend,46,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['depend'],['depend']
Integrability,"// Return true, if No Signed Wrap should be maintained for I.; // The No Signed Wrap flag can be kept if the operation ""B (I.getOpcode) C"",; // where both B and C should be ConstantInts, results in a constant that does; // not overflow. This function only handles the Add and Sub opcodes. For; // all other opcodes, the function conservatively returns false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:29,Wrap,Wrap,29,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,2,['Wrap'],['Wrap']
Integrability,"// Return zero for any address before the first mapping symbol; this means; // we should use the default disassembly mode, depending on the target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp:123,depend,depending,123,interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,1,['depend'],['depending']
Integrability,// Returned type-dependence will never have VariablyModified set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:17,depend,dependence,17,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,1,['depend'],['dependence']
Integrability,"// Returning a record by value is fine. (In this case, the returned; // expression will be a copy-constructor, possibly wrapped in an; // ExprWithCleanups node.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp:120,wrap,wrapped,120,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,1,['wrap'],['wrapped']
Integrability,// Returning null indicates that we don't have a type parameter list.; // The results the caller needs to handle the protocol references are; // captured in the reference parameters already.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:117,protocol,protocol,117,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['protocol'],['protocol']
Integrability,"// Returns NoAlias/MayAliass/MustAlias for two memory locations based upon their; // underlaying objects. If LocA and LocB are known to not alias (for any reason:; // tbaa, non-overlapping regions etc), then it is known there is no dependecy.; // Otherwise the underlying objects are checked to see if they point to; // different identifiable objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:232,depend,dependecy,232,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['dependecy']
Integrability,"// Returns a type for E that yields acceptable member completions.; // In particular, when E->getType() is DependentTy, try to guess a likely type.; // We accept some lossiness (like dropping parameters).; // We only try to handle common expressions on the LHS of MemberExpr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:107,Depend,DependentTy,107,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['Depend'],['DependentTy']
Integrability,// Returns an LLVM function to call for executing an OpenMP static worksharing; // for loop depending on `type`. Only i32 and i64 are supported by the runtime.; // Always interpret integers as unsigned similarly to CanonicalLoopInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:92,depend,depending,92,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['depend'],['depending']
Integrability,// Returns an LLVM function to call for initializing loop bounds using OpenMP; // static scheduling depending on `type`. Only i32 and i64 are supported by the; // runtime. Always interpret integers as unsigned similarly to; // CanonicalLoopInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:100,depend,depending,100,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['depend'],['depending']
Integrability,"// Returns an optional list of (pointer-difference expressions, access size); // pairs that can be used to prove that there are no vectorization-preventing; // dependencies at runtime. There are is a vectorization-preventing dependency; // if any pointer-difference is <u VF * InterleaveCount * access size. Returns; // std::nullopt if pointer-difference checks cannot be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:160,depend,dependencies,160,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,2,['depend'],"['dependencies', 'dependency']"
Integrability,"// Returns one of the stack, base, or frame pointer registers, depending on; // which is used to reference local variables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:63,depend,depending,63,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['depend'],['depending']
Integrability,"// Returns the FirstSeparator if set, otherwise use the default separator; // depending on isGPU",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:78,depend,depending,78,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['depend'],['depending']
Integrability,"// Returns the RecordDecl inside the BaseType, falling back to primary template; // in case of specializations. Since we might not have a decl for the; // instantiation/specialization yet, e.g. dependent code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:194,depend,dependent,194,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['depend'],['dependent']
Integrability,"// Returns the Root Asymptotic Mean Integrated Squared Error according to Silverman's rule of thumb with assumed Gaussian density",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:36,Integrat,Integrated,36,hist/hist/src/TKDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx,1,['Integrat'],['Integrated']
Integrability,// Returns the SDNodes which this SDDbgValue depends on.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SDNodeDbgValue.h:45,depend,depends,45,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SDNodeDbgValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SDNodeDbgValue.h,1,['depend'],['depends']
Integrability,"// Returns the Separator if set, otherwise use the default separator depending; // on isGPU",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:69,depend,depending,69,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['depend'],['depending']
Integrability,// Returns the appropriate wrapper opcode for a global reference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:27,wrap,wrapper,27,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['wrap'],['wrapper']
Integrability,"// Returns the condition the branch at the end of 'B' depends on and whose value; // has been evaluated within 'B'.; // In most cases, the terminator condition of 'B' will be evaluated fully in; // the last statement of 'B'; in those cases, the resolved condition is the; // given 'Condition'.; // If the condition of the branch is a logical binary operator tree, the CFG is; // optimized: in that case, we know that the expression formed by all but the; // rightmost leaf of the logical binary operator tree must be true, and thus; // the branch condition is at this point equivalent to the truth value of that; // rightmost leaf; the CFG block thus only evaluates this rightmost leaf; // expression in its final statement. As the full condition in that case was; // not evaluated, and is thus not in the SVal cache, we need to use that leaf; // expression to evaluate the truth value of the condition in the current state; // space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:54,depend,depends,54,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,1,['depend'],['depends']
Integrability,"// Returns the instruction at which to hoist the dependent condition values and; // insert the CHR branch for a region. This is the terminator branch in the; // entry block or the first select in the entry block, if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:49,depend,dependent,49,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,1,['depend'],['dependent']
Integrability,"// Returns the standard expected CSEConfig for the given optimization level.; // We have this logic here so targets can make use of it from their derived; // TargetPassConfig, but can't put this logic into TargetPassConfig directly; // because the CodeGen library can't depend on GlobalISel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:270,depend,depend,270,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,1,['depend'],['depend']
Integrability,// Returns the target-dependent section name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:22,depend,dependent,22,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,1,['depend'],['dependent']
Integrability,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:69,depend,dependent,69,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,11,"['Depend', 'depend']","['DependentTy', 'dependent', 'dependent-sized', 'dependent-typed']"
Integrability,"// Returns true for the declaration/definition form of @protocol,; // false for the expression form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:56,protocol,protocol,56,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['protocol'],['protocol']
Integrability,// Returns true if RegUsedInAddr is used for calculating the displacement; // depending on addressing mode. Also calculates the Displacement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:78,depend,depending,78,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,1,['depend'],['depending']
Integrability,"// Returns true if a TT_SelectorName should be indented when wrapped,; // false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:61,wrap,wrapped,61,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['wrap'],['wrapped']
Integrability,// Returns true if floating point contraction is allowed on the FMUL-SDValue; // `N`,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:34,contract,contraction,34,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['contract'],['contraction']
Integrability,// Returns true if peeling the first iteration from this loop; // will break this dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:82,depend,dependence,82,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,// Returns true if peeling the last iteration from this loop; // will break this dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:81,depend,dependence,81,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,// Returns true if splitting this loop will break the dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:54,depend,dependence,54,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,// Returns true if the base is dependent or is one of the accumulated base; // classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:31,depend,dependent,31,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['dependent']
Integrability,// Returns true if the libObject code does not support the load command and its; // contents. The cmd value it is treated as an unknown load command but with; // an error message that says the cmd value is obsolete.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp:171,message,message,171,interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp,1,['message'],['message']
Integrability,// Returns true if the scalar result of a VALU instruction depends on exec.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:59,depend,depends,59,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['depend'],['depends']
Integrability,// Returns true if there are expensive instructions in the cold value; // operand's (if any) dependence slice of any of the selects of the given; // group.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:93,depend,dependence,93,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,1,['depend'],['dependence']
Integrability,// Returns true if this is an anti dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:35,depend,dependence,35,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,// Returns true if this is an flow (aka true) dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:46,depend,dependence,46,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,// Returns true if this is an output dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:37,depend,dependence,37,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// Reuse our existing integrators by updating their limits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooImproperIntegrator1D.cxx:22,integrat,integrators,22,roofit/roofitcore/src/RooImproperIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooImproperIntegrator1D.cxx,1,['integrat'],['integrators']
Integrability,"// Reverse stores to do bottom-to-top analysis. This is important if the; // values are stores to the same addresses several times, in this case need; // to follow the stores order (reversed to meet the memory dependecies).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:210,depend,dependecies,210,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['depend'],['dependecies']
Integrability,// Reverse the dependence distance as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:15,depend,dependence,15,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// Review the constraints, looking for opportunities; // to simplify a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.; // Corresponds to Figure 5 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:234,depend,dependence,234,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,2,"['Depend', 'depend']","['Dependence', 'dependence']"
Integrability,"// Rewrite the IR for the unswitched basic blocks. This requires two steps.; // First, we split any exit blocks with remaining in-loop predecessors. Then; // we update the PHIs in one of two ways depending on if there was a split.; // We walk in reverse so that we split in the same order as the cases; // appeared. This is purely for convenience of reading the resulting IR, but; // it doesn't cost anything really.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:196,depend,depending,196,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['depend'],['depending']
Integrability,// Rewrite uses and update the map. The actions depend upon whether; // we generating code for the kernel or epilog blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:48,depend,depend,48,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['depend'],['depend']
Integrability,"// Rewrite uses of F in global initializers, etc. to uses of a wrapper; // function that dynamically resolves the calls to F via our JIT API",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:63,wrap,wrapper,63,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,1,['wrap'],['wrapper']
Integrability,"// RooAbsStudy interfaces",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/ToyMCStudy.h:15,interface,interfaces,15,roofit/roostats/inc/RooStats/ToyMCStudy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/ToyMCStudy.h,1,['interface'],['interfaces']
Integrability,"// RooFit Message Service Singleton class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMsgService.h:10,Message,Message,10,roofit/roofitcore/inc/RooMsgService.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMsgService.h,1,['Message'],['Message']
Integrability,"// RooFit interface to ROOT::Math::Minimizer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMinimizer.h:10,interface,interface,10,roofit/roofitcore/inc/RooMinimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMinimizer.h,1,['interface'],['interface']
Integrability,"// RooGaussian can integrate over x or mu, but not both still, the issue is; // visible regardless",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRealIntegral.cxx:19,integrat,integrate,19,roofit/roofitcore/test/testRooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRealIntegral.cxx,1,['integrat'],['integrate']
Integrability,"// RooObjCacheManager is a wrapper around RooCacheManager",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooCacheManager.cxx:27,wrap,wrapper,27,roofit/roofitcore/test/testRooCacheManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooCacheManager.cxx,1,['wrap'],['wrapper']
Integrability,"// RooSimultaneous is not used in the HS3 standard, we only export the; // dependents and some ROOT internal information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/RooJSONFactoryWSTool.cxx:75,depend,dependents,75,roofit/hs3/src/RooJSONFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/RooJSONFactoryWSTool.cxx,1,['depend'],['dependents']
Integrability,"// Round 1. The first round permutes the message words from the original; // input order, into the groups that get mixed in parallel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_avx512.c:41,message,message,41,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_avx512.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_avx512.c,3,['message'],['message']
Integrability,// Round 2. This round and all following rounds apply a fixed permutation; // to the message words from the round before.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_avx512.c:85,message,message,85,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_avx512.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_avx512.c,3,['message'],['message']
Integrability,// Route to matched type info catch block or run cleanup finally block,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:3,Rout,Route,3,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,1,['Rout'],['Route']
Integrability,"// Routine driving the visiting of the class information/data members.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMemberInspector.cxx:3,Rout,Routine,3,core/base/src/TMemberInspector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMemberInspector.cxx,3,['Rout'],['Routine']
Integrability,"// Routine has an optional paren-wrapped name of a function in the local; // scope. We parse the name, emitting any diagnostics",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:3,Rout,Routine,3,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,2,"['Rout', 'wrap']","['Routine', 'wrapped']"
Integrability,"// Routine to close a list of files using the 'slow' techniques; // that also for the deletion ot update the list itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:3,Rout,Routine,3,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['Rout'],['Routine']
Integrability,"// Routine to delete the content of list of files using the 'slow' techniques",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:3,Rout,Routine,3,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['Rout'],['Routine']
Integrability,"// Routine to read the content of the buffer into 'obj'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h:3,Rout,Routine,3,io/io/inc/TGenCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h,3,['Rout'],['Routine']
Integrability,// Routines for sinking stores,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:3,Rout,Routines,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,1,['Rout'],['Routines']
Integrability,// Routines that add DIEValues to the hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:3,Rout,Routines,3,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,1,['Rout'],['Routines']
Integrability,// Routines that reform the loop CFG and split edges often fail on indirectbr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:3,Rout,Routines,3,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,1,['Rout'],['Routines']
Integrability,// Routines to handle fp16 storage type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:3,Rout,Routines,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['Rout'],['Routines']
Integrability,"// RuntimeDyld clients often want to handle the memory management of; // what gets placed where. For JIT clients, this is the subset of; // JITMemoryManager required for dynamic loading of binaries.; //; // FIXME: As the RuntimeDyld fills out, additional routines will be needed; // for the varying types of objects to be allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RTDyldMemoryManager.h:255,rout,routines,255,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RTDyldMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RTDyldMemoryManager.h,1,['rout'],['routines']
Integrability,// RuntimeDyldImpl is the actual class. RuntimeDyld is just the public; // interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:75,interface,interface,75,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,1,['interface'],['interface']
Integrability,// SDNode dependencies will be calculated as SDNodes that appear in; // LocationOps plus these AdditionalDependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SDNodeDbgValue.h:10,depend,dependencies,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SDNodeDbgValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SDNodeDbgValue.h,1,['depend'],['dependencies']
Integrability,"// SSE codegen depends on cmovs, and all SSE1+ processors support them.; // All 64-bit processors support cmov.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.h:15,depend,depends,15,interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.h,1,['depend'],['depends']
Integrability,"// SSL wrapped socket",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TSSLSocket.h:7,wrap,wrapped,7,net/net/inc/TSSLSocket.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TSSLSocket.h,1,['wrap'],['wrapped']
Integrability,"// SU is a branch; for any predecessors in this dispatch group, with which we; // have a data dependence and set the counter register, return true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:94,depend,dependence,94,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,1,['depend'],['dependence']
Integrability,"// SU is a load; for any predecessors in this dispatch group, that are stores,; // and with which we have an ordering dependency, return true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:118,depend,dependency,118,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,1,['depend'],['dependency']
Integrability,"// SU is an export instruction. Check whether one of its successor; // dependencies is a non-export, in which case we skip export grouping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:71,depend,dependencies,71,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['depend'],['dependencies']
Integrability,"// SValBuilder.h - Construction of SVals from evaluating expressions -*- C++ -*-; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines SValBuilder, a class that defines the interface for; // ""symbolical evaluators"" which construct an SVal from an expression.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SValBuilder.h:439,interface,interface,439,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SValBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SValBuilder.h,1,['interface'],['interface']
Integrability,"// SYNCHRONIZATION FROM WORKERS TO MASTER",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/LikelihoodGradientJob.cxx:3,SYNCHRONIZ,SYNCHRONIZATION,3,roofit/roofitcore/src/TestStatistics/LikelihoodGradientJob.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/LikelihoodGradientJob.cxx,1,['SYNCHRONIZ'],['SYNCHRONIZATION']
Integrability,// S_ENDPGM instructions before which we should insert a DEALLOC_VGPRS; // message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:75,message,message,75,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['message'],['message']
Integrability,// Sandy Bridge microarchitecture based processors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/X86TargetParser.cpp:9,Bridg,Bridge,9,interpreter/llvm-project/llvm/lib/TargetParser/X86TargetParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/X86TargetParser.cpp,1,['Bridg'],['Bridge']
Integrability,// Save '(' location for possible missing ')' message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:46,message,message,46,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['message'],['message']
Integrability,"// Save CudaDeviceActions to DeviceLinkerInputs for each GPU subarch.; // This happens to each device action originated from each input file.; // Later on, device actions in DeviceLinkerInputs are used to create; // device link actions in appendLinkDependences and the created device; // link actions are passed to the offload action as device dependence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:344,depend,dependence,344,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['depend'],['dependence']
Integrability,// Save current instruction`s forbidden slot and whether set reorder.; // This is the judgment condition for whether to add nop.; // We would add a couple of '.set noreorder' and '.set reorder' to; // wrap the current instruction and the next instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:201,wrap,wrap,201,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['wrap'],['wrap']
Integrability,"// Save current integral dependent values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:25,depend,dependent,25,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['depend'],['dependent']
Integrability,// Save dependent expressions in the AST to be instantiated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:8,depend,dependent,8,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,2,['depend'],['dependent']
Integrability,// Scalar evolution does not propagate the non-wrapping flags to values that; // are derived from a non-wrapping induction variable because non-wrapping; // could be flow-sensitive.; //; // Look through the potentially overflowing instruction to try to prove; // non-wrapping for the *specific* value of Ptr.; // The arithmetic implied by an inbounds GEP can't overflow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:47,wrap,wrapping,47,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,4,['wrap'],['wrapping']
Integrability,// Scale is how many times the operands need to be contracted to match; // the representation in the target register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:51,contract,contracted,51,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['contract'],['contracted']
Integrability,// Scan for MFMA long latency instructions and try to add a dependency; // of available SALU instructions to give them a chance to fill MFMA; // shadow. That is desirable to fill MFMA shadow with SALU instructions; // rather than VALU to prevent power consumption bursts and throttle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:60,depend,dependency,60,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,1,['depend'],['dependency']
Integrability,"// Scan the @interface to see if any of the protocols it adopts; // require an explicit implementation, via attribute; // 'objc_protocol_requires_explicit_implementation'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:13,interface,interface,13,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,2,"['interface', 'protocol']","['interface', 'protocols']"
Integrability,// Scan the block for the dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:26,depend,dependency,26,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['dependency']
Integrability,// Scan the file for preprocessor directives that might affect the; // dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:71,depend,dependencies,71,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,1,['depend'],['dependencies']
Integrability,// Scan through class's protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:24,protocol,protocols,24,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,2,['protocol'],['protocols']
Integrability,// Scan through protocol's protocols which did not have a matching property.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:16,protocol,protocol,16,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,2,['protocol'],"['protocol', 'protocols']"
Integrability,// Scan through protocol's protocols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:16,protocol,protocol,16,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,4,['protocol'],"['protocol', 'protocols']"
Integrability,"// Scanning runs once for the first -cc1 invocation in a chain of driver; // jobs. For any dependent jobs, reuse the scanning result and just; // update the LastCC1Arguments to correspond to the new invocation.; // FIXME: to support multi-arch builds, each arch requires a separate scan",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:91,depend,dependent,91,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,1,['depend'],['dependent']
Integrability,// SchedGroups will only synchronize with other SchedGroups that have the same; // SyncID.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:25,synchroniz,synchronize,25,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,1,['synchroniz'],['synchronize']
Integrability,"// Schedule low latency instructions as top as possible.; // Order of priority is:; // . Low latency instructions which do not depend on other low latency; // instructions we haven't waited for; // . Other instructions which do not depend on low latency instructions; // we haven't waited for; // . Low latencies; // . All other instructions; // Goal is to get: low latency instructions - independent instructions; // - (eventually some more low latency instructions); // - instructions that depend on the first low latency instructions.; // If in the block there is a lot of constant loads, the SGPR usage; // could go quite high, thus above the arbitrary limit of 60 will encourage; // use the already loaded constants (in order to release some SGPRs) before; // loading more.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:127,depend,depend,127,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,3,['depend'],['depend']
Integrability,"// Search from our current iterator, either backwards or forwards,; // depending on what element we are looking for.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h:71,depend,depending,71,interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,1,['depend'],['depending']
Integrability,"// Search in bottom-up program order for pairs of accesses (A and B) that can; // form interleaved load or store groups. In the algorithm below, access A; // precedes access B in program order. We initialize a group for B in the; // outer loop of the algorithm, and then in the inner loop, we attempt to; // insert each A into B's group if:; //; // 1. A and B have the same stride,; // 2. A and B have the same memory object size, and; // 3. A belongs in B's group according to its distance from B.; //; // Special care is taken to ensure group formation will not break any; // dependences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:578,depend,dependences,578,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['depend'],['dependences']
Integrability,// Search in the protocol-qualifier list of current protocol.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:17,protocol,protocol-qualifier,17,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,2,['protocol'],"['protocol', 'protocol-qualifier']"
Integrability,// Search protocol qualifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:10,protocol,protocol,10,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['protocol'],['protocol']
Integrability,// Search protocols for class methods.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:10,protocol,protocols,10,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['protocol'],['protocols']
Integrability,// Search protocols for instance methods.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:10,protocol,protocols,10,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,3,['protocol'],['protocols']
Integrability,// Second argument: a pointer to the message ref structure. Leave; // the actual argument value blank for now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:37,message,message,37,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['message'],['message']
Integrability,// Second case: at least one return statement has dependent type.; // Delay type checking until instantiation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:50,depend,dependent,50,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,1,['depend'],['dependent']
Integrability,"// Second, compute a minimum iteration count so that the cost of the; // runtime checks is only a fraction of the total scalar loop cost. This; // adds a loop-dependent bound on the overhead incurred if the runtime; // checks fail. In case the runtime checks fail, the cost is RtC + ScalarC; // * TC. To bound the runtime check to be a fraction 1/X of the scalar; // cost, compute; // RtC < ScalarC * TC * (1 / X) ==> RtC * X / ScalarC < TC",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:159,depend,dependent,159,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['depend'],['dependent']
Integrability,"// Second, the more expensive check that uses alias analysis on the; // base registers. If they alias, and the load offset is less than; // the store offset, the mark the dependence as loop carried.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:171,depend,dependence,171,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['dependence']
Integrability,"// Secondary data (overlay dependent).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLSelectRecord.h:27,depend,dependent,27,graf3d/gl/inc/TGLSelectRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLSelectRecord.h,1,['depend'],['dependent']
Integrability,"// Secondary data (scene dependent) - use; // TGLSceneBase::ResolveSelectRecord() to fill.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLSelectRecord.h:25,depend,dependent,25,graf3d/gl/inc/TGLSelectRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLSelectRecord.h,1,['depend'],['dependent']
Integrability,// Section header table related interfaces.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h:32,interface,interfaces,32,interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,1,['interface'],['interfaces']
Integrability,"// See ARM ARM v7 B1.8.3. On exception entry LR is set to a possibly offset; // version of the ""preferred return address"". These offsets affect the return; // instruction if this is a return from PL1 without hypervisor extensions.; // IRQ/FIQ: +4 ""subs pc, lr, #4""; // SWI: 0 ""subs pc, lr, #0""; // ABORT: +4 ""subs pc, lr, #4""; // UNDEF: +4/+2 ""subs pc, lr, #0""; // UNDEF varies depending on where the exception came from ARM or Thumb; // mode. Alongside GCC, we throw our hands up in disgust and pretend it's 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:378,depend,depending,378,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['depend'],['depending']
Integrability,"// See arch(3) and llvm-gcc's driver-driver.c. We don't implement support for; // archs which Darwin doesn't use.; // The matching this routine does is fairly pointless, since it is neither the; // complete architecture list, nor a reasonable subset. The problem is that; // historically the driver accepts this and also ties its -march=; // handling to the architecture name, so we need to be careful before removing; // support for it.; // This code must be kept in sync with Clang's Darwin specific argument; // translation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:136,rout,routine,136,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['rout'],['routine']
Integrability,// See description in the base class. This interface is designed; // to be used by llvm-profdata (for dumping). Avoid using this when; // the client is the compiler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h:43,interface,interface,43,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,1,['interface'],['interface']
Integrability,"// See if an instruction can use a value from the previous iteration.; // If so, we update the base and offset of the instruction and change; // the dependences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:149,depend,dependences,149,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['dependences']
Integrability,"// See if any term in this group depends in any ay on outerDepInt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:33,depend,depends,33,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['depend'],['depends']
Integrability,// See if there is an unsafe dependency between a load to a uniform address and; // store to the same uniform address.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:29,depend,dependency,29,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['dependency']
Integrability,// See if we can infer some no-wrap flags.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:31,wrap,wrap,31,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,1,['wrap'],['wrap']
Integrability,// See if we can infer the other no-wrap too.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:36,wrap,wrap,36,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,2,['wrap'],['wrap']
Integrability,// See if you can find the hidden message in the magic bytes :-).; // (Hint: it's a little-endian encoding.),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:34,message,message,34,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,1,['message'],['message']
Integrability,// See whether the current checker has a message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:41,message,message,41,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,2,['message'],['message']
Integrability,"// See z/OS Language Environment Vendor Interfaces v2r5, p.23, for; // complete list. Only the C runtime is supported by this backend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp:40,Interface,Interfaces,40,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZAsmPrinter.cpp,1,['Interface'],['Interfaces']
Integrability,// Select either all ones or zeroes depending upon the real predicate bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:36,depend,depending,36,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['depend'],['depending']
Integrability,"// Select subset of allVars that are actual dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/ParamHistFunc.cxx:44,depend,dependents,44,roofit/histfactory/src/ParamHistFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/ParamHistFunc.cxx,4,['depend'],['dependents']
Integrability,"// Select the correct compile unit range, depending if we are dealing with; // a standard or split DWARF object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVELFReader.cpp:42,depend,depending,42,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVELFReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVELFReader.cpp,1,['depend'],['depending']
Integrability,// Select the message schedule based on the round.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_portable.c:14,message,message,14,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_portable.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_portable.c,1,['message'],['message']
Integrability,// Select the optimal opcode depending on how big it is.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp:29,depend,depending,29,interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRFrameLowering.cpp,1,['depend'],['depending']
Integrability,"// Selection interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLSceneBase.h:13,interface,interface,13,graf3d/gl/inc/TGLSceneBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLSceneBase.h,1,['interface'],['interface']
Integrability,// Selection routines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:13,rout,routines,13,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,3,['rout'],['routines']
Integrability,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:104,depend,dependencies,104,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,2,['depend'],['dependencies']
Integrability,// Self dependencies are ignored because they are redundant and; // uninteresting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:8,depend,dependencies,8,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,1,['depend'],['dependencies']
Integrability,"// Semantically skip last iter is ""subtract 1, do not bother about unsigned; // wrap"". getLoopInvariantExitCondDuringFirstIterations knows how to deal; // with umin in a smart way, but umin(a, b) - 1 will likely not simplify.; // So we manually construct umin(a - 1, b - 1).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:80,wrap,wrap,80,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['wrap'],['wrap']
Integrability,// Semantics only depend on children.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:18,depend,depend,18,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,2,['depend'],['depend']
Integrability,"// Semi-abstract interface for classes supporting secondary-selection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveSecondarySelectable.h:17,interface,interface,17,graf3d/eve/inc/TEveSecondarySelectable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveSecondarySelectable.h,1,['interface'],['interface']
Integrability,"// Send Cancel button message to context menu eventhandler",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TRootDialog.cxx:22,message,message,22,gui/gui/src/TRootDialog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TRootDialog.cxx,1,['message'],['message']
Integrability,"// Send a message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSStepButton.cxx:10,message,message,10,test/periodic/XSStepButton.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSStepButton.cxx,1,['message'],['message']
Integrability,"// Send info message on recursion if needed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:13,message,message,13,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['message'],['message']
Integrability,// Send it our message:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:15,message,message,15,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['message'],['message']
Integrability,"// Send last timer message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx:19,message,message,19,proof/proofplayer/src/TPacketizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx,7,['message'],['message']
Integrability,"// Send last timer message and stop the timer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx:19,message,message,19,proof/proofplayer/src/TPacketizerAdaptive.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx,1,['message'],['message']
Integrability,"// Send message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:8,message,message,8,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['message'],['message']
Integrability,"// Send message and dispose object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:8,message,message,8,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['message'],['message']
Integrability,"// Send message length first",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:8,message,message,8,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,2,['message'],['message']
Integrability,"// Send message of the day to the client",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:8,message,message,8,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['message'],['message']
Integrability,"// Send messages off immediately to reduce latency",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx:8,message,messages,8,net/net/src/TApplicationServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx,1,['message'],['messages']
Integrability,"// Send objects in bunches of max fMsgSizeHWM bytes to optimize transfer; // Objects are merged one-by-one by the client; // Messages for objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:125,Message,Messages,125,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['Message'],['Messages']
Integrability,"// Send objects one-by-one to optimize transfer and merging; // Messages for objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:64,Message,Messages,64,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['Message'],['Messages']
Integrability,"// Send one byte out-of-band message to server",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:29,message,message,29,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,2,['message'],['message']
Integrability,"// Send our protocol level to the client",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx:12,protocol,protocol,12,net/net/src/TApplicationServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx,1,['protocol'],['protocol']
Integrability,"// Send stop message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:13,message,message,13,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['message'],['message']
Integrability,"// Send the OOB byte back so that the client knows where; // to stop flushing its input stream of obsolete messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx:107,message,messages,107,net/net/src/TApplicationServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx,2,['message'],['messages']
Integrability,"// Send the message one level up",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx:12,message,message,12,net/net/src/TApplicationServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx,2,['message'],['message']
Integrability,"// Send the message, if any",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdconn.cxx:12,message,message,12,net/rpdutils/src/rpdconn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdconn.cxx,1,['message'],['message']
Integrability,"// Send urgent message to rootd to stop tranfer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TFTP.cxx:15,message,message,15,net/net/src/TFTP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TFTP.cxx,1,['message'],['message']
Integrability,"// Send urgent message to rootd to stop transfer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TFTP.cxx:15,message,message,15,net/net/src/TFTP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TFTP.cxx,1,['message'],['message']
Integrability,// Sending 'release' message?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp:21,message,message,21,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NSAutoreleasePoolChecker.cpp,1,['message'],['message']
Integrability,// Set Base and Disp accordingly depending on the address mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:33,depend,depending,33,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['depend'],['depending']
Integrability,// Set D to be as many least significant bits of C as possible while still; // guaranteeing that adding D to (C - D + x + y + ...) won't cause a wrap:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:145,wrap,wrap,145,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wrap']
Integrability,"// Set FCN using new interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TBackCompFitter.h:21,interface,interface,21,hist/hist/inc/TBackCompFitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TBackCompFitter.h,1,['interface'],['interface']
Integrability,"// Set a wrapper around the Streamer member function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx:9,wrap,wrapper,9,core/meta/src/TGenericClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx,2,['wrap'],['wrapper']
Integrability,"// Set all methods to undefined; // Defined methods will be registered by static initialization routines; // of the various numeric integrator engines",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumGenConfig.cxx:96,rout,routines,96,roofit/roofitcore/src/RooNumGenConfig.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumGenConfig.cxx,4,"['integrat', 'rout']","['integrator', 'routines']"
Integrability,// Set all the active offloading kinds to the link action. Given that it; // is a link action it is assumed to depend on all actions generated so; // far.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:111,depend,depend,111,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['depend'],['depend']
Integrability,// Set an arbitrary limit on the number of candidates we'll spam; // the user with. FIXME: This limit should depend on details of the; // candidate list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:109,depend,depend,109,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['depend'],['depend']
Integrability,"// Set cache mode operator to 'AlwaysDirty' if we depend on any of the given observables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:50,depend,depend,50,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['depend'],['depend']
Integrability,// Set error mode to not display any message boxes. The child process inherits; // this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp:37,message,message,37,interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp,1,['message'],['message']
Integrability,"// Set fParallel to 1 for workers since they do not; // report their fParallel with a LOG_DONE message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx:95,message,message,95,proof/proof/src/TProofLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx,2,['message'],['message']
Integrability,"// Set integration function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/GaussIntegrator.cxx:7,integrat,integration,7,math/mathcore/src/GaussIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/GaussIntegrator.cxx,1,['integrat'],['integration']
Integrability,"// Set members of the abstract interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/sql/sqlite/src/TSQLiteServer.cxx:31,interface,interface,31,sql/sqlite/src/TSQLiteServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/sql/sqlite/src/TSQLiteServer.cxx,1,['interface'],['interface']
Integrability,"// Set of resources available on the subtarget.; //; // There is an instance of ResourceState for every resource declared by the; // target scheduling model.; //; // Elements of this vector are ordered by resource kind. In particular,; // resource units take precedence over resource groups.; //; // The index of a processor resource in this vector depends on the value of; // its mask (see the description of field ResourceState::ResourceMask). In; // particular, it is computed as the position of the most significant bit set; // (MSB) in the mask plus one (since we want to ignore the invalid resource; // descriptor at index zero).; //; // Example (little endian):; //; // Resource | Mask | MSB | Index; // ---------+---------+---------+-------; // A | 0b00001 | 0b00001 | 1; // | | |; // B | 0b00100 | 0b00100 | 3; // | | |; // C | 0b10010 | 0b10000 | 5; //; //; // The same index is also used to address elements within vector `Strategies`; // and vector `Resource2Groups`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:349,depend,depends,349,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['depend'],['depends']
Integrability,// Set our location to be the MAV wrapping the new Value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugProgramInstruction.cpp:34,wrap,wrapping,34,interpreter/llvm-project/llvm/lib/IR/DebugProgramInstruction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugProgramInstruction.cpp,1,['wrap'],['wrapping']
Integrability,"// Set protocol string.; // Check if version should be different ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:7,protocol,protocol,7,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['protocol'],['protocol']
Integrability,"// Set some properties which depend solely on the input kind; it would be nice; // to move these to the language standard, and have the driver resolve the; // input kind + language standard.; //; // FIXME: Perhaps a better model would be for a single source file to have; // multiple language standards (C / C++ std, ObjC std, OpenCL std, OpenMP std); // simultaneously active?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp:29,depend,depend,29,interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp,1,['depend'],['depend']
Integrability,// Set the AT_producer to the clang version when using the integrated; // assembler on assembly source files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:59,integrat,integrated,59,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['integrat'],['integrated']
Integrability,// Set the alignment flags for the node depending on if the node is; // 4-byte or 16-byte aligned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:40,depend,depending,40,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['depend'],['depending']
Integrability,"// Set the bits in `Bits`, which correspond to the value representations of; // the actual members of the record type `RTy`. Note that this function does; // not handle base classes, virtual tables, etc, since they cannot happen in; // CMSE function arguments or return. The bit mask corresponds to the target; // memory layout, i.e. it's endian dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:346,depend,dependent,346,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['depend'],['dependent']
Integrability,// Set the button icon according to the message with the highest severity,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/controller/ClientLog.controller.js:40,message,message,40,ui5/eve7/controller/ClientLog.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/controller/ClientLog.controller.js,1,['message'],['message']
Integrability,// Set the default argument. It should be no problem if it was already done.; // Do not import the default expression before GetImportedOrCreateDecl call; // to avoid possible infinite import loop because circular dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:214,depend,dependency,214,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['depend'],['dependency']
Integrability,"// Set the header flags that we can in the constructor.; // FIXME: This is a fairly terrible hack. We set the rest; // of these in the destructor. The problem here is two-fold:; //; // a: Some of the eflags can be set/reset by directives.; // b: There aren't any usage paths that initialize the ABI; // pointer until after we initialize either an assembler; // or the target machine.; // We can fix this by making the target streamer construct; // the ABI, but this is fraught with wide ranging dependency; // issues as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:495,depend,dependency,495,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,1,['depend'],['dependency']
Integrability,// Set the new type for the injected decl too.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:28,inject,injected,28,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['inject'],['injected']
Integrability,"// Set the objective function to be minimized, by passing a function object implement the; // basic multi-dim Function interface. In this case the derivatives will be; // calculated by Fumili; // Here a TFumili instance is created since only at this point we know the number of parameters; // needed to create TFumili",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumiliMinimizer.cxx:119,interface,interface,119,math/fumili/src/TFumiliMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumiliMinimizer.cxx,1,['interface'],['interface']
Integrability,"// Set the objective function to be minimized, by passing a function object implement the; // basic multi-dim Function interface. In this case the derivatives will be; // calculated by Minuit; // Here a TMinuit instance is created since only at this point we know the number of parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx:119,interface,interface,119,math/minuit/src/TMinuitMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx,1,['interface'],['interface']
Integrability,// Set the opcode to DELETED_NODE to help catch bugs when node; // memory is reallocated.; // FIXME: There are places in SDag that have grown a dependency on the opcode; // value in the released node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:144,depend,dependency,144,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['depend'],['dependency']
Integrability,"// Set the partition to external if we know it is re-defined by the linker; // with -defsym or -wrap options, used elsewhere, e.g. it is visible to a; // regular object, is referenced from llvm.compiler.used/llvm.used, or was; // already recorded as being referenced from a different partition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:96,wrap,wrap,96,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['wrap'],['wrap']
Integrability,"// Set the state of some input widgets depending on whether the fit; // function can be defined by text or if it is an existing one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx:39,depend,depending,39,gui/fitpanel/src/TFitEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx,1,['depend'],['depending']
Integrability,// Set to the number of cycles of stall a given instruction will incur; // because of dependence on instruction in previous packet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h:86,depend,dependence,86,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.h,1,['depend'],['dependence']
Integrability,// Set unsupported atomic operations as Custom so; // we can emit better error messages than fatal error; // from selectiondag.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:79,message,messages,79,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,1,['message'],['messages']
Integrability,"// Set up global aliases for the metaclass or class pointer if they do not; // already exist. These will are forward-references which will be set to; // pointers to the class and metaclass structure created for the runtime; // load function. To send a message to super, we look up the value of the; // super_class pointer from either the class or metaclass structure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:252,message,message,252,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['message'],['message']
Integrability,// Set up target dependant options; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-opt-fuzzer/llvm-opt-fuzzer.cpp:17,depend,dependant,17,interpreter/llvm-project/llvm/tools/llvm-opt-fuzzer/llvm-opt-fuzzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-opt-fuzzer/llvm-opt-fuzzer.cpp,1,['depend'],['dependant']
Integrability,// Set up the creation routine for code-completion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:23,rout,routine,23,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['rout'],['routine']
Integrability,"// Set value caching mode for all nodes that depend on any of the observables to ADirty",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx:45,depend,depend,45,roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,3,['depend'],['depend']
Integrability,"// Set/get switch that activates printing of number of required; // function evaluations for each numeric integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooNumIntConfig.h:106,integrat,integration,106,roofit/roofitcore/inc/RooNumIntConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooNumIntConfig.h,1,['integrat'],['integration']
Integrability,"// SetPosition will send a message which will handled by; // the function TGListBox::ProcessMessage. Now ProcessMessage will; // set the viewport. SetPosition also will check that the idPos is; // not out of range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGListBox.cxx:27,message,message,27,gui/gui/src/TGListBox.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGListBox.cxx,1,['message'],['message']
Integrability,// Sets dependence directly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:8,depend,dependence,8,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,2,['depend'],['dependence']
Integrability,"// Setting up the jobs for some precompile cases depends on whether we are; // treating them as PCH, implicit modules or C++20 ones.; // TODO: inferring the mode like this seems fragile (it meets the objective; // of not requiring anything new for operation, however).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:49,depend,depends,49,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['depend'],['depends']
Integrability,"// Setup lists for factorization terms and their dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:49,depend,dependents,49,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['depend'],['dependents']
Integrability,// Setup the data structure used to plumb customization into the; // `InlineFunction` routine.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:86,rout,routine,86,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,2,['rout'],['routine']
Integrability,"// Setup the main metadata. Depending on the container type, we'll setup the; // required records next.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/BitstreamRemarkSerializer.cpp:28,Depend,Depending,28,interpreter/llvm-project/llvm/lib/Remarks/BitstreamRemarkSerializer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/BitstreamRemarkSerializer.cpp,1,['Depend'],['Depending']
Integrability,// Shared library dependencies,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h:18,depend,dependencies,18,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h,1,['depend'],['dependencies']
Integrability,"// Shift it to the right place, depending on endianness.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:32,depend,depending,32,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['depend'],['depending']
Integrability,// Shift mask depending on type size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:14,depend,depending,14,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['depend'],['depending']
Integrability,"// Shift min and max of dependent variable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:24,depend,dependent,24,hist/hist/src/TMultiDimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx,1,['depend'],['dependent']
Integrability,// Shift the bits to the least significant depending on endianness.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:43,depend,depending,43,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,1,['depend'],['depending']
Integrability,"// Shift the piece of the value into the right place, depending on; // endianness.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:54,depend,depending,54,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['depend'],['depending']
Integrability,// Short helper routines.; /// Constructs a MemberInfo instance from an offset and llvm::Type *.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp:16,rout,routines,16,interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,1,['rout'],['routines']
Integrability,"// Shortcut definitions to issue HistFactory messages through the RooMsgService.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/inc/HFMsgService.h:45,message,messages,45,roofit/histfactory/inc/HFMsgService.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/inc/HFMsgService.h,1,['message'],['messages']
Integrability,// Shortcut: Singly defined vregs do not have output/anti dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:58,depend,dependencies,58,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['depend'],['dependencies']
Integrability,// Shortcuts to some useful interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:28,interface,interface,28,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,1,['interface'],['interface']
Integrability,"// Should be called on updates in which if we're processing an instruction; // \p I that depends on a value \p V, one of the following has to happen:; // - If the value is assumed, then stop.; // - If the value is known but undef, then consider it UB.; // - Otherwise, do specific processing with the simplified value.; // We return std::nullopt in the first 2 cases to signify that an appropriate; // action was taken and the caller should stop.; // Otherwise, we return the simplified value that the caller should; // use for specific processing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:89,depend,depends,89,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['depend'],['depends']
Integrability,"// Should check if a declaration is friend in a dependent context.; // Such templates are not linked together in a declaration chain.; // The ASTImporter strategy is to map existing forward declarations to; // imported ones only if strictly necessary, otherwise import these as new; // forward declarations. In case of the ""dependent friend"" declarations, new; // declarations are created, but not linked in a declaration chain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:48,depend,dependent,48,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,2,['depend'],['dependent']
Integrability,"// Should not be used.; // In the case of vector, so that the I/O can perform better,; // the begin_arena and the end_arena are *not* set to the; // address of any iterator rather they are set to the value of; // the beginning (and end) address of the vector's data.; // Hence this routine (which takes the value of fBegin) can; // *not* update where its points to (which in the case of vector; // would require update the value of fBegin).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollectionProxyInfo.h:282,rout,routine,282,core/cont/inc/TCollectionProxyInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollectionProxyInfo.h,1,['rout'],['routine']
Integrability,"// Should send out some message. Need a new stamp type?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveElement.cxx:24,message,message,24,graf3d/eve7/src/REveElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveElement.cxx,1,['message'],['message']
Integrability,// Show a message about a dropped pattern with some info to make it; // easier to identify it in the .td files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:10,message,message,10,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['message'],['message']
Integrability,// Show the error message and exit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:18,message,message,18,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,1,['message'],['message']
Integrability,"// Show the error plus the usage message, and exit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp:33,message,message,33,interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ar/llvm-ar.cpp,1,['message'],['message']
Integrability,"// Shuffle these instructions using topological sort.; // Returns false if all current instruction's dependencies in this block have; // been shuffled. If so, this instruction can be shuffled too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp:101,depend,dependencies,101,interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/IRMutator.cpp,1,['depend'],['dependencies']
Integrability,"// Shut up integration messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/vectorisedPDFs/VectorisedPDFTests.cxx:11,integrat,integration,11,roofit/roofit/test/vectorisedPDFs/VectorisedPDFTests.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/vectorisedPDFs/VectorisedPDFTests.cxx,2,"['integrat', 'message']","['integration', 'messages']"
Integrability,"// Sign of the product depends on the sign of the ImmVal, since Multiplier; // is always positive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:23,depend,depends,23,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,1,['depend'],['depends']
Integrability,"// Signalling interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/SignalHandler.h:14,interface,interface,14,core/textinput/src/textinput/SignalHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/SignalHandler.h,1,['interface'],['interface']
Integrability,"// Signed 16 bit constant; // If this fails, the parent routine will give an error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:56,rout,routine,56,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,2,['rout'],['routine']
Integrability,"// Silence deduplication error messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAbsCollection.cxx:31,message,messages,31,roofit/roofitcore/test/testRooAbsCollection.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAbsCollection.cxx,2,['message'],['messages']
Integrability,"// Silence possible error message from TFile constructor if this is a tree name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSimpleAnalysis.cxx:26,message,message,26,tree/treeplayer/src/TSimpleAnalysis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSimpleAnalysis.cxx,1,['message'],['message']
Integrability,"// Silence the info about numeric integration because we don't care about it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooCurve.cxx:34,integrat,integration,34,roofit/roofitcore/test/testRooCurve.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooCurve.cxx,2,['integrat'],['integration']
Integrability,"// Silently accept unsupported uses of __weak in both user and system; // declarations when it's been disabled, for ease of integration with; // -fno-objc-arc files. We do have to take some care against attempts; // to define such things; for now, we've only done that for ivars; // and properties.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:124,integrat,integration,124,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['integrat'],['integration']
Integrability,// Silently ignore these if a UsingShadowDecl instantiated to nothing.; // This can happen because of dependent hiding.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:102,depend,dependent,102,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['depend'],['dependent']
Integrability,// Silently overwrite any existing protocol qualifiers.; // TODO: determine whether that's the right thing to do.; // FIXME: Check for protocols to which the class type is already; // known to conform.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:35,protocol,protocol,35,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,2,['protocol'],"['protocol', 'protocols']"
Integrability,"// Similar to above, walk the list of first-implied protocols to find the set; // all the protocols implied excluding the listed protocols themselves since; // they are not yet a part of the `RuntimePds` list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:52,protocol,protocols,52,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,3,['protocol'],['protocols']
Integrability,"// Similarly, if the previous declaration was a dependent local extern; // declaration, we don't really know its type yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:48,depend,dependent,48,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,"// Simple case: normal parameter, or a parameter pack that's; // instantiated to a (still-dependent) parameter pack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:90,depend,dependent,90,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['depend'],['dependent']
Integrability,"// Simple wrapper class to abstract away from the details of memory management.; // SExprs are allocated in pools, and deallocated all at once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyUtil.h:10,wrap,wrapper,10,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyUtil.h,1,['wrap'],['wrapper']
Integrability,// Simple wrapper to add the name of a variable or (if no variable is; // available) a DeclarationName into a diagnostic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:10,wrap,wrapper,10,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['wrap'],['wrapper']
Integrability,"// Simple wrapper to separate, time-wise, the call to the; // TROOT destructor and the actual free-ing of the memory.; //; // Since the interpreter implementation (currently TCling) is; // loaded via dlopen by libCore, the destruction of its global; // variable (i.e. in particular clang's) is scheduled before; // those in libCore so we need to schedule the call to the TROOT; // destructor before that *but* we want to make sure the memory; // stay around until libCore itself is unloaded so that code; // using gROOT can 'properly' check for validity.; //; // The order of loading for is:; // libCore.so; // libRint.so; // ... anything other library hard linked to the executable ...; // ... for example libEvent; // libCling.so; // ... other libraries like libTree for example ....; // and the destruction order is (of course) the reverse.; // By default the unloading of the dictionary, does use; // the service of the interpreter ... which of course; // fails if libCling is already unloaded by that information; // has not been registered per se.; //; // To solve this problem, we now schedule the destruction; // of the TROOT object to happen _just_ before the; // unloading/destruction of libCling so that we can; // maximize the amount of clean-up we can do correctly; // and we can still allocate the TROOT object's memory; // statically.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:10,wrap,wrapper,10,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['wrap'],['wrapper']
Integrability,"// Simplest scenario, full-range integration over all dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHistPdf.cxx:33,integrat,integration,33,roofit/roofitcore/src/RooHistPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHistPdf.cxx,2,"['depend', 'integrat']","['dependents', 'integration']"
Integrability,"// Simplest scenario, integrate over all dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooParamHistFunc.cxx:22,integrat,integrate,22,roofit/roofit/src/RooParamHistFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooParamHistFunc.cxx,2,"['depend', 'integrat']","['dependents', 'integrate']"
Integrability,"// Simplify the display file path, and wrap it in a link if requested.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:39,wrap,wrap,39,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,1,['wrap'],['wrap']
Integrability,"// Since Analysis can't depend on Target, use a std::function to invert the; // dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/TargetMachine.cpp:24,depend,depend,24,interpreter/llvm-project/llvm/lib/Target/TargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/TargetMachine.cpp,2,['depend'],"['depend', 'dependency']"
Integrability,"// Since a projected PDF is an integral, we can use the same logic from; // RooRealIntegral via the projection integral to figure out what the; // servers are. Integration observables will be shape servers, the other; // servers are value servers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProjectedPdf.cxx:160,Integrat,Integration,160,roofit/roofitcore/src/RooProjectedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProjectedPdf.cxx,1,['Integrat'],['Integration']
Integrability,"// Since emitting the mcount call here impacts optimizations such as function; // inlining, we just add an attribute to insert a mcount call in backend.; // The attribute ""counting-function"" is set to mcount function name which is; // architecture dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:248,depend,dependent,248,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['depend'],['dependent']
Integrability,"// Since instance & class methods can have the same name, the loop below; // ensures we get the correct method.; //; // @interface Whatever; // - (int) class_method;; // + (float) class_method;; // @end",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:121,interface,interface,121,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,1,['interface'],['interface']
Integrability,"// Since the STL collection might or might not be emulated and that the; // sizeof the object depends on this, let's just always retrieve the; // current size!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TStreamerElement.cxx:94,depend,depends,94,core/meta/src/TStreamerElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TStreamerElement.cxx,1,['depend'],['depends']
Integrability,"// Since the body of the coroutine will be wrapped in try-catch, it will; // be incompatible with SEH __try if present in a function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:43,wrap,wrapped,43,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,1,['wrap'],['wrapped']
Integrability,// Since the error can be related to the profile or the binary we do not; // pass whence. Instead additional context is provided where necessary in; // the error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp:162,message,message,162,interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,1,['message'],['message']
Integrability,"// Since the message dialog box is created, we disable the; // window manager close mechanism, in order to ensure we; // can't close the fMain window while the MessageBox is open.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/guitest.cxx:13,message,message,13,test/guitest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/guitest.cxx,2,"['Message', 'message']","['MessageBox', 'message']"
Integrability,"// Since the resource directory is embedded in the module hash, it's important; // that all places that need it call this function, so that they get the; // exact same string (""a/../b/"" and ""b/"" get different hashes, for example).; // Dir is bin/ or lib/, depending on where BinaryPath is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:256,depend,depending,256,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['depend'],['depending']
Integrability,"// Since the user does not want this branch to be loaded anyway, we just; // skip it. This prevents us from warning the user that the method might; // be on a disabled branch. However, and more usefully, this allows the; // user to avoid error messages from branches that cannot be currently; // read without warnings/errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:244,message,messages,244,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['message'],['messages']
Integrability,"// Since these expressions can only be value-dependent, we do not; // need to perform semantic analysis again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:45,depend,dependent,45,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['depend'],['dependent']
Integrability,"// Since this dependant is now ready, we erase its; // MaterializingInfo and update its materializing state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:14,depend,dependant,14,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['depend'],['dependant']
Integrability,"// Since this member now becomes a new top-level record, it should have; // gotten a RecordPrefix injected, and that RecordPrefix + the member we; // just wrote should now constitute the entirety of the current ""new""; // segment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/ContinuationRecordBuilder.cpp:98,inject,injected,98,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/ContinuationRecordBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/ContinuationRecordBuilder.cpp,1,['inject'],['injected']
Integrability,"// Since this routine can be called (almost) directly from the command line and is used; // in automated test, it must return 0 in case of success",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressInterpreter.cxx:14,rout,routine,14,test/stressInterpreter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressInterpreter.cxx,1,['rout'],['routine']
Integrability,"// Since this transformation doesn't modify the CFG, it preserves all analyses; // that only depend on the CFG (like dominators, loop info, etc...)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Pass.cpp:93,depend,depend,93,interpreter/llvm-project/llvm/lib/IR/Pass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Pass.cpp,1,['depend'],['depend']
Integrability,"// Since we are in a class method, this is a class message to; // the superclass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:51,message,message,51,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['message'],['message']
Integrability,"// Since we are in an instance method, this is an instance; // message to the superclass instance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:63,message,message,63,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['message'],['message']
Integrability,"// Since we call ParseDeclarationOrFunctionDefinition() instead of; // ParseExternalDeclaration() below (so that this doesn't parse nested; // @interfaces), this needs to duplicate some code from the latter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:144,interface,interfaces,144,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['interface'],['interfaces']
Integrability,"// Since we can assume the conversion won't overflow, our decision as to; // whether the input will fit in the float should depend on the minimum; // of the input range and output range.; // This means this is also safe for a signed input and unsigned output, since; // a negative input would lead to undefined behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:124,depend,depend,124,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['depend'],['depend']
Integrability,"// Since we do not add pseudos to packets, might as well; // ignore order dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:74,depend,dependencies,74,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,1,['depend'],['dependencies']
Integrability,"// Since we have an interface or protocol, we can end it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:20,interface,interface,20,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,2,"['interface', 'protocol']","['interface', 'protocol']"
Integrability,"// Size dependent types are just typedefs to normal integer types; // (e.g. unsigned long), so we cannot distinguish them from other typedefs to; // integers other than by their names.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:8,depend,dependent,8,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,"// Size of fragments in one section can depend on the size of fragments in; // another. If any fragment has changed size, we have to re-layout (and; // as a result possibly further relax) all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:40,depend,depend,40,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,1,['depend'],['depend']
Integrability,"// Size savings will depend on whether we can fold the offset, as an; // immediate of an ADD.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp:21,depend,depend,21,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp,1,['depend'],['depend']
Integrability,"// SizeOfRawData and VirtualSize change what they represent depending on; // whether or not we have an executable image.; //; // For object files, SizeOfRawData contains the size of section's data;; // VirtualSize should be zero but isn't due to buggy COFF writers.; //; // For executables, SizeOfRawData *must* be a multiple of FileAlignment; the; // actual section size is in VirtualSize. It is possible for VirtualSize to; // be greater than SizeOfRawData; the contents past that point should be; // considered to be zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp:60,depend,depending,60,interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp,1,['depend'],['depending']
Integrability,"// Skip ObjCImageInfo -- this shouldn't have any dependencies, and we may; // remove it later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp:49,depend,dependencies,49,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MachOPlatform.cpp,1,['depend'],['dependencies']
Integrability,"// Skip PP directives; they just move the wrap point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp:42,wrap,wrap,42,interpreter/cling/lib/Utils/SourceNormalization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp,1,['wrap'],['wrap']
Integrability,// Skip all dependent types in templates being used as base specifiers.; // Checks below assume that the base specifier is a CXXRecord.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,depend,dependent,12,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['dependent']
Integrability,"// Skip any load instruction that has a tied input. There may be an additional; // dependency requiring a different order than by increasing offsets, and the; // added glue may introduce a cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:83,depend,dependency,83,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['depend'],['dependency']
Integrability,// Skip any properties that are declared in protocols that this class; // conforms to but are not actually implemented by this class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:44,protocol,protocols,44,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['protocol'],['protocols']
Integrability,"// Skip assume intrinsics, they don't really have side effects (although; // they're marked as such to ensure preservation of control dependencies),; // and this pass will not bother with its removal. However, we should mark; // its condition as true for all dominated blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:134,depend,dependencies,134,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['depend'],['dependencies']
Integrability,// Skip dependent types; we can't do any checking on them now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:8,depend,dependent,8,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,1,['depend'],['dependent']
Integrability,// Skip if MemOpb has been clustered already or has dependency with; // MemOpa.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:52,depend,dependency,52,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['depend'],['dependency']
Integrability,// Skip local symbols: we do not track dependencies for these.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:39,depend,dependencies,39,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,1,['depend'],['dependencies']
Integrability,"// Skip over intrinsics since they won't remain as function calls.; // Important to do this check before the linkage check below so we; // won't bail out on debug intrinsics, possibly making the generated; // code dependent on the presence of debug info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:214,depend,dependent,214,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['depend'],['dependent']
Integrability,"// Skip over remaining anti-dependences. Two instructions that are; // anti-dependent can share a packet, since in most such cases all; // operands are read before any modifications take place.; // The exceptions are branch and call instructions, since they are; // executed after all other instructions have completed (at least; // conceptually).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:28,depend,dependences,28,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,2,['depend'],"['dependences', 'dependent']"
Integrability,// Skip synchronization object,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:8,synchroniz,synchronization,8,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['synchroniz'],['synchronization']
Integrability,"// Skip the message prefix",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMsgService.h:12,message,message,12,roofit/roofitcore/inc/RooMsgService.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMsgService.h,1,['message'],['message']
Integrability,"// Skip the object with a reset after merge routine (TTree and other incrementally mergeable objects)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileMerger.cxx:44,rout,routine,44,io/io/src/TFileMerger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileMerger.cxx,1,['rout'],['routine']
Integrability,"// Skip the object without a reset after merge routine (Histograms and other non incrementally mergeable objects)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileMerger.cxx:47,rout,routine,47,io/io/src/TFileMerger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileMerger.cxx,1,['rout'],['routine']
Integrability,// Skip the rest of the checks for a member of a dependent class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:49,depend,dependent,49,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['dependent']
Integrability,// Skip the search if there are no chain dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:41,depend,dependencies,41,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['depend'],['dependencies']
Integrability,"// Skip uninteresting fields: either special to us, or injected; // template parameters (if they contain a ':').",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SearchableTableEmitter.cpp:55,inject,injected,55,interpreter/llvm-project/llvm/utils/TableGen/SearchableTableEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SearchableTableEmitter.cpp,1,['inject'],['injected']
Integrability,// Skip wrap checking when translating pointers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:8,wrap,wrap,8,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['wrap'],['wrap']
Integrability,// Skip writing dependency output and the compilation database itself.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:16,depend,dependency,16,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['depend'],['dependency']
Integrability,"// Skipping the loading part (it would leads to infinite recursion on this very routine)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:80,rout,routine,80,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,1,['rout'],['routine']
Integrability,// Slashes occur in text protocol extension syntax: [type/type] { ... }.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:25,protocol,protocol,25,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['protocol'],['protocol']
Integrability,"// Slope and offset may not depend on variable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooLinearVar.cxx:28,depend,depend,28,roofit/roofitcore/src/RooLinearVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooLinearVar.cxx,1,['depend'],['depend']
Integrability,// Slower path: look in all protocols we referenced.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:28,protocol,protocols,28,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['protocol'],['protocols']
Integrability,"// So that the TTreeCloner can access the protected interfaces",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:52,interface,interfaces,52,tree/tree/inc/TTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h,1,['interface'],['interfaces']
Integrability,"// So, here we replace TLSADDR with the sequence:; // adjust_stackdown -> TLSADDR -> adjust_stackup.; // We need this because TLSADDR is lowered into calls; // inside MC, therefore without the two markers shrink-wrapping; // may push the prologue/epilogue pass them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:212,wrap,wrapping,212,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['wrap'],['wrapping']
Integrability,"// Socket where to redirect the message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TApplicationServer.h:32,message,message,32,net/net/inc/TApplicationServer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TApplicationServer.h,2,['message'],['message']
Integrability,"// Solving an equation q(x) = 0 with coefficients in modular arithmetic; // is really solving a set of equations q(x) = kR for k = 0, 1, 2, ...,; // and R = 2^BitWidth.; // Since we're trying not only to find exact solutions, but also values; // that ""wrap around"", such a set will always have a solution, i.e. an x; // that satisfies at least one of the equations, or such that |q(x)|; // exceeds kR, while |q(x-1)| for the same k does not.; //; // We need to find a value k, such that Ax^2 + Bx + C = kR will have a; // positive solution n (in the above sense), and also such that the n; // will be the least among all solutions corresponding to k = 0, 1, ...; // (more precisely, the least element in the set; // { n(k) | k is such that a solution n(k) exists }).; //; // Consider the parabola (over real numbers) that corresponds to the; // quadratic equation. Since A > 0, the arms of the parabola will point; // up. Picking different values of k will shift it up and down by R.; //; // We want to shift the parabola in such a way as to reduce the problem; // of solving q(x) = kR to solving shifted_q(x) = 0.; // (The interesting solutions are the ceilings of the real number; // solutions.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:252,wrap,wrap,252,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['wrap'],['wrap']
Integrability,"// Some assertions to enforce that strong dependencies are relations in; // between purely modeling checkers, and weak dependencies are about; // diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:42,depend,dependencies,42,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,2,['depend'],['dependencies']
Integrability,// Some bits of the operand may be required to be 1 depending on the; // instruction's encoding. Collect those bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp:52,depend,depending,52,interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,1,['depend'],['depending']
Integrability,// Some browsers return HTTP Status 0 when using non-http protocol; // e.g. 'file://' or 'data://'. Handle as success.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:58,protocol,protocol,58,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,1,['protocol'],['protocol']
Integrability,// Some codegen options depend on language options. Let's provide the expected; // variable name and type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:24,depend,depend,24,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['depend'],['depend']
Integrability,"// Some command line options support shortcuts. For example:; // The command line option '--print=elements' is a shortcut for:; // '--print=instructions,lines,scopes,symbols,types'.; // In the case of logical view comparison, some options related to; // attributes must be set or reset for a proper comparison.; // Resolve any dependencies between command line options.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVOptions.h:327,depend,dependencies,327,interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVOptions.h,1,['depend'],['dependencies']
Integrability,"// Some diagnostics need to vary with subtarget features, so they are handled; // here. For example, the DPR class has either 16 or 32 registers, depending; // on the FPU available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:146,depend,depending,146,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['depend'],['depending']
Integrability,// Some expressions are always dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:31,depend,dependent,31,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,1,['depend'],['dependent']
Integrability,"// Some formulas are instant losers. For example, they may depend on; // nonexistent AddRecs from other loops. These need to be filtered; // immediately, otherwise heuristics could choose them over others leading; // to an unsatisfactory solution. Passing LoserRegs into RateFormula here; // avoids the need to recompute this information across formulae using the; // same bad AddRec. Passing LoserRegs is also essential unless we remove; // the corresponding bad register from the Regs set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:59,depend,depend,59,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['depend'],['depend']
Integrability,"// Some library calls are just wrappers around llvm intrinsics, but compiled; // conservatively. Preserve the flags from the original call site by; // substituting them with direct calls with all the flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp:31,wrap,wrappers,31,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,1,['wrap'],['wrappers']
Integrability,// Some might be dependent for other reasons.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:17,depend,dependent,17,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,1,['depend'],['dependent']
Integrability,"// Some notes on redeclarables:; //; // - Every redeclarable is on a circular linked list.; //; // - Every decl has a pointer to the first element of the chain _and_ a; // DeclLink that may point to one of 3 possible states:; // - the ""previous"" (temporal) element in the chain; // - the ""latest"" (temporal) element in the chain; // - the ""uninitialized-latest"" value (when newly-constructed); //; // - The first element is also often called the canonical element. Every; // element has a pointer to it so that ""getCanonical"" can be fast.; //; // - Most links in the chain point to previous, except the link out of; // the first; it points to latest.; //; // - Elements are called ""first"", ""previous"", ""latest"" or; // ""most-recent"" when referring to temporal order: order of addition; // to the chain.; //; // - It's easiest to just ignore the implementation of DeclLink when making; // sense of the redeclaration chain.; //; // - There's also a ""definition"" link for several types of; // redeclarable, where only one definition should exist at any given; // time (and the defn pointer is stored in the decl's ""data"" which; // is copied to every element on the chain when it's changed).; //; // Here is some ASCII art:; //; // ""first"" ""latest""; // ""canonical"" ""most recent""; // +------------+ first +--------------+; // | | <--------------------------- | |; // | | | |; // | | | |; // | | +--------------+ | |; // | | first | | | |; // | | <---- | | | |; // | | | | | |; // | @class A | link | @interface A | link | @class A |; // | seen first | <---- | seen second | <---- | seen third |; // | | | | | |; // +------------+ +--------------+ +--------------+; // | data | defn | data | defn | data |; // | | ----> | | <---- | |; // +------------+ +--------------+ +--------------+; // | | ^ ^; // | |defn | |; // | link +-----+ |; // +-->-------------------------------------------+; /// Provides common interface for the Decls that can be redeclared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h:1495,interface,interface,1495,interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h,2,['interface'],['interface']
Integrability,// Some of the conditional code depends in I.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:32,depend,depends,32,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,1,['depend'],['depends']
Integrability,// Some targets change the handler depending on whether the call is; // varargs or not. If,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:35,depend,depending,35,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,1,['depend'],['depending']
Integrability,// Some targets require that all access to thread local variables go through; // the thread wrapper. This means that we cannot attempt to create a thread; // wrapper or a thread helper.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:92,wrap,wrapper,92,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,2,['wrap'],['wrapper']
Integrability,"// Some transformations (e.g. instcombine) may decide to turn a Fortran; // character object into an integer, and later ones (e.g. SROA) may; // further inject a constant integer in a llvm.dbg.value call to track; // the object's value. Here we trust the transformations are doing the; // right thing, and treat the constant as unsigned to preserve that value; // (i.e. avoid sign extension).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:153,inject,inject,153,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,1,['inject'],['inject']
Integrability,"// Some types of locations do not have specific kind. Now is the time; // to set those types, depending on the operation type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp:94,depend,depending,94,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp,1,['depend'],['depending']
Integrability,"// Some types skip the assembler phase (e.g., llvm-bc), but we can't; // encode this in the steps because the intermediate type depends on; // arguments. Just special case here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:128,depend,depends,128,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['depend'],['depends']
Integrability,"// Some versions of glibc and gcc use idioms (particularly in their malloc; // routines) that add a pointer-sized integer (known to be a pointer value); // to a null pointer in order to cast the value back to an integer or as; // part of a pointer alignment algorithm. This is undefined behavior, but; // we'd like to be able to compile programs that use it.; //; // Normally, we'd generate a GEP with a null-pointer base here in response; // to that code, but it's also UB to dereference a pointer created that; // way. Instead (as an acknowledged hack to tolerate the idiom) we will; // generate a direct cast of the integer value to a pointer.; //; // The idiom (p = nullptr + N) is not met if any of the following are true:; //; // The operation is subtraction.; // The index is not pointer-sized.; // The pointer type is not byte-sized.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:79,rout,routines,79,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['rout'],['routines']
Integrability,"// Something went wrong, the warning message has already been issued.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:37,message,message,37,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['message'],['message']
Integrability,"// Sometimes in a loop we have a branch whose condition is made false by; // taking it. This is typically something like; // int n = 0;; // while (...) {; // if (++n >= MAX) {; // n = 0;; // }; // }; // In this sort of situation taking the branch means that at the very least it; // won't be taken again in the next iteration of the loop, so we should; // consider it less likely than a typical branch.; //; // We detect this by looking back through the graph of PHI nodes that sets the; // value that the condition depends on, and seeing if we can reach a successor; // block which can be determined to make the condition false.; //; // FIXME: We currently consider unlikely blocks to be half as likely as other; // blocks, but if we consider the example above the likelyhood is actually; // 1/MAX. We could therefore be more precise in how unlikely we consider; // blocks to be, but it would require more careful examination of the form; // of the comparison expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:516,depend,depends,516,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,1,['depend'],['depends']
Integrability,"// Sometimes the VMSET is wrapped in a COPY_TO_REGCLASS, e.g. if the mask came; // from an extract_subvector or insert_subvector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:26,wrap,wrapped,26,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['wrap'],['wrapped']
Integrability,"// Sort by descending size order so that we allocate the most important; // sets first.; // Tie-break equivalent sizes by sorting chains requiring fixups before; // those without fixups. The logic here is that we should look at the; // chains that we cannot change before we look at those we can,; // so the parity counter is updated and we know what color we should; // change them to!; // Final tie-break with instruction order so pass output is stable (i.e. not; // dependent on malloc'd pointer values).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp:469,depend,dependent,469,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp,1,['depend'],['dependent']
Integrability,// Sort header paths so that the pcm doesn't depend on iteration order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:45,depend,depend,45,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,1,['depend'],['depend']
Integrability,// Sort it now (if needed) so that recursive invocations of; // getNonLocalPointerDepFromBB and other routines that could reuse the; // cache value will only see properly sorted cache arrays.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:102,rout,routines,102,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['rout'],['routines']
Integrability,"// Sort protocols, keyed by name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:8,protocol,protocols,8,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['protocol'],['protocols']
Integrability,// Sort the remaining protocols by name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:22,protocol,protocols,22,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['protocol'],['protocols']
Integrability,"// Sorting interface ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooDouble.h:11,interface,interface,11,roofit/roofitcore/inc/RooDouble.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooDouble.h,1,['interface'],['interface']
Integrability,"// Source is the expression which determined the nullability. For example in a; // message like [nullable nonnull_returning] has nullable nullability, because; // the receiver is nullable. Here the receiver will be the source of the; // nullability. This is useful information when the diagnostics are generated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:83,message,message,83,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,1,['message'],['message']
Integrability,"// SourceLocations are stored after Info, one for each protocol qualifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TypeLoc.h:55,protocol,protocol,55,interpreter/llvm-project/clang/include/clang/AST/TypeLoc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TypeLoc.h,1,['protocol'],['protocol']
Integrability,"// SourceLocations are stored after the type argument information, one for; // each Protocol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TypeLoc.h:84,Protocol,Protocol,84,interpreter/llvm-project/clang/include/clang/AST/TypeLoc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TypeLoc.h,1,['Protocol'],['Protocol']
Integrability,// Space between the type and the * in:; // operator void*(); // operator char*(); // operator void const*(); // operator void volatile*(); // operator /*comment*/ const char*(); // operator volatile /*comment*/ char*(); // operator Foo*(); // operator C<T>*(); // operator std::Foo*(); // operator C<T>::D<U>*(); // dependent on PointerAlignment style.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:317,depend,dependent,317,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['depend'],['dependent']
Integrability,// Space for subclasses to store data.; // Note that this should be synchronized with; // MAX_INT_BITS value in IntegerType class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Type.h:68,synchroniz,synchronized,68,interpreter/llvm-project/llvm/include/llvm/IR/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Type.h,1,['synchroniz'],['synchronized']
Integrability,"// Sparc has no architectural need for stack realignment support,; // except that LLVM unfortunately currently implements overaligned; // stack objects by depending upon stack realignment support.; // If that ever changes, this can probably be deleted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp:155,depend,depending,155,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp,1,['depend'],['depending']
Integrability,// Special FieldNode descendants may wrap nullpointers (for example if they; // describe a special relationship between two elements of the fieldchain); // -- we wouldn't like to unique these objects.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h:37,wrap,wrap,37,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h,1,['wrap'],['wrap']
Integrability,"// Special case for ALLOCFRAME: even though there is dependency; // between ALLOCFRAME and subsequent store, allow it to be packetized; // in a same packet. This implies that the store is using the caller's; // SP. Hence, offset needs to be updated accordingly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:53,depend,dependency,53,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['depend'],['dependency']
Integrability,"// Special case messages to -performSelector and friends, which; // can return non-pointer values boxed in a pointer value.; // Some clients may wish to silence warnings in this subcase.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:16,message,messages,16,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['message'],['messages']
Integrability,// Special case the error message for the very common case where only; // a single subtarget feature is missing,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:26,message,message,26,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,1,['message'],['message']
Integrability,"// Special case the error message for the very common case where only; // a single subtarget feature is missing (neon, e.g.).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:26,message,message,26,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,1,['message'],['message']
Integrability,// Special cases for dependencies which vary depending on the base; // architecture version.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/AArch64TargetParser.cpp:21,depend,dependencies,21,interpreter/llvm-project/llvm/lib/TargetParser/AArch64TargetParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/AArch64TargetParser.cpp,2,['depend'],"['dependencies', 'depending']"
Integrability,"// Special handling of case without normalization set (used in numeric integration of pdfs)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:71,integrat,integration,71,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['integrat'],['integration']
Integrability,// Special processing for depend(source) clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:26,depend,depend,26,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,1,['depend'],['depend']
Integrability,"// Specializations of template template parameters are represented as; // TemplateSpecializationTypes, and substitution of type alias templates; // within a dependent context can transform them into; // DependentTemplateSpecializationTypes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:157,depend,dependent,157,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,"['Depend', 'depend']","['DependentTemplateSpecializationTypes', 'dependent']"
Integrability,// Splat the 8-bits of immediate 4 times to help the loop wrap around.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:58,wrap,wrap,58,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,4,['wrap'],['wrap']
Integrability,// Splats are represented differently depending on whether the repeated; // value is a constant or an Instruction,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:38,depend,depending,38,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,1,['depend'],['depending']
Integrability,// Splitting the loop will break dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:33,depend,dependence,33,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,1,['depend'],['dependence']
Integrability,"// Square braces in LK_Proto can either be message field attributes:; //; // optional Aaa aaa = 1 [; // (aaa) = aaa; // ];; //; // extensions 123 [; // (aaa) = aaa; // ];; //; // or text proto extensions (in options):; //; // option (Aaa.options) = {; // [type.type/type] {; // key: value; // }; // }; //; // or repeated fields (in options):; //; // option (Aaa.options) = {; // keys: [ 1, 2, 3 ]; // }; //; // In the first and the third case we want to spread the contents inside; // the square braces; in the second we want to keep them inline.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:43,message,message,43,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['message'],['message']
Integrability,"// Standard check: only the protocol part of 'path' is required to match",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TNetFile.cxx:28,protocol,protocol,28,net/net/src/TNetFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TNetFile.cxx,1,['protocol'],['protocol']
Integrability,// Start at UINT64_MAX so that the first index returned after an increment is; // zero (after the unsigned wrap).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp:107,wrap,wrap,107,interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,1,['wrap'],['wrap']
Integrability,// Start our sequence with a TA splat in the hopes that hardware is able to; // recognize there's no dependency on the prior value of our temporary; // register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:101,depend,dependency,101,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['depend'],['dependency']
Integrability,// Start searching for overridden methods using the method from the; // interface as starting point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:72,interface,interface,72,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,2,['interface'],['interface']
Integrability,"// Start the message loop. ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/win32/asview.cpp:13,message,message,13,graf2d/asimage/src/libAfterImage/win32/asview.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/win32/asview.cpp,1,['message'],['message']
Integrability,// Start the protocol definition,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:13,protocol,protocol,13,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['protocol'],['protocol']
Integrability,"// Start with full list of dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddHelpers.cxx:27,depend,dependents,27,roofit/roofitcore/src/RooAddHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddHelpers.cxx,1,['depend'],['dependents']
Integrability,// Start with the protocol qualifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:18,protocol,protocol,18,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,2,['protocol'],['protocol']
Integrability,// Starting from non-zero and stepping away from zero can never wrap back; // to zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:64,wrap,wrap,64,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['wrap'],['wrap']
Integrability,// Starting with DWARF V5 method declarations are emitted as children of; // the interface type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:81,interface,interface,81,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['interface'],['interface']
Integrability,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:1369,depend,dependent,1369,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,1,['depend'],['dependent']
Integrability,// Stash value of base pointer. Saving RSP instead of EBP shortens; // dependence chain. Used by SjLj EH.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:71,depend,dependence,71,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['depend'],['dependence']
Integrability,// Stash value of base pointer. Saving SP instead of FP shortens; // dependence chain. Used by SjLj EH.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:69,depend,dependence,69,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,1,['depend'],['dependence']
Integrability,// Statepoint intrinsic is vararg but the wrapped function may be not.; // Allow sret here and check the wrapped function in verifyStatepoint.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:42,wrap,wrapped,42,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,2,['wrap'],['wrapped']
Integrability,"// Static class's protocols, or its super class or category protocols; // must be found, direct or indirect in rhs's qualifier list or it is a mismatch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:18,protocol,protocols,18,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,2,['protocol'],['protocols']
Integrability,"// Statically check that the array bounds are in-range. The first subscript we; // don't have a size for and it cannot overflow into another subscript, so is; // always safe. The others need to be 0 <= subscript[i] < bound, for both src; // and dst.; // FIXME: It may be better to record these sizes and add them as constraints; // to the dependency checks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:339,depend,dependency,339,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['dependency']
Integrability,// Step 1: Find the non-local dependencies of the load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:30,depend,dependencies,30,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['depend'],['dependencies']
Integrability,"// Step 3: Eliminate fully redundancy.; //; // If all of the instructions we depend on produce a known value for this; // load, then it is fully redundant and we can use PHI insertion to compute; // its value. Insert PHIs and remove the fully redundant value now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:77,depend,depend,77,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['depend'],['depend']
Integrability,"// Step size has changed, so we cannot guarantee no self-wraparound.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:57,wrap,wraparound,57,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['wrap'],['wraparound']
Integrability,"// Sterilize the cache as certain partial results depend on buffer fraction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:50,depend,depend,50,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['depend'],['depend']
Integrability,"// Stmt; // Expr; // Packing Bits: DependenceKind, ValueKind, ObjectKind,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:35,Depend,DependenceKind,35,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,4,['Depend'],['DependenceKind']
Integrability,// Stmt; // Expr; // Packing Bits: DependenceKind. ValueKind and ObjectKind should; // be 0 in this case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:35,Depend,DependenceKind,35,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,2,['Depend'],['DependenceKind']
Integrability,"// Stmt; // Expr; // PackingBits: DependenceKind, ValueKind. ObjectKind should be 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:34,Depend,DependenceKind,34,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,1,['Depend'],['DependenceKind']
Integrability,"// Stop checking the precise nature of the argument if it is value dependent,; // it should be checked when instantiated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:67,depend,dependent,67,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,"// Stop here and fill this in later, depending on whether or not this; // subprogram turns out to have inlined instances or not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:37,depend,depending,37,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,1,['depend'],['depending']
Integrability,"// Stop if the normalized TemplateSpecializationType has less arguments than; // the one index is pointing at.; // We piggy back on the AddDefaultParameters routine basically.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:157,rout,routine,157,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['rout'],['routine']
Integrability,// Stop processing BB if it's the entry or is now deleted. The following; // routines attempt to eliminate BB and locating a suitable replacement; // for the entry is non-trivial.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:77,rout,routines,77,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['rout'],['routines']
Integrability,"// Storage for the parameter adapters. Since the base class erases the type; // of the parameters, we have to own the storage for the parameters here, and; // have the base class store type-erased pointers into this tuple.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadic.h:29,adapter,adapters,29,interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadic.h,1,['adapter'],['adapters']
Integrability,"// Store a copy of DependenceInfo in the graph, so that individual memory; // dependencies don't need to be stored. Instead when the dependence is; // queried it is recomputed using @DI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:19,Depend,DependenceInfo,19,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,3,"['Depend', 'depend']","['DependenceInfo', 'dependence', 'dependencies']"
Integrability,"// Store integration configuration in registry",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsAnaConvPdf.cxx:9,integrat,integration,9,roofit/roofitcore/src/RooAbsAnaConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsAnaConvPdf.cxx,1,['integrat'],['integration']
Integrability,"// Store set of variables analytically integrated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx:39,integrat,integrated,39,roofit/roofitcore/src/RooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx,1,['integrat'],['integrated']
Integrability,// Store the dependency kind,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:13,depend,dependency,13,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['depend'],['dependency']
Integrability,// Store the index value with offset in depend vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:40,depend,depend,40,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['depend'],['depend']
Integrability,// Stores depend on may/must aliased loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:10,depend,depend,10,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['depend'],['depend']
Integrability,"// Stores the last emitted coro.free for the deallocate expressions, we use it; // to wrap dealloc code with if(auto mem = coro.free) dealloc(mem).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:86,wrap,wrap,86,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,1,['wrap'],['wrap']
Integrability,// Stores whether we're taking the address of these candidates. This helps us; // produce better error messages when dealing with the pass_object_size; // attribute on parameters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:103,message,messages,103,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['message'],['messages']
Integrability,"// Strangely, non-type results are not ignored by this lookup, so the; // program is ill-formed if it finds an injected-class-name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:111,inject,injected-class-name,111,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['inject'],['injected-class-name']
Integrability,// Strategy for the default executor used by the parallel routines provided by; // this file. It defaults to using all hardware threads and should be; // initialized before the first use of parallel routines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h:58,rout,routines,58,interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Parallel.h,2,['rout'],['routines']
Integrability,// Strategy is a map from variables to the way we plan to emit fixes for; // these variables. It is figured out gradually by trying different fixes; // for different variables depending on gadgets in which these variables; // participate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:176,depend,depending,176,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['depend'],['depending']
Integrability,"// Strategy:; // We need to select two types of instruction, maximizing the available; // immediate range of each. The instructions we use will depend on whether; // DestReg and BaseReg are low, high or the stack pointer.; // * CopyOpc - DestReg = BaseReg + imm; // This will be emitted once if DestReg != BaseReg, and never if; // DestReg == BaseReg.; // * ExtraOpc - DestReg = DestReg + imm; // This will be emitted as many times as necessary to add the; // full immediate.; // If the immediate ranges of these instructions are not large enough to cover; // NumBytes with a reasonable number of instructions, we fall back to using a; // value loaded from a constant pool.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp:144,depend,depend,144,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,1,['depend'],['depend']
Integrability,"// Stream names must be exact matches, since they get looked up in a hash; // table and the hash value is dependent on the exact contents of the string.; // link.exe lowercases a path and converts / to \, so we must do the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFileBuilder.cpp:106,depend,dependent,106,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFileBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFileBuilder.cpp,1,['depend'],['dependent']
Integrability,"// StreamerElement injected by a TSchemaRule. Transient only to preserve forward compatibility.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TStreamerElement.h:19,inject,injected,19,core/meta/inc/TStreamerElement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TStreamerElement.h,1,['inject'],['injected']
Integrability,"// Strip any terms from params that do not depend on any term",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:43,depend,depend,43,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['depend'],['depend']
Integrability,"// Strip off __kindof and protocol qualifiers, then check whether; // we can assign the other way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:26,protocol,protocol,26,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,2,['protocol'],['protocol']
Integrability,// Strip out message sends to retain / release in GC mode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:13,message,message,13,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['message'],['message']
Integrability,"// Strong dependencies must be respected by the scheduler. Artificial; // dependencies may be removed only if they are redundant with another; // strong dependence.; //; // Weak dependencies may be violated by the scheduling strategy, but only if; // the strategy can prove it is correct to do so.; //; // Strong OrderKinds must occur before ""Weak"".; // Weak OrderKinds must occur after ""Weak"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:10,depend,dependencies,10,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,4,['depend'],"['dependence', 'dependencies']"
Integrability,"// Stub only, to fill out the python function interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx:46,interface,interface,46,bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,1,['interface'],['interface']
Integrability,"// Subclasses of SExpr must define the following:; //; // This(const This& E, ...) {; // copy constructor: construct copy of E, with some additional arguments.; // }; //; // template <class V>; // typename V::R_SExpr traverse(V &Vs, typename V::R_Ctx Ctx) {; // traverse all subexpressions, following the traversal/rewriter interface.; // }; //; // template <class C> typename C::CType compare(CType* E, C& Cmp) {; // compare all subexpressions, following the comparator interface; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h:324,interface,interface,324,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h,2,['interface'],['interface']
Integrability,"// Submodule order depends on order of header includes for inferred submodules; // we don't care about the exact order, so sort so that it's consistent across; // TUs to improve sharing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:19,depend,depends,19,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,1,['depend'],['depends']
Integrability,// Subscopes.; // The instruction at which to insert the CHR conditional branch (and hoist; // the dependent condition values).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:99,depend,dependent,99,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,1,['depend'],['dependent']
Integrability,// Subsequent checks require interface decl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:29,interface,interface,29,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['interface'],['interface']
Integrability,// Substitute auto in TypeWithAuto for a Dependent auto type,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:41,Depend,Dependent,41,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['Depend'],['Dependent']
Integrability,"// Substitute into the template parameter list of the template; // template parameter, since previously-supplied template arguments; // may appear within the template template parameter.; //; // FIXME: Skip this if the parameters aren't instantiation-dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:251,depend,dependent,251,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,// Substituting a dependent template name: preserve it as written.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TemplateName.cpp:18,depend,dependent,18,interpreter/llvm-project/clang/lib/AST/TemplateName.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TemplateName.cpp,1,['depend'],['dependent']
Integrability,"// Subtract Y from X so that it does not go through border of the IV; // iteration space. Mathematically, it is equivalent to:; //; // ClampedSubtract(X, Y) = min(max(X - Y, INT_MIN), INT_MAX). [1]; //; // In [1], 'X - Y' is a mathematical subtraction (result is not bounded to; // any width of bit grid). But after we take min/max, the result is; // guaranteed to be within [INT_MIN, INT_MAX].; //; // In [1], INT_MAX and INT_MIN are respectively signed and unsigned max/min; // values, depending on type of latch condition that defines IV iteration; // space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:488,depend,depending,488,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,1,['depend'],['depending']
Integrability,// Successors that are in a data dependency with this group.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:33,depend,dependency,33,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,1,['depend'],['dependency']
Integrability,// Successors that are in a order dependency with this group.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:34,depend,dependency,34,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,1,['depend'],['dependency']
Integrability,"// Suggest the (potentially) correct interface name. Don't provide a; // code-modification hint or use the typo name for recovery, because; // this is just a warning. The program may actually be correct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:37,interface,interface,37,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['interface'],['interface']
Integrability,"// Sum of the length of all control messages in the buffer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdconn.cxx:36,message,messages,36,net/rpdutils/src/rpdconn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdconn.cxx,1,['message'],['messages']
Integrability,// Support a single optional message only for Declspec and [[]] spellings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:29,message,message,29,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['message'],['message']
Integrability,"// Support interface for subclasses to advertise their analytic integration; // and generator capabilities in their analyticalIntegral() and generateEvent(); // implementations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:11,interface,interface,11,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,2,"['integrat', 'interface']","['integration', 'interface']"
Integrability,"// Supports only the scenario of integration over all dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooParamHistFunc.cxx:33,integrat,integration,33,roofit/roofit/src/RooParamHistFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooParamHistFunc.cxx,2,"['depend', 'integrat']","['dependents', 'integration']"
Integrability,"// Suppress ""2 errors generated"" or similar messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DumpTool/ClangSrcLocDump.cpp:44,message,messages,44,interpreter/llvm-project/clang/lib/Tooling/DumpTool/ClangSrcLocDump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DumpTool/ClangSrcLocDump.cpp,1,['message'],['messages']
Integrability,// Suppress the warning if the constructor is unresolved because; // its arguments are dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:87,depend,dependent,87,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['dependent']
Integrability,// Surface the protocols of the category to the interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp:15,protocol,protocols,15,interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/Serialization/SymbolGraphSerializer.cpp,4,"['interface', 'protocol']","['interface', 'protocols']"
Integrability,"// Swap all the anti dependences in the DAG. That means it is no longer a DAG,; // but we do this to find the circuits, and then change them back.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:21,depend,dependences,21,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['dependences']
Integrability,// Swap if needed. Depends on the condition code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:19,Depend,Depends,19,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['Depend'],['Depends']
Integrability,"// Swift calling convention does not require we copy the sret argument; // into %rax/%eax for the return, and SRetReturnReg is not set for Swift.; // All x86 ABIs require that for returning structs by value we copy; // the sret argument into %rax/%eax (depending on ABI) for the return.; // We saved the argument into a virtual register in the entry block,; // so now we copy the value out and into %rax/%eax.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:253,depend,depending,253,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,1,['depend'],['depending']
Integrability,"// Swift calling convention does not require we copy the sret argument; // into %rax/%eax for the return, and SRetReturnReg is not set for Swift.; // All x86 ABIs require that for returning structs by value we copy; // the sret argument into %rax/%eax (depending on ABI) for the return.; // We saved the argument into a virtual register in the entry block,; // so now we copy the value out and into %rax/%eax.; //; // Checking Function.hasStructRetAttr() here is insufficient because the IR; // may not have an explicit sret argument. If FuncInfo.CanLowerReturn is; // false, then an sret argument may be implicitly inserted in the SelDAG. In; // either case FuncInfo->setSRetReturnReg() will have been called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:253,depend,depending,253,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['depend'],['depending']
Integrability,"// SwitchToNewBasicBlock - This method is used to jump to a new basic block.; // This function handles the actual updating of block and instruction iterators; // as well as execution of all of the PHI nodes in the destination block.; //; // This method does this because all of the PHI nodes must be executed; // atomically, reading their inputs before any of the results are updated. Not; // doing this can cause problems if the PHI nodes depend on other PHI nodes for; // their inputs. If the input PHI node is updated before it is read, incorrect; // results can happen. Thus we use a two phase approach.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp:440,depend,depend,440,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,1,['depend'],['depend']
Integrability,// Symbol name dependencies:; // Internal: Defined in this graph.; // External: Defined externally.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp:15,depend,dependencies,15,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ObjectLinkingLayer.cpp,1,['depend'],['dependencies']
Integrability,// Symbol value; storage class-dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h:31,depend,dependent,31,interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,3,['depend'],['dependent']
Integrability,"// SymbolsBeforeStripping[i] is the original form of Symbols[i] before; // stripping pointer casts, i.e.,; // Symbols[i] == SymbolsBeforeStripping[i]->stripPointerCasts().; //; // We need to keep these values because AggBuffer::print decides whether to; // emit a ""generic()"" cast for Symbols[i] depending on the address space of; // SymbolsBeforeStripping[i].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h:296,depend,depending,296,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,1,['depend'],['depending']
Integrability,// Synchronization scope names are implicitly mapped to synchronization; // scope IDs by their order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:3,Synchroniz,Synchronization,3,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,2,"['Synchroniz', 'synchroniz']","['Synchronization', 'synchronization']"
Integrability,"// Synchronize MINUIT with function state",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsMinimizerFcn.cxx:3,Synchroniz,Synchronize,3,roofit/roofitcore/src/RooAbsMinimizerFcn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsMinimizerFcn.cxx,1,['Synchroniz'],['Synchronize']
Integrability,// Synchronize added file systems by duplicating the working directory from; // the first one in the list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp:3,Synchroniz,Synchronize,3,interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,1,['Synchroniz'],['Synchronize']
Integrability,// Synchronize the ABI Flags information with the FeatureBits information we; // updated above.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Synchroniz,Synchronize,3,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,9,['Synchroniz'],['Synchronize']
Integrability,// Synchronize the abiflags information with the FeatureBits information we; // changed above.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3,Synchroniz,Synchronize,3,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,3,['Synchroniz'],['Synchronize']
Integrability,"// Synchronize the responses",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/netxng/src/TNetXNGFile.cxx:3,Synchroniz,Synchronize,3,net/netxng/src/TNetXNGFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/netxng/src/TNetXNGFile.cxx,1,['Synchroniz'],['Synchronize']
Integrability,"// Synthesize a loop or unroll it, depending on the number of iterations.; // BuildStackAlignAND ensures that only MaxAlign % StackProbeSize bits left; // between the unaligned rsp and current rsp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:35,depend,depending,35,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['depend'],['depending']
Integrability,"// T is canonical. We can also ignore dependent types because; // we don't need to do ADL at the definition point, but if we; // wanted to implement template export (or if we find some other; // use for associated classes and namespaces...) this would be; // wrong.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:38,depend,dependent,38,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['depend'],['dependent']
Integrability,"// TClassEdit is used to manipulate class and type names.; //; // This class does not dependent on any other ROOT facility; // so that it can be used by rootcint.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/TClassEdit.h:86,depend,dependent,86,core/foundation/inc/TClassEdit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/TClassEdit.h,1,['depend'],['dependent']
Integrability,"// TEveVectorF wrappers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveTrackPropagator.h:15,wrap,wrappers,15,graf3d/eve/inc/TEveTrackPropagator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveTrackPropagator.h,1,['wrap'],['wrappers']
Integrability,"// TFile interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/davix/inc/TDavixFile.h:9,interface,interface,9,net/davix/inc/TDavixFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/davix/inc/TDavixFile.h,1,['interface'],['interface']
Integrability,"// TIter encapsulates the actual class iterator. The type of iterator; // used depends on the type of the collection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/tcollex.cxx:79,depend,depends,79,test/tcollex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/tcollex.cxx,1,['depend'],['depends']
Integrability,"// TJSONNode interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/jsoninterface/src/JSONParser.cxx:13,interface,interface,13,roofit/jsoninterface/src/JSONParser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/jsoninterface/src/JSONParser.cxx,1,['interface'],['interface']
Integrability,"// TMacro wrapper (attempting to fix issues with different macro loading and execution schemes).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveMacro.h:10,wrap,wrapper,10,graf3d/eve/inc/TEveMacro.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveMacro.h,1,['wrap'],['wrapper']
Integrability,"// TNetFile via TNetXNGFile: receive client protocol; // read first next 12 bytes and discard them",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:44,protocol,protocol,44,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['protocol'],['protocol']
Integrability,"// TODO - If we want to chain more than two instructions, we need to create; // artifical edges to make dependencies from the FirstSU also dependent; // on other chained instructions, and other chained instructions also; // dependent on the dependencies of the SecondSU, to prevent them from being; // scheduled into these chained instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp:104,depend,dependencies,104,interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MacroFusion.cpp,4,['depend'],"['dependencies', 'dependent']"
Integrability,// TODO : get a better message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:23,message,message,23,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['message'],['message']
Integrability,// TODO Include more functions or consider checking with mangled prefixes; // The reason we include malloc/free here is to exclude the malloc/free; // calls generated in setjmp prep / cleanup routines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:192,rout,routines,192,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,1,['rout'],['routines']
Integrability,"// TODO Test a batch fit that uses categories once categories can be passed through the batch interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/vectorisedPDFs/testGaussBinned.cxx:94,interface,interface,94,roofit/roofit/test/vectorisedPDFs/testGaussBinned.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/vectorisedPDFs/testGaussBinned.cxx,1,['interface'],['interface']
Integrability,// TODO remove this method from FixableGadget interface,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:46,interface,interface,46,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['interface'],['interface']
Integrability,"// TODO to fix up jump table so later phase won't be confused. if; // (jumpTableInfo->isEmpty() == false) { need to clean the jump table, but; // there isn't such an interface yet. alternatively, replace all the other; // blocks in the jump table with the entryBlk //}",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp:166,interface,interface,166,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp,1,['interface'],['interface']
Integrability,"// TODO(jblomer): can be templated depending on the factory method / constructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx:35,depend,depending,35,tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,1,['depend'],['depending']
Integrability,"// TODO(jblomer): wrap in an std::variant with C++17; /// For updating existing files and for storing more than just an RNTuple in the file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx:18,wrap,wrap,18,tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,1,['wrap'],['wrap']
Integrability,// TODO: 'loop' may require additional parameters depending on the binding.; // Treat similar to OMPD_simd/OMPD_for for now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:50,depend,depending,50,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['depend'],['depending']
Integrability,// TODO: 'loop' may require different capture regions depending on the bind; // clause or the parent directive when there is no bind clause. Use; // OMPD_unknown for now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/OpenMPKinds.cpp:54,depend,depending,54,interpreter/llvm-project/clang/lib/Basic/OpenMPKinds.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/OpenMPKinds.cpp,1,['depend'],['depending']
Integrability,// TODO: Add a better heuristic to select the loop to be interchanged based; // on the dependence matrix. Currently we select the innermost loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:87,depend,dependence,87,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,1,['depend'],['dependence']
Integrability,// TODO: Add more target-dependent nodes later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:25,depend,dependent,25,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['depend'],['dependent']
Integrability,// TODO: Add move constructor and operator= when a testable situation arises.; /// Returns a single error that contains messages for all stored Errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h:120,message,messages,120,interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ifs/ErrorCollector.h,1,['message'],['messages']
Integrability,// TODO: Add support for the slightly common *Matching(table) idiom.; // Cf. IOService::nameMatching() etc. - these function have an unusual; // contract of returning at +0 or +1 depending on their last argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:145,contract,contract,145,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,2,"['contract', 'depend']","['contract', 'depending']"
Integrability,"// TODO: Adjust states of args to constructors in the same way that arguments to; // function calls are handled.; // TODO: Use information from tests in for- and while-loop conditional.; // TODO: Add notes about the actual and expected state for; // TODO: Correctly identify unreachable blocks when chaining boolean operators.; // TODO: Adjust the parser and AttributesList class to support lists of; // identifiers.; // TODO: Warn about unreachable code.; // TODO: Switch to using a bitmap to track unreachable blocks.; // TODO: Handle variable definitions, e.g. bool valid = x.isValid();; // if (valid) ...; (Deferred); // TODO: Take notes on state transitions to provide better warning messages.; // (Deferred); // TODO: Test nested conditionals: A) Checking the same value multiple times,; // and 2) Checking different values. (Deferred)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp:689,message,messages,689,interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp,1,['message'],['messages']
Integrability,"// TODO: As the result is sign-extended, this is conservatively correct. A; // more precise answer could be calculated for SRAW depending on known; // bits in the shift amount.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:128,depend,depending,128,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['depend'],['depending']
Integrability,// TODO: Ask TTI whether synchronization scope is between threads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:25,synchroniz,synchronization,25,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,1,['synchroniz'],['synchronization']
Integrability,// TODO: Attribute new colors depending on color; // combination of children.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:30,depend,depending,30,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['depend'],['depending']
Integrability,"// TODO: Bring all mouse handling into camera classes - would simplify interface and; // remove these non-generic cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLPerspectiveCamera.cxx:71,interface,interface,71,graf3d/gl/src/TGLPerspectiveCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLPerspectiveCamera.cxx,1,['interface'],['interface']
Integrability,"// TODO: Build a wrapper around the expression to avoid decompilation and; // compilation and other string operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx:17,wrap,wrapper,17,core/metacling/src/TClingCallFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx,1,['wrap'],['wrapper']
Integrability,// TODO: Can we actually use the dependence info analysis here?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:33,depend,dependence,33,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['depend'],['dependence']
Integrability,"// TODO: Change the interface to allow single CIs expanded, e.g, to; // include an outer loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:20,interface,interface,20,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['interface'],['interface']
Integrability,"// TODO: Check with Wouter why he uses copyCache in MPFE; makes it very difficult to extend, because; // copyCache is protected (so must be friend). Moved setting value to if-block below.; // _saveVars[ix].copyCache(&_vars[ix]);; // send message to queue (which will relay to workers)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/LikelihoodJob.cxx:238,message,message,238,roofit/roofitcore/src/TestStatistics/LikelihoodJob.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/LikelihoodJob.cxx,1,['message'],['message']
Integrability,// TODO: Clean detach message?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp:22,message,message,22,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp,1,['message'],['message']
Integrability,// TODO: Copied from not. Should have a wrapper around setenv.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/llvm-reduce.cpp:40,wrap,wrapper,40,interpreter/llvm-project/llvm/tools/llvm-reduce/llvm-reduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/llvm-reduce.cpp,1,['wrap'],['wrapper']
Integrability,"// TODO: Could inject an invalid typedef decl in an enclosing scope to; // avoid rippling error messages on subsequent uses of the same type,; // could be useful if #include was forgotten.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:15,inject,inject,15,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,"['inject', 'message']","['inject', 'messages']"
Integrability,// TODO: Deprecate V0 once V1 is fully integrated downstream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp:39,integrat,integrated,39,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,1,['integrat'],['integrated']
Integrability,"// TODO: Document how data pointer is determined using STL iterator interface.; // TODO: Sanitize given container type with type traits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RTensor.hxx:68,interface,interface,68,tmva/tmva/inc/TMVA/RTensor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RTensor.hxx,1,['interface'],['interface']
Integrability,"// TODO: Figure out a way to avoid passing in wrong source locations; // of the symbol being replaced. This is important when we calculate the; // size of the memory buffers and may lead to creation of wrong wrappers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp:208,wrap,wrappers,208,interpreter/cling/lib/Interpreter/DynamicLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp,1,['wrap'],['wrappers']
Integrability,"// TODO: For fully linked images, look through the external relocation; // entries off the dynamic symtab command. For these the r_offset is from the; // start of the first writeable segment in the Mach-O file. So the offset; // to this section from that segment is passed to this routine by the caller,; // as the database_offset. Which is the difference of the section's starting; // address and the first writable segment.; //; // NOTE: need add passing the database_offset to this routine.; // We did not find an external relocation entry so look up the ReferenceValue; // as an address of a symbol and if found return that symbol's name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp:281,rout,routine,281,interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/MachODump.cpp,2,['rout'],['routine']
Integrability,"// TODO: Handle ""@@@"". Depending on SymbolAttribute value it needs to be; // converted into @ or @@.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/RecordStreamer.cpp:23,Depend,Depending,23,interpreter/llvm-project/llvm/lib/Object/RecordStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/RecordStreamer.cpp,1,['Depend'],['Depending']
Integrability,"// TODO: Ideally this would be controlled automatically by detecting that we; // are linking with an allocator that supports these interfaces, rather than; // an internal option (which would still be needed for tests, however). For; // example, if the library exported a symbol like __malloc_hot_cold the linker; // could recognize that and set a flag in the lto::Config.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:131,interface,interfaces,131,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['interface'],['interfaces']
Integrability,"// TODO: If either operand is a single element and the multiply is known to; // be non-wrapping, round the result min and max value to the appropriate; // multiple of that element. If wrapping is possible, at least adjust the; // range according to the greatest power-of-two factor of the single element.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:87,wrap,wrapping,87,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,2,['wrap'],['wrapping']
Integrability,"// TODO: If/when other types of memprof cloning are enabled beyond just for; // hot and cold, we will need to change this to individually control the; // AllocationType passed to addStackNodesForMIB during CCG construction.; // Note that we specifically check this after applying imports above, so that; // the option isn't needed to be passed to distributed ThinLTO backend; // clang processes, which won't necessarily have visibility into the linker; // dependences. Instead the information is communicated from the LTO link to; // the backends via the combined summary index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:456,depend,dependences,456,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['depend'],['dependences']
Integrability,"// TODO: In fact, cost of unswitching a new invariant candidate is *slightly*; // higher because we have just inserted a new block. Need to think how to; // adjust the cost of injected candidates when it was first computed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:176,inject,injected,176,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['inject'],['injected']
Integrability,"// TODO: Make this interface user-friendly.; // The interface here is bad, and we'll want to change this in the future. We; // probably will want to build out these mask vectors as vectors of bools and; // have this utility object convert them to the bit masks. I don't want to; // over-engineer this API now since we don't know what the data coming in to; // feed it will look like, so I kept it extremely simple for the immediate use; // case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/DXContainerPSVInfo.h:19,interface,interface,19,interpreter/llvm-project/llvm/include/llvm/MC/DXContainerPSVInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/DXContainerPSVInfo.h,2,['interface'],['interface']
Integrability,// TODO: Move this right after structurizeCFG to avoid extra divergence; // analysis. This depends on stopping SIAnnotateControlFlow from making; // control flow modifications.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:91,depend,depends,91,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,1,['depend'],['depends']
Integrability,// TODO: Need to support taskwait with dependences in the OpenMPIRBuilder.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:39,depend,dependences,39,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['depend'],['dependences']
Integrability,// TODO: Refine to approxFunc or contract,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp:33,contract,contract,33,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,1,['contract'],['contract']
Integrability,// TODO: Remember a few examples of generated messages; // and display them in the ExplodedGraph dump by; // returning them from this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h:46,message,messages,46,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,1,['message'],['messages']
Integrability,// TODO: Report module maps the same way it's done for modular dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:63,depend,dependencies,63,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,1,['depend'],['dependencies']
Integrability,// TODO: Report the error message properly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h:26,message,message,26,interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFObjectFile.h,3,['message'],['message']
Integrability,// TODO: Rework this interface to be more generic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/Utility.cpp:21,interface,interface,21,interpreter/llvm-project/llvm/lib/Frontend/Offloading/Utility.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/Offloading/Utility.cpp,1,['interface'],['interface']
Integrability,"// TODO: SelectionDAG has several alternative expansions to port which may; // be more reasonble depending on the available instructions. If a target; // has sitofp, does not have CTLZ, or can efficiently use f64 as an; // intermediate type, this is probably worse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:97,depend,depending,97,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['depend'],['depending']
Integrability,// TODO: Sema shouldn't depend on Lex,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:24,depend,depend,24,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['depend'],['depend']
Integrability,"// TODO: Should verify number of def and use operands, but the current; // interface requires passing in IR types for mangling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:75,interface,interface,75,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,1,['interface'],['interface']
Integrability,"// TODO: Some member pointers are `noundef`, but it depends on the ABI. For; // now, never mark them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:52,depend,depends,52,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['depend'],['depends']
Integrability,// TODO: The diagnostic messages where Addr may be 0 should be fixed; // since it cannot differentiate the situation where 0 denotes the default; // address space or user specified __attribute__((address_space(0))).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:24,message,messages,24,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['message'],['messages']
Integrability,"// TODO: These draw routines should take LOD hints",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h:20,rout,routines,20,graf3d/gl/inc/TGLUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h,1,['rout'],['routines']
Integrability,"// TODO: Think about honoring RNTupleWriteOptions::SetUseBufferedWrite(false); this requires synchronization on every; // call to CommitPage() *and* preparing multiple cluster descriptors in parallel!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleParallelWriter.cxx:93,synchroniz,synchronization,93,tree/ntuple/v7/src/RNTupleParallelWriter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleParallelWriter.cxx,1,['synchroniz'],['synchronization']
Integrability,"// TODO: This check for stride values other than 1 and -1 can be eliminated.; // However, doing so may cause the LoopAccessAnalysis to overcompensate,; // generating numerous non-wrap runtime checks that may undermine the; // benefits of load elimination. To safely implement support for non-unit; // strides, we would need to ensure either that the processed case does not; // require these additional checks, or improve the LAA to handle them more; // efficiently, or potentially both.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:179,wrap,wrap,179,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,1,['wrap'],['wrap']
Integrability,"// TODO: This is experimental and in particular, we do not model; // the live range splitting done by spilling correctly.; // We would need a deep integration with the spiller to do the; // right thing here. Anyway, that is still good for early testing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:147,integrat,integration,147,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,1,['integrat'],['integration']
Integrability,"// TODO: This is the same as the MachineOutliner, and should be consolidated; // into the same interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:95,interface,interface,95,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,3,['interface'],['interface']
Integrability,"// TODO: This needs to be locked, but the lock cannot be placed in TClingUtils.cxx as it cannot depend from; // TInterpreter.h for the declaration of gInterpreterMutex. Or can it?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingTypeInfo.cxx:96,depend,depend,96,core/metacling/src/TClingTypeInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingTypeInfo.cxx,3,['depend'],['depend']
Integrability,// TODO: This operation is expansive. If it ever gets called multiple times we; // may think of making a class wrapper with internal states for it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/CallContext.h:111,wrap,wrapper,111,interpreter/llvm-project/llvm/tools/llvm-profgen/CallContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/CallContext.h,1,['wrap'],['wrapper']
Integrability,// TODO: This routine may be simplified if MD_prof used an enum instead of a; // string to differentiate the types of MD_prof nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ProfDataUtils.cpp:14,rout,routine,14,interpreter/llvm-project/llvm/lib/IR/ProfDataUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ProfDataUtils.cpp,1,['rout'],['routine']
Integrability,"// TODO: To support shrink wrapping, this would need to copy; // PrologEpilogInserter's updateLiveness.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerSGPRSpills.cpp:27,wrap,wrapping,27,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerSGPRSpills.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerSGPRSpills.cpp,1,['wrap'],['wrapping']
Integrability,// TODO: Value profiling heavily depends on the data section which is omitted; // in lightweight mode. We need to move the value profile pointer to the; // Counter struct to get this working.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:33,depend,depends,33,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,1,['depend'],['depends']
Integrability,"// TODO: We can handle other cases here; // 1) For GC languages, arguments to functions are often required to be; // base pointers.; // 2) Result of allocation routines are often base pointers. Leverage TLI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:160,rout,routines,160,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['rout'],['routines']
Integrability,"// TODO: We could also reduce to 16 bits, but that's more target-dependent.; // Some targets like it, some don't, some only like it under certain; // conditions/processor versions, etc.; // A TL hook might be needed for this.; // Don't combine",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:65,depend,dependent,65,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['depend'],['dependent']
Integrability,// TODO: We could consider sorting the dependency arrays within the; // AnalysisUsage (since they are conceptually unordered).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h:39,depend,dependency,39,interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,1,['depend'],['dependency']
Integrability,// TODO: We might want to propagate the precise error message here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp:54,message,message,54,interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/ValueList.cpp,1,['message'],['message']
Integrability,// TODO: We might want to return a different type here (ex: id (*ty)(...)); // depending on how it is used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h:79,depend,depending,79,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h,1,['depend'],['depending']
Integrability,// TODO: We need to pass in the full target-id and handle it properly in the; // linker wrapper.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:88,wrap,wrapper,88,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['wrap'],['wrapper']
Integrability,"// TODO: We probably need to verify synchronization is not an issue, e.g.,; // there is no race by not copying a constant byval.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:36,synchroniz,synchronization,36,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['synchroniz'],['synchronization']
Integrability,// TODO: Would be useful to have an iterator based version; // of the load command interface too.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/MachO.h:83,interface,interface,83,interpreter/llvm-project/llvm/include/llvm/Object/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/MachO.h,1,['interface'],['interface']
Integrability,// TODO: add additional info to integrated assembler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp:32,integrat,integrated,32,interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,1,['integrat'],['integrated']
Integrability,// TODO: add bridgeOS & driverKit once in llvm::Triple,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TextAPI/Platform.cpp:13,bridg,bridgeOS,13,interpreter/llvm-project/llvm/lib/TextAPI/Platform.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TextAPI/Platform.cpp,1,['bridg'],['bridgeOS']
Integrability,"// TODO: add no-alias but make sure it doesn't break synchronization by; // introducing fake uses. See:; // [1] Compiler Optimizations for OpenMP, J. Doerfert and H. Finkel,; // International Workshop on OpenMP 2018,; // http://compilers.cs.uni-saarland.de/people/doerfert/par_opt18.pdf",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:53,synchroniz,synchronization,53,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['synchroniz'],['synchronization']
Integrability,// TODO: add this namespace once everyone is switched to using the new; // interface.; // namespace detail {; //===----------------------------------------------------------------------===//; // isa_impl; //===----------------------------------------------------------------------===//; // The core of the implementation of isa<X> is here; To and From should be; // the names of classes. This template can be specialized to customize the; // implementation of isa<> without rewriting it from scratch.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h:75,interface,interface,75,interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,1,['interface'],['interface']
Integrability,// TODO: describe return value as depending on one or more of its arguments.; // StackSafetyDataFlowAnalysis counter stored here for faster access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:34,depend,depending,34,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,1,['depend'],['depending']
Integrability,"// TODO: handle conditional operators here; // For calls and message sends, use the retained-call logic.; // Delegate inits are a special case in that they're the only; // returns-retained expression that *isn't* surrounded by; // a consume.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:61,message,message,61,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['message'],['message']
Integrability,// TODO: ideally we should still be able to generate memset if SCEV expander; // is taught to generate the dependencies at the latest point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:107,depend,dependencies,107,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,2,['depend'],['dependencies']
Integrability,"// TODO: merge these two routines. For the moment, we display the best; // result obtained by *either* implementation. This is a bit unfair since no; // caller actually gets the full power at the moment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:25,rout,routines,25,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,1,['rout'],['routines']
Integrability,"// TODO: move ParsingClassDefinition here.; // TODO: move TentativeParsingAction here.; /// A RAII object used to temporarily suppress access-like; /// checking. Access-like checks are those associated with; /// controlling the use of a declaration, like C++ access control; /// errors and deprecation warnings. They are contextually; /// dependent, in that they can only be resolved with full; /// information about what's being declared. They are also; /// suppressed in certain contexts, like the template arguments of; /// an explicit instantiation. However, those suppression contexts; /// cannot necessarily be fully determined in advance; for; /// example, something starting like this:; /// template <> class std::vector<A::PrivateType>; /// might be the entirety of an explicit instantiation:; /// template <> class std::vector<A::PrivateType>;; /// or just an elaborated type specifier:; /// template <> class std::vector<A::PrivateType> make_vector<>();; /// Therefore this class collects all the diagnostics and permits; /// them to be re-delayed in a new context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/RAIIObjectsForParser.h:339,depend,dependent,339,interpreter/llvm-project/clang/include/clang/Parse/RAIIObjectsForParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/RAIIObjectsForParser.h,1,['depend'],['dependent']
Integrability,"// TODO: only used in pythonizations to add Python-side overloads to existing; // C++ overloads, but may be better off integrated with Pythonize.cxx callbacks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx:119,integrat,integrated,119,bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,1,['integrat'],['integrated']
Integrability,"// TODO: propagate this error to caller w/o use of Python C-API; /*; PyErr_Format(PyExc_RuntimeError, ""could not resolve %s::%s(%s)"",; const_cast<TClassRef&>(klass).GetClassName(),; wrap.fName, callString.c_str()); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:182,wrap,wrap,182,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['wrap'],['wrap']
Integrability,// TODO: see also imagemagick's C++ interface for RColor operations!; // https://www.imagemagick.org/api/magick++-classes.php; /** \class RColor; \ingroup GpadROOT7; \brief The color class; \author Axel Naumann <axel@cern.ch>; \author Sergey Linev <S.Linev@gsi.de>; \date 2017-09-26; \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome!; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RColor.hxx:36,interface,interface,36,graf2d/gpadv7/inc/ROOT/RColor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RColor.hxx,1,['interface'],['interface']
Integrability,"// TODO: the following routine coerce the metadata contents into constants; // or MDStrings before comparison.; // It ignores any other cases, so that the metadata nodes are considered; // equal even though this is not correct.; // We should structurally compare the metadata nodes to be perfect here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:23,rout,routine,23,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,1,['rout'],['routine']
Integrability,"// TODO: there can be many reasons a loop is not considered a; // candidate, so we should let isHardwareLoopCandidate fill in the; // reason and then report a better message here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:166,message,message,166,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,1,['message'],['message']
Integrability,// TODO: unify the error message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp:25,message,message,25,interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp,1,['message'],['message']
Integrability,"// TODO: verify in parallel:; // - dataset = GetDataSet(uri); // - TList flist; TDataSetManager::ScanDataSet(dataset, ..., &flist); // - fPlayer->Process( ... flist ...) // needs to be developed; // - dataset->Integrate(flist) (perhaps automatic; flist object owned by dataset); // - RegisterDataSet(uri, dataset, ""OT"")",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:210,Integrat,Integrate,210,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['Integrat'],['Integrate']
Integrability,"// TODO: we need to factor out the routine for the branch alone...; // Maybe a cache for the names?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RRootDS.cxx:35,rout,routine,35,tree/dataframe/src/RRootDS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RRootDS.cxx,1,['rout'],['routine']
Integrability,"// TODO:; // - add an TGFrame::HandleDNDStatus event handler?; // - implement INCR protocol; // - cache several requests?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGDNDManager.cxx:83,protocol,protocol,83,gui/gui/src/TGDNDManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGDNDManager.cxx,1,['protocol'],['protocol']
Integrability,"// TODO:; // - implement ""custom"" colors.; // - optimize the code, specially the one handling the fColormap image; // and dithering in pseudo-color modes; remove duplicated code.; // - improve the color allocation routine.; // - use a buffering pixmap for the fColormap image.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGColorDialog.cxx:214,rout,routine,214,gui/gui/src/TGColorDialog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGColorDialog.cxx,1,['rout'],['routine']
Integrability,"// TROOT sets the error ignore level handler, the system error message handler, and the error abort handler on; // construction such that the ""Root.ErrorIgnoreLevel"" environment variable is used for the ignore level; // and gSystem is used to generate a stack trace on abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/TError.h:63,message,message,63,core/foundation/inc/TError.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/TError.h,1,['message'],['message']
Integrability,"// TTabCom adapter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/Getline.cxx:11,adapter,adapter,11,core/textinput/src/Getline.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/Getline.cxx,1,['adapter'],['adapter']
Integrability,"// TVirtualViewer3D interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLScenePad.h:20,interface,interface,20,graf3d/gl/inc/TGLScenePad.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLScenePad.h,2,['interface'],['interface']
Integrability,"// TVirtualViewer3D interface ... mostly a facade; // Forward to TGLScenePad",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLViewer.h:20,interface,interface,20,graf3d/gl/inc/TGLViewer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLViewer.h,1,['interface'],['interface']
Integrability,// TW <object name> # Thread-local wrapper,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h:35,wrap,wrapper,35,interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h,1,['wrap'],['wrapper']
Integrability,"// Tab completion handler / TTabCom adapter; // Config values:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/Getline.cxx:36,adapter,adapter,36,core/textinput/src/Getline.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/Getline.cxx,1,['adapter'],['adapter']
Integrability,"// Table that maps Darwin's Mach-O stab constants to strings to allow printing.; // llvm-nm has very similar code, the strings used here are however slightly; // different and part of the interface of dsymutil (some project's build-systems; // parse the ouptut of dsymutil -s), thus they shouldn't be changed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:188,interface,interface,188,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,1,['interface'],['interface']
Integrability,"// Tail folding is not supported for outer loops, so the induction increment; // is guaranteed to not wrap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:102,wrap,wrap,102,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['wrap'],['wrap']
Integrability,// Tailor the diagnostics for the common case where a readwrite; // property is declared both in the @interface and the continuation.; // This is a common error where the user often intended the original; // declaration to be readonly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:102,interface,interface,102,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['interface'],['interface']
Integrability,// Take care of wrap-arounds,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:16,wrap,wrap-arounds,16,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['wrap'],['wrap-arounds']
Integrability,"// Take list of normalization, integrated dependents from factorization algorithm",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:31,integrat,integrated,31,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,2,"['depend', 'integrat']","['dependents', 'integrated']"
Integrability,"// Take out all non-dependents of function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:20,depend,dependents,20,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['depend'],['dependents']
Integrability,"// Take out data-projected dependens from projectedVars",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:27,depend,dependens,27,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['depend'],['dependens']
Integrability,"// Take out data-projected dependents from projectedVars",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:27,depend,dependents,27,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['depend'],['dependents']
Integrability,// Take type- and value- dependency from the active branch. Propagate all; // other flags from all branches.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:25,depend,dependency,25,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,1,['depend'],['dependency']
Integrability,"// Takes a key being looked up in the map and wraps it into a; // ValueMapCallbackVH, the actual key type of the map. We use a helper; // function because ValueMapCVH is constructed with a second parameter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ValueMap.h:46,wrap,wraps,46,interpreter/llvm-project/llvm/include/llvm/IR/ValueMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ValueMap.h,1,['wrap'],['wraps']
Integrability,"// Target may not be determinable yet, for instance if this is a dependent; // call in an uninstantiated template.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:65,depend,dependent,65,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['depend'],['dependent']
Integrability,"// Target type does derive from source type. Now we're serious. If an error; // appears now, it's not ignored.; // This may not be entirely in line with the standard. Take for example:; // struct A {};; // struct B : virtual A {; // B(A&);; // };; //; // void f(); // {; // (void)static_cast<const B&>(*((A*)0));; // }; // As far as the standard is concerned, p5 does not apply (A is virtual), so; // p2 should be used instead - ""const B& t(*((A*)0));"" is perfectly valid.; // However, both GCC and Comeau reject this example, and accepting it would; // mean more complex code if we're to preserve the nice error message.; // FIXME: Being 100% compliant here would be nice to have.; // Must preserve cv, as always, unless we're in C-style mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:613,message,message,613,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,1,['message'],['message']
Integrability,"// Target-specific (either 4, 5 or gnu depending on triple).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:39,depend,depending,39,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,1,['depend'],['depending']
Integrability,"// Target-specific (either soft or hard depending on triple, etc).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:40,depend,depending,40,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,1,['depend'],['depending']
Integrability,// TargetObjectWriter wrappers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp:22,wrap,wrappers,22,interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp,1,['wrap'],['wrappers']
Integrability,"// TargetSelect.h moved to a different directory between LLVM 2.9 and 3.0,; // and if the old one gets included then MCAsmInfo will be NULL and; // we'll crash later.; // Provide the user with a useful error message about what's wrong.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:208,message,message,208,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,1,['message'],['message']
Integrability,"// Targets can define their own custom Views that exist within their; // /lib/Target/ directory so that the View can utilize their CustomBehaviour; // or other backend symbols / functionality that are not already exposed; // through one of the MC-layer classes. These Views will be initialized; // using the CustomBehaviour::getViews() variants.; // If a target makes a custom View that does not depend on their target; // CB or their backend, they should put the View within; // /tools/llvm-mca/Views/ instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:396,depend,depend,396,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,1,['depend'],['depend']
Integrability,"// Technical note:; //; // Most of these functions are identical, converting to Quaternions; // and then taking the simple distance between two Quaternions. This; // makes it tempting to use a template function (which could appear in; // each individual rotation header).; //; // However, then we would have to include Quaternion.h in this header,; // and by induction, each rotation class would depend on Quaternion, which; // would be undesirable.; // ----------------------------------------------------------------------; // Distance from Rotation3D",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/3DDistances.h:396,depend,depend,396,math/genvector/inc/Math/GenVector/3DDistances.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/3DDistances.h,1,['depend'],['depend']
Integrability,// Technically -Wformat-nonliteral does not warn about this case.; // The behavior of printf and friends in this case is implementation; // dependent. Ideally if the format string cannot be null then; // it should have a 'nonnull' attribute in the function prototype.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:140,depend,dependent,140,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['depend'],['dependent']
Integrability,"// Technically, due to ELF symbol interposition semantics, we can't change the; // alignment or size of symbols. If we increase the alignment or size of a; // symbol, the compiler may make optimisations based on this new alignment or; // size. If the symbol is interposed, this optimisation could lead to; // alignment-related or OOB read/write crashes.; //; // This is handled in the linker. When the linker sees multiple declarations of; // a global variable, and some are tagged, and some are untagged, it resolves it; // to be an untagged definition - but preserves the tag-granule-rounded size and; // tag-granule-alignment. This should prevent these kind of crashes intra-DSO.; // For cross-DSO, it's been a reasonable contract that if you're interposing a; // sanitizer-instrumented global, then the interposer also needs to be; // sanitizer-instrumented.; //; // FIXME: In theory, this can be fixed by splitting the size/alignment of; // globals into two uses: an ""output alignment"" that's emitted to the ELF file,; // and an ""optimisation alignment"" that's used for optimisation. Thus, we could; // adjust the output alignment only, and still optimise based on the pessimistic; // pre-tagging size/alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64GlobalsTagging.cpp:725,contract,contract,725,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64GlobalsTagging.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64GlobalsTagging.cpp,1,['contract'],['contract']
Integrability,"// Technically, global module fragment belongs to global module. And global; // module has no name: [module.unit]p6:; // The global module has no name, no module interface unit, and is not; // introduced by any module-declaration.; //; // <global> is the default name showed in module map.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h:162,interface,interface,162,interpreter/llvm-project/clang/include/clang/Basic/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h,1,['interface'],['interface']
Integrability,"// Technically, we don't need to sort the dependency list to get determinism.; // Leaving these be will simply preserve the import order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:42,depend,dependency,42,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,1,['depend'],['dependency']
Integrability,// Tell the result set to ignore all of the protocols we have; // already seen.; // FIXME: This doesn't work when caching code-completion results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:44,protocol,protocols,44,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['protocol'],['protocols']
Integrability,"// Tell the runtime that this is ARC __weak, called by the; // byref routines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:69,rout,routines,69,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,1,['rout'],['routines']
Integrability,// Tentatively parse the protocol qualifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:25,protocol,protocol,25,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['protocol'],['protocol']
Integrability,"// Terminate call if this node was already processed (tree structure may be cyclical); // LM : RooLinkedList::findArg looks by name and not but by object pointer,; // should one use RooLinkedList::FindObject (look byt pointer) instead of findArg when; // tree contains nodes with the same name ?; // Add an info message if the require node does not exist but a different node already exists with same name",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:312,message,message,312,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['message'],['message']
Integrability,"// Terminate here if there are conflicts and no resolution protocol",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx:59,protocol,protocol,59,roofit/roofitcore/src/RooWorkspace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx,2,['protocol'],['protocol']
Integrability,// Terminate when we reach an interface type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:30,interface,interface,30,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,3,['interface'],['interface']
Integrability,"// Termination has been detected by the status check; print; // appropriate message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TGondzioSolver.cxx:76,message,message,76,math/quadp/src/TGondzioSolver.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TGondzioSolver.cxx,2,['message'],['message']
Integrability,"// Test a conditional fit with batch mode; //; // In a conditional fit, it happens that the value normalization integrals can; // be different for every event because a pdf is conditional on another; // observable. That's why the integral also has to be evaluated with the batch; // interface in general.; //; // This test checks if the results of a conditional fit are the same for batch; // and scalar mode. It also verifies that for non-conditional fits, the batch; // mode recognizes that the integral only needs to be evaluated once. This is; // checked by hijacking the FastEvaluations log. If a RooRealIntegral is; // evaluated in batch mode and data size is greater than one, the batch mode; // will inform that a batched evaluation function is missing.; //; // This test is disabled if the legacy backend is not available, because then; // we don't have any reference to compare to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAbsPdf.cxx:283,interface,interface,283,roofit/roofitcore/test/testRooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAbsPdf.cxx,1,['interface'],['interface']
Integrability,"// Test dependencies, e.g. ""1,3""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:8,depend,dependencies,8,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,1,['depend'],['dependencies']
Integrability,"// Test for the uniform pdf. Since it doesn't depend on any parameters, we need; // to add it to some other model like a Gaussian to get a meaningful fit model.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooFuncWrapper.cxx:46,depend,depend,46,roofit/roofitcore/test/testRooFuncWrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooFuncWrapper.cxx,1,['depend'],['depend']
Integrability,"// Test ranged integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooBernstein.cxx:15,integrat,integration,15,roofit/roofit/test/testRooBernstein.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooBernstein.cxx,1,['integrat'],['integration']
Integrability,"// Test the recursion anchors of the Romberg integration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRombergIntegrator.cxx:45,integrat,integration,45,roofit/roofitcore/test/testRooRombergIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRombergIntegrator.cxx,1,['integrat'],['integration']
Integrability,// Test whether it's safe to move Def to just before Insert.; // TODO: Compute memory dependencies in a way that doesn't require always; // walking the block.; // TODO: Compute memory dependencies in a way that uses AliasAnalysis to be; // more precise.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:86,depend,dependencies,86,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,2,['depend'],['dependencies']
Integrability,"// Test whether we depend on (ie, are served by) any object in the; // specified collection. Uses the dependsOn(RooAbsArg&) member function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:19,depend,depend,19,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,2,['depend'],"['depend', 'dependsOn']"
Integrability,"// Testing recursive enabling via dependencies: upload packtest3",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:34,depend,dependencies,34,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,1,['depend'],['dependencies']
Integrability,"// Tests the merge method with different binned 2D Histograms; //LM. t.b.u.: for 1D can make h3 with 330 bins , while in 2D if I make h3 with 33 bins; // routine which check axis fails. Needs to be improved ???",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx:154,rout,routine,154,test/stressHistogram.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx,1,['rout'],['routine']
Integrability,// Tests the single-subscript MIV pair (Src and Dst) for dependence.; // Return true if dependence disproved.; // Can sometimes refine direction vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:57,depend,dependence,57,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,2,['depend'],['dependence']
Integrability,// That can fail in the somewhat crazy situation that we're; // type-checking a message send within the @interface declaration; // that declared the @property. But it's not clear that that's; // valuable to support.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:80,message,message,80,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,2,"['interface', 'message']","['interface', 'message']"
Integrability,"// The ""DPI""/""DPI-C"" in SystemVerilog direct programming interface; // imports/exports cannot be split, e.g.; // `import ""DPI"" function foo();`; // FIXME: make this use same infra as C++ import checks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:57,interface,interface,57,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['interface'],['interface']
Integrability,"// The ""Should have been caught earlier!"" messages refer to the fact; // that the ExactCR.isFullSet() or ExactCR.isEmptySet() check above; // should have fired on the corresponding cases, and canonicalized the; // check to trivial case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:42,message,messages,42,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['message'],['messages']
Integrability,"// The ""bridge"" between the interpreters.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:8,bridg,bridge,8,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,1,['bridg'],['bridge']
Integrability,"// The ""default"" for integer RMW operations is to expand to an LL/SC loop.; // However, with the LSE instructions (or outline-atomics mode, which provides; // library routines in place of the LSE-instructions), we can directly emit many; // operations instead.; //; // Floating-point operations are always emitted to a cmpxchg loop, because they; // may trigger a trap which aborts an LLSC sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:167,rout,routines,167,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['rout'],['routines']
Integrability,"// The ""evaluator/rewriter"" of machine instructions. This is an abstract; // base class that provides the interface that the propagator will use,; // as well as some helper functions that are target-independent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:106,interface,interface,106,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,1,['interface'],['interface']
Integrability,"// The ""template"" keyword can follow ""->"" or ""."" in the grammar.; // However, we only want to suggest the template keyword if something; // is dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:143,depend,dependent,143,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['depend'],['dependent']
Integrability,"// The ""template"" keyword can follow ""::"" in the grammar, but only; // put it into the grammar if the nested-name-specifier is dependent.; // FIXME: results is always empty, this appears to be dead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:127,depend,dependent,127,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['depend'],['dependent']
Integrability,"// The '_node_get' helper function is used to avoid dependency on onnx submodule; // (for the subscript operator of torch._C.Node), as done in https://github.com/pytorch/pytorch/pull/82628",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/RModelParser_PyTorch.cxx:52,depend,dependency,52,tmva/pymva/src/RModelParser_PyTorch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/RModelParser_PyTorch.cxx,1,['depend'],['dependency']
Integrability,// The 'template' keyword is always present in dependent template; // specializations. Except in the case of incorrect code; // TODO: Treat the case of incorrect code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:47,depend,dependent,47,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,1,['depend'],['dependent']
Integrability,"// The 'unless' matcher will always discard the result:; // If the inner matcher doesn't match, unless returns true,; // but the inner matcher cannot have bound anything.; // If the inner matcher matches, the result is false, and; // any possible binding will be discarded.; // We still need to hand in all the bound nodes up to this; // point so the inner matcher can depend on bound nodes,; // and we need to actively discard the bound nodes, otherwise; // the inner matcher will reset the bound nodes if it doesn't; // match, but this would be inversed by 'unless'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp:369,depend,depend,369,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,1,['depend'],['depend']
Integrability,// The .bind here is in order to compose the error message more accurately.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:51,message,message,51,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,2,['message'],['message']
Integrability,// The .bind here is in order to compose the error message more accurately.; // Also avoid intptr_t and uintptr_t because they were specifically created; // for storing pointers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:51,message,message,51,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,1,['message'],['message']
Integrability,"// The /LDd option implies /MTd. The dependent lib part can be overridden,; // but defining _DEBUG is sticky.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:37,depend,dependent,37,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['depend'],['dependent']
Integrability,"// The 2nd server is the integrated function, which doesn't have the same; // name (it's ""gaussWrapped"" for the second integral instead of ""gauss"")",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRealIntegral.cxx:25,integrat,integrated,25,roofit/roofitcore/test/testRooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRealIntegral.cxx,1,['integrat'],['integrated']
Integrability,// The @interface does not have type parameters. Complain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:8,interface,interface,8,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['interface'],['interface']
Integrability,"// The ABI list files control how shadow parameters are passed. The pass treats; // every function labelled ""uninstrumented"" in the ABI list file as conforming; // to the ""native"" (i.e. unsanitized) ABI. Unless the ABI list contains; // additional annotations for those functions, a call to one of those functions; // will produce a warning message, as the labelling behaviour of the function is; // unknown. The other supported annotations for uninstrumented functions are; // ""functional"" and ""discard"", which are described below under; // DataFlowSanitizer::WrapperKind.; // Functions will often be labelled with both ""uninstrumented"" and one of; // ""functional"" or ""discard"". This will leave the function unchanged by this; // pass, and create a wrapper function that will call the original.; //; // Instrumented functions can also be annotated as ""force_zero_labels"", which; // will make all shadow and return values set zero labels.; // Functions should never be labelled with both ""force_zero_labels"" and; // ""uninstrumented"" or any of the unistrumented wrapper kinds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:341,message,message,341,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,4,"['Wrap', 'message', 'wrap']","['WrapperKind', 'message', 'wrapper']"
Integrability,"// The ADRP instruction adds some multiple of 0x1000 to the current PC &; // ~0xfff. This means that the required offset to reach a symbol can vary by; // up to one step depending on where the ADRP is in memory. For example:; //; // ADRP x0, there; // there:; //; // If the ADRP occurs at address 0xffc then ""there"" will be at 0x1000 and; // we'll need that as an offset. At any other address ""there"" will be in the; // same page as the ADRP and the instruction should encode 0x0. Assuming the; // section isn't 0x1000-aligned, we therefore need to delegate this decision; // to the linker -- a relocation!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64AsmBackend.cpp:170,depend,depending,170,interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64AsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64AsmBackend.cpp,1,['depend'],['depending']
Integrability,"// The AddRec must depend on one of the containing loops. Otherwise,; // mapSrcLoop and mapDstLoop return indices outside the intended range. This; // can happen when a subscript in one loop references an IV from a sibling; // loop that could not be replaced with a concrete exit value by; // getSCEVAtScope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:19,depend,depend,19,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['depend']
Integrability,"// The AliasSetTracker has nicely partitioned our pointers by metadata; // compatibility and potential for underlying-object overlap. As a result, we; // only need to check for potential pointer dependencies within each alias; // set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:195,depend,dependencies,195,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['dependencies']
Integrability,"// The Basic Block where CHI is must dominate the value we want to; // track in a CHI. In the PDom walk, there can be values in the; // stack which are not control dependent e.g., nested loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:164,depend,dependent,164,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['depend'],['dependent']
Integrability,"// The DeclRefExpr is not value-dependent, but the variable it refers to; // has a value-dependent initializer. This should only happen in; // constant-folding cases, where the variable is not actually of a suitable; // type for use in a constant expression (otherwise the DeclRefExpr would; // have been value-dependent too), so diagnose that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:32,depend,dependent,32,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,3,['depend'],['dependent']
Integrability,// The EHABI requires a dependency preserving R_ARM_NONE relocation to the; // personality routine to protect it from an arbitrary platform's static; // linker garbage collection. We disable this for Android where the unwinder; // is either dynamically linked or directly references the personality; // routine.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp:24,depend,dependency,24,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp,3,"['depend', 'rout']","['dependency', 'routine']"
Integrability,"// The Error message already issued. However if we reach here; // we need to make sure that we do not use fTree.; //; // Force a reload of the tree next time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:13,message,message,13,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['message'],['message']
Integrability,// The Function wrapped by N could have been deleted since we last saw it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:16,wrap,wrapped,16,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,1,['wrap'],['wrapped']
Integrability,"// The Gaussian PDF wrapped in a RooGenericPdf should have exactly the same; // server structure, so let's check that:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRealIntegral.cxx:20,wrap,wrapped,20,roofit/roofitcore/test/testRooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRealIntegral.cxx,1,['wrap'],['wrapped']
Integrability,// The Hue component of the HSV interpolation Routine,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-color-helper.cpp:46,Rout,Routine,46,interpreter/llvm-project/llvm/tools/llvm-xray/xray-color-helper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-color-helper.cpp,1,['Rout'],['Routine']
Integrability,"// The ID is only used wrapped in MetadataAsValue(ID), so lets check that; // one of those already exists first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:23,wrap,wrapped,23,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,1,['wrap'],['wrapped']
Integrability,"// The IO bits flag is to provide improved forward-compatibility detection.; // Any new non-forward compatibility flags related serialization should be; // added here. When a new flag is added, set it in the kSupported field;; //; // The values and names of this (and EUnsupportedIOBits) enum need not be aligned; // with the values of the various TIOFeatures enums, as there's a clean separation; // between these two interfaces. Practically, it is reasonable to keep them as aligned; // as possible in order to avoid confusion.; //; // If (fIOBits & ~kSupported) is non-zero -- i.e., an unknown IO flag is set; // in the fIOBits -- then the zombie flag will be set for this object.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h:419,interface,interfaces,419,tree/tree/inc/TBasket.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h,1,['interface'],['interfaces']
Integrability,"// The IV is used as the operand of a GEP which dominates the loop; // latch, and the IV is at least as wide as the address space of the; // GEP. In this case, the GEP would wrap around the address space; // before the IV increment wraps, which would be UB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:174,wrap,wrap,174,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,2,['wrap'],"['wrap', 'wraps']"
Integrability,// The Id field's size depends on the DWARF format,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugFrame.cpp:23,depend,depends,23,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugFrame.cpp,1,['depend'],['depends']
Integrability,"// The Idecl->lookupMethod() above will find declarations for ObjCMethod; // in one of these places:; //; // (1) the canonical declaration in an @interface container paired; // with the ImplDecl,; // (2) non canonical declarations in @interface not paired with the; // ImplDecl for the same Class,; // (3) any superclass container.; //; // Direct methods only allow for canonical declarations in the matching; // container (case 1).; //; // Direct methods overriding a superclass declaration (case 3) is; // handled during overrides checks in CheckObjCMethodOverrides().; //; // We deal with same-class container mismatches (Case 2) here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:146,interface,interface,146,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['interface'],['interface']
Integrability,"// The Init() function is called when the selector needs to initialize; // a new tree or chain. Typically here the branch addresses and branch; // pointers of the tree will be set.; // It is normally not necessary to make changes to the generated; // code, but the routine can be extended by the user if needed.; // Init() will be called many times when running on PROOF; // (once per file to be processed).; // Set branch addresses and branch pointers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/macros/MySelector.h:265,rout,routine,265,documentation/primer/macros/MySelector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/macros/MySelector.h,2,['rout'],['routine']
Integrability,"// The Init() function is called when the selector needs to initialize; // a new tree or chain. Typically here the branch addresses of the tree; // will be set. It is normaly not necessary to make changes to the; // generated code, but the routine can be extended by the user if needed.; // Init() will be called many times when running with PROOF.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TSelEventGen.h:240,rout,routine,240,proof/proofbench/inc/TSelEventGen.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TSelEventGen.h,1,['rout'],['routine']
Integrability,"// The Init() function is called when the selector needs to initialize; // a new tree or chain. Typically here the branch addresses of the tree; // will be set. It is normaly not necessary to make changes to the; // generated code, but the routine can be extended by the user if needed.; // Init() will be called many times when running with PROOF.; // Set branch addresses",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TSelEvent.h:240,rout,routine,240,proof/proofbench/inc/TSelEvent.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TSelEvent.h,5,['rout'],['routine']
Integrability,// The InjectedClassNameType is created in VisitRecordDecl when the; // T->getDecl() is imported. Here we can return the existing type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:7,Inject,InjectedClassNameType,7,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['Inject'],['InjectedClassNameType']
Integrability,// The MIPS MSA ABI passes vector arguments in the integer register set.; // The number of integer registers used is dependant on the ABI used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:117,depend,dependant,117,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['depend'],['dependant']
Integrability,"// The MS ABI changed between VS2013 and VS2015 with regard to numbers used to; // disambiguate entities defined in different scopes.; // While the VS2015 ABI fixes potential miscompiles, it is also breaks; // compatibility.; // We will pick our mangling number depending on which version of MSVC is being; // targeted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:262,depend,depending,262,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['depending']
Integrability,"// The MemoryBuffer passed into this constructor is just a wrapper around the; // actual memory. Ultimately, the Binary parent class will take ownership of; // this MemoryBuffer object but not the underlying memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:59,wrap,wrapper,59,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,1,['wrap'],['wrapper']
Integrability,// The Microsoft extension __interface does not permit bases that; // are not themselves public interfaces.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:96,interface,interfaces,96,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['interface'],['interfaces']
Integrability,"// The N last elements in NodeNums will be removed, and the SU with; // the lowest NodeNum of them will become the new BarrierChain to; // let the not yet seen SUs have a dependency to the removed SUs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:171,depend,dependency,171,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['depend'],['dependency']
Integrability,"// The Notify() function is called when a new file is opened. This; // can be either for a new TTree in a TChain or when when a new TTree; // is started when using PROOF. It is normally not necessary to make changes; // to the generated code, but the routine can be extended by the; // user if needed. The return value is currently not used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/macros/MySelector.h:251,rout,routine,251,documentation/primer/macros/MySelector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/macros/MySelector.h,2,['rout'],['routine']
Integrability,"// The Notify() function is called when a new file is opened. This; // can be either for a new TTree in a TChain or when when a new TTree; // is started when using PROOF. Typically here the branch pointers; // will be retrieved. It is normaly not necessary to make changes; // to the generated code, but the routine can be extended by the; // user if needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TSelEvent.h:308,rout,routine,308,proof/proofbench/inc/TSelEvent.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TSelEvent.h,3,['rout'],['routine']
Integrability,"// The Notify() function is called when a new file is opened. This; // can be either for a new TTree in a TChain or when when a new TTree; // is started when using PROOF. Typically here the branch pointers; // will be retrieved. It is normaly not necessary to make changes; // to the generated code, but the routine can be extended by the; // user if needed.; // Get branch pointers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/ProofBench/EventTree_NoProc.h:308,rout,routine,308,test/ProofBench/EventTree_NoProc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/ProofBench/EventTree_NoProc.h,3,['rout'],['routine']
Integrability,"// The PartIterator is a wrapper around the iterator for the PartOffsets; // member of the DXContainer. It contains a refernce to the container, and the; // current iterator value, as well as storage for a parsed part header.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/DXContainer.h:25,wrap,wrapper,25,interpreter/llvm-project/llvm/include/llvm/Object/DXContainer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/DXContainer.h,1,['wrap'],['wrapper']
Integrability,"// The Preprocessor will try to set the NumCreatedFIDs but we are; // reparsing and this value was already set. Force reset it to avoid; // triggering an assertion in the setNumCreatedFIDsForFileID routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp:198,rout,routine,198,interpreter/cling/lib/Interpreter/LookupHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp,1,['rout'],['routine']
Integrability,"// The RFTS classes used for minimization (RooAbsL and Wrapper derivatives) will return offset; // values, whereas RooNLLVar::getVal will always return the non-offset value, since that is the ""actual"" likelihood; // value. RooRealL will also give the non-offset value, so that can be directly compared to the RooNLLVar::getVal; // result (the nll0 vs nll2 comparison below). To compare to the raw RooAbsL/Wrapper value nll1, however, we need to; // manually add the offset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/TestStatistics/testLikelihoodJob.cxx:55,Wrap,Wrapper,55,roofit/roofitcore/test/TestStatistics/testLikelihoodJob.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/TestStatistics/testLikelihoodJob.cxx,6,['Wrap'],['Wrapper']
Integrability,"// The Reader is the module that creates the logical view using the debug; // information contained in the binary file specified in the command line.; // This is the main entry point for the Reader and performs the following; // steps:; // - Process any patterns collected from the '--select' options.; // - For each compile unit in the debug information:; // * Create the logical elements (scopes, symbols, types, lines).; // * Collect debug ranges and debug locations.; // * Move the collected logical lines to their associated scopes.; // - Once all the compile units have been processed, traverse the scopes; // tree in order to:; // * Calculate symbol coverage.; // * Detect invalid ranges and locations.; // * ""resolve"" the logical elements. During this pass, the names and; // file information are updated, to reflect any dependency with other; // logical elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVReader.cpp:829,depend,dependency,829,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVReader.cpp,1,['depend'],['dependency']
Integrability,"// The RecordKeeper stores records (options) in lexicographical order, and we; // have reordered the options again when generating prefix groups. We need to; // restore the original definition order of options with marshalling to honor; // the topology of the dependency graph implied by `DefaultAnyOf`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/OptParserEmitter.cpp:260,depend,dependency,260,interpreter/llvm-project/llvm/utils/TableGen/OptParserEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/OptParserEmitter.cpp,1,['depend'],['dependency']
Integrability,"// The RooDataHit can be analytically integrated with the RooDataHist::sum(); // member functions. This functionality is used in the analytical; // integration capabilities of RooHistPdf and RooHistFunc. Therefore, to; // test these two classes at the same time, this tests validated; // RooDataHist::sum() via the RooHistPdf and RooHistFunc interfaces.; // The histograms for this example are kept simple such that one can easily; // calculate the expected values with a calculator.; // We first create an easy non-uniform histogram for the x variable so we; // can know what we expect as test results analytically. The histogram will; // have the following bins with contents:; // - bin1 [0.0, 1.0]: 3 counts (bin volume x counts = 3); // - bin2 [1.0, 3.0]: 1 count (bin volume x counts = 2); // - bin3 [3.0, 3.5]: 8 counts (bin volume x counts = 4)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataHist.cxx:38,integrat,integrated,38,roofit/roofitcore/test/testRooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataHist.cxx,3,"['integrat', 'interface']","['integrated', 'integration', 'interfaces']"
Integrability,"// The RooHistFunc is only used to access this histogram observables in a; // convenient way. That's why this proxy is not ""serving"" this; // RooBinWidthFunction in any way (see proxy constructor arguments in the; // initializer list above).; //; // However, the variables of the histFunc **need to be** value servers,; // because the width of the current bin depends on the values of the; // observables:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinWidthFunction.cxx:360,depend,depends,360,roofit/roofitcore/src/RooBinWidthFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinWidthFunction.cxx,1,['depend'],['depends']
Integrability,"// The SIMD&FP variant of CLAST[AB] is significantly faster than the scalar; // integer variant across a variety of micro-architectures. Replace scalar; // integer CLAST[AB] intrinsic with optimal SIMD&FP variant. A simple; // bitcast-to-fp + clast[ab] + bitcast-to-int will cost a cycle or two more; // depending on the micro-architecture, but has been observed as generally; // being faster, particularly when the CLAST[AB] op is a loop-carried; // dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:304,depend,depending,304,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,2,['depend'],"['dependency', 'depending']"
Integrability,"// The TBAA metadata could have a control dependency on the predication; // condition, so we cannot rely on it when determining whether or not we; // need runtime pointer checks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:42,depend,dependency,42,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,2,['depend'],['dependency']
Integrability,"// The TProof::ActivateWorker/TProof::DeactivateWorker functions were fixed /; // improved starting with protocol version 33",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofNodes.cxx:105,protocol,protocol,105,proof/proofbench/src/TProofNodes.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofNodes.cxx,1,['protocol'],['protocol']
Integrability,"// The TRACE macro is used to print internal information about the; // HTML layout engine during testing and debugging. The amount of; // information printed is governed by a global variable named; // HtmlTraceMask. If bits in the first argument to the TRACE macro; // match any bits in HtmlTraceMask variable, then the trace message; // is printed.; //; // All of this is completely disabled, of course, if the DEBUG macro; // is not defined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h:326,message,message,326,gui/guihtml/inc/TGHtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h,1,['message'],['message']
Integrability,// The WrappedAction can be nullptr if we issued an error in the ctor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:7,Wrap,WrappedAction,7,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,1,['Wrap'],['WrappedAction']
Integrability,"// The above message send needs these objects, but in ARC they are; // passed in a buffer that is essentially __unsafe_unretained.; // Therefore we must prevent the optimizer from releasing them until; // after the call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:13,message,message,13,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['message'],['message']
Integrability,"// The actions to be performed on the Remote Reduce list is dependent; // on the algorithm version.; //; // if (AlgoVer==0) || (AlgoVer==1 && (LaneId < Offset)) || (AlgoVer==2 &&; // LaneId % 2 == 0 && Offset > 0):; // do the reduction value aggregation; //; // The thread local variable Reduce list is mutated in place to host the; // reduced data, which is the aggregated value produced from local and; // remote lanes.; //; // Note that AlgoVer is expected to be a constant integer known at compile; // time.; // When AlgoVer==0, the first conjunction evaluates to true, making; // the entire predicate true during compile time.; // When AlgoVer==1, the second conjunction has only the second part to be; // evaluated during runtime. Other conjunctions evaluates to false; // during compile time.; // When AlgoVer==2, the third conjunction has only the second part to be; // evaluated during runtime. Other conjunctions evaluates to false; // during compile time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:60,depend,dependent,60,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['depend'],['dependent']
Integrability,"// The actual CompilationDatabase wrapper delegates to its inner database.; // If no match, looks up a proxy file in FileIndex and transfers its; // command to the requested file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:34,wrap,wrapper,34,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,1,['wrap'],['wrapper']
Integrability,"// The actual servers for a given normalization set depend on whether the; // cache is rearranged or not. See RooProdPdf::calculateBatch to see; // which args in the cache are used directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:52,depend,depend,52,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['depend'],['depend']
Integrability,// The actual update starts here. We look at all allocations and depending on; // their status perform the appropriate check(s).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:65,depend,depending,65,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['depend'],['depending']
Integrability,"// The address calculation must not wrap. Otherwise, a dependence could be; // inverted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:36,wrap,wrap,36,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,2,"['depend', 'wrap']","['dependence', 'wrap']"
Integrability,"// The address passed to operator() will be the address of the start of the; // object. Overload this routine, if your derived class can optimize; // the handling of the onfileClass (rather than storing and restoring from the; // fOnFileClass member.; // Note we can not name this routine 'operator' has it would be slightly; // backward incompatible and lead to the following warning/error from the; // compiler in the derived class overloading the other operator():; // include/TClassStreamer.h:51: error: virtual void TClassStreamer::operator()(TBuffer&, void*, const TClass*) was hidden; // include/TCollectionProxyFactory.h:180: error: by virtual void TCollectionClassStreamer::operator()(TBuffer&, void*); // cc1plus: warnings being treated as errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TClassStreamer.h:102,rout,routine,102,core/meta/inc/TClassStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TClassStreamer.h,2,['rout'],['routine']
Integrability,"// The algorithm initially places the values of the routine in the TOP; // congruence class. The leader of TOP is the undetermined value `poison`.; // When the algorithm has finished, values still in TOP are unreachable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:52,rout,routine,52,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['rout'],['routine']
Integrability,// The alignment of the vtordisp is at least the required alignment of the; // entire record. This requirement may be present to support vtordisp; // injection.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:150,inject,injection,150,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['inject'],['injection']
Integrability,"// The allocator in ASTContext is mutable ...; // Keep the argument const to be inline will all the other interfaces; // like: NestedNameSpecifier::Create",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/AST.cpp:106,interface,interfaces,106,interpreter/cling/lib/Utils/AST.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/AST.cpp,2,['interface'],['interfaces']
Integrability,"// The architecture doesn't allow three dependent instructions in the same; // packet. So, if the destination has a zero latency successor, then it's; // not a candidate for a zero latency predecessor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:40,depend,dependent,40,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['depend'],['dependent']
Integrability,// The are two cases we need to handle depending on where in the pipeline; // the folding attempt is being made.; // -Register has the undef flag set.; // -Register is produced by the IMPLICIT_DEF instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:39,depend,depending,39,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['depend'],['depending']
Integrability,// The argument could be a global variable or a getelementptr with base to; // a global variable depending on whether the clang option `opaque-options`; // is set or not.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:97,depend,depending,97,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,1,['depend'],['depending']
Integrability,// The argument for a dependent or non-block parameter is a placeholder; // containing that parameter's type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:22,depend,dependent,22,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['depend'],['dependent']
Integrability,// The argument is value-dependent. Create a new; // TemplateArgument with the converted expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:25,depend,dependent,25,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,"// The assembler has relaxed rules for accepting identifiers, in particular we; // allow things like '.globl $foo' and '.def @feat.00', which would normally be; // separate tokens. At this level, we have already lexed so we cannot (currently); // handle this as a context dependent token, instead we detect adjacent tokens; // and return the combined identifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:272,depend,dependent,272,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,1,['depend'],['dependent']
Integrability,"// The assembler has relaxed rules for accepting identifiers, in particular we; // allow things like '.globl $foo' and '.def @feat.00', which would normally; // be separate tokens. At this level, we have already lexed so we cannot; // (currently) handle this as a context dependent token, instead we detect; // adjacent tokens and return the combined identifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp:272,depend,dependent,272,interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,1,['depend'],['dependent']
Integrability,// The assume intrinsic has a control dependency which we model by claiming; // that it writes arbitrarily. Debuginfo intrinsics may be considered; // clobbers when we have a nonstandard AA pipeline. Ignore these fake memory; // dependencies here.; // FIXME: Replace this special casing with a more accurate modelling of; // assume's control dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:38,depend,dependency,38,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,3,['depend'],"['dependencies', 'dependency']"
Integrability,"// The basic code generated is conceptually straightforward. Pseudo code:; //; // accum = mad_64_32 lhs.lo, rhs.lo, accum; // accum.hi = add (mul lhs.hi, rhs.lo), accum.hi; // accum.hi = add (mul lhs.lo, rhs.hi), accum.hi; //; // The second and third lines are optional, depending on whether the factors; // are {sign,zero}-extended or not.; //; // The actual DAG is noisier than the pseudo code, but only due to; // instructions that disassemble values into low and high parts, and; // assemble the final result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:271,depend,depending,271,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['depend'],['depending']
Integrability,"// The below routines verify the correctness of the dominator tree relative to; // the CFG it's coming from. A tree is a dominator tree iff it has two; // properties, called the parent property and the sibling property. Tarjan; // and Lengauer prove (but don't explicitly name) the properties as part of; // the proofs in their 1972 paper, but the proofs are mostly part of proving; // things about semidominators and idoms, and some of them are simply asserted; // based on even earlier papers (see, e.g., lemma 2). Some papers refer to; // these properties as ""valid"" and ""co-valid"". See, e.g., ""Dominators,; // directed bipolar orders, and independent spanning trees"" by Loukas; // Georgiadis and Robert E. Tarjan, as well as ""Dominator Tree Verification; // and Vertex-Disjoint Paths "" by the same authors.; // A very simple and direct explanation of these properties can be found in; // ""An Experimental Study of Dynamic Dominators"", found at; // https://arxiv.org/abs/1604.02711; // The easiest way to think of the parent property is that it's a requirement; // of being a dominator. Let's just take immediate dominators. For PARENT to; // be an immediate dominator of CHILD, all paths in the CFG must go through; // PARENT before they hit CHILD. This implies that if you were to cut PARENT; // out of the CFG, there should be no paths to CHILD that are reachable. If; // there are, then you now have a path from PARENT to CHILD that goes around; // PARENT and still reaches CHILD, which by definition, means PARENT can't be; // a dominator of CHILD (let alone an immediate one).; // The sibling property is similar. It says that for each pair of sibling; // nodes in the dominator tree (LEFT and RIGHT) , they must not dominate each; // other. If sibling LEFT dominated sibling RIGHT, it means there are no; // paths in the CFG from sibling LEFT to sibling RIGHT that do not go through; // LEFT, and thus, LEFT is really an ancestor (in the dominator tree) of; // RIGHT, not a sibling.; // It i",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h:13,rout,routines,13,interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,1,['rout'],['routines']
Integrability,// The block we're going to end up in after any message send or nil path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:48,message,message,48,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['message'],['message']
Integrability,// The body of the coroutine may be a try statement if it is in; // 'function-try-block' syntax. Here we wrap it into a compound; // statement for consistency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:105,wrap,wrap,105,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,1,['wrap'],['wrap']
Integrability,// The branch should be in this exact loop. Any inner loop's invariant branch; // should be handled by unswitching that inner loop. The caller of this; // routine should filter out any candidates that remain (but were skipped for; // whatever reason).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:155,rout,routine,155,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['rout'],['routine']
Integrability,"// The call to get_return_object is sequenced before the call to; // initial_suspend and is invoked at most once, but there are caveats; // regarding on whether the prvalue result object may be initialized; // directly/eager or delayed, depending on the types involved.; //; // More info at https://github.com/cplusplus/papers/issues/1414",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:240,depend,depending,240,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,1,['depend'],['depending']
Integrability,"// The call to get_return_object is sequenced before the call to; // initial_suspend and is invoked at most once, but there are caveats; // regarding on whether the prvalue result object may be initialized; // directly/eager or delayed, depending on the types involved.; //; // More info at https://github.com/cplusplus/papers/issues/1414; //; // The general cases:; // 1. Same type of get_return_object and coroutine return type (direct; // emission):; // - Constructed in the return slot.; // 2. Different types (delayed emission):; // - Constructed temporary object prior to initial suspend initialized with; // a call to get_return_object(); // - When coroutine needs to to return to the caller and needs to construct; // return value for the coroutine it is initialized with expiring value of; // the temporary obtained above.; //; // Direct emission for void returning coroutines or GROs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:240,depend,depending,240,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,1,['depend'],['depending']
Integrability,// The called routine is expected to preserve r19-r28; // r29 and r30 are used as frame pointer and link register resp.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:14,rout,routine,14,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['rout'],['routine']
Integrability,"// The caller frequently adds the same dependence twice. If so, then; // return true for this case too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:39,depend,dependence,39,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['depend'],['dependence']
Integrability,// The can wrap an actual call which may grow the stack by an unbounded; // amount or run forever.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:11,wrap,wrap,11,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,1,['wrap'],['wrap']
Integrability,"// The canonical declaration of every specialization is registered with; // the FunctionTemplateDecl.; // Note this might unload too much in the case:; // template<typename T> T f(){ return T();}; // template<> int f();; // template<> int f() { return 0;}; // when the template specialization was forward declared the canonical; // becomes the first forward declaration. If the canonical forward; // declaration was declared outside the set of the decls to unload we have; // to keep it registered as a template specialization.; //; // In order to diagnose mismatches of the specializations, clang 'injects'; // a implicit forward declaration making it very hard distinguish between; // the explicit and the implicit forward declaration. So far the only way; // to distinguish is by source location comparison.; // FIXME: When the misbehavior of clang is fixed we must avoid relying on; // source locations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp:599,inject,injects,599,interpreter/cling/lib/Interpreter/DeclUnloader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp,1,['inject'],['injects']
Integrability,"// The central theory of this routine is based on the following:; // A _try scope is always a SEME (Single Entry Multiple Exits) region; // as jumping into a _try is not allowed; // The single entry must start with a seh_try_begin() invoke with a; // correct State number that is the initial state of the SEME.; // Through control-flow, state number is propagated into all blocks.; // Side exits marked by seh_try_end() will unwind to parent state via; // existing SEHUnwindMap[].; // Side exits can ONLY jump into parent scopes (lower state number).; // Thus, when a block succeeds various states from its predecessors,; // the lowest State trumphs others.; // If some exits flow to unreachable, propagation on those paths terminate,; // not affecting remaining blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:30,rout,routine,30,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,1,['rout'],['routine']
Integrability,"// The checker knows that an out-of-line object is deallocated if it is; // passed as an argument to one of these functions. If this object is; // additionally an argument of a MIG routine, the checker keeps track of that; // information and issues a warning when an error is returned from the; // respective routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:181,rout,routine,181,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,2,['rout'],['routine']
Integrability,"// The cint interface always returns 0L for these guys.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx:12,interface,interface,12,core/metacling/src/TClingClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx,1,['interface'],['interface']
Integrability,"// The clang-cl driver passes ""-o -"" to the frontend. Inject the real; // file here to ensure ""-MT"" can be deduced if need be.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:54,Inject,Inject,54,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,1,['Inject'],['Inject']
Integrability,"// The class in which this member exists is currently being; // instantiated, and we haven't gotten around to instantiating this; // member yet. This can happen when the code uses forward declarations; // of member classes, and introduces ordering dependencies via; // template instantiation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:248,depend,dependencies,248,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['depend'],['dependencies']
Integrability,// The class interface might be NULL if we are working with invalid code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:13,interface,interface,13,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,1,['interface'],['interface']
Integrability,// The class may have size 0 and a vfptr (e.g. it's an interface class). The; // size was not correctly set before in this case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:55,interface,interface,55,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['interface'],['interface']
Integrability,"// The client may be running the old pass manager, in which case, we need to; // map the requested Analysis to its equivalent wrapper in the old pass; // manager. The scheme implemented here does not require every Analysis to be; // updated. Only those new analyses that the client cares about in the old; // pass manager need to expose a LegacyWrapper type, and that wrapper should; // support a getResult() method that matches the new Analysis.; //; // We need SFINAE to check for the LegacyWrapper, but function templates don't; // allow partial specialization, which is needed in this case. So instead, we; // use a constexpr bool to perform the SFINAE, and then use this information; // inside the function template.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:126,wrap,wrapper,126,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,2,['wrap'],['wrapper']
Integrability,"// The code below allows the target to create a new instruction to break the; // dependence. That opposes the goal of minimizing size, so bail out now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:81,depend,dependence,81,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,2,['depend'],['dependence']
Integrability,// The code is missing a 'template' keyword prior to the dependent template; // name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:57,depend,dependent,57,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,"// The completion point is set one a 1-based line/column numbering.; // It relies on the implementation to account for the wrapper extra line.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp:123,wrap,wrapper,123,interpreter/cling/lib/Interpreter/IncrementalParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp,1,['wrap'],['wrapper']
Integrability,"// The concept of the reassociation pass is that these operations can benefit; // from this kind of transformation:; //; // A = ? op ?; // B = A op X (Prev); // C = B op Y (Root); // -->; // A = ? op ?; // B = X op Y; // C = A op B; //; // breaking the dependency between A and B, allowing them to be executed in; // parallel (or back-to-back in a pipeline) instead of depending on each other.; // FIXME: This has the potential to be expensive (compile time) while not; // improving the code at all. Some ways to limit the overhead:; // 1. Track successful transforms; bail out if hit rate gets too low.; // 2. Only enable at -O3 or some other non-default optimization level.; // 3. Pre-screen pattern candidates here: if an operand of the previous; // instruction is known to not increase the critical path, then don't match; // that pattern.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:253,depend,dependency,253,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,2,['depend'],"['dependency', 'depending']"
Integrability,// The conservative assumption is that a dependence between memory operations; // may be loop carried. The following code checks when it can be proved that; // there is no loop carried dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:41,depend,dependence,41,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,2,['depend'],['dependence']
Integrability,"// The constant 25 instructions is added to avoid depending too much on; // accidental SlotIndex gaps for small intervals. The effect is that small; // intervals have a spill weight that is mostly proportional to the number; // of uses, while large intervals get a spill weight that is closer to a use; // density.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CalcSpillWeights.h:50,depend,depending,50,interpreter/llvm-project/llvm/include/llvm/CodeGen/CalcSpillWeights.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CalcSpillWeights.h,1,['depend'],['depending']
Integrability,// The contract is to store None instead of TY_INVALID.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:7,contract,contract,7,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,1,['contract'],['contract']
Integrability,// The contract with the ML side is that CandidatePos is mask == 1 (i.e.; // Regs[CandidatePos].second),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:7,contract,contract,7,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,1,['contract'],['contract']
Integrability,// The controlling expression of a generic selection is not evaluated.; // Don't visit either child expression if the condition is type-dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/EvaluatedExprVisitor.h:136,depend,dependent,136,interpreter/llvm-project/clang/include/clang/AST/EvaluatedExprVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/EvaluatedExprVisitor.h,1,['depend'],['dependent']
Integrability,"// The conversion routine works on fp-reg to fp-reg and the operand above; // was an integer, move it to the fp registers if possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:18,rout,routine,18,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,1,['rout'],['routine']
Integrability,"// The corner case exist when there is true data dependency between; // candidate and one of current packet members, this dep is on; // predicate reg, and there already exist anti dep on the same pred in; // the packet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:49,depend,dependency,49,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['depend'],['dependency']
Integrability,// The cost of passing function arguments through the stack:; // 1 instruction to put a function argument on the stack in the caller.; // 1 instruction to take a function argument from the stack in callee.; // 1 instruction is explicitly take care of data dependencies in callee; // function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:256,depend,dependencies,256,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,1,['depend'],['dependencies']
Integrability,// The coverage is dependent on the kind of location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp:19,depend,dependent,19,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp,1,['depend'],['dependent']
Integrability,// The createTuple interface requires 3 RegClassIDs for each possible; // tuple type even though we only have them for ZPR2 and ZPR4.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:19,interface,interface,19,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['interface'],['interface']
Integrability,// The data after unwindCodes depends on flags.; // If UNW_ExceptionHandler or UNW_TerminateHandler is set then follows; // the address of the language-specific exception handler.; // If UNW_ChainInfo is set then follows a RuntimeFunction which defines; // the chained unwind info.; // For more information please see MSDN at:; // http://msdn.microsoft.com/en-us/library/ddssxxy8.aspx; /// Return pointer to language specific data part of UnwindInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Win64EH.h:30,depend,depends,30,interpreter/llvm-project/llvm/include/llvm/Support/Win64EH.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Win64EH.h,1,['depend'],['depends']
Integrability,// The data dependency chain must be improved.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:12,depend,dependency,12,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,1,['depend'],['dependency']
Integrability,// The declaration is visible to argument-dependent lookup if either; // it's ordinarily visible or declared as a friend in an associated; // class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:42,depend,dependent,42,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['depend'],['dependent']
Integrability,// The declaration that defines this protocol.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:37,protocol,protocol,37,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['protocol'],['protocol']
Integrability,"// The declaration won't be seen outside of the statement, so we don't; // have to wrap the uses of any declared variables in if (@available).; // Therefore we can avoid setting Scope here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:83,wrap,wrap,83,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['wrap'],['wrap']
Integrability,"// The default assumption needs to be ecc is enabled, but no directly; // exposed operations depend on it, so it can be safely inlined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:93,depend,depend,93,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,1,['depend'],['depend']
Integrability,"// The default bundling behavior depends on the type of output, therefore; // BundleOutput needs to be tri-value: None, true, or false.; // Bundle code objects except --no-gpu-output is specified for device; // only compilation. Bundle other type of output files only if; // --gpu-bundle-output is specified for device only compilation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:33,depend,depends,33,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['depend'],['depends']
Integrability,// The default depends on the language standard.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:15,depend,depends,15,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['depend'],['depends']
Integrability,// The default handling is broken and doesn't handle illegal SGPR->VGPR copies; // properly.; //; // TODO: There are additional exec masking dependencies to analyze.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:141,depend,dependencies,141,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['depend'],['dependencies']
Integrability,// The default implementation returns 0 for no partial register dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:64,depend,dependency,64,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['depend'],['dependency']
Integrability,// The default implementation returns 0 for no undef register dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:62,depend,dependency,62,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['depend'],['dependency']
Integrability,"// The default value depends on the default triple. Mach-O has symbols; // prefixed with ""_"", so strip by default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxfilt/llvm-cxxfilt.cpp:21,depend,depends,21,interpreter/llvm-project/llvm/tools/llvm-cxxfilt/llvm-cxxfilt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cxxfilt/llvm-cxxfilt.cpp,1,['depend'],['depends']
Integrability,"// The definition/declaration form,; // @protocol Foo; // - (int)someMethod;; // @end",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:41,protocol,protocol,41,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['protocol'],['protocol']
Integrability,"// The delinearization transforms a single-subscript MIV dependence test into; // a multi-subscript SIV dependence test that is easier to compute. So we; // resize Pair to contain as many pairs of subscripts as the delinearization; // has found, and then initialize the pairs following the delinearization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:57,depend,dependence,57,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,2,['depend'],['dependence']
Integrability,"// The density is calculated by doing :; // (double)DensityA = A.ObjectNumUses / A.ObjectSize; // (double)DensityB = B.ObjectNumUses / B.ObjectSize; // Since this approach may cause inconsistencies in; // the floating point <, >, == comparisons, depending on the floating; // point model with which the compiler was built, we're going; // to scale both sides by multiplying with; // A.ObjectSize * B.ObjectSize. This ends up factoring away; // the division and, with it, the need for any floating point; // arithmetic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:246,depend,depending,246,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['depend'],['depending']
Integrability,// The depended loop count.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:7,depend,depended,7,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['depend'],['depended']
Integrability,"// The dependence distance can be positive/negative, so we sign extend Dist;; // The multiplication of the absolute stride in bytes and the; // backedgeTakenCount is non-negative, so we zero extend Product.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:7,depend,dependence,7,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['dependence']
Integrability,// The dependence does not clobber live-ins in NullSucc block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:7,depend,dependence,7,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,1,['depend'],['dependence']
Integrability,// The dependence edges that represent anti- and output-; // dependencies that are candidates for breaking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:7,depend,dependence,7,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,2,['depend'],"['dependence', 'dependencies']"
Integrability,"// The dependence graph may not include edges between dead definitions,; // so without extra checks, we could end up packetizing two instruction; // defining the same (dead) register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:7,depend,dependence,7,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['depend'],['dependence']
Integrability,// The dependence is optional so we don't give up once we give up on the; // alignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:7,depend,dependence,7,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['depend'],['dependence']
Integrability,// The dependent expression has to be folded into a constant (TODO).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:7,depend,dependent,7,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,1,['depend'],['dependent']
Integrability,// The descriptive text message for -help,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h:24,message,message,24,interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,1,['message'],['message']
Integrability,// The diagnostic message is 'quoted',MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp:18,message,message,18,interpreter/llvm-project/clang/lib/AST/APValue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp,1,['message'],['message']
Integrability,"// The different predicates and matchers created during; // addInstructionMatcher use the RuleMatcher M to set up their; // instruction ID (InsnVarID) that are going to be used when; // M is going to be emitted.; // However, the code doing the emission still relies on the IDs; // returned during that process by the RuleMatcher when issuing; // the recordInsn opcodes.; // Because of that:; // 1. The order in which we created the predicates; // and such must be the same as the order in which we emit them,; // and; // 2. We need to reset the generation of the IDs in M somewhere between; // addInstructionMatcher and emit; //; // FIXME: Long term, we don't want to have to rely on this implicit; // naming being the same. One possible solution would be to have; // explicit operator for operation capture and reference those.; // The plus side is that it would expose opportunities to share; // the capture accross rules. The downside is that it would; // introduce a dependency between predicates (captures must happen; // before their first use.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp:971,depend,dependency,971,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp,1,['depend'],['dependency']
Integrability,// The dominance frontier of a live block X in the reverse; // control graph is the set of blocks upon which X is control; // dependent. The following sequence computes the set of blocks; // which currently have dead terminators that are control; // dependence sources of a block which is in NewLiveBlocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:126,depend,dependent,126,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,2,['depend'],"['dependence', 'dependent']"
Integrability,"// The drop operation timed out without receiving; // status confirmation from the target. Send a; // leave message instead (and notify the user or widget).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGDNDManager.cxx:108,message,message,108,gui/gui/src/TGDNDManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGDNDManager.cxx,1,['message'],['message']
Integrability,// The entry block was removed and there is no external interface for; // the dominator tree to be notified of this change. In this corner-case; // we recalculate the entire tree.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:56,interface,interface,56,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,2,['interface'],['interface']
Integrability,"// The error message is in the output file, let's print it out from there.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:13,message,message,13,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,1,['message'],['message']
Integrability,// The error messages must match.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:13,message,messages,13,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,1,['message'],['messages']
Integrability,"// The evaluation should happen on the global scope, because of the wrapper; // that is created.; //; // We can't PushDeclContext, because we don't have scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:68,wrap,wrapper,68,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,1,['wrap'],['wrapper']
Integrability,// The event type. The exact meaning depends on the subtarget.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h:37,depend,depends,37,interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h,1,['depend'],['depends']
Integrability,// The exact meaning of the stall event type depends on the subtarget.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h:45,depend,depends,45,interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HWEventListener.h,1,['depend'],['depends']
Integrability,"// The expression form of @protocol, e.g. ""Protocol* p = @protocol(foo);"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:27,protocol,protocol,27,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,3,"['Protocol', 'protocol']","['Protocol', 'protocol']"
Integrability,"// The expression operand for decltype is in an unevaluated expression; // context, so side effects could result in unintended consequences.; // Exclude instantiation-dependent expressions, because 'decltype' is often; // used to build SFINAE gadgets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:167,depend,dependent,167,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['depend'],['dependent']
Integrability,"// The extra condition (fElement is not a TStreamerSTL) is to handle the case where fBranch is a; // TBranchElement and fElement is a TStreamerSTL. Without the extra condition we get an error; // message, although the vector (i.e. the TBranchElement) is accessible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TBranchProxy.cxx:196,message,message,196,tree/treeplayer/src/TBranchProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TBranchProxy.cxx,1,['message'],['message']
Integrability,"// The facility for ""private modules"" -- adjacent, optional module maps named; // module.private.modulemap that are supposed to define private submodules --; // may have different flavors of names: FooPrivate, Foo_Private and Foo.Private.; //; // Foo.Private is now deprecated in favor of Foo_Private. Users of FooPrivate; // should also rename to Foo_Private. Representing private as submodules; // could force building unwanted dependencies into the parent module and cause; // dependency cycles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:430,depend,dependencies,430,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,2,['depend'],"['dependencies', 'dependency']"
Integrability,"// The filename contained also the protocol and host: this was dropped; // in version > 1 to allow re-localization",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:35,protocol,protocol,35,tree/tree/src/TEntryList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx,1,['protocol'],['protocol']
Integrability,"// The first Interface we find may be a @class,; // which should only be treated as the source of; // truth in the absence of a true declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:13,Interface,Interface,13,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['Interface'],['Interface']
Integrability,"// The first parameter type is not allowed to be dependent. As a tentative; // DR resolution, we allow a dependent parameter type if it is the right; // type anyway, to allow destroying operator delete in class templates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:49,depend,dependent,49,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,2,['depend'],['dependent']
Integrability,"// The first pass over the block: collect all the loads which can have their; // loaded value hardened and all the loads that instead need their address; // hardened. During this walk we propagate load dependence for address; // hardened loads and also look for LFENCE to stop hardening wherever; // possible. When deciding whether or not to harden the loaded value or not,; // we check to see if any registers used in the address will have been; // hardened at this point and if so, harden any remaining address registers; // as that often successfully re-uses hardened addresses and minimizes; // instructions.; //; // FIXME: We should consider an aggressive mode where we continue to keep as; // many loads value hardened even when some address register hardening would; // be free (due to reuse).; //; // Note that we only need this pass if we are actually hardening loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:202,depend,dependence,202,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['depend'],['dependence']
Integrability,"// The first variant was originally CSK_None, encoded as 0. The new; // internal representation removes the need for this by wrapping the; // ChecksumInfo in an Optional, but to preserve Bitcode compatibility the 0; // encoding is reserved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h:125,wrap,wrapping,125,interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,1,['wrap'],['wrapping']
Integrability,"// The folds in here may rely on wrapping flags and special constants, so; // they can break up min/max idioms in some cases but not seemingly similar; // patterns.; // FIXME: It may be possible to enhance select folding to make this; // unnecessary. It may also be moot if we canonicalize to min/max; // intrinsics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:33,wrap,wrapping,33,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['wrap'],['wrapping']
Integrability,// The following are the private interface used by AttributePool.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h:33,interface,interface,33,interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,1,['interface'],['interface']
Integrability,"// The following case may be scalarized depending on the VF.; // The flag shows whether we can use a usual Call for vectorized; // version of the instruction.; // If we've found a variant at a previous VF, then stop looking. A; // vectorized variant of a function expects input in a certain shape; // -- basically the number of input registers, the number of lanes; // per register, and whether there's a mask required.; // We store a pointer to the variant in the VPWidenCallRecipe, so; // once we have an appropriate variant it's only valid for that VF.; // This will force a different vplan to be generated for each VF that; // finds a valid variant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:40,depend,depending,40,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['depend'],['depending']
Integrability,"// The following check extends the definition of `isConvergent` to; // assume a convergent instruction is dependent not only on additional; // conditions, but also on fewer conditions. LLVM does not have a; // MachineInstr attribute which expresses this extended definition, so; // it's necessary to use `isConvergent` to prevent illegally PRE-ing the; // subset of `isConvergent` instructions which do fall into this; // extended definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:106,depend,dependent,106,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['depend'],['dependent']
Integrability,// The following code is dependent on the order in which the DbgValues are; // constructed in ScheduleDAGInstrs::buildSchedGraph.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:25,depend,dependent,25,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,1,['depend'],['dependent']
Integrability,"// The following code pattern is handled:; // %3 = call i8* @llvm.stacksave(); // store i8* %3, i8** %saved_stack, align 8; // ...; // %4 = load i8*, i8** %saved_stack, align 8; // call void @llvm.stackrestore(i8* %4); // ...; // The goal is to remove the above four instructions,; // so we won't have instructions with r11 (stack pointer); // if eventually there is no variable length stack allocation.; // InstrCombine also tries to remove the above instructions,; // if it is proven safe (constant alloca etc.), but depending; // on code pattern, it may still miss some.; //; // With unconditionally removing these instructions, if alloca is; // constant, we are okay then. Otherwise, SelectionDag will complain; // since BPF does not support dynamic allocation yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp:519,depend,depending,519,interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp,1,['depend'],['depending']
Integrability,"// The following could be precomputed as they do not depend on the state.; // However, as they should take effect only if the UnwrappedLine does not fit; // into the ColumnLimit, they are checked here in the ContinuationIndenter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:53,depend,depend,53,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['depend'],['depend']
Integrability,"// The following function is not memory safe, because it takes ownership of var; // without moving it. It is not publicly available in the memory safe; // interfaces mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCollectionProxy.h:155,interface,interfaces,155,roofit/roofitcore/inc/RooCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCollectionProxy.h,1,['interface'],['interfaces']
Integrability,"// The following interface to AA is fashioned after DAGCombiner::isAlias and; // operates with MachineMemOperand offset with some important assumptions:; // - LLVM fundamentally assumes flat address spaces.; // - MachineOperand offset can *only* result from legalization and cannot; // affect queries other than the trivial case of overlap checking.; // - These offsets never wrap and never step outside of allocated objects.; // - There should never be any negative offsets here.; //; // FIXME: Modify API to hide this math from ""user""; // Even before we go to AA we can reason locally about some memory objects. It; // can save compile time, and possibly catch some corner cases not currently; // covered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:17,interface,interface,17,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,2,"['interface', 'wrap']","['interface', 'wrap']"
Integrability,// The following is a convenience method that returns an ObjCObjectPointerType; // for object declared using an interface.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:112,interface,interface,112,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['interface'],['interface']
Integrability,// The following portion depends only on the data type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:25,depend,depends,25,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,2,['depend'],['depends']
Integrability,"// The form has a byte size that doesn't depend on Params.; // If it's a fixed size, keep track of it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAbbreviationDeclaration.cpp:41,depend,depend,41,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAbbreviationDeclaration.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAbbreviationDeclaration.cpp,1,['depend'],['depend']
Integrability,"// The friend class needs to have access to the internal storage; // to be able to build dependency graph, can't declare only one; // function a 'friend' due to the incomplete declaration at this point; // and mutual dependency problems.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h:89,depend,dependency,89,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h,2,['depend'],['dependency']
Integrability,"// The frontend treats 'id' as a typedef to an ObjCObjectType,; // whereas 'id<protocol>' is treated as an ObjCPointerType. For the; // debug info, we want to emit 'id' in both cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:79,protocol,protocol,79,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['protocol'],['protocol']
Integrability,"// The full name of the stream that contains the contents of this injected; // source. This is built as a concatenation of the literal ""/src/files""; // plus the ""vname"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/PDBFileBuilder.h:66,inject,injected,66,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/PDBFileBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/PDBFileBuilder.h,1,['inject'],['injected']
Integrability,"// The function definition has parameters, so this will change behavior; // in C23. If there is a possible prototype, it comes before the; // function definition.; // FIXME: The declaration may have already been diagnosed as being; // deprecated in GetFullTypeForDeclarator() if it had no arguments, but; // there's no way to test for the ""changes behavior"" condition in; // SemaType.cpp when forming the declaration's function type. So, we do; // this awkward dance instead.; //; // If we have a possible prototype and it declares a function with a; // prototype, we don't want to diagnose it; if we have a possible; // prototype and it has no prototype, it may have already been; // diagnosed in SemaType.cpp as deprecated depending on whether; // -Wstrict-prototypes is enabled. If we already warned about it being; // deprecated, add a note that it also changes behavior. If we didn't; // warn about it being deprecated (because the diagnostic is not; // enabled), warn now that it is deprecated and changes behavior.; // This K&R C function definition definitely changes behavior in C23,; // so diagnose it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:725,depend,depending,725,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['depend'],['depending']
Integrability,"// The function epilogue should not depend on the current stack pointer!; // It should use the frame pointer only. This is mandatory because; // of alloca; we also take advantage of it to omit stack adjustments; // before returning.; //; // Note that when we go to restore the preserved register values we must; // not try to address their slots by using offsets from the stack pointer.; // That's because the stack pointer may have been moved during the function; // execution due to a call to alloca(). Rather, we must restore all; // preserved registers via offsets from the frame pointer value.; //; // Note also that when the current frame is being ""popped"" (by adjusting; // the value of the stack pointer) on function exit, we must (for the; // sake of alloca) set the new value of the stack pointer based upon; // the current value of the frame pointer. We can't just add what we; // believe to be the (static) frame size to the stack pointer because; // if we did that, and alloca() had been called during this function,; // we would end up returning *without* having fully deallocated all of; // the space grabbed by alloca. If that happened, and a function; // containing one or more alloca() calls was called over and over again,; // then the stack would grow without limit!; //; // RET is lowered to; // ld -4[%fp],%pc # modify %pc (two delay slots); // as the return address is in the stack frame and mov to pc is allowed.; // emitEpilogue emits; // mov %fp,%sp # restore the stack pointer; // ld -8[%fp],%fp # restore the caller's frame pointer; // before RET and the delay slot filler will move RET such that these; // instructions execute in the delay slots of the load to PC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp:36,depend,depend,36,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiFrameLowering.cpp,1,['depend'],['depend']
Integrability,// The function is going to insert a wait on everything in its prolog.; // This still needs to be careful if the call target is a load (e.g. a GOT; // load). We also need to check WAW dependency with saved PC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:184,depend,dependency,184,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['depend'],['dependency']
Integrability,// The function type can be built; call the appropriate routines to; // build it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp:56,rout,routines,56,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.cpp,1,['rout'],['routines']
Integrability,"// The function type itself was not dependent and therefore no; // substitution occurred. However, we still need to instantiate; // the function parameters themselves.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:36,depend,dependent,36,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['depend'],['dependent']
Integrability,"// The functions are used to bridge cling/clang/llvm compiled with no-rtti and; // ROOT (which uses rtti); ////////////////////////////////////////////////////////////////////////////////; /// Print a StackTrace!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:29,bridg,bridge,29,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['bridg'],['bridge']
Integrability,"// The group; the client receives it in the kPROOF_SESSIONTAG message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:62,message,message,62,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['message'],['message']
Integrability,"// The hot path for PartialDiagnostic is when we just used it to wrap an ID; // (typically so we have the flexibility of passing a more complex; // diagnostic into the callee, but that does not commonly occur).; //; // Split this out into a slow function for silly compilers (*cough*) which; // can't do decent partial inlining.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:65,wrap,wrap,65,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['wrap'],['wrap']
Integrability,// The id of the dependence set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:17,depend,dependence,17,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// The idea of the RooGenProdProj is that we divide two integral objects each; // created with this makeIntegral() function to get the normalized integral of; // a product. Therefore, we don't need to normalize the numerater and; // denominator integrals themselves. Doing the normalization would be; // expensive and it would cancel out anyway. However, if we don't specify an; // explicit normalization integral in createIntegral(), the last-used; // normalization set might be used to normalize the pdf, resulting in; // redundant computations.; //; // For this reason, the normalization set of the integrated pdfs is fixed to; // an empty set in this case. Note that in RooFit, a nullptr normalization; // set and an empty normalization set is not equivalent. The former implies; // taking the last-used normalization set, and the latter means explicitly no; // normalization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenProdProj.cxx:602,integrat,integrated,602,roofit/roofitcore/src/RooGenProdProj.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenProdProj.cxx,1,['integrat'],['integrated']
Integrability,// The identifier; // Objective-C supports type arguments and protocol references; // following an Objective-C object or object pointer; // type. Handle either one of them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:62,protocol,protocol,62,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['protocol'],['protocol']
Integrability,// The import path contains import-dependency nodes first.; // Save the node that was imported as dependency of the current node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:35,depend,dependency,35,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,2,['depend'],['dependency']
Integrability,// The index in GEP is signed. It is non-wrapping if it's derived from a NSW; // AddRec using a NSW operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:41,wrap,wrapping,41,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['wrap'],['wrapping']
Integrability,// The inheriting constructor was inlined; just inject its arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:48,inject,inject,48,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,1,['inject'],['inject']
Integrability,// The initial value for the dependency counters. It means that the; // dependencies are not calculated yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:29,depend,dependency,29,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['depend'],"['dependencies', 'dependency']"
Integrability,// The input chain to this libcall is the entry node of the function.; // Legalizing the call will automatically add the previous call to the; // dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:146,depend,dependence,146,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,2,['depend'],['dependence']
Integrability,// The instance methods on the root class can be messaged via the; // metaclass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:49,message,messaged,49,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['message'],['messaged']
Integrability,"// The instruction this candidate corresponds to. It helps us to rewrite a; // candidate with respect to its immediate basis. Note that one instruction; // can correspond to multiple candidates depending on how you associate the; // expression. For instance,; //; // (a + 1) * (b + 2); //; // can be treated as; //; // <Base: a, Index: 1, Stride: b + 2>; //; // or; //; // <Base: b, Index: 2, Stride: a + 1>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:194,depend,depending,194,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,1,['depend'],['depending']
Integrability,"// The integrated assembler doesn't implement e_flags setting behavior for; // -meabi=gnu (gcc -mabi={apcs-gnu,atpcs} passes -meabi=gnu to gas). For; // compatibility we accept but warn.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:7,integrat,integrated,7,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,2,['integrat'],['integrated']
Integrability,"// The integrators will warn, since we let them run until maxSteps",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRombergIntegrator.cxx:7,integrat,integrators,7,roofit/roofitcore/test/testRooRombergIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRombergIntegrator.cxx,1,['integrat'],['integrators']
Integrability,// The interface can be NULL.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:7,interface,interface,7,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['interface'],['interface']
Integrability,// The interface for an implementation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:7,interface,interface,7,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,1,['interface'],['interface']
Integrability,// The interface for this implementation must exist and be loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:7,interface,interface,7,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,1,['interface'],['interface']
Integrability,"// The interface says user should call NextIteration() before binding any parameters,; // this makes no sense at least for SQLite.; // We just return kTRUE here and wait for data to really do something.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/sql/sqlite/src/TSQLiteStatement.cxx:7,interface,interface,7,sql/sqlite/src/TSQLiteStatement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/sql/sqlite/src/TSQLiteStatement.cxx,1,['interface'],['interface']
Integrability,"// The interface says user should call NextResultRow() before getting any data,; // this makes no sense at least for SQLite.; // We just return kTRUE here and only do something on second request.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/sql/sqlite/src/TSQLiteStatement.cxx:7,interface,interface,7,sql/sqlite/src/TSQLiteStatement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/sql/sqlite/src/TSQLiteStatement.cxx,1,['interface'],['interface']
Integrability,// The interface symbol for a given class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp:7,interface,interface,7,interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp,1,['interface'],['interface']
Integrability,// The intrinsics below depend on rounding mode in MXCSR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:24,depend,depend,24,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['depend'],['depend']
Integrability,// The isScheduleHigh flag allows nodes with wraparound dependencies that; // cannot easily be modeled as edges with latencies to be scheduled as; // soon as possible in a top-down schedule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:45,wrap,wraparound,45,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,4,"['depend', 'wrap']","['dependencies', 'wraparound']"
Integrability,"// The language fp contract option FPM_FastHonorPragmas has the same effect; // as FPM_Fast in frontend. For simplicity, use FPM_Fast uniformly in; // frontend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h:19,contract,contract,19,interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h,1,['contract'],['contract']
Integrability,"// The last message on the path to final bug is the most important; // one. Since we traverse the path backwards, do not add the message; // if one has been previously added.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:12,message,message,12,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,2,['message'],['message']
Integrability,// The last operand of XTHeadMemPair instructions must be constant 3 or 4; // depending on the data width.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:78,depend,depending,78,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,1,['depend'],['depending']
Integrability,// The latency of dependence chains leading into this zone.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:18,depend,dependence,18,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['depend'],['dependence']
Integrability,"// The latency of dependence chains leading into this zone.; // For each node scheduled bottom-up: DLat = max DLat, N.Depth.; // For each cycle scheduled: DLat -= 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:18,depend,dependence,18,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['depend'],['dependence']
Integrability,// The line above the wrapped l_brace.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:22,wrap,wrapped,22,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['wrap'],['wrapped']
Integrability,"// The line in which we collect the resulting reconstructed output.; // To reduce special cases in the algorithm, the first level of the line; // contains a single null token that has the reconstructed incoming; // lines as children.; // In the end, we stich the lines together so that each subsequent line; // is a child of the last token of the previous line. This is necessary; // in order to format the overall expression as a single logical line -; // if we created separate lines, we'd format them with their own top-level; // indent depending on the semantic structure, which is not desired.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Macros.h:540,depend,depending,540,interpreter/llvm-project/clang/lib/Format/Macros.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Macros.h,1,['depend'],['depending']
Integrability,"// The linker on AIX is not happy with missing weak symbols. However,; // other TUs will not know whether the initialization routine exists; // so create an empty, init function to satisfy the linker.; // This is needed whenever a thread wrapper function is not used, and; // also when the symbol is weak.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:125,rout,routine,125,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,2,"['rout', 'wrap']","['routine', 'wrapper']"
Integrability,"// The list is now ordered with leafs first, we want the libraries to printed; // in the reverse order of dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:106,depend,dependency,106,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,1,['depend'],['dependency']
Integrability,// The load may have dependencies to unanalyzable stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:21,depend,dependencies,21,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['depend'],['dependencies']
Integrability,// The loads must not depend on one another.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:22,depend,depend,22,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['depend'],['depend']
Integrability,"// The log file is send either in HandleProcess or HandleSubmergers.; // The reason is that the order of various messages depend on the; // processing mode (sync/async) and/or merging mode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:113,message,messages,113,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,2,"['depend', 'message']","['depend', 'messages']"
Integrability,"// The logic for non-templates is handled in ASTContext::isSameEntity, so we; // don't have to bother checking 'DependsOnEnclosingTemplate' for a; // non-function-template.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:112,Depend,DependsOnEnclosingTemplate,112,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,1,['Depend'],['DependsOnEnclosingTemplate']
Integrability,"// The logic for summing over the histogram is borrowed from RooHistPdf with some differences:; //; // - a lambda function is used to inject the parameters for bin scaling into the RooDataHist::sum method; //; // - for simplicity, there is no check for the possibility of full-range integration with another overload of; // RooDataHist::sum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooParamHistFunc.cxx:134,inject,inject,134,roofit/roofit/src/RooParamHistFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooParamHistFunc.cxx,2,"['inject', 'integrat']","['inject', 'integration']"
Integrability,"// The loop branch contains the parallel loop metadata. In order to ensure; // that any parallel-loop-unaware optimization pass hasn't added loop-carried; // dependencies (thus converted the loop back to a sequential loop), check; // that all the memory instructions in the loop belong to an access group that; // is parallel to this loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:158,depend,dependencies,158,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,1,['depend'],['dependencies']
Integrability,"// The loop transformation construct has generated loops, but these; // may not have been generated yet due to being in a dependent; // context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtOpenMP.cpp:122,depend,dependent,122,interpreter/llvm-project/clang/lib/AST/StmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtOpenMP.cpp,1,['depend'],['dependent']
Integrability,"// The maximum length of a single segment is 64KB minus the size to insert a; // continuation. So if we are over that, inject a continuation between the; // previous member and the member that was just written, then end the previous; // segment after the continuation and begin a new one with the just-written; // member.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/ContinuationRecordBuilder.cpp:119,inject,inject,119,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/ContinuationRecordBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/ContinuationRecordBuilder.cpp,1,['inject'],['inject']
Integrability,"// The maximum number of things we should be trying to materialize at once; // right now is 4, depending on if we had an assume, a branch, and both used; // and of conditions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:95,depend,depending,95,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,1,['depend'],['depending']
Integrability,// The memory instruction can refer to the loop identifier metadata; // directly or indirectly through another list metadata (in case of; // nested parallel loops). The loop identifier metadata refers to; // itself so we can check both cases with the same routine.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:256,rout,routine,256,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,1,['rout'],['routine']
Integrability,"// The message is logged for debugging purposes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:7,message,message,7,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['message'],['message']
Integrability,"// The message send could be nil due to the receiver being nil.; // At this point in the path, the receiver should be live since we are at; // the message send expr. If it is nil, start tracking it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:7,message,message,7,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,2,['message'],['message']
Integrability,"// The message type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:7,message,message,7,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['message'],['message']
Integrability,// The messages logged in the current context but not yet written.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp:7,message,messages,7,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp,1,['message'],['messages']
Integrability,"// The method `NestedNameSpecifierLoc::getLocalSourceRange` *should*; // return the desired `SourceRange`, but there is a corner case. For a; // `DependentTemplateSpecializationType` this method returns its; // qualifiers as well, in other words in the example above this method; // returns `T::template X<U>::` instead of only `template X<U>::`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:146,Depend,DependentTemplateSpecializationType,146,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,1,['Depend'],['DependentTemplateSpecializationType']
Integrability,// The minimal length of the vector is limited by the real length of vector; // operations performed on the current platform. That's why several final; // reduction operations are performed on the vectors with the same; // architecture-dependent length.; // By default reductions need one shuffle per reduction level.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:236,depend,dependent,236,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,1,['depend'],['dependent']
Integrability,// The minimal length of the vector is limited by the real length of vector; // operations performed on the current platform. That's why several final; // reduction opertions are perfomed on the vectors with the same; // architecture-dependent length.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:234,depend,dependent,234,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,1,['depend'],['dependent']
Integrability,"// The mkdir failed __and__ we can not write to the target directory,; // let make sure the error message will be about the target directory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:98,message,message,98,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['message'],['message']
Integrability,// The model learns to pick one of the mask == 1 interferences. This is the; // name of the output tensor. The contract with the model is that the output; // will be guaranteed to be to a mask == 1 position. Using a macro here to; // avoid 'not used' warnings (and keep cond compilation to a minimum),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:111,contract,contract,111,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,1,['contract'],['contract']
Integrability,"// The module cannot contain symbols for dependent decls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp:41,depend,dependent,41,interpreter/cling/lib/Interpreter/DeclUnloader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp,1,['depend'],['dependent']
Integrability,"// The module may be out of date in the presence of file system races,; // or if one of its imports depends on header search paths that are not; // consistent with this ImportingInstance. Try again...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:100,depend,depends,100,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['depend'],['depends']
Integrability,"// The name is still dependent, so build a dependent expression again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:21,depend,dependent,21,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['depend'],['dependent']
Integrability,"// The name of the type being destroyed is a dependent name, and we; // couldn't find anything useful in scope. Just store the identifier and; // it's location, and we'll perform (qualified) name lookup again at; // template instantiation time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:45,depend,dependent,45,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['depend'],['dependent']
Integrability,// The need for symbol size depends on the symbol type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp:28,depend,depends,28,interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/IFSHandler.cpp,1,['depend'],['depends']
Integrability,"// The nested name specifier may be dependent, for example; // template <typename T> struct t {; // struct s1 { T f1(); };; // struct s2 : s1 { using s1::f1; };; // };; // template struct t<int>;; // Here, in using s1::f1, s1 refers to t<T>::s1;; // we need to substitute for t<int>::s1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:36,depend,dependent,36,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['depend'],['dependent']
Integrability,"// The nested-name-specifier never matters in a TemplateSpecializationType,; // because we can't have a dependent nested-name-specifier anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:104,depend,dependent,104,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['depend'],['dependent']
Integrability,// The new memory operation must have the same position as the old load in; // terms of memory dependency. Create a TokenFactor for the old load and new; // memory operation and update uses of the old load's output chain to use that; // TokenFactor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:95,depend,dependency,95,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['depend'],['dependency']
Integrability,"// The new type parameter got the implicit bound of 'id'. That's okay for; // categories and extensions (overwrite it later), but not for forward; // declarations and @interfaces, because those must be standalone.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:168,interface,interfaces,168,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['interface'],['interfaces']
Integrability,"// The new value depends on the predicate, true for != and false for ==.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:17,depend,depends,17,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['depend'],['depends']
Integrability,// The no-wrap behavior proved by IsIncrement(NUW|NSW) is only applicable if; // we actually do emit an addition. It does not apply if we emit a; // subtraction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:10,wrap,wrap,10,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['wrap'],['wrap']
Integrability,"// The object itself can't wrap around the address space, so it shouldn't be; // possible for the adds of the offsets to the split parts to overflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:27,wrap,wrap,27,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['wrap'],['wrap']
Integrability,"// The object type must be complete (or dependent), or; // C++11 [expr.prim.general]p3:; // Unlike the object expression in other contexts, *this is not required to; // be of complete type for purposes of class member access (5.2.5) outside; // the member function body.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:40,depend,dependent,40,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['depend'],['dependent']
Integrability,"// The offload action is expected to be used in four different situations.; //; // a) Set a toolchain/architecture/kind for a host action:; // Host Action 1 -> OffloadAction -> Host Action 2; //; // b) Set a toolchain/architecture/kind for a device action;; // Device Action 1 -> OffloadAction -> Device Action 2; //; // c) Specify a device dependence to a host action;; // Device Action 1 _; // \; // Host Action 1 ---> OffloadAction -> Host Action 2; //; // d) Specify a host dependence to a device action.; // Host Action 1 _; // \; // Device Action 1 ---> OffloadAction -> Device Action 2; //; // For a) and b), we just return the job generated for the dependences. For; // c) and d) we override the current action with the host/device dependence; // if the current toolchain is host/device and set the offload dependences; // info with the jobs obtained from the device/host dependence(s).; // If there is a single device option or has no host action, just generate; // the job for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:341,depend,dependence,341,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,6,['depend'],"['dependence', 'dependences']"
Integrability,"// The offsets are scaled by 1, 2 or 4 depending on the Opcode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:39,depend,depending,39,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['depend'],['depending']
Integrability,"// The only addition to fCacheReadMap is via an interface that takes; // a TFileCacheRead* so the C-cast is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:48,interface,interface,48,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['interface'],['interface']
Integrability,// The only odd/even lanes of operand 0 will only be demanded depending; // on whether this is a top/bottom instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:62,depend,depending,62,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,1,['depend'],['depending']
Integrability,"// The only other type of operand is an immediate or address. As above,; // real address operands should have used a context-dependent parse routine,; // so we treat any plain expression as an immediate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:125,depend,dependent,125,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,2,"['depend', 'rout']","['dependent', 'routine']"
Integrability,"// The only reason why ebIgnore nodes still need to be chained is that; // they might depend on the current rounding mode, and therefore must; // not be moved across instruction that may change that mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:86,depend,depend,86,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['depend'],['depend']
Integrability,"// The operand for sizeof and alignof is in an unevaluated expression context,; // so side effects could result in unintended consequences.; // Exclude instantiation-dependent expressions, because 'sizeof' is sometimes; // used to build SFINAE gadgets.; // FIXME: Should we consider instantiation-dependent operands to 'alignof'?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:166,depend,dependent,166,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['depend'],['dependent']
Integrability,// The operand to @synchronized is a full-expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:19,synchroniz,synchronized,19,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['synchroniz'],['synchronized']
Integrability,"// The order of S-reg depends on which instruction holds A0, instead of; // the order of register pair.; // e,g.; // mv a1, s1; // mv a0, s2 => cm.mva01s s2,s1; //; // mv a0, s2; // mv a1, s1 => cm.mva01s s2,s1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp:22,depend,depends,22,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp,1,['depend'],['depends']
Integrability,"// The order of fields in this struct depends on the order of; // varables in the argument which varies when changing how they; // are identified, leading to spurious test breakage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:38,depend,depends,38,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['depend'],['depends']
Integrability,// The ordered directive with depend clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:30,depend,depend,30,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['depend'],['depend']
Integrability,"// The original icmp gets replaced with the overflow value, maybe inverted; // depending on predicate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:79,depend,depending,79,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['depend'],['depending']
Integrability,"// The original live-range may have been shrunk to; // an empty live-range. It happens when it is dead, but; // we still keep it around to be able to rematerialize; // other values that depend on it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp:186,depend,depend,186,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,1,['depend'],['depend']
Integrability,"// The original load itself didn't wrap, so an offset within it doesn't.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:35,wrap,wrap,35,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['wrap'],['wrap']
Integrability,// The overflow may be detected via the add wrapping round.; // This is only valid for strict comparison!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:44,wrap,wrapping,44,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['wrap'],['wrapping']
Integrability,"// The page sink's callback when the data set gets committed will call this method to get the field's extra; // type information. This has to happen at the end of writing because the type information may change depending; // on the data that's written, e.g. for polymorphic types in the streamer field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:211,depend,depending,211,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,1,['depend'],['depending']
Integrability,"// The parameter type is dependent and is not a template template parameter,; // so there is nothing that we can deduce.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:25,depend,dependent,25,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['depend'],['dependent']
Integrability,"// The parameters are stored in a std::tuple, which does not provide runtime; // indexing capabilities. In order to enable runtime indexing, we use this; // structure to put the parameters into a std::array. Since the parameters; // are not all the same type, we use some type-erasure by wrapping the; // parameters in a template class that derives from a non-template superclass.; // Essentially, we are converting a std::tuple<Derived<Ts...>> to a; // std::array<Base*>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadic.h:288,wrap,wrapping,288,interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadic.h,1,['wrap'],['wrapping']
Integrability,// The parent of the injected class name is the class itself.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:21,inject,injected,21,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['inject'],['injected']
Integrability,"// The pgo-specific indirect call promotion function declared below is used by; // the pgo-driven indirect call promotion and sample profile passes. It's a; // wrapper around llvm::promoteCall, et al. that additionally computes !prof; // metadata. We place it in a pgo namespace so it's not confused with the; // generic utilities.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation.h:160,wrap,wrapper,160,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation.h,1,['wrap'],['wrapper']
Integrability,// The plus sign may need to be unindented depending on the style.; // FIXME: Add support for DontAlign.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:43,depend,depending,43,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,1,['depend'],['depending']
Integrability,"// The pointers to call/move/destroy functions are determined for each; // callable type (and called-as type, which determines the overload chosen).; // (definitions are out-of-line).; // By default, we need an object that contains all the different; // type erased behaviors needed. Create a static instance of the struct type; // here and each instance will contain a pointer to it.; // Wrap in a struct to avoid https://gcc.gnu.org/PR71954",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h:389,Wrap,Wrap,389,interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,1,['Wrap'],['Wrap']
Integrability,"// The previous value must not depend on the users of the recurrence phi. In; // that case, FOR is not a fixed order recurrence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:31,depend,depend,31,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,1,['depend'],['depend']
Integrability,"// The profile matcher applies hotness attributes directly for allocations,; // and those will cause us to generate calls to the hot/cold interfaces; // unconditionally. If supports-hot-cold-new was not enabled in the LTO; // link then assume we don't want these calls (e.g. not linking with; // the appropriate library, or otherwise trying to disable this behavior).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:138,interface,interfaces,138,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['interface'],['interfaces']
Integrability,"// The profile should not depend on whether the array is expanded or; // not, but we don't want to profile the array filler many times for; // a large array. So treat all equal trailing elements as the filler.; // Elements are profiled in reverse order to support this, and the; // first profiled element is followed by a count. For example:; //; // ['a', 'c', 'x', 'x', 'x'] is profiled as; // [5, 'x', 3, 'c', 'a']",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp:26,depend,depend,26,interpreter/llvm-project/clang/lib/AST/APValue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp,1,['depend'],['depend']
Integrability,"// The profile summary is one or more (Cutoff, MinCount, NumCounts) triplets.; // The semantics of counts depend on the type of profile. For instrumentation; // profile, counts are block counts and for sample profile, counts are; // per-line samples. Given a target counts percentile, we compute the minimum; // number of counts needed to reach this target and the minimum among these; // counts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ProfileSummary.h:106,depend,depend,106,interpreter/llvm-project/llvm/include/llvm/IR/ProfileSummary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ProfileSummary.h,1,['depend'],['depend']
Integrability,"// The ptx syntax and format is very different from that usually seem in a .s; // file,; // therefore we are not able to use the MCAsmStreamer interface here.; //; // We are handcrafting the output method here.; //; // A better approach is to clone the MCAsmStreamer to a MCPTXAsmStreamer; // (subclass of MCStreamer).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h:143,interface,interface,143,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,1,['interface'],['interface']
Integrability,// The public interface to this file...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:14,interface,interface,14,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['interface'],['interface']
Integrability,// The range is implicitly used as a placeholder when it is dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:60,depend,dependent,60,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['depend'],['dependent']
Integrability,"// The range is wrapped. We decompose it into two ranges, [0, Upper) and; // [Lower, 0).; // Handle [Lower, 0)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:16,wrap,wrapped,16,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,1,['wrap'],['wrapped']
Integrability,"// The range is wrapped. We decompose it into two ranges, [0, Upper) and; // [Lower, 0).; // Handle [Lower, 0) == [Lower, Max]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:16,wrap,wrapped,16,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,1,['wrap'],['wrapped']
Integrability,"// The range may or may not wrap around, but both limits are valid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:28,wrap,wrap,28,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['wrap'],['wrap']
Integrability,// The range starts above what's possible but ends within it (wrap).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:62,wrap,wrap,62,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['wrap'],['wrap']
Integrability,"// The range wraps around, but all lower values are not possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:13,wrap,wraps,13,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['wrap'],['wraps']
Integrability,// The range wraps but is outside the symbol's set of possible values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:13,wrap,wraps,13,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['wrap'],['wraps']
Integrability,"// The ranges-v3 library uses an odd pattern of a top-level ""||"" with; // a left-hand side that is value-dependent but never true. Identify; // the idiom and ignore that term.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:105,depend,dependent,105,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['depend'],['dependent']
Integrability,// The real basic parser is just a template wrapper that provides a typedef for; // the provided data type.; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h:44,wrap,wrapper,44,interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,1,['wrap'],['wrapper']
Integrability,"// The received message included an empty dataset, with only the name; // defined: assume that a dataset, stored on the PROOF master by that; // name, should be processed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:16,message,message,16,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['message'],['message']
Integrability,"// The receiver was nil, and hence the method was skipped.; // Register a BugReporterVisitor to issue a message telling us how; // the receiver was null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:104,message,message,104,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,1,['message'],['message']
Integrability,"// The record bytes are not present, and it is the; // responsibility of the visitor callback interface to; // supply the bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/CVTypeVisitor.h:94,interface,interface,94,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/CVTypeVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/CVTypeVisitor.h,1,['interface'],['interface']
Integrability,"// The record forms set the condition register based on a signed comparison; // with zero (so says the ISA manual). This is not as straightforward as it; // seems, however, because this is always a 64-bit comparison on PPC64, even; // for instructions that are 32-bit in nature (like slw for example).; // So, on PPC32, for unsigned comparisons, we can use the record forms only; // for equality checks (as those don't depend on the sign). On PPC64,; // we are restricted to equality for unsigned 64-bit comparisons and for; // signed 32-bit comparisons the applicability is more restricted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:419,depend,depend,419,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['depend'],['depend']
Integrability,// The remaining checks depend on the data arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:24,depend,depend,24,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,2,['depend'],['depend']
Integrability,"// The remaining entries in our list of leaf nodes are the external; // dependents (x) and parameters (p) of the projection. Patch them back; // into the theClone. This orphans the nodes they replace, but the orphans; // are still in the cloneList and so will be cleaned up eventually.; //cout << ""redirection leafNodes : "" ; leafNodes.Print(""1"") ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:72,depend,dependents,72,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['depend'],['dependents']
Integrability,"// The remaining operators just wrap the logic of APInt, but retain the; // signedness information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h:32,wrap,wrap,32,interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APSInt.h,1,['wrap'],['wrap']
Integrability,"// The representation depends on the bound values. If the lower value; // is zero, treat the pair as the elements count. Otherwise, just use; // the pair, as they are representing arrays in languages other than; // C/C++ and the lower limit is not zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp:22,depend,depends,22,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp,1,['depend'],['depends']
Integrability,"// The required interface:; // - A set of three ""evaluate"" functions. Each returns ""true"" if the; // computation succeeded, ""false"" otherwise.; // (1) Given an instruction MI, and the map with input values ""Inputs"",; // compute the set of output values ""Outputs"". An example of when; // the computation can ""fail"" is if MI is not an instruction that; // is recognized by the evaluator.; // (2) Given a register R (as reg:subreg), compute the cell that; // corresponds to the ""subreg"" part of the given register.; // (3) Given a branch instruction BrI, compute the set of target blocks.; // If the branch can fall-through, add null (0) to the list of; // possible targets.; // - A function ""rewrite"", that given the cell map after propagation,; // could rewrite instruction MI in a more beneficial form. Return; // ""true"" if a change has been made, ""false"" otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:16,interface,interface,16,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,1,['interface'],['interface']
Integrability,// The result of VP reductions depends on the mask and evl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:31,depend,depends,31,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,1,['depend'],['depends']
Integrability,"// The result of the bottom bits of an integer multiply can be; // inferred by looking at the bottom bits of both operands and; // multiplying them together.; // We can infer at least the minimum number of known trailing bits; // of both operands. Depending on number of trailing zeros, we can; // infer more bits, because (a*b) <=> ((a/m) * (b/n)) * (m*n) assuming; // a and b are divisible by m and n respectively.; // We then calculate how many of those bits are inferrable and set; // the output. For example, the i8 mul:; // a = XXXX1100 (12); // b = XXXX1110 (14); // We know the bottom 3 bits are zero since the first can be divided by; // 4 and the second by 2, thus having ((12/4) * (14/2)) * (2*4).; // Applying the multiplication to the trimmed arguments gets:; // XX11 (3); // X111 (7); // -------; // XX11; // XX11; // XX11; // XX11; // -------; // XXXXX01; // Which allows us to infer the 2 LSBs. Since we're multiplying the result; // by 8, the bottom 3 bits will be 0, so we can infer a total of 5 bits.; // The proof for this can be described as:; // Pre: (C1 >= 0) && (C1 < (1 << C5)) && (C2 >= 0) && (C2 < (1 << C6)) &&; // (C7 == (1 << (umin(countTrailingZeros(C1), C5) +; // umin(countTrailingZeros(C2), C6) +; // umin(C5 - umin(countTrailingZeros(C1), C5),; // C6 - umin(countTrailingZeros(C2), C6)))) - 1); // %aa = shl i8 %a, C5; // %bb = shl i8 %b, C6; // %aaa = or i8 %aa, C1; // %bbb = or i8 %bb, C2; // %mul = mul i8 %aaa, %bbb; // %mask = and i8 %mul, C7; // =>; // %mask = i8 ((C1*C2)&C7); // Where C5, C6 describe the known bits of %a, %b; // C1, C2 describe the known bottom bits of %a, %b.; // C7 describes the mask of the known bits of the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/KnownBits.cpp:248,Depend,Depending,248,interpreter/llvm-project/llvm/lib/Support/KnownBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/KnownBits.cpp,1,['Depend'],['Depending']
Integrability,"// The result of this routine is by definition a fully qualified name. There is an implicit starting '::' at the beginning of the name.; // Depending on how the user typed their code, in particular typedef declarations, we may end up with an explicit '::' being; // part of the result string. For consistency, we must remove it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:22,rout,routine,22,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,2,"['Depend', 'rout']","['Depending', 'routine']"
Integrability,"// The returned value depends on the PDB producer,; // but 0 is guaranteed to mean ""no compression"".; // The enum PDB_SourceCompression lists known return values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/IPDBInjectedSource.h:22,depend,depends,22,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/IPDBInjectedSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/IPDBInjectedSource.h,1,['depend'],['depends']
Integrability,"// The right formula for StdDev error depends on 4th momentum (see Kendall-Stuart Vol 1 pag 243); // formula valid for only gaussian distribution ( 4-th momentum = 3 * sigma^4 )",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:38,depend,depends,38,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['depend'],['depends']
Integrability,// The roots of the dependency DAG of AST files. This is used; // to implement short-circuiting logic when running DFS over the dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:20,depend,dependency,20,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,2,['depend'],"['dependencies', 'dependency']"
Integrability,// The routines below are provided in a separate header but referenced here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTree.h:7,rout,routines,7,interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTree.h,1,['rout'],['routines']
Integrability,// The rsqrt contraction increases accuracy from ~2ulp to ~1ulp.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:13,contract,contraction,13,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,2,['contract'],['contraction']
Integrability,// The scheduling region got new instructions at the lower end (or it is a; // new region for the first bundle). This makes it necessary to; // recalculate all dependencies.; // It is seldom that this needs to be done a second time after adding the; // initial bundle to the region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:160,depend,dependencies,160,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['depend'],['dependencies']
Integrability,"// The scope spec must refer to a class, or be dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:47,depend,dependent,47,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['depend'],['dependent']
Integrability,"// The scratch registers here with the EarlyClobber | Define | Implicit; // flags is used to persuade the register allocator and the machine; // verifier to accept the usage of this register. This has to be a real; // register which has an UNDEF value but is dead after the instruction which; // is unique among the registers chosen for the instruction.; // The EarlyClobber flag has the semantic properties that the operand it is; // attached to is clobbered before the rest of the inputs are read. Hence it; // must be unique among the operands to the instruction.; // The Define flag is needed to coerce the machine verifier that an Undef; // value isn't a problem.; // The Dead flag is needed as the value in scratch isn't used by any other; // instruction. Kill isn't used as Dead is more precise.; // The implicit flag is here due to the interaction between the other flags; // and the machine verifier.; // For correctness purpose, a new pseudo is introduced here. We need this; // new pseudo, so that FastRegisterAllocator does not see an ll/sc sequence; // that is spread over >1 basic blocks. A register allocator which; // introduces (or any codegen infact) a store, can violate the expectations; // of the hardware.; //; // An atomic read-modify-write sequence starts with a linked load; // instruction and ends with a store conditional instruction. The atomic; // read-modify-write sequence fails if any of the following conditions; // occur between the execution of ll and sc:; // * A coherent store is completed by another process or coherent I/O; // module into the block of synchronizable physical memory containing; // the word. The size and alignment of the block is; // implementation-dependent.; // * A coherent store is executed between an LL and SC sequence on the; // same processor to the block of synchornizable physical memory; // containing the word.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:1591,synchroniz,synchronizable,1591,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,2,"['depend', 'synchroniz']","['dependent', 'synchronizable']"
Integrability,// The section data is padded to pointer size bytes.; //; // FIXME: Is this machine dependent?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:84,depend,dependent,84,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,1,['depend'],['dependent']
Integrability,"// The select routine does not have access to the LoadSDNode instance, so; // pass along the extension information",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:14,rout,routine,14,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['rout'],['routine']
Integrability,"// The semantics of dynamic initialization of variables with static or thread; // storage duration depends on whether they are declared at block-scope. The; // initialization of such variables at block-scope can be aborted with an; // exception and later retried (per C++20 [stmt.dcl]p4), and recursive entry; // to their initialization has undefined behavior (also per C++20; // [stmt.dcl]p4). For such variables declared at non-block scope, exceptions; // lead to termination (per C++20 [except.terminate]p1), and recursive; // references to the variables are governed only by the lifetime rules (per; // C++20 [class.cdtor]p2), which means such references are perfectly fine as; // long as they avoid touching memory. As a result, block-scope variables must; // not be marked as initialized until after initialization completes (unless; // the mark is reverted following an exception), but non-block-scope variables; // must be marked prior to initialization so that recursive accesses during; // initialization do not restart initialization.; // Variables used when coping with thread-safe statics and exceptions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:99,depend,depends,99,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['depend'],['depends']
Integrability,"// The semantics of fAddress and fObject are violated.; // Assume the user changed the pointer on us.; // Note: The cast is here because we want to be able to; // be called from the constant get functions.; // FIXME: Disable the check/warning TTree until we add a missing interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchElement.h:272,interface,interface,272,tree/tree/inc/TBranchElement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchElement.h,1,['interface'],['interface']
Integrability,"// The session working dir depends on the role",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx:27,depend,depends,27,proof/proof/src/TProofLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx,1,['depend'],['depends']
Integrability,// The shape of certain elements of the AST can vary depending on the; // language. We currently only support C++.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/ControlFlowContext.cpp:53,depend,depending,53,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/ControlFlowContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/ControlFlowContext.cpp,1,['depend'],['depending']
Integrability,// The shift instructions only modify ZF if their shift count is non-zero.; // N.B.: The processor truncates the shift count depending on the encoding.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:125,depend,depending,125,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['depend'],['depending']
Integrability,"// The sign/zero extend pseudo-instruction does two shifts, with the shift; // amounts dependent on the XLEN.; //; // The expansion looks like this; //; // SLLI rd, rs, XLEN - Width; // SR[A|R]I rd, rd, XLEN - Width",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:87,depend,dependent,87,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,1,['depend'],['dependent']
Integrability,"// The simplification queries below may return the original value. Consider:; // %div = udiv i32 %arg, %arg2; // %mul = mul nsw i32 %div, %arg2; // %cmp = icmp eq i32 %mul, %arg; // %sel = select i1 %cmp, i32 %div, i32 undef; // Replacing %arg by %mul, %div becomes ""udiv i32 %mul, %arg2"", which; // simplifies back to %arg. This can only happen because %mul does not; // dominate %div. To ensure a consistent return value contract, we make sure; // that this case returns nullptr as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:423,contract,contract,423,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['contract'],['contract']
Integrability,"// The size of the entire header depends upon the filename the binary is being; // written to, but the rest of the header is fixed in size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOLayoutBuilder.h:33,depend,depends,33,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOLayoutBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOLayoutBuilder.h,1,['depend'],['depends']
Integrability,// The size of the n field depends on the element size; // The register class also depends on this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp:27,depend,depends,27,interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Disassembler/MipsDisassembler.cpp,2,['depend'],['depends']
Integrability,"// The slot depends on the capacity and WriteClass has induced an increase.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:12,depend,depends,12,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,1,['depend'],['depends']
Integrability,"// The slot depends on the capacity and WriteClass might induce an increase.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:12,depend,depends,12,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,1,['depend'],['depends']
Integrability,// The stitching of the branched code back together depends on whether we're; // doing full unswitching or not with the exception that we always want to; // nuke the initial terminator placed in the split block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:52,depend,depends,52,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['depend'],['depends']
Integrability,// The store may have dependencies to unanalyzable loads and; // stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:22,depend,dependencies,22,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['depend'],['dependencies']
Integrability,// The strategy assumes that we can efficiently load power-of-two widths.; // The routine chops the vector into the largest vector loads with the same; // element type or scalar loads and then recombines it to the widen vector; // type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:82,rout,routine,82,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['rout'],['routine']
Integrability,// The strategy assumes that we can efficiently store power-of-two widths.; // The routine chops the vector into the largest vector stores with the same; // element type or scalar stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:83,rout,routine,83,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['rout'],['routine']
Integrability,"// The table will contain these structs that point to the sled, the function; // containing the sled, and what kind of sled (and whether they should always; // be instrumented). We also use a version identifier that the runtime can use; // to decide what to do with the sled, depending on the version of the sled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:276,depend,depending,276,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,1,['depend'],['depending']
Integrability,// The template-name in the simple-template-id refers to; // something other than a type template. Give an appropriate; // error message and skip to the ';'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:129,message,message,129,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['message'],['message']
Integrability,// The terminating condition depends on the direction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:29,depend,depends,29,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['depend'],['depends']
Integrability,// The truncated value wraps around. Check if we can do better than fullset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:23,wrap,wraps,23,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,1,['wrap'],['wraps']
Integrability,"// The two addresses refer to our first dependent variable and; // parameter, respectively, as declared in the rdl file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooBukinPdf.cxx:40,depend,dependent,40,roofit/roofit/src/RooBukinPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooBukinPdf.cxx,2,['depend'],['dependent']
Integrability,"// The type argument, wrapped in substitution sugar, gets reused as the; // first template argument in the synthetic template argument list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:22,wrap,wrapped,22,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['wrap'],['wrapped']
Integrability,"// The type is not known to the interpreter, but we don't want to error out; // here, rather if/when this column is used in jitted code, so we inject a broken but telling type name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:143,inject,inject,143,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['inject'],['inject']
Integrability,"// The type may have been previously dependent and not now, which means we; // might have to implicit cast the argument to the new type, for example:; // template<auto T, decltype(T) U>; // concept C = sizeof(U) == 4;; // void foo() requires C<2, 'a'> { }; // When normalizing foo(), we first form the normalized constraints of C:; // AtomicExpr(sizeof(U) == 4,; // U=SubstNonTypeTemplateParmExpr(Param=U,; // Expr=DeclRef(U),; // Type=decltype(T))); // Then we substitute T = 2, U = 'a' into the parameter mapping, and need to; // produce:; // AtomicExpr(sizeof(U) == 4,; // U=SubstNonTypeTemplateParmExpr(Param=U,; // Expr=ImpCast(; // decltype(2),; // SubstNTTPE(Param=U, Expr='a',; // Type=char)),; // Type=decltype(2))); // The call to CheckTemplateArgument here produces the ImpCast.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:37,depend,dependent,37,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['depend'],['dependent']
Integrability,"// The type of __null will be int or long, depending on the size of; // pointers on the target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:43,depend,depending,43,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['depend'],['depending']
Integrability,"// The type of the conditional operator depends on the type of the conditional; // to support the GCC vector conditional extension. Additionally,; // [temp.dep.expr] does specify state that this should be dependent on ALL sub; // expressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:40,depend,depends,40,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,2,['depend'],"['dependent', 'depends']"
Integrability,"// The type of this expr depends on a template parameter, or an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:25,depend,depends,25,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,1,['depend'],['depends']
Integrability,// The type-to-delete may not be a pointer if it's a dependent type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:53,depend,dependent,53,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,1,['depend'],['dependent']
Integrability,"// The types we specifically need to rebuild are:; // - typenames, typeofs, and decltypes; // - types which will become injected class names; // Of course, we also need to rebuild any type referencing such a; // type. It's safest to just say ""dependent"", but we call out a; // few cases here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:120,inject,injected,120,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,"['depend', 'inject']","['dependent', 'injected']"
Integrability,// The underlying objects alias; test accesses for dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:51,depend,dependence,51,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['depend'],['dependence']
Integrability,"// The underlying type is dependent on a template parameter,; // we have no idea what it is yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingTypedefInfo.cxx:26,depend,dependent,26,core/metacling/src/TClingTypedefInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingTypedefInfo.cxx,1,['depend'],['dependent']
Integrability,"// The use we are examining is inserted into an aggregate. Our liveness; // depends on all uses of that aggregate, but if it is used as a return; // value, only index at which we were inserted counts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:76,depend,depends,76,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,1,['depend'],['depends']
Integrability,"// The value V returned from this function is used differently depending; // on whether MemInst is a load or a store. If it's a load, we will replace; // MemInst with V, if it's a store, we will check if V is the same as the; // available value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:63,depend,depending,63,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['depend'],['depending']
