quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Energy Efficiency,"ep86_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('DSD-PBEP86'); # Tab in, trailing newlines; sup.set_description(' DSD-PBEP86 Dispersion-corrected SCS Double Hybrid XC Functional (opt. for -D2)\n'); # Tab in, trailing newlines; sup.set_citation(' S. Kozuch, Phys. Chem. Chem. Phys., 13, 20104, 2011\n'). # Add member functionals; X = build_functional('PBE_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('P86_C'); C.set_alpha(0.45); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.68); sup.set_c_alpha(1.0); sup.set_c_ss_alpha(0.23); sup.set_c_os_alpha(0.51). # => -D2 <=. sup.set_dispersion(PsiMod.Dispersion.build('-D2', 0.29)). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_dsd_pbepbe_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('DSD-PBEPBE'); # Tab in, trailing newlines; sup.set_description(' DSD-PBEPBE Dispersion-corrected SCS Double Hybrid XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' S. Kozuch, Phys. Chem. Chem. Phys., 13, 20104, 2011\n'). # Add member functionals; X = build_functional('PBE_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('PBE_C'); C.set_alpha(0.51); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.66); sup.set_c_alpha(1.0); sup.set_c_ss_alpha(0.12); sup.set_c_os_alpha(0.53). # => -D2 <=. sup.set_dispersion(PsiMod.Dispersion.build('-D2', 0.42)). # => End User-Customization <= #. # Call this la",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/functional.html:67795,allocate,allocate,67795,psi4manual/4.0b3/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency,"epa(0). pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cc17; Single point energies of multiple excited states with EOM-CCSD. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). fnocc2; Test G2 method for H2O. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. dft-g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:29988,energy,energy,29988,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"epa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. mp2-module; OMP2 cc-pVDZ energy for the H2O molecule. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. dft-bench-interaction; functionals + DFTD3 interaction energies vs. other programs. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dcft6; DCFT calculation for the triplet O2 using DC-06, DC-12 and CEPA0 functionals. Only two-step algorithm is tested. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mode. dfmp2-ecp; He-Ne dimer MP2 energies with ECP, Ne electrons correlated then frozen. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:7039,energy,energy,7039,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"epsilon_a().to_array() if wfn.epsilon_a() else None,; 'epsilon_b': wfn.epsilon_b().to_array() if wfn.epsilon_b() else None,; 'frequencies': wfn.frequencies().to_array() if wfn.frequencies() else None; },; 'dimension': {; 'doccpi': wfn.doccpi().to_tuple(),; 'frzcpi': wfn.frzcpi().to_tuple(),; 'frzvpi': wfn.frzvpi().to_tuple(),; 'nalphapi': wfn.nalphapi().to_tuple(),; 'nbetapi': wfn.nbetapi().to_tuple(),; 'nmopi': wfn.nmopi().to_tuple(),; 'nsopi': wfn.nsopi().to_tuple(),; 'soccpi': wfn.soccpi().to_tuple(); },; 'int': {; 'nalpha': wfn.nalpha(),; 'nbeta': wfn.nbeta(),; 'nfrzc': wfn.nfrzc(),; 'nirrep': wfn.nirrep(),; 'nmo': wfn.nmo(),; 'nso': wfn.nso(),; 'print': wfn.get_print(),; },; 'string': {; 'name': wfn.name(),; 'module': wfn.module(),; 'basisname': wfn.basisset().name(); },; 'boolean': {; 'PCM_enabled': wfn.PCM_enabled(),; 'same_a_b_dens': wfn.same_a_b_dens(),; 'same_a_b_orbs': wfn.same_a_b_orbs(),; 'basispuream': wfn.basisset().has_puream(); },; 'float': {; 'energy': wfn.energy(),; 'efzc': wfn.efzc(),; 'dipole_field_x': wfn.get_dipole_field_strength()[0],; 'dipole_field_y': wfn.get_dipole_field_strength()[1],; 'dipole_field_z': wfn.get_dipole_field_strength()[2]; },; 'floatvar': wfn.scalar_variables(),; 'matrixarr': {k: v.to_array() for k, v in wfn.array_variables().items()}; } # yapf: disable. if filename is not None:; if not filename.endswith('.npy'): filename += '.npy'; np.save(filename, wfn_data, allow_pickle=True). return wfn_data. core.Wavefunction.to_file = _core_wavefunction_to_file. ## Python JK helps. @staticmethod; def _core_jk_build(; orbital_basis: core.BasisSet,; aux: Optional[core.BasisSet] = None,; jk_type: Optional[str] = None,; do_wK: Optional[bool] = None,; memory: Optional[int] = None,; ) -> core.JK:; """"""; Constructs a Psi4 JK object from an input basis. Parameters; ----------; orbital_basis; Orbital basis to use in the JK object.; aux; Optional auxiliary basis set for density-fitted tensors. Defaults; to the :term:`DF_BASIS_SCF <DF_BASIS_SCF (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:12996,energy,energy,12996,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,8,['energy'],['energy']
Energy Efficiency,"epsilon_a(): compare_vectors(expected.epsilon_a(), computed.epsilon_a(), digits, 'compare epsilon_a'); if expected.epsilon_b(): compare_vectors(expected.epsilon_b(), computed.epsilon_b(), digits, 'compare epsilon_b'); if expected.frequencies(): compare_vectors(expected.frequencies(), computed.frequencies(), digits, 'compare frequencies'); # yapf: enable; compare_integers(expected.nalpha(), computed.nalpha(), 'compare nalpha'); compare_integers(expected.nbeta(), computed.nbeta(), 'compare nbeta'); compare_integers(expected.nfrzc(), computed.nfrzc(), 'compare nfrzc'); compare_integers(expected.nirrep(), computed.nirrep(), 'compare nirrep'); compare_integers(expected.nmo(), computed.nmo(), 'compare nmo'); compare_integers(expected.nso(), computed.nso(), 'compare nso'); compare_strings(expected.name(), computed.name(), 'compare name'); compare_values(expected.energy(), computed.energy(), digits, 'compare energy'); compare_values(expected.efzc(), computed.efzc(), digits, 'compare frozen core energy'); compare_values(expected.get_dipole_field_strength()[0],; computed.get_dipole_field_strength()[0], digits, 'compare dipole field strength x'); compare_values(expected.get_dipole_field_strength()[1],; computed.get_dipole_field_strength()[1], digits, 'compare dipole field strength y'); compare_values(expected.get_dipole_field_strength()[2],; computed.get_dipole_field_strength()[2], digits, 'compare dipole field strength z'). compare_strings(expected.basisset().name(), computed.basisset().name(), 'compare basis set name'); compare_integers(expected.basisset().nbf(), computed.basisset().nbf(), 'compare number of basis functions in set'); compare_integers(expected.basisset().nprimitive(),; computed.basisset().nprimitive(), 'compare total number of primitives in basis set'). compare_strings(expected.molecule().name(), computed.molecule().name(), 'compare molecule name'); compare_strings(expected.molecule().get_full_point_group(),; computed.molecule().get_full_point_group(), 'compar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html:16083,energy,energy,16083,psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,1,['energy'],['energy']
Energy Efficiency,"ept IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.strip().split(None, 10); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if label == 'electronic energy' and s[8:10] == ['electronic', 'energy']:; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); if label == 'electronic gradient' and s[8:10] == ['electronic', 'gradient']:; E = ast.literal_eval(s[-1]); psi4.print_out('%s RESULT: electronic gradient = %r\n' % (quantity, E)); freagent.close(); return E. [docs]def prepare_options_for_modules(changedOnly=False, commandsInsteadDict=False):; """"""Function to return a string of commands to replicate the; current state of user-modified options. Used to capture C++; options information for distributed (sow/reap) input files. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Need some option to get either all or changed. - Need some option to either get dict or set string or psimod command list. - command return doesn't revoke has_changed setting for unchanged with changedOnly=False. """"""; modules = [; # PSI4 Modules; ""ADC"", ""CCENERGY"", ""CCEOM"", ""CCDENSITY"", ""CCLAMBDA"", ""CCHB",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:9420,energy,energy,9420,psi4manual/1.0.0/_modules/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html,2,['energy'],['energy']
Energy Efficiency,"ept ImportError:; raise ImportError(; """"""Python module deepdiff not found. Solve by installing it: `conda install deepdiff -c conda-forge` or `pip install deepdiff`""""""; ). # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; header_diff = DeepDiff(; ref_intdump,; intdump,; ignore_order=True,; exclude_paths={""root['enuc']"", ""root['hcore']"", ""root['eri']"", ""root['epsilon']""}); if header_diff:; message = (""\tComputed FCIDUMP file header does not match expected header.\n""); raise TestComparisonError(header_diff). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). if (pass_1el and pass_2el and pass_scf and pass_mp2):; success(label). return True. [docs]def energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html:13633,energy,energy,13633,psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html,1,['energy'],['energy']
Energy Efficiency,"ept for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. scf7; Tests SCF gradient in the presence of a dipole field. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. ao-casscf-sp; CASSCF/6-31G** energy point. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). dfcasscf-sp; CASSCF/6-31G** energy point. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. omp2-3; OMP2 cc-pVDZ energy for the NO radical. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:13277,energy,energy,13277,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"eption. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""; message: str; iteration: int; wfn: core.Wavefunction. def __init__(self, eqn_description: str, iteration: int, wfn: core.Wavefunction):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]; class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF preiterations).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. """"""; message: str; iteration: int; wfn: core.Wavefunction; e_conv: float; d_conv: float. def __init__(; self,; eqn_description: str,; iteration: int,; wfn: core.Wavefunction,; e_conv: float,; d_conv: float,; ):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]; class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn; Wavefunction at time of exception; what; What we were trying to solve for (singlets/triplets, irrep) when we failed to converge; stats; Dictionary of convergence statistics of last iteration.; Keys are:. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue fr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:7107,energy,energy,7107,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,6,['energy'],['energy']
Energy Efficiency,"eption.; stats; Dictionary of conditions for which method request was made.; Keys are:. - driver : {""energy"", ""gradient"", ""hessian"", ""properties""}; - derivative_int : {0, 1, 2, ""prop""}, integer representation of driver; - method : str, model/method/level-of-theory; - link : str, link address to table in docs; - method_type : (str, str), raw value and str repr of governing variable and algorithm; - reference : (str, str), raw value and str repr of reference type; - qc_module : (str, str), raw value and str repr of targeted implementation; - fcae : (str, str), raw value and str repr of all-electron/frozen-core status. """"""; message: str; stats: Dict[str, Any]. def __init__(self, circs: List[str]):. if circs[0].endswith(""_property""):; driver = ""properties""; derivative_int = ""prop"" # differs from QCSchema Driver.derivative_int that uses `0` here; elif circs[0].endswith(""_hessian""):; driver = ""hessian""; derivative_int = 2; elif circs[0].endswith(""_gradient""):; driver = ""gradient""; derivative_int = 1; else:; driver = ""energy""; derivative_int = 0. docslink = docs_table_link(circs[1], mode=(""summary"" if circs[5] == """" else ""details"")); all_electron = circs[6] if (len(circs) == 7) else ""(n/a)"". stats = {; # use QCSchema AtomicInput keys where available; ""driver"": driver,; ""derivative_int"": derivative_int,; ""method"": circs[1],; ""link"": docslink,; ""method_type"": (circs[3], f""{circs[2].upper()}={circs[3]}""),; ""reference"": (circs[4], f""REFERENCE={circs[4]}""),; ""qc_module"": (circs[5], f""QC_MODULE={circs[5] or '(auto)'}""),; # Note on fcae: most select_* functions don't consider this circumstance. Index 0 of tuple documents this.; # Index 1 of tuple always returns the circumstance, regardless of whether considered, so user can look up availability in table.; ""fcae"": (all_electron, f""FREEZE_CORE={core.get_global_option('FREEZE_CORE')}""),; }. # Note that this message is not generally seen, as driver_util catches and edits it from `stats`; conditions2 = [stats[k][1] for k in [""method_t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html:11512,energy,energy,11512,psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html,8,['energy'],['energy']
Energy Efficiency,"eq):; freqsum += freqs.get(i); zpe = freqsum / p4const.psi_hartree2wavenumbers * 0.8929 * 0.5; psi4.clean(). # optimize geometry at mp2 (no frozen core) level; # note: freeze_core isn't an option in MP2; psi4.set_global_option('FREEZE_CORE',""FALSE""); optimize('conv-mp2'); psi4.clean(). # qcisd(t); psi4.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES',""TRUE""); psi4.set_global_option('FREEZE_CORE',""TRUE""); psi4.set_global_option('BASIS',""6-311G(D_P)""); run_fnocc('qcisd(t)',**kwargs). # HLC: high-level correction based on number of valence electrons; ref = psi4.wavefunction(); nirrep = ref.nirrep(); frzcpi = ref.frzcpi(); nfzc = 0; for i in range (0,nirrep):; nfzc += frzcpi[i]; nalpha = ref.nalpha() - nfzc; nbeta = ref.nbeta() - nfzc; # hlc of gaussian-2; hlc = -0.00481 * nalpha -0.00019 * nbeta; # hlc of gaussian-1; hlc1 = -0.00614 * nalpha. eqci_6311gdp = psi4.get_variable(""QCISD(T) TOTAL ENERGY""); emp4_6311gd = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311gd = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # correction for diffuse functions; psi4.set_global_option('BASIS',""6-311+G(D_P)""); energy('mp4'); emp4_6311pg_dp = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311pg_dp = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # correction for polarization functions; psi4.set_global_option('BASIS',""6-311G(2DF_P)""); energy('mp4'); emp4_6311g2dfp = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311g2dfp = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # big basis mp2; psi4.set_global_option('BASIS',""6-311+G(3DF_2P)""); run_fnocc('_mp2',**kwargs); emp2_big = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). eqci = eqci_6311gdp; e_delta_g2 = emp2_big + emp2_6311gd - emp2_6311g2dfp - emp2_6311pg_dp; e_plus = emp4_6311pg_dp - emp4_6311gd; e_2df = emp4_6311g2dfp - emp4_6311gd. eg2 = eqci + e_delta_g2 + e_plus + e_2df; eg2_mp2_0k = eqci + (emp2_big - emp2_6311gd) + hlc + zpe. psi4.print_out('\n'); psi4.print_out(' ==> G1/G2 Energy Components <==\n'); psi4.print_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/gaussian_n.html:3130,ENERGY,ENERGY,3130,psi4manual/4.0b5/_modules/gaussian_n.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/gaussian_n.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"equations code.; ; ccresponse(...); ccresponse() -> float :; Runs the coupled cluster response theory code.; ; ccsort(...); ccsort() -> float :; Runs CCSORT, which reorders integrals for use in the coupled cluster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psimod-1.html:106085,adapt,adapted,106085,psi4manual/4.0b4/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html,2,['adapt'],['adapted']
Energy Efficiency,"equency computations with SOS-OMP3, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF); CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF); MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DOMAIN_PRINT (CIS); CIS — Do print the domains?. Type: boolean; Default: false. DOMAIN_PRINT_EXIT (LMP2); LMP2 — Do exit after printing the domains?. Type: boolean; Default: false. DOMAINS (CIS); CIS —. Type: array; Default: No Default. E3_SCALE (OMP3); OMP3 — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-8. E_CONVERGENCE (DETCI); DETCI — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (LMP2); LMP2 — Convergence criterion for energy (change). Type: conv double; Default: 1e-7. E_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (MRCC); MRCC — This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-8. E_CONVERGENCE (OMP2); OMP2 — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (OMP3); OMP3 — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (PSIMRCC); PSIMRCC — Convergence criterion for energy. Type: conv double; Default: 1e-9. E_CONVERGENCE (SAPT); SAPT — Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF); SCF — Convergen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:35629,energy,energy,35629,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"equested <= #. old_df_ints_io = PsiMod.get_global_option(""DF_INTS_IO""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = PsiMod.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. mol.set_molecular_charge(chargem); mol.set_multiplicity(multm); ; # => Burn the anion in with hf, if requested <= #; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True); PsiMod.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [LUMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(LUMO)-1]). occs.append(occ); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if (not continuous_guess):; PsiMod.set_global_option(""GUESS"", old_guess); if (hf_guess):; PsiMod.set_global_option(""FRAC_START"", 0); PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUES",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/frac.html:3613,energy,energy,3613,psi4manual/4.0b2/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html,4,['energy'],['energy']
Energy Efficiency,"equested <= #. old_df_ints_io = PsiMod.get_global_option(""DF_INTS_IO""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = PsiMod.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. mol.set_molecular_charge(chargem); mol.set_multiplicity(multm); ; # => Burn the anion in with hf, if requested <= #; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True); PsiMod.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [LUMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = PsiMod.wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(LUMO)-1]). occs.append(occ); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if (not continuous_guess):; PsiMod.set_global_option(""GUESS"", old_guess); if (hf_guess):; PsiMod.set_global_option(""FRAC_START"", 0); PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/frac.html:3610,energy,energy,3610,psi4manual/4.0b4/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/frac.html,2,['energy'],['energy']
Energy Efficiency,"er (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – corl_basis || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:; scf_scheme (function) – highest_1 || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy. corl_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy. delta_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. delta2_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cbs-1.html:4635,energy,energy,4635,psi4manual/4.0b2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cbs-1.html,6,['energy'],['energy']
Energy Efficiency,"er Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n\n' %; tuple(CT * u for u in units)); core.set_variable(""SAPT CT ENERGY"", CT) # P::e SAPT. optstash.restore(); return dimer_wfn. def run_fisapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an F/ISAPT0 computation. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! FISAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e. # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' FISAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); _ini_cart = getattr(sapt_dimer, ""_initial_cartesian"", None); sapt_dimer",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:158915,ENERGY,ENERGY,158915,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"er Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n\n' %; tuple(CT * u for u in units)); core.set_variable(""SAPT CT ENERGY"", CT) # P::e SAPT. optstash.restore(); return dimer_wfn. def run_fisapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an F/ISAPT0 computation. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! FISAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e. # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' FISAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer = sapt_dimer.clone(); sapt_dimer.reset_point_group('c1'); sa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:145019,ENERGY,ENERGY,145019,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"er Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolecular Interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/plugin_snsmp2-1.html:1687,adapt,adapted,1687,psi4manual/1.4.0/plugin_snsmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/plugin_snsmp2-1.html,4,"['adapt', 'energy']","['adapted', 'energy']"
Energy Efficiency,"er Møller–Plesset Perturbation Theory) interaction energies for dimer molecules.; The plugin is distributed under the 2-clause BSD license. Installation¶; Binary. snsmp2 is available as a conda package for Linux and macOS (and Windows, through the Ubuntu shell).; If using the Psi4conda installer, snsmp2 has already been installed alongside.; If using the PSI4 conda package, the snsmp2 conda package can; be obtained through conda install snsmp2 -c psi4 or conda install; psi4-rt -c psi4.; If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; snsmp2 can be obtained through conda install snsmp2 -c psi4.; Then, hint its location with PYTHONPATH.; To remove a conda installation, conda remove snsmp2. Source. Download the plugin from the GitHub repository:; >>> git clone https://github.com/DEShawResearch/sns-mp2. Once dowloaded, the plugin can be installed as outlined in the documentation:; >>> cd {top-level-sns-mp2-directory}; >>> PSI4_PYTHON=$(head $(which psi4) -n 1 | sed -r 's/^.{2}//'); >>> $PSI4_PYTHON -m pip install . Sample Input¶; A sample input file, adapted from the documentation, is shown below:; # Sample SNS-MP2 calculation for two helium atoms. molecule dimer {; He 0 0 0; --; He 2 0 0; }. energy('sns-mp2'). Note that the two monomers are separated by double dashes, indicating that; they should be treated as separate molecules. (See; Analysis of Intermolecular Interactions for more details on; setting up dimer molecules.) This input file can be run in the usual fashion:; >>> psi4 input.dat. table of contents. Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Installation; Sample Input. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/plugin_snsmp2-1.html:1687,adapt,adapted,1687,psi4manual/1.5.0/plugin_snsmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/plugin_snsmp2-1.html,4,"['adapt', 'energy']","['adapted', 'energy']"
Energy Efficiency,"er convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:12853,monitor,monitored,12853,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,10,['monitor'],['monitored']
Energy Efficiency,"er counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMod.print_out(""\n""); banner(""CP Computation: Complex.\nFull Basis Set.""); PsiMod.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). PsiMod.clean(); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). # All monomers with ghosts; monomers = extract_clusters(molecule, True, 1); e_monomer_full = []. cluster_n = 0; for cluster in monomers:; activate(cluster); PsiMod.print_out(""\n""); banner((""CP Computation: Monomer %d.\n Full Basis Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_full.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_full.append(energy(name,**kwargs)); cluster_n = cluster_n + 1; PsiMod.clean(). PsiMod.set_global_option('DF_INTS_IO', 'NONE'); if (check_bsse):; # All monomers without ghosts; monomers = extract_clusters(molecule, False, 1); e_monomer_bsse = []. cluster_n = 0; for cluster in monomers:; activate(cluster); PsiMod.print_out(""\n""); #cluster.print_to_output(); banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:19764,energy,energy,19764,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,4,['energy'],['energy']
Energy Efficiency,"er default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(f""Invalid type {type_val} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := core.get_global_option(""SCF_TYPE"")) not in [""CD"", ""DISK_DF""]:; raise ValidationError(f""Invalid {scf_type=} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; ra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:168108,energy,energy,168108,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['energy'],['energy']
Energy Efficiency,"er interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. dforemp-grad2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). mints2-bse; Similar to mints2, but using the BSE to specify the basis sets. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. sapt0-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. nbo; Generation of NBO file. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. dfccsd-t-grad2; DF-CCSD(T) cc-pVDZ gradient for the NH molecule. dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. cubeprop-frontier; ROHF frontier orbitals of CH2(s) and CH2(t). omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-step algorithm is tested. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. mbis-2; MBIS calculation on OH- (Expanded Arrays). dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. frac-ip-fitting; Omega optimization for LRC functional wB97 o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:29274,energy,energy,29274,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"er of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP (CFOUR); CFOUR — Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. CFOUR_GEO_METHOD (CFOUR); CFOUR — Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — straightforward Newton-Raphson search for minimum; RFA (=1) — Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) — Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); SINGLE_POINT (=5) for a single-point energy calculation. ENERONLY (=6) requests a geometry optimization based on single-point energy calculations. Default: SINGLE-POINT (NR as soon as variables are marked to be optimized). Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT, ENERONLY; Default: SINGLE_POINT. CFOUR_GIAO (CFOUR); CFOUR — Specifies whether gauge-including atomic orbitals are used (ON) or not (OFF). Default: ON for CFOUR_PROPS =NMR and =MAGNETIC, otherwise OFF. Type: string; Possible Values: ON, OFF; Default: No Default. CFOUR_GRID (CFOUR); CFOUR — Keyword used to control type of grid calculation (see later section in this manual). Options are OFF (=0), no grid calculation; CARTESIAN (=1), steps are in Cartesia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:49073,efficient,efficient,49073,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,16,"['efficient', 'energy']","['efficient', 'energy']"
Energy Efficiency,"er of initial vectors to use in the CI iterative procedure. Defaults to the number of roots. Type: integer; Default: 0. REFERENCE_SYM¶. Irrep for CI vectors; -1 = find automatically. This option allows the user to look for CI vectors of a different irrep than the reference. This probably only makes sense for Full CI, and it would probably not work with unit vector guesses. Numbering starts from zero for the totally-symmetric irrep. Type: integer; Default: -1. Expert File Handling¶. HD_OTF¶. Do compute the diagonal elements of the Hamiltonian matrix on-the-fly? Otherwise, a diagonal element vector is written to a separate file on disk. Type: boolean; Default: true. NO_DFILE¶. Do use the last vector space in the BVEC file to write scratch DVEC rather than using a separate DVEC file? (Only possible if NUM_ROOTS = 1.). Type: boolean; Default: false. Expert General-Order Perturbation Theory¶. MPN_ORDER_SAVE¶. If 0, save the MPn energy; if 1, save the MP(2n-1) energy (if available from MPN_WIGNER = true); if 2, save the MP(2n-2) energy (if available from MPN_WIGNER = true). Type: integer; Default: 0. MPN_SCHMIDT¶. Do employ an orthonormal vector space rather than storing the kth order wavefunction?. Type: boolean; Default: false. MPN_WIGNER¶. Do use Wigner formulas in the \(E_{text{mp}n}\) series?. Type: boolean; Default: true. PERTURB_MAGNITUDE¶. The magnitude of perturbation \(z\) in \(H = H_0 + z H_1\). Type: double; Default: 1.0. Expert General-Order Coupled-Cluster¶. CC_FIX_EXTERNAL¶. Do fix amplitudes involving RAS I or RAS IV? Useful in mixed MP2-CC methods. Type: boolean; Default: false. CC_FIX_EXTERNAL_MIN¶. Number of external indices before amplitude gets fixed by CC_FIX_EXTERNAL Experimental. Type: integer; Default: 1. CC_MACRO¶. CC_MACRO = [ [ex_lvl, max_holes_I, max_parts_IV, max_I+IV], [ex_lvl, max_holes_I, max_parts_IV, max_I+IV], ... ] Optional additional restrictions on allowed excitations in coupled-cluster computations, based on macroconfiguration select",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__detci-1.html:19401,energy,energy,19401,psi4manual/1.1.0/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__detci-1.html,6,['energy'],['energy']
Energy Efficiency,"er of initial vectors to use in the CI iterative procedure. Defaults to the number of roots. Type: integer; Default: 0. REFERENCE_SYM¶. Irrep for CI vectors; -1 = find automatically. This option allows the user to look for CI vectors of a different irrep than the reference. This probably only makes sense for Full CI, and it would probably not work with unit vector guesses. Numbering starts from zero for the totally-symmetric irrep. Type: integer; Default: -1. Expert File Handling¶. HD_OTF¶. Do compute the diagonal elements of the Hamiltonian matrix on-the-fly? Otherwise, a diagonal element vector is written to a separate file on disk. Type: boolean; Default: true. NO_DFILE¶. Do use the last vector space in the BVEC file to write scratch DVEC rather than using a separate DVEC file? (Only possible if NUM_ROOTS = 1.). Type: boolean; Default: false. Expert General-Order Perturbation Theory¶. MPN_ORDER_SAVE¶. If 0, save the MPn energy; if 1, save the MP(2n-1) energy (if available from MPN_WIGNER = true); if 2, save the MP(2n-2) energy (if available from MPN_WIGNER = true). Type: integer; Default: 0. MPN_SCHMIDT¶. Do employ an orthonormal vector space rather than storing the kth order wavefunction?. Type: boolean; Default: false. MPN_WIGNER¶. Do use Wigner formulas in the \(E_{text{mp}n}\) series?. Type: boolean; Default: true. PERTURB_MAGNITUDE¶. The magnitude of perturbation \(z\) in \(H = H_0 + z H_1\). Type: double; Default: 1.0. Expert General-Order Coupled-Cluster¶. CC_FIX_EXTERNAL¶. Do fix amplitudes involving RAS I or RAS IV? Useful in mixed MP2-CC methods. Type: boolean; Default: false. CC_FIX_EXTERNAL_MIN¶. Number of external indices before amplitude gets fixed by CC_FIX_EXTERNAL Experimental. Type: integer; Default: 1. CC_MACRO¶. CC_MACRO = [ [ex_lvl, max_holes_I, max_parts_IV, max_I+IV], [ex_lvl, max_holes_I, max_parts_IV, max_I+IV], … ] Optional additional restrictions on allowed excitations in coupled-cluster computations, based on macroconfiguration selectio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html:19562,energy,energy,19562,psi4manual/1.3.2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html,66,['energy'],['energy']
Energy Efficiency,"er of initial vectors to use in the CI iterative procedure. Defaults to the number of roots. Type: integer; Default: 0. REFERENCE_SYM¶. Irrep for CI vectors; -1 = find automatically. This option allows the user to look for CI vectors of a different irrep than the reference. This probably only makes sense for Full CI, and it would probably not work with unit vector guesses. Numbering starts from zero for the totally-symmetric irrep. Type: integer; Default: -1. Expert File Handling¶. HD_OTF¶. Do compute the diagonal elements of the Hamiltonian matrix on-the-fly? Otherwise, a diagonal element vector is written to a separate file on disk. Type: boolean; Default: true. NO_DFILE¶. Do use the last vector space in the BVEC file to write scratch DVEC rather than using a separate DVEC file? (Only possible if NUM_ROOTS = 1.). Type: boolean; Default: false. Expert General-Order Perturbation Theory¶. MPN_ORDER_SAVE¶. If 0, save the MPn energy; if 1, save the MP(2n-1) energy (if available from MPN_WIGNER = true); if 2, save the MP(2n-2) energy (if available from MPN_WIGNER = true). Type: integer; Default: 0. MPN_SCHMIDT¶. Do employ an orthonormal vector space rather than storing the kth order wavefunction?. Type: boolean; Default: false. MPN_WIGNER¶. Do use Wigner formulas in the series?. Type: boolean; Default: true. PERTURB_MAGNITUDE¶. The magnitude of perturbation in . Type: double; Default: 1.0. Expert General-Order Coupled-Cluster¶. CC_FIX_EXTERNAL¶. Do fix amplitudes involving RAS I or RAS IV? Useful in mixed MP2-CC methods. Type: boolean; Default: false. CC_FIX_EXTERNAL_MIN¶. Number of external indices before amplitude gets fixed by CC_FIX_EXTERNAL Experimental. Type: integer; Default: 1. CC_MACRO¶. CC_MACRO = [ [ex_lvl, max_holes_I, max_parts_IV, max_I+IV], [ex_lvl, max_holes_I, max_parts_IV, max_I+IV], ... ] Optional additional restrictions on allowed exictations in coupled-cluster computations, based on macroconfiguration selection. For each sub-array, [ex_lvl, max_holes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__detci-1.html:19291,energy,energy,19291,psi4manual/4.0b2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__detci-1.html,54,['energy'],['energy']
Energy Efficiency,"er of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'). table of contents. HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess; Convergence Stabilization; ERI Algorithms; Second-order Convergence; Stability Analysis; Effective core potentials (ECPs); External potentials and QM/MM; Convergence and Algorithm Defaults; Recommendations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/scf-1.html:39213,energy,energy,39213,psi4manual/1.2.1/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/scf-1.html,2,['energy'],['energy']
Energy Efficiency,"er provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; if wfn.gradient(): # available for analytic and any findif including totally symmetric space; gradient_rms = wfn.gradient().rms(); else:; gradient_rms = 1 # choose to force non-projection of rotations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def vibanal_wfn(; wfn: core.Wavefunction,; hess: Optional[np.ndarray] = None,; irrep: Optional[Union[int, str]] = None,; molecule=None,; project_trans: bool = True,; project_rot: bool = True,; ) -> Dict[str, np.ndarray]:; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis; is skipped if this is specified (non-None),; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull inform",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:87826,ENERGY,ENERGY,87826,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"er provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; if wfn.gradient(): # available for analytic and any findif including totally symmetric space; gradient_rms = wfn.gradient().rms(); else:; gradient_rms = 1 # choose to force non-projection of rotations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def vibanal_wfn(; wfn: core.Wavefunction,; hess: Optional[np.ndarray] = None,; irrep: Optional[Union[int, str]] = None,; molecule=None,; project_trans: bool = True,; project_rot: bool = True,; ) -> Dict[str, np.ndarray]:; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis; is skipped if this is specified (non-None),; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull informat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:87797,ENERGY,ENERGY,87797,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"er provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; if wfn.gradient(): # available for analytic and any findif including totally symmetric space; gradient_rms = wfn.gradient().rms(); else:; gradient_rms = 1 # choose to force non-projection of rotations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def vibanal_wfn(wfn: core.Wavefunction, hess: np.ndarray = None, irrep: Union[int, str] = None, molecule=None, project_trans: bool = True, project_rot: bool = True):; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis is skipped if this is given,; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geome",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:79777,ENERGY,ENERGY,79777,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"er that the DC-06 analytic; gradients code will be executed to perform the solution of the DCFT response; equations, compute the analytic gradients of the DCFT energy and perform the; geometry optimization. Recommendations¶; Here is the list of the recommendations for the DCFT module:. For the computations of small systems (less than 150 basis; functions and high symmetry) the use of the default parameters is recommended,; including the choice of the two-step algorithm.; For large systems (more than 150 basis functions) the simultaneous algorithm; is preferred and can be significantly faster than two-step, as the result of; smaller number of the expensive steps. In addition,; significant savings can be achieved if one sets AO_BASIS option to; DISK together with simultaneous algorithm.; In the case when insufficient memory is available, set AO_BASIS option; to DISK. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In the case when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by setting; DIIS_START_CONVERGENCE option to the value greater than; by one or two orders of magnitude (e.g. or; ).; If the oscillatory convergence is observed for atoms or molecules with high; symmetry, it is recommended to use quadratically-convergent algorithm.; When using quadratically-convergent algorithm for closed-shell molecules, it; is recommended to set QC_COUPLING option to FALSE for efficiency; reasons. Table Of Contents. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Minimal Input; Recommendations. Previous topic; DFT: Density Functional Theory; Next topic; DF-MP2: Density-Fitted Sec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/dcft-1.html:11867,energy,energy,11867,psi4manual/4.0b5/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/dcft-1.html,2,['energy'],['energy']
Energy Efficiency,"er to two modes of interacting with; Psi4. In Psithon mode, you write an input file in our domain-specific; language (not quite Python) where commands don’t have psi4. in; front, then submit it to the executable psi4 which processes the; Psithon into pure Python and runs it internally. In PsiAPI mode, you; write a pure Python script with import psi4 at the top and commands; are behind the psi4. namespace, then submit it to the python; interpreter. Both modes are equally powerful. This tutorial covers the; PsiAPI mode. Warning: Although the developers have been using PsiAPI mode stably; for months before the 1.1 release and while we believe we’ve gotten; everything nicely arranged within the psi4. namespace, the API; should not be considered completely stable. Most importantly, as we; someday deprecate the last of the global variables, options will be; added to the method calls (e.g.,; energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after; compilation; or How to run Psi4 as a Python module from conda; installation; for assistance in setting up Psi4. Unlike in the past, where Psi4 was executable software which could only; be called via input files like input.dat, it is now interactive,; able to be loaded directly as a Python module. Here, we will explore the; basics of using Psi4 in this new style by reproducing the section A; Psi4 Tutorial; from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your; path, feel free to execute each cell as you read along by pressing; Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python; environment:. In [1]:. try:; import os, sys; sys.path.insert(1, os.path.abspath('/scratch/psilocaluser/conda-builds/psi4-docs-multiout_1532505956776/work/build/stage//opt/anaconda1anaconda2anaconda3/lib/python3.6/site-packages')); except ImportError:; pass. impo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psiapi-1.html:1144,energy,energy,1144,psi4manual/1.2.1/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psiapi-1.html,2,['energy'],['energy']
Energy Efficiency,"er type (for interchangeable solvers). Type: string; Possible Values: DL, RAYLEIGH; Default: DL. SOS_TYPE (DFOCC); DFOCC — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOS_TYPE (OCC); OCC — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOSCF (SCF); SCF — Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV (SCF); SCF — Second order convergence threshold. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER (SCF); SCF — Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER (SCF); SCF — Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT (SCF); SCF — Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE (SCF); SCF — When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. SPINADAPT_ENERGIES (CCENERGY); CCENERGY — Do print spin-adapted pair energies?. Type: boolean; Default: false. SS_E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG (CCEOM); CCEOM — Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT (CCEOM); CCEOM — SS vectors stored per root. Type: integer; Default: 5. SSAPT0_SCALE (FISAPT); FISAPT — Do sSAPT0 exchange-scaling with F-SAPT. Type: boolean; Default: false. STABILITY_ADD_VECTORS (DCFT); DCFT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF); SCF — Whether to perform stability analysis after conve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:212442,adapt,adapted,212442,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['adapt'],['adapted']
Energy Efficiency,"er"": self.driver,; ""method"": job[""f_wfn""],; ""basis"": job[""f_basis""],; ""keywords"": keywords or {},; }); self.task_list.append(task). # logger.debug(""TASK\n"" + pp.pformat(task.dict())). [docs] def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs] def plan(self):; # uncalled function; return [t.plan() for t in self.task_list]. [docs] def compute(self, client: Optional[""qcportal.FractalClient""] = None):; label = self.metameta['label']; instructions = ""\n"" + p4util.banner(f"" CBS Computations{':' + label if label else ''} "",; strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in reversed(self.task_list):; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = [x.get_results(client=client) for x in self.task_list]. modules = [getattr(v.provenance, ""module"", None) for v in results_list]; if self.driver != ""energy"" and len(set(modules)) == 2 and modules.count(""scf"") == len(modules) / 2:; # signature of ""MP2 GRAD"" - ""HF GRAD"" implementation detail; # * avoid having post-scf single-method gradients/Hessians show up as ""(mixed)"" module just because an outright HF call in the jobs list; modules = set(modules) - {""scf""}; modules = list(set(modules)); modules = modules[0] if len(modules) == 1 else ""(mixed)"". # load results_list numbers into compute_list (task_list is AtomicComputer-s); for itask, mc in enumerate(self.compute_list):; task = results_list[itask]; response = task.return_result. if self.metameta['ptype'] == 'energy':; mc['f_energy'] = response. elif self.metameta['ptype'] == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif self.metameta['ptype'] == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; mc['f_gradient'] = task.extras['qcvars']['CURRENT GRA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:56050,energy,energy,56050,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"er())); core.print_out("""""" LO-zeta (%s) Data\n"""""" % (str(zLO))); valueLO.print_out(); core.print_out("""""" HI-zeta (%s) Data\n"""""" % (str(zHI))); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % alpha); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). # value.add(valueSCF); return value. else:; raise ValidationError(""corl_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). def return_energy_components():; """"""Define some quantum chemical knowledge, namely what methods are subsumed in others."""""". # yapf: disable; VARH = {}; VARH['scf'] = {; 'scf': 'SCF TOTAL ENERGY'}; VARH['hf'] = {; 'hf': 'HF TOTAL ENERGY'}; VARH['mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY'}; VARH['dlpno-mp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'dlpno-mp2': 'MP2 TOTAL ENERGY'}; VARH['mp2d'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2d': 'MP2D TOTAL ENERGY'}; VARH['mp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY'}; VARH['mp4(sdq)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY'}; VARH['mp4'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'mp4(sdq)': 'MP4(SDQ) TOTAL ENERGY',; 'mp4': 'MP4 TOTAL ENERGY'}; VARH['omp2'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'omp2': 'OMP2 TOTAL ENERGY'}; VARH['omp2.5'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp2.5': 'MP2.5 TOTAL ENERGY',; 'omp2.5': 'OMP2.5 TOTAL ENERGY'}; VARH['omp3'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'mp3': 'MP3 TOTAL ENERGY',; 'omp3': 'OMP3 TOTAL ENERGY'}; VARH['olccd'] = {; 'hf': 'HF TOTAL EN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver_cbs.html:23810,ENERGY,ENERGY,23810,psi4manual/1.5.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver_cbs.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"er().startswith(""MBIS""):; if key.upper().endswith(""CHARGES""):; return val; elif key.upper().endswith(""DIPOLES""):; reshaper = (-1, 3); return val.reshape(reshaper); elif key.upper().endswith(""QUADRUPOLES""):; val = val.reshape(-1, 3, 3); val = np.array([_multipole_compressor(val[iat], 2) for iat in range(len(val))]); return val; elif key.upper().endswith(""OCTUPOLES""):; val = val.reshape(-1, 3, 3, 3); val = np.array([_multipole_compressor(val[iat], 3) for iat in range(len(val))]); return val; elif key.upper().endswith(""DIPOLE"") or ""DIPOLE -"" in key.upper():; reshaper = (1, 3); elif ""QUADRUPOLE POLARIZABILITY TENSOR"" in key.upper():; reshaper = (3, 3, 3); elif any((key.upper().endswith(p) or f""{p} -"" in key.upper()) for p in _multipole_order):; p = [p for p in _multipole_order if (key.upper().endswith(p) or f""{p} -"" in key.upper())]; val = _multipole_compressor(val, _multipole_order.index(p[0])); reshaper = (1, -1); elif key.upper() in [""MULLIKEN_CHARGES"", ""LOWDIN_CHARGES"", ""MULLIKEN CHARGES"", ""LOWDIN CHARGES"", ""SCF TOTAL ENERGIES""]:; reshaper = (1, -1). if reshaper:; return val.reshape(reshaper); else:; return val. def _qcvar_reshape_get(key: str, val: core.Matrix) -> Union[core.Matrix, np.ndarray]:; """"""For QCVariables where the 2D :py:class:`psi4.core.Matrix` shape is; unnatural, convert to natural shape in :class:`numpy.ndarray`. """"""; reshaper = None; if key.upper().startswith(""MBIS""):; if key.upper().endswith(""CHARGES""):; return val.np; elif key.upper().endswith(""DIPOLES""):; reshaper = (-1, 3); return val.np.reshape(reshaper); elif key.upper().endswith(""QUADRUPOLES""):; val = val.np.reshape(-1, 6); val = np.array([_multipole_plumper(val[iat], 2) for iat in range(len(val))]); return val; elif key.upper().endswith(""OCTUPOLES""):; val = val.np.reshape(-1, 10); val = np.array([_multipole_plumper(val[iat], 3) for iat in range(len(val))]); return val; elif key.upper().endswith(""DIPOLE"") or ""DIPOLE -"" in key.upper():; reshaper = (3, ); elif ""QUADRUPOLE POLARIZABILITY TENSOR"" ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:31065,CHARGE,CHARGES,31065,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,4,['CHARGE'],['CHARGES']
Energy Efficiency,"er()}` [D A] instead of array `{key.upper()[:-3]}` [e a0^2] is deprecated, and in 1.5 it will stop working\n"",; category=FutureWarning,; stacklevel=3). if key.upper() in _qcvar_transitions:; warnings.warn(; f""Using QCVariable `{key.upper()}` instead of `{_qcvar_transitions[key.upper()]}` is deprecated, and in 1.5 it will stop working\n"",; category=FutureWarning,; stacklevel=3); return _qcvar_transitions[key.upper()]. if key.upper() in _qcvar_cancellations:; raise UpgradeHelper(key.upper(), ""no direct replacement"", 1.4, "" Consult QCVariables "" + "", "".join(_qcvar_cancellations[key.upper()]) + "" to recompose the quantity.""). return key. _multipole_order = [""dummy"", ""dummy"", ""QUADRUPOLE"", ""OCTUPOLE"", ""HEXADECAPOLE""]; for order in range(5, 10):; _multipole_order.append(f""{int(2**order)}-POLE""). def _qcvar_reshape_set(key, val):; """"""Reverse `_qcvar_reshape_get` for internal psi4.core.Matrix storage."""""". reshaper = None. if key.upper().startswith(""MBIS""):; if key.upper().endswith(""CHARGES""):; return val; elif key.upper().endswith(""DIPOLES""):; reshaper = (-1, 3); return val.reshape(reshaper); elif key.upper().endswith(""QUADRUPOLES""):; val = val.reshape(-1, 3, 3); val = np.array([_multipole_compressor(val[iat], 2) for iat in range(len(val))]); return val; elif key.upper().endswith(""OCTUPOLES""):; val = val.reshape(-1, 3, 3, 3); val = np.array([_multipole_compressor(val[iat], 3) for iat in range(len(val))]); return val; elif key.upper().endswith(""DIPOLE""):; reshaper = (1, 3); elif any(key.upper().endswith(p) for p in _multipole_order):; val = _multipole_compressor(val, _multipole_order.index(key.upper().split()[-1])); reshaper = (1, -1); elif key.upper() in [""MULLIKEN_CHARGES"", ""LOWDIN_CHARGES"", ""MULLIKEN CHARGES"", ""LOWDIN CHARGES""]:; reshaper = (1, -1). if reshaper:; return val.reshape(reshaper); else:; return val. def _qcvar_reshape_get(key, val):; """"""For QCVariables where the 2D psi4.core.Matrix shape is unnatural, convert to natural shape in ndarray."""""". reshaper = None; if",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:21369,CHARGE,CHARGES,21369,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,2,['CHARGE'],['CHARGES']
Energy Efficiency,"er, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(; f""scf_xtpl_helgaker_3: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueMD)}, {type(valueHI)})""; ). if isinstance(valueLO, float):. ratio = (valueHI - valueMD) / (valueMD - valueLO); alpha = -1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zMD].upper(),; _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. nonzero_mask = np.abs(valueHI) > 1.e-14; top = (valueHI - valueMD)[nonzero_mask]; bot = (valueMD - valueLO)[nonzero_mask]. ratio = top / bot; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~no",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:15607,Energy,Energy,15607,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,5,['Energy'],['Energy']
Energy Efficiency,"er, default = 23); --iso [<isovalue>] the isosurface value (float, default = 0.05); --rx [<angle>] the x-axis rotation angle (float, default = 30.0); --ry [<angle>] the y-axis rotation angle (float, default = 40.0); --rz [<angle>] the z-axis rotation angle (float, default = 15.0); --tx [<length>] the x-axis translation (float, default = 0.0); --ty [<length>] the y-axis translation (float, default = 0.0); --tz [<length>] the z-axis translation (float, default = 0.0); --opacity [<opacity>]; opacity of the isosurface (float, default = 1.0); --scale [<factor>] the scaling factor (float, default = 1.0); --no-montage call montage to combine images. (string, default =; false); --no-labels do not add labels to images. (string, default = false); --imagesize [<integer>]; the size of each image (integer, default = 250); --imagew [<integer>] the width of images (integer, default = 250); --imageh [<integer>] the height of images (integer, default = 250); --fontsize [<integer>]; the font size (integer, default = 20); --interactive run in interactive mode (default = false); --gzip gzip cube files (default = false); --national_scheme use a red/blue color scheme. (string, default = false); --silver_scheme use a gray/white color scheme. (string, default =; false); --bright_scheme use a soft yellow/blue color scheme. (string, default; = false); --electron_scheme use a purple/green color scheme. (string, default =; false). table of contents. Generation of Cube Files — cubeprop(); Introduction; Cubeprop Tasks; Keywords; CUBEPROP_TASKS; CUBEPROP_FILEPATH; CUBEPROP_ORBITALS; CUBEPROP_BASIS_FUNCTIONS; CUBIC_GRID_SPACING; CUBIC_GRID_OVERAGE. Orbital Visualization with VMD; Script Prerequisites; Running the Script; Script Options. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cubeprop-1.html:10315,green,green,10315,psi4manual/1.2.1/cubeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cubeprop-1.html,2,['green'],['green']
Energy Efficiency,"er. sapt-ecp; sapt0 of charged system in ECP basis set. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. dfremp-1; density fitted REMP/cc-pVDZ energies for the CO2 molecule. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. aediis-2; EDIIS test case from 10.1063/1.1470195. scf-response3; UHF Dipole Polarizability Test. mom-h2o-3; MOM excitation from LUMO HOMO+3. extern3; External potential calculation with one Ghost atom and one point charge at the same position. pywrap-cbs1; Various basis set extrapolation tests. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN updated ref gradient due to new BraggSlater radii. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. numpy-array-interface; Numpy interface testing. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. cdremp-2; Cholesky decomposed REMP/cc-pVDZ energies for the CH3 radical. mom-h2o-4; MOM excitation from LUMO HOMO+4. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. dfccsd-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:34565,energy,energy,34565,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"er.QMMM class,; psi4.driver.QMMMbohr, is operable, but it is discouraged; from being used directly. To run a computation in a constant dipole field, the PERTURB_H,; PERTURB_WITH and PERTURB_DIPOLE keywords can be used. As an; example, to add a dipole field of magnitude 0.05 a.u. in the y direction and; 0.1 a.u. in the z direction, we can use the following keywords:; set perturb_h true; set perturb_with dipole; set perturb_dipole [ 0, 0.05, 0.1 ]. Note that if any specified fields do not fall along a symmetry axis, the; symmetry of the calculation should be reduced accordingly; if in doubt run the; calculation in C1 symmetry. For examples of SCF and MP2 calculations in an; external field, see scf7 and dfmp2-grad5. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type 1¶. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 6; DF. optimization; 8; 8. frequency 7; 8; 8. SCF of post-HF; energy; 8; 8; PK 3. optimization; 10; 10. frequency 7; 10; 10. CC property 2; 10; 10. Post-SCF convergence criteria defaults by calculation type 4¶. Ab Initio Method; Calculation Type; E_CONVERGENCE 5; R_CONVERGENCE 6. post-HF of post-HF; energy; 6. optimization; 8. frequency 7; 8. CC property 2; 8. Footnotes. 1; Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. 2(1,2); This applies to properties computed through the properties() function. 3; Post-HF methods that do not rely upon the usual 4-index AO integrals use a; density-fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. 4; Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. 5; The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list begin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/scf.html:46785,energy,energy,46785,psi4manual/1.6.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/scf.html,1,['energy'],['energy']
Energy Efficiency,"er.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(LUMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(LUMO) - 1)). occs.append(occ); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); #core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if not continuous_guess:; core.set_local_option(""SCF"", ""GUESS"", old_guess); if hf_guess:; core.set_local_option(""SCF"", ""FRAC_START"", 0); core.set_local_option(""SCF"", ""REFERENCE"", ""UHF""); driver.energy('scf', dft_functional=name, molecule=molecule, **kwargs); core.set_local_option(""SCF"", ""REFERENCE"", ""UKS""); core.set_local_option(""SCF"", ""GUESS"", ""READ""); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", False). core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.get(int(HOMO) - 1)); else:; eps = wfn.epsilon_b(); potentials.append(eps.get(-int(HOMO) - 1)). occs.append(occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""GUESS"", ""READ""); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_dii",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:7280,energy,energy,7280,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,8,['energy'],['energy']
Energy Efficiency,"er.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr passed as keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.di",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qmmm.html:4102,charge,charges,4102,psi4manual/1.6.x/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qmmm.html,4,['charge'],['charges']
Energy Efficiency,"er:; return val.reshape(reshaper); else:; return val. def _qcvar_reshape_get(key, val):; """"""For QCVariables where the 2D psi4.core.Matrix shape is unnatural, convert to natural shape in ndarray."""""". reshaper = None; if key.upper().startswith(""MBIS""):; if key.upper().endswith(""CHARGES""):; return val.np; elif key.upper().endswith(""DIPOLES""):; reshaper = (-1, 3); return val.np.reshape(reshaper); elif key.upper().endswith(""QUADRUPOLES""):; val = val.np.reshape(-1, 6); val = np.array([_multipole_plumper(val[iat], 2) for iat in range(len(val))]); return val; elif key.upper().endswith(""OCTUPOLES""):; val = val.np.reshape(-1, 10); val = np.array([_multipole_plumper(val[iat], 3) for iat in range(len(val))]); return val; elif key.upper().endswith(""DIPOLE""):; reshaper = (3, ); elif any(key.upper().endswith(p) for p in _multipole_order):; return _multipole_plumper(val.np.reshape((-1, )), _multipole_order.index(key.upper().split()[-1])); elif key.upper() in [""MULLIKEN_CHARGES"", ""LOWDIN_CHARGES"", ""MULLIKEN CHARGES"", ""LOWDIN CHARGES""]:; reshaper = (-1, ). if reshaper:; return val.np.reshape(reshaper); else:; return val. def _multipole_compressor(complete, order):; """"""Form flat unique components multipole array from complete Cartesian array. Parameters; ----------; order : int; Multipole order. e.g., 1 for dipole, 4 for hexadecapole.; complete : ndarray; Multipole array, order-dimensional Cartesian array expanded to complete components. Returns; -------; compressed : ndarray; Multipole array, length (order + 1) * (order + 2) / 2 compressed to unique components. """"""; compressed = []; for ii in range(order + 1):; lx = order - ii; for lz in range(ii + 1):; ly = ii - lz. np_index = []; for xval in range(lx):; np_index.append(0); for yval in range(ly):; np_index.append(1); for zval in range(lz):; np_index.append(2); compressed.append(complete[tuple(np_index)]). assert len(compressed) == ((order + 1) * (order + 2) / 2); return np.array(compressed). def _multipole_plumper(compressed: np.nda",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:23169,CHARGE,CHARGES,23169,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,4,['CHARGE'],['CHARGES']
Energy Efficiency,"er; Default: 0. PRINT¶. The amount of information to print to the output file. 1 prints basic information, and higher levels print more information. A value of 5 will print very large amounts of debugging information. Type: integer; Default: 1. PROPERTIES¶. List of properties to compute. Type: array; Default: No Default. PROPERTIES_ORIGIN¶. Either a set of 3 coordinates, or a string (see manual) describing the origin about which one-electron properties are computed. Type: array; Default: No Default. PUREAM¶. Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Type: boolean; Default: true. SOCC¶. An array containing the number of singly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. UNITS¶. Units used in geometry specification. Type: string; Possible Values: BOHR, AU, A.U., ANGSTROMS, ANG, ANGSTROM; Default: ANGSTROMS. Expert¶. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. DERTYPE¶. Derivative level. Type: string; Possible Values: NONE, FIRST, SECOND, RESPONSE; Default: NONE. DIE_IF_NOT_CONVERGED¶. PSI4 dies if energy does not converge. Type: boolean; Default: true. MAT_NUM_COLUMN_PRINT¶. Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. WFN¶. Wavefunction type. Type: string; Default: SCF. Table Of Contents. GLOBALS; General; BENCH; DOCC; FREEZE_CORE; FROZEN_DOCC; FROZEN_UOCC; NUM_FROZEN_DOCC; NUM_FROZEN_UOCC; PRINT; PROPERTIES; PROPERTIES_ORIGIN; PUREAM; SOCC; UNITS. Expert; DEBUG; DERTYPE; DIE_IF_NOT_CONVERGED; MAT_NUM_COLUMN_PRINT; WFN. Previous topic; Keywords by Module; Next topic; BENCH; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Keywords by Module ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__globals-1.html:3062,energy,energy,3062,psi4manual/4.0b3/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__globals-1.html,4,['energy'],['energy']
Energy Efficiency,"er; Default: 1. TDSCF_COEFF_CUTOFF¶. Cutoff for printing excitations and de-excitations contributing to each excited state. Type: double; Default: 0.1. TDSCF_TDM_PRINT¶. Which transition dipole moments to print out: - E_TDM_LEN : electric transition dipole moments, length representation - E_TDM_VEL : electric transition dipole moments, velocity representation - M_TDM : magnetic transition dipole moments. Type: array; Default: No Default. PsiAPI usage¶; The TDSCF functionality is also accessible from PsiAPI. The example calculation shown above can be carried out as follows:; import psi4. from psi4.driver.procrouting.response.scf_response import tdscf_excitations. psi4.core.set_output_file(""h2o2.out""). h2o2 = psi4.geometry(""""""0 1; O 0.000000 0.695000 -0.092486; O -0.000000 -0.695000 -0.092486; H -0.388142 0.895249 0.739888; H 0.388142 -0.895249 0.739888; symmetry c1; """""", name=""H2O2""). psi4.set_options({; 'save_jk': True,; }). e, wfn = psi4.energy(""HF/cc-pvdz"", return_wfn=True, molecule=h2o2); res = tdscf_excitations(wfn, states=10). Plotting one-photon absorption and electronic circular dichroism spectra¶; Excitation energies and corresponding spectroscopic observables can be used to; produce spectra for one-photon absorption (OPA) and electronic circular; dichroism (ECD) with phenomenological line broadening.; PSI4 provides the spectrum function for this purpose implementing the; recommendations of Rizzo et al. [Rizzo2011-to].; This function will not plot the spectrum, but rather return a pair of NumPy; arrays containing the \(x\) and \(y\) values resulting from the; convolution with broadening of the computed spectroscopic observables.; import numpy as np. import psi4. from psi4.driver.procrouting.response.scf_response import tdscf_excitations; from psi4.driver.p4util import spectrum. psi4.core.set_output_file(""moxy.out""). moxy = psi4.geometry(""""""0 1; C 0.152133 -0.035800 0.485797; C -1.039475 0.615938 -0.061249; C 1.507144 0.097806 -0.148460; O -0.828215 -0.788248",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/tdscf.html:10848,energy,energy,10848,psi4manual/1.7.x/tdscf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/tdscf.html,4,['energy'],['energy']
Energy Efficiency,"er_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. delta3_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta3_basis and xtpl_highest_1() otherwise. delta4_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:9215,energy,energy,9215,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"er_2}]). The difference is that the main function; psi4.cbs() and extrapolation schemes like; psi4.driver.driver_cbs_helper.xtpl_highest_1() and; psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2() and composite; aliases like psi4.driver.aliases.sherrill_gold_standard(); and psi4.driver.aliases.allen_focal_point() in the old way; passed the Python function directly, whereas the new way uses the; string of the function name. A CCSD(T) DT coupled-cluster correction atop a TQ MP2 extrapolation; geometry optimization can also be accessed through the first item below more; conveniently than the equivalent second and third items. optimize('mp2/cc-pv[tq]z + D:ccsd(t)/cc-pvdz'); optimize(""cbs"", corl_wfn='mp2', corl_basis='cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='cc-pvdz'); optimize(""cbs"", cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvqz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvdz""}]). Many examples can be found at cbs-xtpl-energy,; cbs-xtpl-gradient, cbs-xtpl-opt,; cbs-xtpl-freq, cbs-xtpl-func,; cbs-xtpl-wrapper, cbs-xtpl-dict. psi4.cbs(name[, scf_basis, scf_scheme, corl_wfn, corl_basis, corl_scheme, delta_wfn, delta_wfn_lesser, delta_basis, delta_scheme, delta2_wfn, delta2_wfn_lesser, delta2_basis, delta2_scheme, cbs_metadata])[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases; complete_basis_set(). Returns; (float) – Total electronic energy in Hartrees. PSI variables. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/cbs.html:2134,energy,energy,2134,psi4manual/1.6.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/cbs.html,1,['energy'],['energy']
Energy Efficiency,"er_df_basis_elst == 'NONE')):; commands += """"""psi4.set_global_option('DF_BASIS_ELST', '%s')\n"""""" % (user_df_basis_elst); commands += """"""molecule = psi4.get_active_molecule()\n""""""; commands += """"""molecule.update_geometry()\n"""""". if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(1)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""psi4.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""psi4.set_global_option('REFERENCE', 'UKS')\n"""""". commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec(banners); exec(p4util.format_molecule_for_input(GEOS[rgt])); exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, psi4.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); psi4.set_variable('NATOM', molecule.natom()); psi4.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); if re.match(r'^verify', lowername):; compare_values(DATA['NUCLEAR REPULSION ENERGY'][rgt], psi4.get_variable('NUCLEAR REPULSION ENERGY'),; 4, '%s %.4f' % (rgt, psi4.get_variable('NUCLEAR REPULSION ENERGY'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:43516,energy,energy,43516,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,4,['energy'],['energy']
Energy Efficiency,"er_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec(banners); exec(format_molecule_for_input(GEOS[rgt])); exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, PsiMod.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); PsiMod.set_variable('NATOM', molecule.natom()); PsiMod.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); if re.match(r'^verify', lowername):; compare_values(DATA['NUCLEAR REPULSION ENERGY'][rgt], PsiMod.get_variable('NUCLEAR REPULSION ENERGY'), ; 4, '%s %.4f' % (rgt, PsiMod.get_variable('NUCLEAR REPULSION ENERGY'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; PsiMod.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = PsiMod.get_variable(envv); PsiMod.set_global_option(""REFERENCE"", user_reference); PsiMod.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.print_variables()\n""""""); freagent.write(""""""PsiMod.print_out('\\nDATABASE RESULT:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:43682,ENERGY,ENERGY,43682,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,er_norm.txt; solver__solver_precondition.txt. /autodir_psivariables; ; module__adc.txt; module__ccenergy.txt; module__cceom.txt; module__cctriples.txt; module__dcft.txt; module__detci.txt; module__dfmp2.txt; module__lmp2.txt; module__mcscf.txt; module__mp2.txt; module__omp2.txt; module__optking.txt; module__psimrcc.txt; module__sapt.txt; module__scf.txt. adc.txt; appendices.txt; autodoc_available_databases.txt; autodoc_available_plugins.txt; autodoc_dft_all.txt; autodoc_dft_disp.txt; autodoc_dft_energy.txt; autodoc_dft_gga.txt; autodoc_dft_hybrid.txt; autodoc_dft_lrc.txt; autodoc_dft_meta.txt; autodoc_driver.txt; autodoc_glossary_options_c.txt; autodoc_options_c_bymodule.txt; autodoc_psi4bases.txt; autodoc_psivariables_bymodule.txt; autodoc_testsuite.txt; basissets.txt; basissets_byelement.txt; bestpractices_py.txt; bibliography.txt; cbs.txt; cbs_eqn.txt; cc.txt; contributing.txt; cp.txt; customizing.txt; db.txt; detci.txt; dfmp2.txt; dft.txt; dft_byfunctional.txt; documentation.txt; energy.txt; external.txt; freq.txt; glossary_psivariables.txt; index.txt; intercalls.txt; interfacing.txt; introduction.txt; methods.txt; mrcc.txt; notes_c.txt; notes_py.txt; opt.txt; optking.txt; plugins.txt; programming.txt; prop.txt; psimod.txt; psimrcc.txt; psithonfunc.txt; psithoninput.txt; quickaddalias.txt; quickaddbasis.txt; quickadddatabase.txt; sapt.txt; scf.txt; sowreap.txt; testsuite.txt; tutorial.txt. /_static; ; basic.css; copybutton.js; doctools.js; jquery.js; psi4.css; pygments.css; searchtools.js; toggle_sections.js; underscore.js. Ab Initio Polarization Propagator — PSI4 [beta2] documentation; Ab Initio Polarization Propagator — PSI4 [beta2] documentation; Appendices — PSI4 [beta2] documentation; Appendices — PSI4 [beta2] documentation. /autodir_options_c; ; CACHELEVEL — PSI4 [beta2] documentation; MEMORY — PSI4 [beta2] documentation; NEWTON_CONVERGENCE — PSI4 [beta2] documentation; NORM_TOLERANCE — PSI4 [beta2] documentation; NUM_AMPS_PRINT — PSI4 [beta2] documentatio,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:1006942,energy,energy,1006942,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['energy'],['energy']
Energy Efficiency,er_norm.txt; solver__solver_precondition.txt. /autodir_psivariables; ; module__adc.txt; module__ccenergy.txt; module__cceom.txt; module__cctriples.txt; module__dcft.txt; module__detci.txt; module__dfmp2.txt; module__lmp2.txt; module__mcscf.txt; module__mp2.txt; module__omp2.txt; module__optking.txt; module__psimrcc.txt; module__sapt.txt; module__scf.txt. adc.txt; appendices.txt; autodoc_available_databases.txt; autodoc_available_plugins.txt; autodoc_dft_all.txt; autodoc_dft_disp.txt; autodoc_dft_energy.txt; autodoc_dft_gga.txt; autodoc_dft_hybrid.txt; autodoc_dft_lrc.txt; autodoc_dft_meta.txt; autodoc_driver.txt; autodoc_glossary_options_c.txt; autodoc_options_c_bymodule.txt; autodoc_psi4bases.txt; autodoc_psivariables_bymodule.txt; autodoc_testsuite.txt; basissets.txt; basissets_byelement.txt; bestpractices_py.txt; bibliography.txt; cbs.txt; cbs_eqn.txt; cc.txt; contributing.txt; cp.txt; customizing.txt; db.txt; detci.txt; dfmp2.txt; dft.txt; dft_byfunctional.txt; documentation.txt; energy.txt; external.txt; freq.txt; glossary_psivariables.txt; index.txt; intercalls.txt; interfacing.txt; introduction.txt; methods.txt; mrcc.txt; notes_c.txt; notes_py.txt; opt.txt; optking.txt; plugins.txt; programming.txt; prop.txt; psimod.txt; psimrcc.txt; psithonfunc.txt; psithoninput.txt; quickaddalias.txt; quickaddbasis.txt; quickadddatabase.txt; sapt.txt; scf.txt; sowreap.txt; testsuite.txt; tutorial.txt. _static; ; basic.css; copybutton.js; doctools.js; jquery.js; psi4.css; pygments.css; searchtools.js; toggle_sections.js; underscore.js. <no title> — PSI4 [beta2] documentation; Ab Initio Polarization Propagator — PSI4 [beta2] documentation; Ab Initio Polarization Propagator — PSI4 [beta2] documentation; Appendices — PSI4 [beta2] documentation; Appendices — PSI4 [beta2] documentation. autodir_options_c; ; CACHELEVEL — PSI4 [beta2] documentation; MEMORY — PSI4 [beta2] documentation; NEWTON_CONVERGENCE — PSI4 [beta2] documentation; NORM_TOLERANCE — PSI4 [beta2] documentation; NUM,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:902332,energy,energy,902332,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['energy'],['energy']
Energy Efficiency,"eraction potential, . The monomer Fock operators, , are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of Psi4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); The and terms take into; account higher-order induction effects and are included in the definition; of SAPT terms. They are computed from the Hartree-Fock supermolecular interaction energy; and are only available in dimer-centered basis SAPT; computations, which is the default (see below for monomer-centered basis; computations). They are defined by:. (6). (7); Additionally, high-order coupling between induction and dispersion can be; extracted from the supermolecular MP2 interaction energy:. where is the correlation part of the supermolecular MP2; interaction energy. and also improve the; description of electrostatically dominated complexes. ; can be applied to SAPT2+ or SAPT2+(3) energies whereas ; should be applied to SAPT2+3 energies.; A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs],; and a systematic study of the accuracy of these truncations (with and; without an improved CCD treatment of dispersion) using different basis sets; is reported in [Parker:2014:094106].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:2864,energy,energy,2864,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"eraged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. cepa1; cc-pvdz H2O Test CEPA(1) Energy. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. mp2-module; OMP2 cc-pVDZ energy for the H2O molecule. psimrcc-pt2; Mk-MRPT2 single point. F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. omp2p5-1; OMP2 cc-pVDZ energy for the H2O molecule. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. rasci-h2o; RASCI/6-31G** H2O Energy Point. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. dcft-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. cc32; CC3/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. cc17; Single point energies of multiple excited states with EOM-CCSD. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis ). fci-dipole; 6-31G H2O Test FCI Energy Point. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. matrix1; An example of using BLA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:19957,energy,energy,19957,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"eral fixed values; of the dihedral angle of HOOH.; molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:8207,efficient,efficiently,8207,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,2,['efficient'],['efficiently']
Energy Efficiency,"eral, Optional, Sequence, Set, Tuple, Union, TYPE_CHECKING; from ast import literal_eval; from enum import Enum; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import pprint; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; from qcelemental.models import DriverEnum, AtomicResult. from psi4 import core; from psi4.driver import constants, driver_nbody_multilevel, p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.task_base import BaseComputer, AtomicComputer, EnergyGradientHessianWfnReturn; from psi4.driver.driver_cbs import CompositeComputer; from psi4.driver.driver_findif import FiniteDifferenceComputer. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpois",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:8265,energy,energy,8265,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,2,['energy'],['energy']
Energy Efficiency,"erate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule; molecule.set_geometry(displacement); ; # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). # Obtain the gradient. This function stores the gradient into the reference wavefunction.; PsiMod.fd_freq_0(energies, irrep). print ' Computation complete.'; ; # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to frequency().""""""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); frequencies(name, **kwargs). [docs]def molden(filename):; m = PsiMod.MoldenWriter(PsiMod.reference_wavefunction()); m.write(filename). [docs]def parse_cotton_irreps(irrep):; r""""""Function to return validated Cotton ordering index from string or integer; irreducible representation *irrep*. """"""; cotton = {; 'c1': {; 'a': 1,; '1': 1; },; 'ci': {; 'ag': 1,; 'au': 2,; '1': 1,; '2': 2; },; 'c2': {; 'a': 1,; 'b': 2,; '1': 1,; '2': 2; },; 'cs': {; 'ap': 1,; 'app': 2,; '1': 1,; '2': 2; },; 'd2': {; 'a': 1,; 'b1': 2,; 'b2': 3,; 'b3': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2v': {; 'a1': 1,; 'a2': 2,; 'b1': 3,; 'b2': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2h':",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:48312,energy,energy,48312,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"erated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:; scf_scheme (function) – xtpl_highest_1 || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. corl_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. delta_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. delta2_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. delta3_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta3_basis and xtpl_highest_1() otherwise. delta4_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:7978,energy,energy,7978,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"eration of cubic constants of isotopologs (see manual entries associated with anharmonic calculations for an example); 2) calculation of vibrational energy levels with VPT2. This keyword also directs the program to analyze resonances and calculate intensities of one- and two-quantum transitions. FULLQUARTIC (=2) (not part of the public release) is largely self-explanatory; it directs the program to calculate all quartic constants. This is sufficient (but this has not been implemented) to generate the full quartic force field of all isotopologs. Type: string; Possible Values: CUBIC, VPT2, FULLQUARTIC, VIBROT, OFF; Default: OFF. CFOUR_AO_LADDERS (CFOUR); CFOUR — Can be used to control the algorithm used by CFOUR when terms involving molecular orbital integrals are calculated in the atomic orbital basis (see CFOUR_ABCDTYPE). MULTIPASS (= 0) uses an approach where the AO integral file is read a number of times in order to ensure maximal vectorization and is usually the optimal strategy on supercomputers; SINGLEPASS (= 1) determines the contributions with only a single pass through the AO integrals, but at the cost of significantly reduced vectorization. In general, however, SINGLEPASS is definitely preferable on workstations with RISC architectures. (Default : MULTIPASS on all 64-bit machines (e.g., CRAY-YMP) ; SINGLEPASS on all 32-bit machines (e.g., IBM-RS6000, HP-735, SGI-Indigo, DEC alphastations)). SPARSE_AO (=2) uses a sparse matrix algorithm which first rearranges the integral matrix in order to get “well-occupied” and “very sparse” blocks. “Well-occupied” blocks will be multiplied by matrix multiplication while in “very sparse” blocks only the non-zero elements are considered. The computational time is further reduced using symmetrized and anti-symmetrized integral and amplitude matrices in the multiplication. Substantial saving is assumed if SPARSE_AO (=2) is used. Type: string; Possible Values: MULTIPASS, SINGLEPASS; Default: SINGLEPASS. CFOUR_AV_SCF (CFOUR); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:22604,reduce,reduced,22604,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['reduce'],['reduced']
Energy Efficiency,"erature values in litref.in/litref.out. dft-dsd; DSD S22 Ammonia test. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. scf-auto-cholesky; Cholesky filter a complete basis. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-step algorithm is tested. omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. nbody-nocp-gradient; Computation of NoCP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mints3; Test individual integral objects for correctness. phi-ao; Test computing values of basis functions (puream and non-puream) at points. dct3; DC-06 calculation for the He d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:36620,energy,energy,36620,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ere case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number or an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to \(10^{-6} E_h\), the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Notes on PSI Variables¶. Note; Starting in 1.6, there are three standard ways to access an excited state; property. We give examples below, but the method name and property name may change. method ROOT 0 -> ROOT m property to get root m.; method ROOT 0 -> ROOT m property - h TRANSITION to get root m and; independently specify that the total transition symmetry is h, e.g., A2.; method ROOT 0 (h) -> ROOT m (i) property to get the transition; between two roots, specifying the symmetry of both states and the index of the target; roots among states of their own symmetry. For example, to target the second excited-state, which is also the lowest energy state; of its irrep, the first two calls will take m = 2, while the last takes m = 0.; Methods that use this interface are: TD-fctl.; Note that numberings are associated with the calculation much more strongly than; with the molecular system. Changing the number of roots sought, the symmetry; subspace or the symmetry apportionment of roots under which the computation is run,; or the excited state method are all likely to scramble root numberings. table of contents. Notes on Options; Notes on PSI Variables. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Theoretical Methods: SCF to FCI; Notes on Options. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/notes_c.html:1807,energy,energy,1807,psi4manual/1.8.x/notes_c.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/notes_c.html,1,['energy'],['energy']
Energy Efficiency,"ere case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number or an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to \(10^{-6} E_h\), the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Notes on PSI Variables¶. Note; Starting in 1.6, there are three standard ways to access an excited state; property. We give examples below, but the method name and property name may change. method ROOT 0 -> ROOT m property to get root m.; method ROOT 0 -> ROOT m property - h TRANSITION to get root m and; independently specify that the total transition symmetry is h, e.g., A2.; method ROOT 0 (h) -> ROOT m (i) property to get the transition; between two roots, specifying the symmetry of both states and the index of the target; roots among states of their own symmetry. For example, to target the second excited-state, which is also the lowest energy state; of its irrep, the first two calls will take m = 2, while the last takes m = 0.; Methods that use this interface are: TD-fctl.; Note that numberings are associated with the calculation much more strongly than; with the molecular system. Changing the number of roots sought, the symmetry; subspace or the symmetry apportionment of roots under which the computation is run,; or the excited state method are all likely to scramble root numberings. table of contents. Notes on Options; Notes on PSI Variables. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Theoretical Methods: SCF to FCI; Notes on Options. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/notes_c.html:1807,energy,energy,1807,psi4manual/1.9.x/notes_c.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/notes_c.html,1,['energy'],['energy']
Energy Efficiency,"ere the recommended exponent is \(\alpha = 1\). To obtain SAPT energies with this scaling,; simply set the keyword exch_scale_alpha true. Alternatively, another value for \(\alpha\); can be specified by setting EXCH_SCALE_ALPHA to a value. For example,; set exch_scale_alpha 1.0. will set \(\alpha = 1.0\) and scale exchange energies with \(p_{EX}(1.0)\).; Instead of this straightforward scaling, SAPT0 energies benefit from a slightly modified; recipe that involves an empirically adjusted exponent \(\alpha = 3.0\).; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]). (9)¶\[E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)}; + \delta_{HF}^{(2)}\]; where \(\delta_{HF}^{(2)}\) is computed without any scaling. Please note that; sSAPT0 is thus not the same as requesting exch_scale_alpha 3.0, and that the; scaling is automatically performed by requesting energy('ssapt0'). A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods,; not all of them).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis aug-cc-pvdz. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the exampl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:9914,energy,energy,9914,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,7,['energy'],['energy']
Energy Efficiency,"ered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; set {; basis def2-svp; }. # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). API¶. class psi4.driver.driver_nbody.BsseEnum(value)[source]¶; Available basis-set superposition error (BSSE) treatments. cp = 'cp'¶. nocp = 'nocp'¶. vmfc = 'vmfc'¶. pydantic model psi4.driver.driver_nbody.ManyBodyComputer[source]¶. Show JSON schema{; ""title"": ""ManyBodyComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {; ""molecule"": {; ""title"": ""Molecule"",; ""description"": ""The target molecule, if not the last molecule defined.""; },; ""basis"": {; ""title"": ""Basis"",; ""default"": ""(auto)"",; ""type"": ""string""; },; ""method"": {; ""title"": ""Method"",; ""default"": ""(auto)"",; ""type"": ""string""; },; ""driver"": {; ""description"": ""The computation driver; i.e., energy, gradient, hessian."",; ""allOf"": [; {; ""$ref"": ""#/definitions/DriverEnum""; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/nbody.html:3518,energy,energy,3518,psi4manual/master/nbody.html,https://psicode.org,https://psicode.org/psi4manual/master/nbody.html,1,['energy'],['energy']
Energy Efficiency,"erence energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. corl_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. delta_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. delta2_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. delta3_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta3_basis and xtpl_highest_1() otherwise. delta4_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cbs-1.html:9076,energy,energy,9076,psi4manual/1.1.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cbs-1.html,3,['energy'],['energy']
Energy Efficiency,"erence values for new BraggSlater radii. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. numpy-array-interface; Numpy interface testing. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. sapt-ecp; sapt0 of charged system in ECP basis set. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. opt-multi-frozen-dimer-c2h; Frozen-fragment opt of C2h methane dimer with user-combined reference points. casscf-sp; CASSCF/6-31G** energy point. mbis-3; MBIS calculation on OH radical. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. ao-casscf-sp; CASSCF/6-31G** energy point. cisd-sp-2; 6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:37816,energy,energy,37816,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"erence values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn}}\]. db_name DATABASE ROOT-MEAN-SQUARE DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\sqrt{\frac{1}{n}\sum_{rxn}^{n}{(\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn})^2}}\]. DCT LAMBDA ENERGY¶; An energy term in density cumulant theory [E_h]. This term is the; 2-electron cumulant’s contribution contribution to the reduced; density matrix energy expression. Not recommended for interpretative; use except by reduced density matrix specialists. DCT SCF ENERGY¶; An energy term in density cumulant theory [E_h]. This term is the; 1-electron reduced density matrix (1RDM) contribution to the reduced; density matrix energy expression, plus the contribution of the; antisymmetrized product of 1RDMs. Not recommended for interpretative; use except by reduced density matrix specialists. DCT THREE-PARTICLE ENERGY¶; The three-particle correlation energy correction [E_h] in density cumulant; theory, akin to (T) CORRECTION ENERGY in coupled-cluster. DCT TOTAL ENERGY¶; Total energy [E_h] in density cumulant theory. Sum of DCT SCF ENERGY,; DCT LAMBDA ENERGY, and DCT THREE-PARTICLE ENERGY when present. DETCI AVG DVEC NORM¶; A measure of configuration interaction convergence. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [E_h] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (4) or (1). Quantity; \(E_{\text{FCTL}}\) in Eqs. (4) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [E_h] for the requested DFT method,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:27371,reduce,reduced,27371,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,12,"['energy', 'reduce']","['energy', 'reduced']"
Energy Efficiency,"erences with the exception of meta-; GGA functionals. To enable, set the option SOSCF to true.; Additional options to modify the number of microiterations taken are as; follows:. SOSCF_START_CONVERGENCE: when to start SOSCF based on the current density RMS; SOSCF_MAX_ITER: the maximum number of SOSCF microiterations per macroiteration; SOSCF_CONV: the relative convergence tolerance of the SOSCF microiterations; SOSCF_PRINT: option to print the microiterations or not. Stability Analysis¶; SCF algorithms attempt to minimize the gradient of the energy with respect; to orbital variation parameters. At convergence, the gradient should be approximately zero; given a convergence criterion. Although this is enough to make sure the SCF converged to a; stationary point, this is not a sufficient condition for a minimal SCF solution. It may be; a saddle point or a maximum.; To ensure that a minimum has been found, the electronic Hessian, i.e. the matrix of second; derivatives of the energy with respect to orbital variation parameters, must be computed.; If one or more eigenvalues of the electronic Hessian are negative, the SCF solution is not a minimum.; In that case, orbital parameters can be varied along the lowest Hessian eigenvector to lower the energy.; Orbital variation parameters are usually constrained. For example, in RHF the; spatial parts of the \(\alpha\) and \(\beta\) orbitals are the same. In; UHF, the orbital coefficients are usually constrained to be real. A stability analysis; can check whether a lower SCF solution exists while respecting the constraints of the original; solution; this is an internal instability. If one or more constraints have to be relaxed to reach; a lower-energy solution, there is an external instability. In PSI4, the only external instability; that can be checked at present is the RHF \(\rightarrow\) UHF one.; Currently, two algorithms exist in PSI4 for stability analysis: the original; Direct Inversion and the newly implemented Davidson a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/scf-1.html:27123,energy,energy,27123,psi4manual/1.3.2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/scf-1.html,11,['energy'],['energy']
Energy Efficiency,"erfaces: Enhancing PSI4 Capabilities; Interface to programs through FCHK files — fchk(). Interface to programs through FCHK files — fchk()¶; Code author: Andrew C. Simmonett; Section author: Andrew C. Simmonett; Many post-processing tools can read information from Gaussian’s formatted; checkpoint (FCHK) files.; To allow interoperability with such tools, PSI4 includes a utility to; generate FCHK files. Wavefunction information, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and hand it to the fchk driver function:; energy, wfn = energy('scf', return_wfn=True); fchk(wfn,'output.fchk'). The file will be written to the name passed to the fchk function.; Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree–Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; grad, wfn = gradient('mp2', return_wfn=True); fchk(wfn,'output.fchk'). psi4.fchk(wfn, filename, *, debug=False, strict_label=True)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. Added in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is htt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/fchk.html:1065,energy,energy,1065,psi4manual/master/fchk.html,https://psicode.org,https://psicode.org/psi4manual/master/fchk.html,2,['energy'],['energy']
Energy Efficiency,"erfaces: Enhancing PSI4 Capabilities; Interface to programs through FCHK files — fchk(). Interface to programs through FCHK files — fchk()¶; Code author: Andrew C. Simmonett; Section author: Andrew C. Simmonett; Many post-processing tools can read information from Gaussian’s formatted; checkpoint (FCHK) files.; To allow interoperability with such tools, PSI4 includes a utility to; generate FCHK files. Wavefunction information, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and hand it to the fchk driver function:; energy, wfn = energy('scf', return_wfn=True); fchk(wfn,'output.fchk'). The file will be written to the name passed to the fchk function.; Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree–Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; grad, wfn = gradient('mp2', return_wfn=True); fchk(wfn,'output.fchk'). psi4.fchk(wfn, filename, *, debug=False, strict_label=True)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/fchk.html:1056,energy,energy,1056,psi4manual/1.7.x/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/fchk.html,6,['energy'],['energy']
Energy Efficiency,"erfaces: Enhancing PSI4 Capabilities; Interface to programs through FCHK files — fchk(). Interface to programs through FCHK files — fchk()¶; Code author: Andrew C. Simmonett; Section author: Andrew C. Simmonett; Many post-processing tools can read information from Gaussian’s formatted; checkpoint (FCHK) files.; To allow interoperability with such tools, PSI4 includes a utility to; generate FCHK files. Wavefunction information, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and hand it to the fchk driver function:; energy, wfn = energy('scf', return_wfn=True); fchk(wfn,'output.fchk'). The file will be written to the name passed to the fchk function.; Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree–Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; grad, wfn = gradient('mp2', return_wfn=True); fchk(wfn,'output.fchk'). psi4.fchk(wfn, filename, *, debug=False, strict_label=True)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns; None. Parameters. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fchk-1.html:1056,energy,energy,1056,psi4manual/1.4.0/fchk-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fchk-1.html,10,['energy'],['energy']
Energy Efficiency,"erformed in C2v symmetry, and then in C1. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. nbody-nocp-gradient; Computation of NoCP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. scf6; Tests RHF/ROHF/UHF SCF gradients. casscf-sp; CASSCF/6-31G** energy point. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. scf-auto-cholesky; Cholesky filter a complete basis. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:42194,energy,energy,42194,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"erforms a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and input.yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMod.print_out(""\n""); banner(""CP Computation: Complex.\nFull",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:18602,energy,energy,18602,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"erfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('DSD-PBEPBE'); # Tab in, trailing newlines; sup.set_description(' DSD-PBEPBE Dispersion-corrected SCS Double Hybrid XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' S. Kozuch, Phys. Chem. Chem. Phys., 13, 20104, 2011\n'). # Add member functionals; X = build_functional('PBE_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('PBE_C'); C.set_alpha(0.51); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.66); sup.set_c_alpha(1.0); sup.set_c_ss_alpha(0.12); sup.set_c_os_alpha(0.53). # => -D2 <=. sup.set_dispersion(PsiMod.Dispersion.build(*dash_server('dsd-pbepbe', 'd2p4'))). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b2plypd2p4_superfunctional(name, npoints, deriv):. sup = build_b2plyp_superfunctional(name, npoints, deriv); sup.set_name('B2PLYP-D2P4'). # => -D2 <= #; sup.set_dispersion(PsiMod.Dispersion.build(*dash_server('b2plyp', 'd2p4'))). return sup. [docs]def build_b2plypd2gr_superfunctional(name, npoints, deriv):. sup = build_b2plyp_superfunctional(name, npoints, deriv); sup.set_name('B2PLYP-D2GR'). # => -D2 <= #; sup.set_dispersion(PsiMod.Dispersion.build(*dash_server('b2plyp', 'd2gr'))). return sup. [docs]def build_b2plypd3zero_superfunctional(name, npoints, deriv):. sup = build_b2plyp_superfunctional(name, npoints, deriv); sup.set_name('B2PLYP-D3ZERO'). # => -D3 <= #; sup.set_dispersion(PsiMod.Dispersion.build(*dash_server('b2plyp', 'd3zero'))). return sup. [docs]def build_b2plypd3bj_superfunctional(name, npoints, deriv):. sup = build_b2plyp_superfunctional(name, npoints, deriv); sup.set_name('B2PLYP-D3BJ'). # => -D3 <= #; sup.set_dispersion(PsiMod.Dispersion.bu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/functional.html:77290,allocate,allocate,77290,psi4manual/4.0b4/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency,"ergies and forces. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. mints-benchmark; run some BLAS benchmarks. scf-bs; UHF and broken-symmetry UHF energy for molecular hydrogen. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Test Suite and Sample Inputs. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:40768,energy,energy,40768,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,8,['energy'],['energy']
Energy Efficiency,"ergies'][tup]. # Do ptype; if metadata['ptype'] != 'energy':; _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], cp_compute_list[n],; fragment_slice_dict, fragment_size_dict, cp_ptype_by_level[n]); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], nocp_compute_list[n],; fragment_slice_dict, fragment_size_dict, nocp_ptype_by_level[n]); _sum_cluster_ptype_data(; metadata['ptype'],; component_results['ptype'],; vmfc_level_list[n],; fragment_slice_dict,; fragment_size_dict,; vmfc_ptype_by_level[n],; vmfc=True,; n=n). if metadata['ptype'] != 'energy':; # Extract ptype data for monomers in monomer basis for CP total data; monomer_ptype = np.zeros(arr_shape); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], monomers_in_monomer_basis,; fragment_slice_dict, fragment_size_dict, monomer_ptype). # Compute cp energy and ptype; if 'cp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; cp_energy_body_dict[n] = cp_energy_by_level[n] - bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n] - bsse_ptype; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. if n == 1:; bsse = cp_energy_body_dict[n] - monomer_energies; cp_energy_body_dict[n] = monomer_energies; if metadata['ptype'] != 'energy':; bsse_ptype = cp_ptype_body_dict[n] - monomer_ptype; cp_ptype_body_dict[n] = monomer_ptype.copy(). else:; cp_energy_body_dict[n] -= bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n] -= bsse_ptype. cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. for n in nbody_range[1:]:; var_key ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:25196,energy,energy,25196,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,8,['energy'],['energy']
Energy Efficiency,"ergies); if min_index < 3 :; core.print_out(""\nWarning: fewer than 3 points provided with a r < r(min(E))!\n""); if min_index >= len(energies) - 3:; core.print_out(""\nWarning: fewer than 3 points provided with a r > r(min(E))!\n""). # Optimize the geometry, refitting the surface around each new geometry; core.print_out(""\nOptimizing geometry based on current surface:\n\n""); re = rvals[min_index]; maxit = 30; thres = 1.0e-9; for i in range(maxit):; derivs = least_squares_fit_polynomial(rvals,energies,localization_point=re); e,g,H = derivs[0:3]; core.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if abs(g) < thres:; break; re -= g/H; if i == maxit-1:; raise ConvergenceError(""diatomic geometry optimization"", maxit); core.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if re < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if re > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). # Convert to convenient units, and compute spectroscopic constants; d0,d1,d2,d3,d4 = derivs*constants.hartree2aJ; core.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % e); core.print_out(""Gradient %20.14f\n"" % g); core.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % d2); core.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % d3); core.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * np.pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11 * np.sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d4). # Rotational constant: Be; I = ((m1*m2)/(m1+m2)) * constants.amu2kg * (re * angstrom_to_meter)**2; B = constants.h / (8.0 * np.pi**2 * constants.c * I). # alpha_e and quartic centrifugal distortion constant; ae = -(6.0 * B**2 / we) * ((1.05052209e-3*we*d3)/(np.sqrt(B * d2**3))+1.0); de = 4.0*B**3 / we**2. # B0 and r0 (pl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/diatomic.html:5623,energy,energy,5623,psi4manual/1.6.x/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/diatomic.html,10,['energy'],['energy']
Energy Efficiency,"ergies_n_mon[n])); PsiMod.print_out('\n'). if bsse == 'both':; PsiMod.print_out(' => BSSE Results <=\n\n'); PsiMod.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""Delta E [H]"", ""Delta E [kcal mol^-1]"")); energies_n_bsse = {}; for n in Ns:; if n == 1:; continue; En = 0.0; for k in range(len(energies_mon[n])):; E = energies_full[n][k] - energies_mon[n][k]; for l in range(len(combos[n][k])):; E -= energies_full[1][combos[n][k][l] - 1]; E += energies_mon[1][combos[n][k][l] - 1]; PsiMod.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, E, physconst.psi_hartree2kcalmol * E)); En += E; energies_n_bsse[n] = En; for n in Ns:; if n == 1:; continue; nn = molecule.nfragments() - 2; kk = n - 2; energies_n_bsse[n] /= (math.factorial(nn) / (math.factorial(kk) * math.factorial(nn - kk))); PsiMod.print_out(' %6d %6s %24.16E %24.16E\n' % (n, 'Total', energies_n_bsse[n],; physconst.psi_hartree2kcalmol * energies_n_bsse[n])); PsiMod.print_out('\n'). PsiMod.print_out(' ==> N-Body Interaction Energy Analysis: Non-Additivities <==\n\n'). if bsse == 'on' or bsse == 'both':; energies_n_full[1] = 0.0; PsiMod.print_out(' => Full Basis Set Results <=\n\n'); PsiMod.print_out(' %6s %24s %24s\n' % (""N-Body"", ""E [H]"", ""E [kcal mol^-1]"")); for k in range(len(Ns)):; n = Ns[k]; if n == 1:; continue; E = energies_n_full[Ns[k]] - energies_n_full[Ns[k + 1]]; PsiMod.print_out(' %6s %24.16E %24.16E\n' % (n, E, physconst.psi_hartree2kcalmol * E)); PsiMod.print_out('\n'). if bsse == 'off' or bsse == 'both':; energies_n_mon[1] = 0.0; PsiMod.print_out(' => Cluster Basis Set Results <=\n\n'); PsiMod.print_out(' %6s %24s %24s\n' % (""N-Body"", ""E [H]"", ""E [kcal mol^-1]"")); for k in range(len(Ns)):; n = Ns[k]; if n == 1:; continue; E = energies_n_mon[Ns[k]] - energies_n_mon[Ns[k + 1]]; PsiMod.print_out(' %6s %24.16E %24.16E\n' % (n, E, physconst.psi_hartree2kcalmol * E)); PsiMod.print_out('\n'). if bsse == 'both':; energies_n_bsse[1] = 0.0; PsiMod.print_out(' => BSSE Results <=\n\n'); PsiMod.print_out(' %",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:14534,Energy,Energy,14534,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['Energy'],['Energy']
Energy Efficiency,"ergy Results //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. Variable Map:; ----------------------------------------------------------------------------; ""(T) CORRECTION ENERGY"" => -0.007263598030; ""CCSD CORRELATION ENERGY"" => -0.275705492359; ""CCSD TOTAL ENERGY"" => -76.338453952539; ""CCSD(T) CORRELATION ENERGY"" => -0.007263598030; ""CCSD(T) TOTAL ENERGY"" => -76.345717550569; ""CFOUR ERROR CODE"" => 0.000000000000; ""CURRENT CORRELATION ENERGY"" => -0.007263598030; ""CURRENT ENERGY"" => -76.345717550569; ""CURRENT REFERENCE ENERGY"" => -76.062748460180; ""MP2 CORRELATION ENERGY"" => -0.270191667755; ""MP2 OPPOSITE-SPIN ENERGY"" => -0.204890356651; ""MP2 SAME-SPIN ENERGY"" => -0.065301311104; ""MP2 TOTAL ENERGY"" => -76.332940127935; ""NUCLEAR REPULSION ENERGY"" => 9.187331653300; ""SCF TOTAL ENERGY"" => -76.062748460180. The PSI Variables are also available from the input file for manipulation.; For instance, to compute the MBPT 2 3/4 energy from MBPT 3 results, the; following could be used.; energy('c4-mp3'); mp2p75_corl = 0.75 * get_variable('mp3 correlation energy') + \; 0.25 * get_variable('MP2 correlation energy'); print mp2p75_corl + get_variable('scf total energy'). Caution; Some features are not yet implemented. Buy a developer a coffee. No PSI Variables for properties: e.g., SCF DIPOLE X; No PSI Variables for excited state energies. The formation of further regexes for properties, excited states, etc.; is one of the primary areas in which this interface requires further; work. Gradients and Arrays; In addition to parsing the output stream, results are collected from files; written to the scratch directory. Presently, the GRD file is parsed; and printed to the output file, as shown below. Also printed is the Cfour; gradient after manipulation by the P4C4 interface and used by PSI4; going forward. Manipulation is necessary because Cfour determinedly uses; its own internal orientation and atom ordering while PSI4 naturally; expects the gradient to be aligned with the active molecule.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:20179,energy,energy,20179,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,4,['energy'],['energy']
Energy Efficiency,"ergy Results //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. Variable Map:; ----------------------------------------------------------------------------; ""(T) CORRECTION ENERGY"" => -0.007263598030; ""CCSD CORRELATION ENERGY"" => -0.275705492359; ""CCSD TOTAL ENERGY"" => -76.338453952539; ""CCSD(T) CORRELATION ENERGY"" => -0.007263598030; ""CCSD(T) TOTAL ENERGY"" => -76.345717550569; ""CFOUR ERROR CODE"" => 0.000000000000; ""CURRENT CORRELATION ENERGY"" => -0.007263598030; ""CURRENT ENERGY"" => -76.345717550569; ""CURRENT REFERENCE ENERGY"" => -76.062748460180; ""MP2 CORRELATION ENERGY"" => -0.270191667755; ""MP2 OPPOSITE-SPIN ENERGY"" => -0.204890356651; ""MP2 SAME-SPIN ENERGY"" => -0.065301311104; ""MP2 TOTAL ENERGY"" => -76.332940127935; ""NUCLEAR REPULSION ENERGY"" => 9.187331653300; ""SCF TOTAL ENERGY"" => -76.062748460180. The PSI Variables are also available from the input file for manipulation.; For instance, to compute the MBPT 2 3/4 energy from MBPT 3 results, the; following could be used.; energy('c4-mp3'); mp2p75_corl = 0.75 * get_variable('mp3 correlation energy') + \; 0.25 * get_variable('MP2 correlation energy'); print mp2p75_corl + get_variable('scf total energy'). Caution; Some features are not yet implemented. Buy a developer a coffee. No PSI Variables for properties: e.g., SCF DIPOLE X; No PSI Variables for excited state energies. The formation of further regexes for properties, excited states, etc.; is one of the primary areas in which this interface requires further; work. Gradients and Arrays; In addition to parsing the output stream, results are collected from files; written to the scratch directory. Presently, the GRD file is parsed; and printed to the output file, as shown below. Also printed is the Cfour; gradient after manipulation by the P4C4 interface and used by Psi4; going forward. Manipulation is necessary because Cfour determinedly uses; its own internal orientation and atom ordering while Psi4 naturally; expects the gradient to be aligned with the active molecule.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:20244,energy,energy,20244,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"ergy Results //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. Variable Map:; ----------------------------------------------------------------------------; ""(T) CORRECTION ENERGY"" => -0.007263598030; ""CCSD CORRELATION ENERGY"" => -0.275705492359; ""CCSD TOTAL ENERGY"" => -76.338453952539; ""CCSD(T) CORRELATION ENERGY"" => -0.007263598030; ""CCSD(T) TOTAL ENERGY"" => -76.345717550569; ""CFOUR ERROR CODE"" => 0.000000000000; ""CURRENT CORRELATION ENERGY"" => -0.007263598030; ""CURRENT ENERGY"" => -76.345717550569; ""CURRENT REFERENCE ENERGY"" => -76.062748460180; ""MP2 CORRELATION ENERGY"" => -0.270191667755; ""MP2 OPPOSITE-SPIN ENERGY"" => -0.204890356651; ""MP2 SAME-SPIN ENERGY"" => -0.065301311104; ""MP2 TOTAL ENERGY"" => -76.332940127935; ""NUCLEAR REPULSION ENERGY"" => 9.187331653300; ""SCF TOTAL ENERGY"" => -76.062748460180. The PSI Variables are also available from the input file for manipulation.; For instance, to compute the MBPT 2 3/4 energy from MBPT 3 results, the; following could be used.; energy('c4-mp3'); mp2p75_corl = 0.75 * get_variable('mp3 correlation energy') + \; 0.25 * get_variable('MP2 correlation energy'); print mp2p75_corl + get_variable('scf total energy'). Caution; Some features are not yet implemented. Buy a developer a coffee. No PSI Variables for properties: e.g., SCF DIPOLE; No PSI Variables for excited state energies. The formation of further regexes for properties, excited states, etc.; is one of the primary areas in which this interface requires further; work. Gradients and Arrays; In addition to parsing the output stream, results are collected from files; written to the scratch directory. Presently, the GRD file is parsed; and printed to the output file, as shown below. Also printed is the Cfour; gradient after manipulation by the P4C4 interface and used by PSI4; going forward. Manipulation is necessary because Cfour determinedly uses; its own internal orientation and atom ordering while PSI4 naturally; expects the gradient to be aligned with the active molecule. T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/cfour.html:20165,energy,energy,20165,psi4manual/1.6.x/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/cfour.html,5,['energy'],['energy']
Energy Efficiency,"ergy [E_h] for the requested theory and root n (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (IN h) TOTAL ENERGY¶. TD-fctl ROOT n (IN h) TOTAL ENERGY¶; The total electronic energy [E_h] for the requested theory and root n within irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (h) TOTAL ENERGY¶. TD-fctl ROOT n (h) TOTAL ENERGY¶; The total electronic energy [E_h] for the requested theory and root n, which is of irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n TOTAL ENERGY - h TRANSITION¶. TD-fctl ROOT n TOTAL ENERGY - h TRANSITION¶; The total electronic energy [E_h] for the requested theory and root n, and the transition is of irrep h, (n starts at 0). CCname ROOT n CORRELATION ENERGY¶; The correlation energy [E_h] for the requested coupled cluster level of theory and root n (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (IN h) CORRELATION ENERGY¶; The correlation energy [E_h] for the requested coupled cluster level of theory and root n within irrep h (n starts at 0). CCname ROOT n (h) CORRELATION ENERGY¶; The correlation energy [E_h] for the requested coupled cluster level of theory and root n, which is of irrep h (n starts at 0). CCname ROOT n CORRELATION ENERGY - h TRANSITION¶; The correlation energy [E_h] for the requested coupled cluster level of theory and root n, and the transition is of irrep h, (n starts at 0). CCname ROOT n DIPOLE¶; Dipole array [e a0] for the requested coupled cluster level of theory and root n (n starts at 0), (3,). CCname ROOT n (IN h) DIPOLE¶; Dipole array [e a0] for the requested coupled cluster level of theory and root n within irrep h (n starts at 0), (3,). CCname ROOT n (h) DIPOLE¶; Dipole array [e a0] for the requested coupled cluster level of theory and root n, which is of irrep h (n starts at 0), (3,). CCname ROOT n DIPOLE - h TRANSITION¶; Dipole array [e a0] for the requested coupled cluster level of theory and root n, and the tr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:9153,energy,energy,9153,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"ergy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. BASIS_RELATIVISTIC¶. Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. table of contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; BASIS_RELATIVISTIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Theoretical Methods: SCF to FCI; Scalar relativistic Hamiltonians. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/relativistic.html:4889,energy,energy,4889,psi4manual/master/relativistic.html,https://psicode.org,https://psicode.org/psi4manual/master/relativistic.html,1,['energy'],['energy']
Energy Efficiency,"ergy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. BASIS_RELATIVISTIC¶. Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. table of contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; BASIS_RELATIVISTIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/relativistic-1.html:4942,energy,energy,4942,psi4manual/1.2.1/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/relativistic-1.html,2,['energy'],['energy']
Energy Efficiency,"ergy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. BASIS_RELATIVISTIC¶. Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. table of contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; BASIS_RELATIVISTIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/relativistic-1.html:4942,energy,energy,4942,psi4manual/1.3.2/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/relativistic-1.html,2,['energy'],['energy']
Energy Efficiency,"ergy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. BASIS_RELATIVISTIC¶. Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. table of contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; BASIS_RELATIVISTIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Theoretical Methods: SCF to FCI; Scalar relativistic Hamiltonians. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/relativistic-1.html:4880,energy,energy,4880,psi4manual/1.4.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/relativistic-1.html,2,['energy'],['energy']
Energy Efficiency,"ergy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. BASIS_RELATIVISTIC¶. Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. table of contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; BASIS_RELATIVISTIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Theoretical Methods: SCF to FCI; Scalar relativistic Hamiltonians. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/relativistic-1.html:4880,energy,energy,4880,psi4manual/1.5.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/relativistic-1.html,2,['energy'],['energy']
Energy Efficiency,"ergy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. BASIS_RELATIVISTIC¶. Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. table of contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; BASIS_RELATIVISTIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Scalar relativistic Hamiltonians. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/relativistic.html:4880,energy,energy,4880,psi4manual/1.6.x/relativistic.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/relativistic.html,1,['energy'],['energy']
Energy Efficiency,"ergy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. BASIS_RELATIVISTIC¶. Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. table of contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; BASIS_RELATIVISTIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Theoretical Methods: SCF to FCI; Scalar relativistic Hamiltonians. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/relativistic.html:4880,energy,energy,4880,psi4manual/1.7.x/relativistic.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/relativistic.html,1,['energy'],['energy']
Energy Efficiency,"ergy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. BASIS_RELATIVISTIC¶. Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. table of contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; BASIS_RELATIVISTIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Theoretical Methods: SCF to FCI; Scalar relativistic Hamiltonians. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 Octobe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/relativistic.html:4882,energy,energy,4882,psi4manual/1.8.x/relativistic.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/relativistic.html,1,['energy'],['energy']
Energy Efficiency,"ergy and nuclear-electron interaction potential (\(V\)), coupling matrix ( \(X\)) and renormalization matrix ( \(R\)). \[T_{\rm X2C} = R^{\dagger} (TX + {X}^{\dagger}T - {X}^{\dagger}TX ) R\]. \[V_{\rm X2C} = R^{\dagger}(V + \frac{1}{4c^2} X^{\dagger}W^{\text{SF}}X) R\]; The coupling matrix ( \({X} = C^{S} (C^{L})^{-1}\) ) is obtained from the large (\(C^{\rm L}\)) and small (\(C^{\rm S}\)) components of the \(N\) positive energy solutions of the Dirac equation.; The renormalization matrix; \({R}=S^{-1/2}(S^{-1/2}\tilde{S}S^{-1/2})^{-1/2}S^{1/2}\),; depends on the modified overlap matrix; \(\tilde{S}=S+\frac{1}{2c^2}X^{\dagger}TX\). The integrals \(W^{\rm SF}_{\mu\nu} = \langle {\chi_\mu} | \hat{p}\cdot (\hat{V}\hat{p}) |{\chi_\nu}\rangle\) can be easily computed as derivatives of the nuclear-electron attraction integrals with respect to nuclear coordinates.; Existing nonrelativistic electronic structure code can be extended to include scalar relativistic effects; treated with the X2C method by replacing nonrelativistic kinetic and potential energy with the corresponding; X2C operators \(T_{X2C}\) and \(V_{X2C}\). It is important to note that fully uncontracted basis in needed for the construction of X2C Hamiltonian as Foldy-Wouthuysen (FW [FW:1950]) transformation is obtained in kinetically balance basis. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. BASIS_RELATIVISTIC¶. Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. table of contents. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory; Keywords; RELATIVISTIC; BASIS_RELATIVISTIC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Theoretical Methods: SCF to FCI; Scalar relativistic Hamiltonians. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 Februar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/relativistic.html:4882,energy,energy,4882,psi4manual/1.9.x/relativistic.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/relativistic.html,1,['energy'],['energy']
Energy Efficiency,"ergy between Ne and Ar atoms. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. mints3; Test individual integral objects for correctness. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. linK-3; UHF and ROHF Linear Exchange Algorithm test for benzyl cation. pubchem2; Superficial test of PubChem interface. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. matrix2; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. casscf-sp; CASSCF/6-31G** energy point. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:6590,energy,energy,6590,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ergy component [Eh]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CCSDT(Q)/A TOTAL ENERGY¶. CCSDT(Q)/A CORRELATION ENERGY¶. CCSDT(Q)/B TOTAL ENERGY¶. CCSDT(Q)/B CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the modified CCSDT(Q) level of theory. CCSD DIPOLE POLARIZABILITY @ xNM¶; The dipole polarizability [au] calculated at the CCSD level; for a given (x) wavelength, (x) rounded to nearest integer. CCSD SPECIFIC ROTATION (LEN) @ xNM¶; The specific rotation [deg/(dm (g/cm^3))] calculated at the CCSD level in the; length gauge for a given (x) wavelength, (x) rounded to nearest integer. CCSD SPECIFIC ROTATION (VEL) @ xNM¶; The specific rotation [deg/(dm (g/cm^3))] calculated at the CCSD level in the; velocity gauge for a given (x) wavelength, (x) rounded to nearest integer. CCSD SPECIFIC ROTATION (MVG) @ xNM¶; The specific rotation [deg/(dm (g/cm^3))] calculated at the CCSD level in the; modified veloci",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:7943,energy,energy,7943,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency,"ergy component [Eh]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CCSDT(Q)/A TOTAL ENERGY¶. CCSDT(Q)/A CORRELATION ENERGY¶. CCSDT(Q)/B TOTAL ENERGY¶. CCSDT(Q)/B CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the modified CCSDT(Q) level of theory. CEPA(0) DIPOLE¶; Dipole array [e a0] for the coupled electron pair approximation variant 0 level of theory, (3,). CEPA(0) QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the coupled electron pair approximation variant 0 level of theory, (3, 3). CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested variant of coupled electron pair approximation level of theory. CFOUR ERROR CODE¶; The non-zero return value from a Cfo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:19946,energy,energy,19946,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,2,['energy'],['energy']
Energy Efficiency,"ergy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. fnocc3; Test FNO-QCISD(T) computation. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest state of H2O+ (A1 excitation). cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. cc52; CCSD Response for H2O2. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. dcft6; DCFT calculation for the trip",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:4993,energy,energy,4993,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ergy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:. scf_basis (basis string) – \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:. scf_scheme (str) – \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'scf_xtpl_helgaker_3' || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_helgaker_3() if three valid basis sets; present in psi4.driver.driver_cbs.scf_basis, scf_xtpl_helgaker_2() if two valid basis; sets present in scf_basis, and xtpl_highest_1() otherwise. xtpl_highest_1(); scf_xtpl_helgaker_3(); scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_scheme (str) – \(\Rightarrow\) 'xtpl_highest_1' \(\Leftarrow\) || 'corl_xtpl_helgaker_2' || etc.; Indicates the basis set extrapolation scheme to be applied to the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html:7463,energy,energy,7463,psi4manual/1.7.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html,12,['energy'],['energy']
Energy Efficiency,"ergy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: cbs(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY <CBSTOTALENERGY>`; * :psivar:`CBS REFERENCE ENERGY <CBSREFERENCEENERGY>`; * :psivar:`CBS CORRELATION ENERGY <CBSCORRELATIONENERGY>`; * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t);",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:18602,energy,energy,18602,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,4,['energy'],['energy']
Energy Efficiency,"ergy of H2O+. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. dcft1; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. Previous topic; Test Suite and Sample Inputs; Next topic; Basis Sets by Element; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices »; Test Suite and Sample Inputs ». © Copyright 2013, The Psi4 Project.; Last updated o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:22735,charge,charge,22735,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,2,['charge'],['charge']
Energy Efficiency,"ergy routines; if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'E_CONVERGENCE', scf_Ec); if verbose >= 2:; print(scf_Ec, end=' '); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', pscf_Ec); if verbose >= 2:; print(pscf_Ec, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'E_CONVERGENCE'), end=' '). if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'D_CONVERGENCE', scf_Dc); if verbose >= 2:; print(scf_Dc, end=' '); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', pscf_Dc); if verbose >= 2:; print(pscf_Dc, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'D_CONVERGENCE'), end=' '). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if procedures['energy'][method_name] not in [proc.run_scf, proc.run_dft]:; psi4.set_global_option('E_CONVERGENCE', gen_Ec); if verbose >= 2:; print(gen_Ec, end=' '); else:; if procedures['energy'][method_name] not in [proc.run_scf, proc.run_dft]:; if verbose >= 2:; print('CUSTOM', psi4.get_global_option('E_CONVERGENCE'), end=' '). if verbose >= 2:; print(''); return optstash. [docs]def parse_arbitrary_order(name):; r""""""Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. """""". name = name.lower(). # matches 'mrccsdt(q)'; if name.startswith('mrcc'):. # avoid undoing fn's good work when called twice; if name == 'mrcc':; return name, None. # grabs 'sdt(q)'; ccfullname = name[4:]. # A negative order indicates perturbative method; methods = {; 'sd' : { 'method': 1, 'order': 2, 'fullname': 'CCSD' },; 'sdt' : { 'method': 1, 'order': 3, 'fullname': 'CCSDT' },; 'sdtq' : { 'method': 1, 'order': 4, 'fullname': 'CCSDTQ' },; '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:3965,energy,energy,3965,psi4manual/1.0.0/_modules/driver_util.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html,1,['energy'],['energy']
Energy Efficiency,"ergy'] = job['f_energy']. for stage in GRAND_NEED:; stage['d_energy'] = call_function_in_1st_argument(stage['d_scheme'], needname=stage['d_need'], mode='evaluate'); finalenergy += stage['d_energy'] * stage['d_coef']. # Build string of results table; table_delimit = ' ' + '-' * 105 + '\n'; tables = ''; tables += """"""\n ==> %s <==\n\n"""""" % ('Components'); tables += table_delimit; tables += """""" %6s %20s %1s %-26s %3s %16s %-s\n"""""" % ('', 'Method', '/', 'Basis', 'Rqd', 'Energy [H]', 'Variable'); tables += table_delimit; for job in JOBS_EXT:; star = ''; for mc in MODELCHEM:; if (job['f_wfn'] == mc['f_wfn']) and (job['f_basis'] == mc['f_basis']):; star = '*'; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('', job['f_wfn'],; '/', job['f_basis'], star, job['f_energy'], VARH[job['f_wfn']][job['f_wfn'] + job['f_portion']]); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('Stages'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', 'Wt', 'Energy [H]', 'Scheme'); tables += table_delimit; for stage in GRAND_NEED:; tables += """""" %6s %20s %1s %-27s %2d %16.8f %-s\n"""""" % (stage['d_stage'], stage['d_wfn'],; '/', stage['d_basis'], stage['d_coef'], stage['d_energy'], stage['d_scheme'].__name__); tables += table_delimit. tables += """"""\n ==> %s <==\n\n"""""" % ('CBS'); tables += table_delimit; tables += """""" %6s %20s %1s %-27s %2s %16s %-s\n"""""" % ('Stage', 'Method', '/', 'Basis', '', 'Energy [H]', 'Scheme'); tables += table_delimit; if do_scf:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[0]['d_stage'], GRAND_NEED[0]['d_wfn'],; '/', GRAND_NEED[0]['d_basis'], '', GRAND_NEED[0]['d_energy'], GRAND_NEED[0]['d_scheme'].__name__); if do_corl:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[1]['d_stage'], GRAND_NEED[1]['d_wfn'],; '/', GRAND_NEED[1]['d_basis'], '', GRAND_NEED[1]['d_energy'], GRAND_NEED[1]['d_scheme'].__name__); if do_delta:; tables += """""" %6s %20s %1s %-27s ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:72132,Energy,Energy,72132,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,4,['Energy'],['Energy']
Energy Efficiency,"ergy'], GRAND_NEED[1]['d_scheme'].__name__); if len(metadata) > 2:; dc = 3; for delta in metadata[2:]:; deltaE_total = GRAND_NEED[dc]['d_energy'] - GRAND_NEED[dc + 1]['d_energy']; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (; GRAND_NEED[dc]['d_stage'], GRAND_NEED[dc]['d_wfn'] + ' - ' + GRAND_NEED[dc + 1]['d_wfn'], '/',; GRAND_NEED[dc]['d_basis'], '', deltaE_total,; GRAND_NEED[dc]['d_scheme'].__name__); core.set_variable(f""CBS {GRAND_NEED[dc]['d_stage'].upper()} TOTAL ENERGY"", deltaE_total); dc += 2. tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. core.print_out(tables). core.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); core.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); core.set_variable('CBS TOTAL ENERGY', finalenergy); core.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); core.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); core.set_variable('CURRENT ENERGY', finalenergy); core.set_variable('CBS NUMBER', Njobs). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; basis = core.BasisSet.build(molecule, ""ORBITAL"", 'def2-svp'); wfn = core.Wavefunction(molecule, basis). optstash.restore(). if ptype == 'energy':; finalquantity = finalenergy; elif ptype == 'gradient':; finalquantity = finalgradient; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif ptype == 'hessian':; finalquantity = finalhessian; wfn.set_gradient(finalgradient); wfn.set_hessian(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT HESSIAN'); finalquantity.print_out(). if return_wfn:; return (finalquantity, wfn); else:; return finalquantity. ######### COMPUTE / ASSEMBLE; ######### ASSEMBLE / REPORT. def _expand_scheme_orders(scheme, basisname, basiszeta, wfnname, option",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:59785,ENERGY,ENERGY,59785,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"ergy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set globals basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn = True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""MP2/cc-pV[DT]Z""). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody._nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). for precallback in hooks['energy']['pre']:; precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if restartfile != list(restartfile):; restartfile = [restartfile]; # Rename the files to be read to be consistent with ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:29131,energy,energy,29131,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"ergy('scf'); >>> H2.set_multiplicity(3); >>> energy('detci', bypass_scf=True). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). optstash = OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; # Set method-dependent scf convergence criteria; if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 6); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 8); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 6); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 8). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 6). procedures['energy'][lowername](lowername, **kwargs). except KeyError:; raise ValidationError('Energy method %s not available.' % (lowername)). optstash.restore(); return PsiMod.get_variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. optstash = OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']).",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:29705,energy,energy,29705,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,4,['energy'],['energy']
Energy Efficiency,"ergy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:119243,ENERGY,ENERGY,119243,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['ENERGY'],['ENERGY']
Energy Efficiency,"ergy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree-Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree-Fock (RHF) on neutral singlet Helium in; spatial symmetry with a minimal STO-3G basis, 1.0E-6; energy and 1.0E-5 density convergence criteria (since single-point, see; SCF Convergence & Algorithm), a DF ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more; information on any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of Hartree-Fock; theory, including:. Restricted Hartree-Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree-Fock (UHF); Appropriate for most open-shell systems, and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/scf-1.html:5837,energy,energy,5837,psi4manual/4.0b4/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/scf-1.html,4,['energy'],['energy']
Energy Efficiency,"ergy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree-Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree-Fock (RHF) on neutral singlet Helium in; spatial symmetry with a minimal STO-3G basis, 1.0E-6; energy and 1.0E-5 density convergence criteria (since single-point, see; SCF Convergence & Algorithm), a DF ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more; information on any of these options, see the relevant section below. Spin/Symmetry Treatment¶; Psi4 implements the most popular spin specializations of Hartree-Fock; theory, including:. Restricted Hartree-Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree-Fock (UHF); Appropriate for most open-shell systems, and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:5800,energy,energy,5800,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['energy'],['energy']
Energy Efficiency,"ergy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree-Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree-Fock (RHF) on neutral singlet Helium in; spatial symmetry with a minimal STO-3G basis, 1.0E-6; energy and 1.0E-5 density convergence criteria (since single-point, see; SCF Convergence & Algorithm), a PK ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more; information on any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of Hartree-Fock; theory, including:. Restricted Hartree-Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree-Fock (UHF); Appropriate for most open-shell systems, and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/scf-1.html:5188,energy,energy,5188,psi4manual/4.0b3/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/scf-1.html,2,['energy'],['energy']
Energy Efficiency,"ergy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree-Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree-Fock (RHF) on neutral singlet Helium in; spatial symmetry with a minimal STO-3G basis, 1.0E-8 energy; and density convergence criteria, a PK ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more information on; any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of Hartree-Fock; theory, including:. Restricted Hartree-Fock (RHF) [Default]; Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical.; Unrestricted Hartree-Fock (UHF); Appropriate for most open-shell systems, and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:5180,energy,energy,5180,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,2,['energy'],['energy']
Energy Efficiency,"ergy. :param expected: reference FCIDUMP file; :param computed: computed FCIDUMP file; :param label: string labelling the test; """""". try:; from deepdiff import DeepDiff; except ImportError:; raise ImportError(""""""Install deepdiff. `conda install deepdiff -c conda-forge` or `pip install deepdiff`""""""). # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; header_diff = DeepDiff(; ref_intdump,; intdump,; ignore_order=True,; exclude_paths={""root['enuc']"", ""root['hcore']"", ""root['eri']"", ""root['epsilon']""}); if header_diff:; message = (""\tComputed FCIDUMP file header does not match expected header.\n""); raise TestComparisonError(header_diff). ref_energies = _energies_from_fcidump(ref_intdump); energies = _energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7, label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7, label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10, label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10, label + '. MP2 correlation energy'). if (pass_1el and pass_2el and pass_scf and pass_mp2):; success(label). return True. def _energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATIO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html:12733,energy,energy,12733,psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,1,['energy'],['energy']
Energy Efficiency,"ergy_body_dict, ""Counterpoise Corrected (CP)""); cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; nbody_dict['Counterpoise Corrected Total Energy'] = cp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. for n in nbody_range[1:]:; var_key = 'CP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = cp_energy_body_dict[n] - cp_energy_body_dict[1]. # Compute nocp energy and ptype; if 'nocp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; nocp_energy_body_dict[n] = nocp_energy_by_level[n]; if metadata['ptype'] != 'energy':; nocp_ptype_body_dict[n][:] = nocp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1) ** (n - k)); value = nocp_energy_by_level[k]; nocp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = nocp_ptype_by_level[k]; nocp_ptype_body_dict[n] += take_nk * sign * value. _print_nbody_energy(nocp_energy_body_dict, ""Non-Counterpoise Corrected (NoCP)""); nocp_interaction_energy = nocp_energy_body_dict[metadata['max_nbody']] - nocp_energy_body_dict[1]; nbody_dict['Non-Counterpoise Corrected Total Energy'] = nocp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Non-Counterpoise Corrected Interaction Energy'] = nocp_interaction_energy. for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = nocp_energy_body_dict[n] - nocp_energy_body_dict[1]. # Compute vmfc energy and ptype; if 'vmfc' in metadata['bsse_type_list']:; _print_nbody_energy(vmfc_energy_body_dict, ""Valiron-Mayer Function Couterpoise (VMFC)""); vmfc_interaction_energy = vmfc_energy_body_dict[metadata['max_nbody']] - vmfc_energy_body_dict[1]; nbody_dict['Valiron-Mayer Function Couterpoise Total Energy'] = vmfc_energy_body_dict[metadata['max_nbody']]; nbody_dict['Valiron-Mayer Function Co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html:22551,energy,energy,22551,psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"ergy_by_level[n] = sum(component_results['energies'][v] for v in cp_compute_list[n]); nocp_energy_by_level[n] = sum(component_results['energies'][v] for v in nocp_compute_list[n]). # Special vmfc case; if n > 1:; vmfc_energy_body_dict[n] = vmfc_energy_body_dict[n - 1]; for tup in vmfc_level_list[n]:; vmfc_energy_body_dict[n] += ((-1)**(n - len(tup[0]))) * component_results['energies'][tup]. # Do ptype; if metadata['ptype'] != 'energy':; _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], cp_compute_list[n],; fragment_slice_dict, fragment_size_dict, cp_ptype_by_level[n]); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], nocp_compute_list[n],; fragment_slice_dict, fragment_size_dict, nocp_ptype_by_level[n]); _sum_cluster_ptype_data(; metadata['ptype'],; component_results['ptype'],; vmfc_level_list[n],; fragment_slice_dict,; fragment_size_dict,; vmfc_ptype_by_level[n],; vmfc=True,; n=n). if metadata['ptype'] != 'energy':; # Extract ptype data for monomers in monomer basis for CP total data; monomer_ptype = np.zeros(arr_shape); _sum_cluster_ptype_data(metadata['ptype'], component_results['ptype'], monomers_in_monomer_basis,; fragment_slice_dict, fragment_size_dict, monomer_ptype). # Compute cp energy and ptype; if 'cp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; cp_energy_body_dict[n] = cp_energy_by_level[n] - bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n] - bsse_ptype; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. if n == 1:; bsse = cp_energy_body_dict[n] - monomer_energies; cp_energy_body_dict[n] = monomer_energies; if metadata['ptype'] != 'energy':; bsse_ptype = cp_ptype_body_dict[n] - mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:24910,energy,energy,24910,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,4,['energy'],['energy']
Energy Efficiency,"erical Points. Type: integer; Default: 302. MCSCF_ALGORITHM (DETCI)¶DETCI — Convergence algorithm to utilize. Two-Step, Augmented Hessian. Defaults to TS for RASSCF. Type: string; Possible Values: TS, AH; Default: TS. MCSCF_CI_CLEANUP (DETCI)¶DETCI — Cleanup the CI info at the end of a run?. Type: boolean; Default: true. MCSCF_DIIS_ERROR_TYPE (DETCI)¶DETCI — DIIS error vector type either, the AO orbital gradient or the orbital rotation update matrix. Type: string; Possible Values: GRAD, UPDATE; Default: GRAD. MCSCF_DIIS_FREQ (DETCI)¶DETCI — How often to do a DIIS extrapolation for TS convergence. Type: integer; Default: 1. MCSCF_DIIS_MAX_VECS (DETCI)¶DETCI — Maximum number of DIIS vectors for TS convergence. Type: integer; Default: 8. MCSCF_DIIS_START (DETCI)¶DETCI — Iteration to turn on DIIS for TS convergence. Type: integer; Default: 3. MCSCF_DPD_CLEANUP (DETCI)¶DETCI — Cleanup the DPD MCSCF object at the end of a run?. Type: boolean; Default: true. MCSCF_E_CONVERGENCE (DETCI)¶DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-7. MCSCF_GUESS (DETCI)¶DETCI — Initial MCSCF starting guess, MP2 natural orbitals only available for DF-RHF reference. Type: string; Possible Values: MP2, SCF; Default: SCF. MCSCF_MAX_ROT (DETCI)¶DETCI — Maximum value in the rotation matrix. If a value is greater than this number all values are scaled. Type: double; Default: 0.5. MCSCF_MAXITER (DETCI)¶DETCI — Maximum number MCSCF of iterations. Type: integer; Default: 30. MCSCF_R_CONVERGENCE (DETCI)¶DETCI — Convergence criterion for the RMS of the orbital gradient. Type: conv double; Default: 1e-5. MCSCF_ROTATE (DETCI)¶DETCI — Apply a list of 2x2 rotation matrices to the orbitals in the form of [irrep, orbital1, orbital2, theta] where an angle of 0 would do nothing and an angle of 90 would switch the two orbitals. Type: array; Default: No Default. MCSCF_SO_START_E (DETCI)¶DE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:169505,energy,energy,169505,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,4,['energy'],['energy']
Energy Efficiency,"erical/Cartesian with basis and cfour_spherical. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/kw-2; testing best practices options, part ii. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_cfour.html:2763,energy,energy,2763,psi4manual/1.7.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_cfour.html,1,['energy'],['energy']
Energy Efficiency,"erm in EFP computation?. Type: boolean; Default: true. EFP_DISP_DAMPING¶. Fragment-fragment dispersion damping type. TT is a damping formula by Tang and Toennies. OVERLAP is overlap-based dispersion damping. Type: string; Possible Values: TT, OVERLAP, OFF; Default: OVERLAP. EFP_ELST¶. Do include electrostatics energy term in EFP computation?. Type: boolean; Default: true. EFP_ELST_DAMPING¶. Fragment-fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH¶. Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_IND¶. Do include polarization energy term in EFP computation? (EFP_POL c. v1.1). Type: boolean; Default: true. EFP_IND_DAMPING¶. Fragment-fragment polarization damping type. TT is a damping formula like Tang and Toennies. (EFP_POL_DAMPING c. v1.1). Type: string; Possible Values: TT, OFF; Default: TT. EFP_QM_ELST¶. Do include electrostatics energy term in QM/EFP computation? (QMEFP_ELST c. v1.1). Type: boolean; Default: true. EFP_QM_IND¶. Do include polarization energy term in QM/EFP computation? (QMEFP_POL c. v1.1). Type: boolean; Default: true. PRINT¶. The amount of information printed to the output file. Type: integer; Default: 1. Expert¶. DERTYPE¶. Do EFP gradient?. Type: string; Possible Values: NONE, FIRST; Default: NONE. QMEFP¶. Do turn on QM/EFP terms?. Type: boolean; Default: false. table of contents. EFP; General; EFP_DISP; EFP_DISP_DAMPING; EFP_ELST; EFP_ELST_DAMPING; EFP_EXCH; EFP_IND; EFP_IND_DAMPING; EFP_QM_ELST; EFP_QM_IND; PRINT. Expert; DERTYPE; QMEFP. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; EFP. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__efp.html:1358,energy,energy,1358,psi4manual/1.8.x/autodir_options_c/module__efp.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__efp.html,4,['energy'],['energy']
Energy Efficiency,"erm in EFP computation?. Type: boolean; Default: true. EFP_DISP_DAMPING¶. Fragment-fragment dispersion damping type. TT is a damping formula by Tang and Toennies. OVERLAP is overlap-based dispersion damping. Type: string; Possible Values: TT, OVERLAP, OFF; Default: OVERLAP. EFP_ELST¶. Do include electrostatics energy term in EFP computation?. Type: boolean; Default: true. EFP_ELST_DAMPING¶. Fragment-fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH¶. Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_IND¶. Do include polarization energy term in EFP computation? (EFP_POL c. v1.1). Type: boolean; Default: true. EFP_IND_DAMPING¶. Fragment-fragment polarization damping type. TT is a damping formula like Tang and Toennies. (EFP_POL_DAMPING c. v1.1). Type: string; Possible Values: TT, OFF; Default: TT. EFP_QM_ELST¶. Do include electrostatics energy term in QM/EFP computation? (QMEFP_ELST c. v1.1). Type: boolean; Default: true. EFP_QM_IND¶. Do include polarization energy term in QM/EFP computation? (QMEFP_POL c. v1.1). Type: boolean; Default: true. PRINT¶. The amount of information printed to the output file. Type: integer; Default: 1. Expert¶. DERTYPE¶. Do EFP gradient?. Type: string; Possible Values: NONE, FIRST; Default: NONE. QMEFP¶. Do turn on QM/EFP terms?. Type: boolean; Default: false. table of contents. EFP; General; EFP_DISP; EFP_DISP_DAMPING; EFP_ELST; EFP_ELST_DAMPING; EFP_EXCH; EFP_IND; EFP_IND_DAMPING; EFP_QM_ELST; EFP_QM_IND; PRINT. Expert; DERTYPE; QMEFP. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; EFP. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__efp.html:1358,energy,energy,1358,psi4manual/1.9.x/autodir_options_c/module__efp.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__efp.html,4,['energy'],['energy']
Energy Efficiency,"ername == 'df-ccsd'):; PsiMod.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); if (lowername == 'df-ccsd(t)'):; PsiMod.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); if (lowername == 'fno-df-ccsd'):; PsiMod.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); PsiMod.set_local_option('FNOCC', 'NAT_ORBS', True); if (lowername == 'fno-df-ccsd(t)'):; PsiMod.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); PsiMod.set_local_option('FNOCC', 'NAT_ORBS', True). # set scf-type to df unless the user wants something else; if PsiMod.has_option_changed('SCF','SCF_TYPE') == False:; PsiMod.set_local_option('SCF','SCF_TYPE', 'DF'). if PsiMod.get_option('FNOCC','DF_BASIS_CC') == '':; basis = PsiMod.get_global_option('BASIS'); dfbasis = corresponding_rifit(basis); PsiMod.set_local_option('FNOCC','DF_BASIS_CC',dfbasis). scf_helper(name,**kwargs); PsiMod.fnocc(). molecule.reset_point_group(user_pg); molecule.update_geometry(). # restore options; optstash.restore(). return PsiMod.get_variable(""CURRENT ENERGY""). [docs]def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); if 'level' in kwargs:; level = kwargs['level']; else:; level = 0; . # stash user options:; optstash = OptionsState(; ['TRANSQT2','WFN'],; ['FNOCC','RUN_MP2'],; ['FNOCC','RUN_MP3'],; ['FNOCC','RUN_MP4'],; ['FNOCC','RUN_CCSD'],; ['FNOCC','COMPUTE_TRIPLES'],; ['FNOCC','COMPUTE_MP4_TRIPLES'],; ['FNOCC','DFCC'],; ['FNOCC','RUN_CEPA'],; ['FNOCC','NAT_ORBS']). PsiMod.set_local_option('FNOCC','DFCC', False); PsiMod.set_local_option('FNOCC','RUN_CEPA', False). # which method?; if (lowername == '_ccsd'):; PsiMod.set_local_option('FNOCC','COMPUTE_TRIPLES', False); PsiMod.set_local_option('FNOCC','RUN_CCSD', True); elif (lowername == '_ccsd(t)'):; PsiMod.set_local_option('FNOCC','COMPUTE_TRIPLES', True); PsiMod.set_local_option('FNOCC','RUN_CCSD', Tr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:69970,ENERGY,ENERGY,69970,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"erpoise correction. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. tdscf-1; td-uhf test on triplet states of methylene (rpa). scf-hess5; DF SCF 6-31G analytical vs finite-difference tests Tests DF UHF hessian code for Ca != Cb. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. scf-ecp2; Water-Argon complex with ECP present; check of RHF Hessian. fnocc7; Test fnocc with linear dependencies. props4; Electrostatic potential and electric field evaluated on a grid around water. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix inp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:44264,energy,energy,44264,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"erridden by ``embedding_charges``; if both are provided. :type charge_type: str; :param charge_type: ``MULLIKEN_CHARGES`` || ``LOWDIN_CHARGES``. Default is ``MULLIKEN_CHARGES``; """""". # Initialize dictionaries for easy data passing; metadata, component_results, nbody_results = {}, {}, {}. # Parse some kwargs; kwargs = p4util.kwargs_lower(kwargs); if kwargs.get('levels', False):; return driver_nbody_helper.multi_level(func, **kwargs); metadata['ptype'] = kwargs.pop('ptype', None); metadata['return_wfn'] = kwargs.pop('return_wfn', False); metadata['return_total_data'] = kwargs.pop('return_total_data', None); metadata['molecule'] = kwargs.pop('molecule', core.get_active_molecule()); metadata['molecule'].update_geometry(); metadata['molecule'].fix_com(True); metadata['molecule'].fix_orientation(True); metadata['embedding_charges'] = kwargs.get('embedding_charges', False); metadata['kwargs'] = kwargs; core.clean_variables(). if metadata['ptype'] not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % metadata['ptype']). if metadata['return_total_data'] is None:; if metadata['ptype'] in ['gradient', 'hessian']:; metadata['return_total_data'] = True; else:; metadata['return_total_data'] = False. # Parse bsse_type, raise exception if not provided or unrecognized; metadata['bsse_type_list'] = kwargs.pop('bsse_type'); if metadata['bsse_type_list'] is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(metadata['bsse_type_list'], list):; metadata['bsse_type_list'] = [metadata['bsse_type_list']]. for num, btype in enumerate(metadata['bsse_type_list']):; metadata['bsse_type_list'][num] = btype.lower(); if btype.lower() not in ['cp', 'nocp', 'vmfc']:; raise ValidationError(""N-Body GUFunc: bsse_type '%s' is not recognized"" % btype.lower()). metadata['max_nbody'] = kwargs.get('max_nbody', -1); if metadata['molecule'].nfragments() == 1:; raise ValidationError(""N-Body requires active mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:7901,energy,energy,7901,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,4,['energy'],['energy']
Energy Efficiency,"erridden by embedding_charges if both are provided. :type charge_type: string; :param charge_type: ``MULLIKEN_CHARGES`` || ``LOWDIN_CHARGES`` . Default is ``MULLIKEN_CHARGES``; """""". # Initialize dictionaries for easy data passing; metadata, component_results, nbody_results = {}, {}, {}. # Parse some kwargs; kwargs = p4util.kwargs_lower(kwargs); if kwargs.get('levels', False):; return driver_nbody_helper.multi_level(func, **kwargs); metadata['ptype'] = kwargs.pop('ptype', None); metadata['return_wfn'] = kwargs.pop('return_wfn', False); metadata['return_total_data'] = kwargs.pop('return_total_data', False); metadata['molecule'] = kwargs.pop('molecule', core.get_active_molecule()); metadata['molecule'].update_geometry(); metadata['molecule'].fix_com(True); metadata['molecule'].fix_orientation(True); metadata['embedding_charges'] = kwargs.get('embedding_charges', False); metadata['kwargs'] = kwargs; core.clean_variables(). if metadata['ptype'] not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % metadata['ptype']). # Parse bsse_type, raise exception if not provided or unrecognized; metadata['bsse_type_list'] = kwargs.pop('bsse_type'); if metadata['bsse_type_list'] is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(metadata['bsse_type_list'], list):; metadata['bsse_type_list'] = [metadata['bsse_type_list']]. for num, btype in enumerate(metadata['bsse_type_list']):; metadata['bsse_type_list'][num] = btype.lower(); if btype.lower() not in ['cp', 'nocp', 'vmfc']:; raise ValidationError(""N-Body GUFunc: bsse_type '%s' is not recognized"" % btype.lower()). metadata['max_nbody'] = kwargs.get('max_nbody', -1); metadata['max_frag'] = metadata['molecule'].nfragments(); if metadata['max_nbody'] == -1:; metadata['max_nbody'] = metadata['molecule'].nfragments(); else:; metadata['max_nbody'] = min(metadata['max_nbody'], metadata['max_frag']). # Flip this off for now, needs more te",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html:7084,energy,energy,7084,psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"ers); psi4.set_variable('NUCLEAR REPULSION ENERGY', moleculeclone.nuclear_repulsion_energy()); pygrad = p4util.extract_sowreap_from_output(rfile, 'HESSIAN', n, freq_linkage, True, label='electronic gradient'); p4mat = psi4.Matrix(moleculeclone.natom(), 3); p4mat.set(pygrad); p4mat.print_out(); gradients.append(p4mat); energies.append(p4util.extract_sowreap_from_output(rfile, 'HESSIAN', n, freq_linkage, True)). # S/R: Quit sow after writing files. Initialize skeleton wfn to receive grad for reap; if freq_mode == 'sow':; optstash.restore(); optstash_conv.restore(); if return_wfn:; return (None, None); else:; return None; elif freq_mode == 'reap':; wfn = psi4.new_wavefunction(molecule, psi4.get_global_option('BASIS')). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = psi4.fd_freq_1(molecule, gradients, irrep) # TODO or moleculeclone?; wfn.set_hessian(H); wfn.set_frequencies(psi4.get_frequencies()). # The last item in the list is the reference energy, return it; psi4.set_variable('CURRENT ENERGY', energies[-1]). psi4.set_parent_symmetry(''); optstash.restore(); optstash_conv.restore(). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). else:; psi4.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; displacements = psi4.fd_geoms_freq_0(moleculeclone, irrep); moleculeclone.fix_orientation(True); moleculeclone.reinterpret_coordentry(False). # Record undisplaced symmetry for projection of diplaced point groups; psi4.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:72104,energy,energy,72104,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"ers. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. mbis-2; MBIS calculation on OH- (Expanded Arrays). dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. pywrap-cbs1; Various basis set extrapolation tests. cc52; CCSD Response for H2O2. mints-benchmark; run some BLAS benchmarks. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. freq-masses; check nonphysical masses possible. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. cc17; Single point energies of multiple excited states with EOM-CCSD. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. explicit-am-basis; Check that",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:30767,energy,energy,30767,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ers. name_hint (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; dashcoeff[dashlevel][functional-without-dashlevel] or; dashcoeff_supplement[dashlevel][functional-with-dashlevel]; can be overwritten via param_tweaks.; level_hint (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to one.; param_tweaks (Union[Dict, List, None]) – Values for the same keys as dashcoeff[dashlevel][‘default’]; (and same order if list) used to override any or all values; initialized by name_hint. Extra parameters will error.; engine (Optional[str]) – Override which code computes dispersion. See above for allowed; values. Really only relevant for -D2, which can be computed by; libdisp or dftd3. Methods Summary. compute_energy(molecule[, wfn]); Compute dispersion energy based on engine, dispersion level, and parameters in self. compute_gradient(molecule[, wfn]); Compute dispersion gradient based on engine, dispersion level, and parameters in self. compute_hessian(molecule[, wfn]); Compute dispersion Hessian based on engine, dispersion level, and parameters in self. print_out(); Format dispersion parameters of self for output file. Methods Documentation. compute_energy(molecule, wfn=None)[source]¶; Compute dispersion energy based on engine, dispersion level, and parameters in self. Parameters. molecule (Molecule) – System for which to compute empirical dispersion correction.; wfn (Optional[Wavefunction]) – Location to set QCVariables. Returns; Dispersion energy [Eh]. Return type; float. Notes. DISPERSION CORRECTION ENERGYDisp always set. Overridden in SCF finalization, but that only changes for “-3C” methods. fctl DISPERSION CORRECTION ENERGYSet if fctldash nonempty. compute_gradient(molecule, wfn=None)[source]¶; Compute dispersion gradient based on e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.empiricaldispersion.html:3323,energy,energy,3323,psi4manual/1.4.0/api/psi4.driver.empiricaldispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.empiricaldispersion.html,6,['energy'],['energy']
Energy Efficiency,"ers; Conda Binary Distribution; Conda Binary Distribution; Generation of Cube Files — cubeprop(); Generation of Cube Files — cubeprop(); Customization: Adding Simple Extensions; Customization: Adding Simple Extensions; Database — database(); Database — database(); DCFT: Density Cumulant Functional Theory; DCFT: Density Cumulant Functional Theory; CI: Configuration Interaction; CI: Configuration Interaction; DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory; DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory; DFT: Density Functional Theory; DFT: Density Functional Theory; DFT Functionals; DFT Functionals; Interface to DFTD3 by S. Grimme; Interface to DFTD3 by S. Grimme; DFT-NL; Spectroscopic Constants for Diatomics; Spectroscopic Constants for Diatomics; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Updating the PSI4 Users’ and Programmers’ Manual; Updating the PSI4 Users’ and Programmers’ Manual; Single-Point Energy — energy(); Single-Point Energy — energy(); Interface to ERD by N. Flocke and V. Lotrich; Interface to ERD by N. Flocke and V. Lotrich; Installation and Runtime Configuration; Installation and Runtime Configuration; Interface to programs through FCHK files — fchk(); Interface to programs through FCHK files — fchk(); F/I-SAPT: Functional Group and/or Intramolecular SAPT; F/I-SAPT: Functional Group and/or Intramolecular SAPT; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Interface to gau2grid by D. G. A. Smith; Interface to gau2grid by D. G. A. Smith; Interface to gCP by S. Grimme; Interface to gCP by S. Grimme; Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:496181,energy,energy,496181,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['energy'],['energy']
Energy Efficiency,"erse <= #; psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; energy('scf'). # Determine HOMO; ref = psi4.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if (E_a >= E_b):; HOMO = Na; else:; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""LOAD""); psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N,Nmin,-1):. # Nuke the current HOMO; for occ in foccs:. psi4.set_global_option(""FRAC_OCC"", [HOMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E = energy('scf'); C = 1; if (E == 0.0):; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = psi4.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = psi4.wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge); mol.set_multiplicity(mult). # Determine HOMO; ref = psi4.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if (E_a >= E_b):; HOMO = Na; else:; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/frac.html:9360,ENERGY,ENERGY,9360,psi4manual/4.0b5/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/frac.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ersion of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. table of contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; RESTRICTED_DOCC; RESTRICTED_UOCC; FROZEN_UOCC; CI_MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Spin Multiplicities of Higher Roots; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; CI: Configuration Interaction. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/detci.html:15398,energy,energy,15398,psi4manual/1.6.x/detci.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/detci.html,1,['energy'],['energy']
Energy Efficiency,"ert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get_block(self, rows, cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load_mpqc(self, filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read(filename[, prefix]); Reads the data from a NumPy compress file. np_write([filename, prefix]); Writes the irreped matrix to a NumPy zipped file. partial_cholesky_factorize(self[, delta, ...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self, alpha[, cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[, RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self, condition, nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self, a, transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self, h, i, j, theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[, h]); Returns the rows in irrep h. save(*args, **kwargs); Overloaded function. scale(self, a); Scales the matrix by the floating point value a. scale_column(self, h, n, a); Scales column n of irrep h by a. scale_row(self, h, m, a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args, **kwargs); Overloaded function. set_block(self, rows, cols, bl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Matrix.html:3256,power,power,3256,psi4manual/1.6.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Matrix.html,4,['power'],['power']
Energy Efficiency,"ert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get_block(self, rows, cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load_mpqc(self, filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read(filename[, prefix]); Reads the data from a NumPy compress file. np_write([filename, prefix]); Writes the irreped matrix to a NumPy zipped file. partial_cholesky_factorize(self[, delta, ...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self, alpha[, cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[, RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self, condition, nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self, a, transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self, h, i, j, theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[, h]); Returns the rows in irrep h. save(self, filename[, append, ...]); Saves the matrix in ASCII format to filename, as symmetry blocks or full matrix. scale(self, a); Scales the matrix by the floating point value a. scale_column(self, h, n, a); Scales column n of irrep h by a. scale_row(self, h, m, a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.matrix.html:3256,power,power,3256,psi4manual/1.5.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.matrix.html,4,['power'],['power']
Energy Efficiency,"erties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:4137,energy,energy,4137,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,8,['energy'],['energy']
Energy Efficiency,"erties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in Psi4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. Here the tensor is an AO Electron-Repulsion; Integral (ERI) in chemists’ notation,. The MO coefficients are found as the generalized eigenvectors of the Fock Matrix,. The eigenvalues are the orbital energies, and the metric matrix; is the AO-basis overlap matrix. Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix and the exchange matrix; dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:4757,energy,energy,4757,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['energy'],['energy']
Energy Efficiency,"erties, lowername, ptype='properties', **kwargs). return_wfn = kwargs.pop('return_wfn', False); props = kwargs.get('properties', ['dipole', 'quadrupole']). if len(args) > 1:; props += args[1:]. kwargs['properties'] = p4util.drop_duplicates(props); optstash = driver_util._set_convergence_criterion('properties', lowername, 6, 10, 6, 10, 8); wfn = procedures['properties'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i) for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname):; self.p4_mol.set_geometry(core.Matrix.from_array(coords.reshape(-1,3))); self.p4_mol.update_geometry(); if self.p4_return_wfn:; g, wfn = gradient(self.p4_name, return_wfn=True, molecule=self.p4_mol, **self.p4_kwargs); self.p4_wfn = wfn; else:; g = gradient(self.p4_name, return_wfn=False, molecule=self.p4_mol, **self.p4_kwargs); e = core.variable('CURRENT ENERGY'); return {'energy': e, 'gradient': g.np.ravel()}. return_wfn = kwargs.pop('return_wfn', False); return_history = kwargs.pop('return_history', False). if ret",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:52126,energy,energy,52126,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['energy'],['energy']
Energy Efficiency,"ertified. if core.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:159975,ENERGY,ENERGY,159975,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"ery later one is ```corl```.; * ```stage```: tag for the stage used in tables. The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters; are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters; are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it; is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the; ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:43985,energy,energy,43985,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"es (cheapest terms). mrccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). mrccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). mrccsdt-1b; CC through doubles with iterative triples (cheaper terms). mrccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). mrccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). mrccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). mrcc2; approximate CC through doubles. mrcc3; approximate CC through triples. mrcc4; approximate CC through quadruples. mrcc5; approximate CC through quintuples. mrcc6; approximate CC through sextuples. mrccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). mrccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). mrccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). mrccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Interface Details¶. MRCC methods¶. MRCC_METHOD; Method; Description. 1; CC;  . 2; CC(n-1)[n];  . 3; CC(n-1)(n); (CC(n-1)[n] energy is also calculated). 4; CC(n-1)(n)_L; (CC(n-1)[n] and CC(n-1)(n) energies are also calculated). 5; CC(n)-1a;  . 6; CC(n)-1b;  . 7; CCn;  . 8; CC(n)-3;  . table of contents. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/mrcc-1.html:4269,energy,energy,4269,psi4manual/1.2.1/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/mrcc-1.html,2,['energy'],['energy']
Energy Efficiency,"es :db(). Returns:(float) Mean absolute deviation of the database in kcal/mol. Psi variables:. db_name DATABASE MEAN SIGNED DEVIATION; db_name DATABASE MEAN ABSOLUTE DEVIATION; db_name DATABASE ROOT-MEAN-SQUARE DEVIATION; Python dictionaries of results accessible as DB_RGT and DB_RXN. Note; It is very easy to make a database from a collection of xyz files; using the script psi4/lib/scripts/ixyz2database.pl.; See Creating a Database for details. Caution; Some features are not yet implemented. Buy a developer some coffee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4; distribution, add the path to the directory containing the database; to the environment variable PYTHONPATH. Parameters:; name (string) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). db_name (string) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; psi4/lib/databases or PYTHONPATH. Consult that; directory for available databases and literature citations. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; Indicates whether the calculations required to complete the; database are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job wi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/db-1.html:1448,energy,energy,1448,psi4manual/4.0b5/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/db-1.html,2,['energy'],['energy']
Energy Efficiency,"es = ''; # tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); # tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); # tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); # tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); # tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); # tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); # tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); # psi4.print_out(tables); #; # return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options; # are set for different qc steps.; #def run_plugin_omega(name, **kwargs):; # r""""""Function encoding sequence of PSI module and plugin calls, as well; # as typical options, to access Rob Parrish's omega plugin.; #; # >>> energy('plugin_omega'); #; # """"""; # lowername = name.lower(); # kwargs = p4util.kwargs_lower(kwargs); #; # plugfile = psi4.Process.environment[""PSIDATADIR""] + ""/../tests/plugin_omega/plugin_omega.so""; # psi4.plugin_load(""%s"" % (plugfile)); #; # psi4.set_global_option('BASIS', 'AUG-CC-PVDZ'); # psi4.set_global_option('DF_BASIS_SCF', 'AUG-CC-PVDZ-RI'); # psi4.set_global_option('REFERENCE', 'UHF'); # psi4.set_global_option('SCF_TYPE', 'DF'); # energy('scf', **kwargs); #; # psi4.set_global_option('dft_functional', 'wB97'); # psi4.set_global_option('dft_order_spherical', 25); # psi4.set_global_option('dft_num_radial', 35); # psi4.set_global_option('omega_procedure', 'ip'); # psi4.set_global_option('maxiter', 50); # psi4.set_global_option('d_convergence', 5); # psi4.set_global_option('e_convergence', 7); # psi4.plugin(""plugin_omega.so""); #; # return psi4.get_variable('SCF TOTAL ENERGY'). # Integration with driver routines; #procedures['energy']['mp2.5'] = run_mp2_5; procedures['energy']['sherrill_gold_standard']",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html:8688,energy,energy,8688,psi4manual/4.0b5/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html,2,['energy'],['energy']
Energy Efficiency,"es = [getattr(v.provenance, ""module"", None) for v in results_list]; if self.driver != ""energy"" and len(set(modules)) == 2 and modules.count(""scf"") == len(modules) / 2:; # signature of ""MP2 GRAD"" - ""HF GRAD"" implementation detail; # * avoid having post-scf single-method gradients/Hessians show up as ""(mixed)"" module just because an outright HF call in the jobs list; modules = set(modules) - {""scf""}; modules = list(set(modules)); modules = modules[0] if len(modules) == 1 else ""(mixed)"". # load results_list numbers into compute_list (task_list is AtomicComputer-s); for itask, mc in enumerate(self.compute_list):; task = results_list[itask]; response = task.return_result. if self.metameta['ptype'] == 'energy':; mc['f_energy'] = response. elif self.metameta['ptype'] == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif self.metameta['ptype'] == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; mc['f_gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; mc['f_dipole'] = np.array(task.extras['qcvars']['CURRENT DIPOLE']). if 'CURRENT DIPOLE GRADIENT' in task.extras['qcvars']:; mc['f_dipder'] = np.array(task.extras['qcvars']['CURRENT DIPOLE GRADIENT']). # Fill in energies for subsumed methods; if self.metameta['ptype'] == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in self.trove:; if ((wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']); and (mc['f_options'] == job['f_options'])):; job['f_energy'] = task.extras['qcvars'][VARH[wfn][wfn]]. # Copy data from 'run' to 'obtained' table; for mce in self.trove:; if ((mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:56956,ENERGY,ENERGY,56956,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"es = [getattr(v.provenance, ""module"", None) for v in results_list]; if self.driver != ""energy"" and len(set(modules)) == 2 and modules.count(""scf"") == len(modules) / 2:; # signature of ""MP2 GRAD"" - ""HF GRAD"" implementation detail; # * avoid having post-scf single-method gradients/Hessians show up as ""(mixed)"" module just because an outright HF call in the jobs list; modules = set(modules) - {""scf""}; modules = list(set(modules)); modules = modules[0] if len(modules) == 1 else ""(mixed)"". # load results_list numbers into compute_list (task_list is AtomicComputer-s); for itask, mc in enumerate(self.compute_list):; task = results_list[itask]; response = task.return_result. if self.metameta['ptype'] == 'energy':; mc['f_energy'] = response. elif self.metameta['ptype'] == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif self.metameta['ptype'] == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; mc['f_gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; mc['f_dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. if 'CURRENT DIPOLE GRADIENT' in task.extras['qcvars']:; mc['f_dipder'] = task.extras['qcvars']['CURRENT DIPOLE GRADIENT']. # Fill in energies for subsumed methods; if self.metameta['ptype'] == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in self.trove:; if ((wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']); and (mc['f_options'] == job['f_options'])):; job['f_energy'] = task.extras['qcvars'][VARH[wfn][wfn]]. # Copy data from 'run' to 'obtained' table; for mce in self.trove:; if ((mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dip",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:56705,ENERGY,ENERGY,56705,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"es Hessian reuse for different temperatures and pressures but not for different isotopologs. pywrap-cbs1; Various basis set extrapolation tests. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. freq-masses; check nonphysical masses possible. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. scf-cholesky-basis; incremental Cholesky filtered SCF. rasci-h2o; RASCI/6-31G** H2O Energy Point. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN updated ref gradient due to new BraggSlater radii. props4; Electrostatic potential and electric field evaluated on a grid around water. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cepa1; cc-pvdz H2O Test CEPA(1) Energy. psimrcc-pt2; Mk-MRPT2 single point. \(^1A_1\) F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). explicit-am-basis; Check that basis sets can be input with explicit angular momentum format. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. sapt-sf1; Tests the Psi4 SF-SAPT code. opt14; 6-31G(d) optimization of SF4 st",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:3220,energy,energy,3220,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"es and doubles in the active space. cc52; CCSD Response for H2O2. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. dft-custom-mgga; updated dldf reference to new BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. linK-2; RKS Linear Exchange Algorithm test for benzene. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. ao-dfcasscf-sp; CASSCF/6-31G** energy point. cbs-parser; mtd/basis syntax examples. dlpnomp2-3; comparison of DF-MP2 and DLPNO-MP2 with a cartesian basis set. fisapt-siao1; This test case shows an example of running the I-SAPT0/jun-cc-pVDZ computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups) The SIAO1 link partitioning algorithm is used. An F-SAPT partitioning follows I-SAPT. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. dft-jk; DFT JK on-disk test. cubeprop-esp; RHF orbitals and density for water. cbs-delta-energy; Extrapolated energies with delta correction. dfcasscf-sp; CASSCF/6-31G** energy point. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. dfo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:31072,energy,energy,31072,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"es for and used in several; coupled-pair methods are given in Table CEPA Shifts. Note that these shifts are defined in a spin-free; formalism for closed-shell references only. method. sdci. dci. NA. cepa(0); 0; 0. cepa(1). cepa(3). acpf. aqcc. The pair correlation energy, , is simply a partial; sum of the correlation energy. In a spin-free formalism, the pair energy; is given by. (7); Methods whose shifts ( and ) do not; explicitly depend on orbitals or (CISD, CEPA(0), ACPF,; and AQCC) have solutions that render the energy stationary with respect; variations in the amplitudes. This convenient property allows density; matrices and 1-electron properties to be evaluated without any additional; effort. Note, however, that 1-electron properties are currently; unavailable when coupling these stationary CEPA-like methods with frozen; natural orbitals. Density-fitted coupled cluster¶; Density fitting (DF) or resolution of the identity (RI) techniques are; popular in quantum chemistry to avoid the computation and storage of the; 4-index electron repulsion integral (ERI) tensor and even to reduce the; computational scaling of some terms. DF-CCSD(T) computations are; available in PSI4, with or without the use of FNOs, through the FNOCC; module. The implementation and accuracy of the DF-CCSD(T) method are; described in Ref. [DePrince:2013:inprep].; The default auxiliary basis set for a DF-CCSD computation is chosen to be; the RI set (optimized for DFMP2) most similar to the primary basis set.; For example, if the primary basis set is aug-cc-pVDZ, the default; auxiliary basis set will be the aug-cc-pVDZ-RI set. PSI4 of course; allows the user to specify any supported predefined basis set as the; auxiliary set. Alternatively, the user can request a set defined by the; partial Cholesky decomposition of the 4-index ERI tensor.; The following is a minimal input file that describes a DF-CCSD(T); computation using 3-index integrals obtained by partial Cholesky; decomposition of the 4-i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/fnocc-1.html:7864,reduce,reduce,7864,psi4manual/4.0b4/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/fnocc-1.html,2,['reduce'],['reduce']
Energy Efficiency,"es force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs); dertype = 2. optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['hessian']:; dertype = 2; elif lowername in procedures['gradient']:; dertype = 1; func = gradient; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; freq_dertype = kwargs['dertype']. if der0th.match(str(freq_dertype)):; dertype = 0; func = energy; elif der1st.match(str(freq_dertype)):; dertype = 1; func = gradient; elif der2nd.match(str(freq_dertype)):; dertype = 2; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function frequency.' % (freq_dertype)). # 3. if the user provides a custom function THAT takes precedence; if ('freq_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['freq_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['freq_func']. # Summary validation; if (dertype == 2) and (lowername in procedures['hessian']):; pass; elif (dertype == 1) and (func is gradient) and (lowername in procedures['gradient']):; pass; elif (dertype == 1) and not(func is gradient):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not avai",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:59008,energy,energy,59008,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"es in units given by GDMA_MULTIPOLE_UNITS; with the row index corresponding to the site and the column index; referencing the multipole component. Both indices are zero based,; and the Qlm components of the multipoles are ordered as Q00, Q10,; Q11c, Q11s, Q20, Q21c, Q21s, Q22c, Q22s, etc. DMA TOTAL MULTIPOLES¶; Distributed multipoles as a single row, whose columns are the total; multipoles, translated to GDMA_ORIGIN, and summed. DMRG-SCF TOTAL ENERGY¶; The total DMRG total electonic energy [E_h]. Not unique because oribital spaces vary. DMRG-CASPT2 TOTAL ENERGY¶; The total DMRG plus CASPT2 total electonic energy [E_h] . Not unique because orbital spaces vary. EFP DISP ENERGY¶. EFP ELST ENERGY¶. EFP EXCH ENERGY¶. EFP IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [E_h] for EFP/EFP; computations. The sum of these four components yields; EFP TOTAL ENERGY. EFP TOTAL ENERGY¶; The total electronic interaction energy [E_h] for EFP/EFP computations. EFP TORQUE¶; The torque, not gradient for EFP/EFP computations. ENTHALPY¶; Total enthalpy H [E_h] at given temperature. ENTHALPY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the enthalpy at given temperature. ESP AT CENTER n¶; Property of electrostatic potential [E_h / e] at location, usually atom center, n. FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the full configuration interaction level of theory. GIBBS FREE ENERGY¶; Total Gibbs free energy [E_h], free enthalpy at given temperature. GIBBS FREE ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the free enthalpy at given temperature. GRID ELECTRONS TOTAL¶. GRID ELECTRONS ALPHA¶. GRID ELECTRONS BETA¶; The number of electrons integrated by the xc quadrature grid. HF TOTAL ENERGY¶; The total electronic energy [E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:31182,energy,energy,31182,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"es the data; is passed in. Returns:A deserialized Wavefunction object. Return type:Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_amplitudes(self: psi4.core.CCWavefunction) → Dict[str, psi4.core.Matrix]¶. Get dict of converged T amplitudes. amps : dict (spacestr, SharedMatrix); spacestr is a description of the amplitude set using the following conventions.; I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF: “tIA”, “tIjAb”; UHF: tIA, tia, tIjAb, tIJAB, tijab; ROHF: tIA, tia, tIjAb, tIJAB, tijab. Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”“”; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_wfn=True); >>> t1 = wfn.get_amplitudes()[‘tia’].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(“CC T1 DIAGNOSTIC”); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. get_array(key)¶. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Wavefunction",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:14173,energy,energy,14173,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency,"es the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:23310,energy,energy,23310,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,8,['energy'],['energy']
Energy Efficiency,"es the spin-averaged effect and a spin-flip term responsible; for the splittings between the states. The numerical factors in this linear; combination are determined solely by the Clebsch-Gordan coefficients:; accordingly, the \(S^{2}\) approximation implies a Heisenberg Hamiltonian; picture with a single coupling strength parameter determining all the; splittings. This method can be invoked with energy(“SF-SAPT”) and; publications resulting from the use of the SF-SAPT code should cite the; following publications: [Patkowski:2018:164110]. Higher-Order Exchange Terms without Single-Exchange Approximation¶; Recently, several SAPT higher-order exchange terms have been derived without; the \(S^{2}\) approximation: \(E_{exch-ind}^{(20)}\) [Schaffer:2012:1235],; \(E_{exch-disp}^{(20)}\) [Schaffer:2013:2570], and \(E_{exch-ind}^{(30)}\); [Waldrop:2021:024103]. The second-order terms can be computed with the following; settings:; set SAPT_DFT_FUNCTIONAL HF; set DO_IND_EXCH_SINF true # calculate Exch-Ind20 (S^inf); set SAPT_DFT_MP2_DISP_ALG fisapt; set DO_DISP_EXCH_SINF true # calculate Exch-Disp20 (S^inf); energy('sapt(dft)'). and the third-order exchange-induction term is computed as follows:; set DO_IND30_EXCH_SINF true # calculate Exch-Ind30 (S^inf); energy('sapt2+3'). These calculations are performed with the atomic orbital and; density-fitting scheme described in the Supplementary Material to; [Smith:2020:184108] for the second-order terms and in [Waldrop:2021:024103]; for the third-order exchange induction. The coupled (response) version of the; exchange-induction corrections are also calculated, exactly for; \(E_{exch-ind,resp}^{(20)}\) and by scaling the uncoupled term for; \(E_{exch-ind,resp}^{(30)}\). S^inf Keywords¶. DO_IND_EXCH_SINF¶. For SAPT0 or SAPT(DFT), compute the non-approximated second-order exchange-induction term. Type: boolean; Default: false. DO_DISP_EXCH_SINF¶. For SAPT0 or SAPT(DFT), compute the non-approximated second-order exchange-dispersion term",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/sapt.html:46227,energy,energy,46227,psi4manual/1.6.x/sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/sapt.html,5,['energy'],['energy']
Energy Efficiency,"es to dfmp2 or just scf; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; PsiMod.print_out('\n'); PsiMod.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); PsiMod.print_out(' BSSE Treatment: %s\n' % (bsse)); PsiMod.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); PsiMod.print_out(' Compute Total Energy: %s\n' % (do_total)); PsiMod.print_out(' External Field: %s\n' % (has_external)); if (external):; PsiMod.print_out(' External Field Monomers: '); for k in external_indices:; PsiMod.print_out('%-3d ' % (k)); PsiMod.print_out('\n'); PsiMod.print_out('\n'). # Run the total molecule, if required; energies_full = {}; energies_mon = {}; N = molecule.nfragments(); Etotal = 0.0; if do_total or max_n_body == molecule.nfragments():; PsiMod.print_out(' => Total Cluster Energy <=\n'); # Full cluster always gets the external field; if (external):; PsiMod.set_global_option_python(""EXTERN"", external); Etotal = call_function_in_1st_argument(func, **kwargs); if (external):; PsiMod.set_global_option_python(""EXTERN"", None); energies_full[N] = []; energies_full[N].append(Etotal); energies_mon[N] = []; energies_mon[N].append(Etotal); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'); PsiMod.clean(). max_effective = max_n_body; if (max_effective == N):; max_effective = N - 1. # Build the combos for indexing purposes; Ns = []; if (max_n_body == N or do_total):; Ns.append(N); for n in range(max_effective, 0, -1):; Ns.append(n). combos = {}; for n in Ns:. combos[n] = []. # Loop through combinations in lexical order #. # initialize the reals list; reals = []; #setup first combination [3,2,1] lexical ordering; #fragments indexing is 1's based, bloody hell; for index in range(n, 0, -1):; reals.append(index); #start loop through lexical promotion; counter = 0; while True:. counter = counter + 1. # ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:6798,Energy,Energy,6798,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Energy'],['Energy']
Energy Efficiency,"es    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». HF: Hartree–Fock Theory¶; Code author: Justin M. Turney, Robert M. Parrish, and Andrew C. Simmonett; Section author: Robert M. Parrish; Module: Keywords, PSI Variables, LIBSCF_SOLVER, LIBMINTS, LIBFOCK, LIBDIIS. Introduction¶; Self-Consistent-Field (SCF) theory forms the cornerstone of ab initio quantum; chemistry. Here SCF refers both to conventional Hartree–Fock (HF) molecular; orbital theory and also to generalized Kohn–Sham Density Functional Theory; (KS-DFT). PSI4 contains a wholly rewritten SCF code, including many of the; most popular spin specializations, several efficient numerical methods for; treating Fock Matrix construction, and a brand new KS-DFT code featuring many of; the most popular DFT functional technologies.; An illustrative example of using the SCF module is as follows:; molecule {; 0 3; O; O 1 1.21; }. set {; basis cc-pvdz; guess sad; reference uhf; scf_type pk; }. energy('scf'). This will run a UHF computation for triplet molecular oxygen (the ground state); using a PK algorithm for the Electron Repulsion Integrals (ERI) and starting; from a Superposition of Atomic Densities (SAD) guess. After printing all manner; of titles, geometries, sizings, and algorithm choices, the SCF finally reaches; the iterations:; Total Energy Delta E Density RMS. @UHF iter 0: -149.76856421865352 -4.69109e+01 0.00000e+00; @UHF iter 1: -149.59793338958522 1.70631e-01 5.72371e-02; @UHF iter 2: -149.62408782458331 -2.61544e-02 8.04195e-03 DIIS; @UHF iter 3: -149.62679515182390 -2.70733e-03 2.51542e-03 DIIS; @UHF iter 4: -149.62726459105770 -4.69439e-04 1.06897e-03 DIIS; @UHF iter 5: -149.62730549814114 -4.09071e-05 2.70311e-04 DIIS; @UHF iter 6: -149.62730736371790 -1.86558e-06 5.94924e-05 DIIS; @UHF iter 7: -149.62730740227752 -3.85596e-08 9.93250e-06 DIIS; @UHF iter 8: -149.62730740325136 -9.73841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/scf-1.html:1075,energy,energy,1075,psi4manual/4.0b3/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/scf-1.html,2,['energy'],['energy']
Energy Efficiency,"es    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». HF: Hartree–Fock Theory¶; Code author: Justin M. Turney, Robert M. Parrish, and Andrew C. Simmonett; Section author: Robert M. Parrish; Module: Keywords, PSI Variables, LIBSCF_SOLVER, LIBMINTS, LIBFOCK, LIBDIIS. Introduction¶; Self-Consistent-Field (SCF) theory forms the cornerstone of ab initio quantum; chemistry. Here SCF refers both to conventional Hartree–Fock (HF) molecular; orbital theory and also to generalized Kohn–Sham Density Functional Theory; (KS-DFT). PSI4 contains a wholly rewritten SCF code, including many of the; most popular spin specializations, several efficient numerical methods for; treating Fock Matrix construction, and a brand new KS-DFT code featuring many of; the most popular DFT functional technologies.; An illustrative example of using the SCF module is as follows:; molecule {; 0 3; O; O 1 1.21; }. set {; basis cc-pvdz; guess sad; reference uhf; scf_type pk; }. energy('scf'). This will run a UHF computation for triplet molecular oxygen (the ground state); using a PK algorithm for the Electron Repulsion Integrals (ERI) and starting; from a Superposition of Atomic Densities (SAD) guess. DF integrals are; automatically used to converge the DF-SCF solution before the PK algorithm is; activated. After printing all manner of titles, geometries, sizings, and; algorithm choices, the SCF finally reaches the iterations:; Total Energy Delta E RMS |[F,P]|. @UHF iter 0: -149.76816019169962 -1.49768e+02 1.36000e-01; @UHF iter 1: -149.59759112756984 1.70569e-01 2.42437e-02; @UHF iter 2: -149.62372414554761 -2.61330e-02 6.10239e-03 DIIS; @UHF iter 3: -149.62643112722810 -2.70698e-03 2.17299e-03 DIIS; @UHF iter 4: -149.62690062294968 -4.69496e-04 5.66895e-04 DIIS; @UHF iter 5: -149.62694151409750 -4.08911e-05 1.26359e-04 DIIS; @UHF iter 6: -149.62694337042228 -1.85632e-06 1.84114e-05 DIIS; @UHF iter 7: -149.62694340901407 -3.85918e-08 2.91692e-06 DIIS; @UHF iter 8: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/scf-1.html:1075,energy,energy,1075,psi4manual/4.0b4/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/scf-1.html,2,['energy'],['energy']
Energy Efficiency,"es    . toc    . next    . previous    ; PSI4 [beta5] » ; Theoretical Methods: SCF to FCI ». HF: Hartree–Fock Theory¶; Code author: Justin M. Turney, Robert M. Parrish, and Andrew C. Simmonett; Section author: Robert M. Parrish; Module: Keywords, PSI Variables, LIBSCF_SOLVER, LIBMINTS, LIBFOCK, LIBDIIS. Introduction¶; Self-Consistent-Field (SCF) theory forms the cornerstone of ab initio quantum; chemistry. Here SCF refers both to conventional Hartree–Fock (HF) molecular; orbital theory and also to generalized Kohn–Sham Density Functional Theory; (KS-DFT). PSI4 contains a wholly rewritten SCF code, including many of the; most popular spin specializations, several efficient numerical methods for; treating Fock Matrix construction, and a brand new KS-DFT code featuring many of; the most popular DFT functional technologies.; An illustrative example of using the SCF module is as follows:; molecule {; 0 3; O; O 1 1.21; }. set {; basis cc-pvdz; guess sad; reference uhf; scf_type pk; }. energy('scf'). This will run a UHF computation for triplet molecular oxygen (the ground state); using a PK algorithm for the Electron Repulsion Integrals (ERI) and starting; from a Superposition of Atomic Densities (SAD) guess. DF integrals are; automatically used to converge the DF-SCF solution before the PK algorithm is; activated. After printing all manner of titles, geometries, sizings, and; algorithm choices, the SCF finally reaches the iterations:; Total Energy Delta E RMS |[F,P]|. @UHF iter 0: -149.76816019169962 -1.49768e+02 1.36000e-01; @UHF iter 1: -149.59759112756984 1.70569e-01 2.42437e-02; @UHF iter 2: -149.62372414554761 -2.61330e-02 6.10239e-03 DIIS; @UHF iter 3: -149.62643112722810 -2.70698e-03 2.17299e-03 DIIS; @UHF iter 4: -149.62690062294968 -4.69496e-04 5.66895e-04 DIIS; @UHF iter 5: -149.62694151409750 -4.08911e-05 1.26359e-04 DIIS; @UHF iter 6: -149.62694337042228 -1.85632e-06 1.84114e-05 DIIS; @UHF iter 7: -149.62694340901407 -3.85918e-08 2.91692e-06 DIIS; @UHF iter 8: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/scf-1.html:1075,energy,energy,1075,psi4manual/4.0b5/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/scf-1.html,2,['energy'],['energy']
Energy Efficiency,"es    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/mrcc-1.html:1066,energy,energy,1066,psi4manual/1.4.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/mrcc-1.html,2,['energy'],['energy']
Energy Efficiency,"es    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/mrcc-1.html:1066,energy,energy,1066,psi4manual/1.5.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/mrcc-1.html,2,['energy'],['energy']
Energy Efficiency,"es    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (https://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/mrcc.html:1066,energy,energy,1066,psi4manual/1.6.x/mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html,1,['energy'],['energy']
Energy Efficiency,"es(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. Classes¶. AtomicComputer(**data); Computer for analytic single-geometry computations. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. Table([rows, row_label_width, ...]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Error called for problems with the input file. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psi4api.html:22634,charge,charges,22634,psi4manual/1.6.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html,1,['charge'],['charges']
Energy Efficiency,"es(expected.hessian(), computed.hessian(), digits, 'compare hessian'); if expected.epsilon_a(): compare_vectors(expected.epsilon_a(), computed.epsilon_a(), digits, 'compare epsilon_a'); if expected.epsilon_b(): compare_vectors(expected.epsilon_b(), computed.epsilon_b(), digits, 'compare epsilon_b'); if expected.frequencies(): compare_vectors(expected.frequencies(), computed.frequencies(), digits, 'compare frequencies'); # yapf: enable; compare_integers(expected.nalpha(), computed.nalpha(), 'compare nalpha'); compare_integers(expected.nbeta(), computed.nbeta(), 'compare nbeta'); compare_integers(expected.nfrzc(), computed.nfrzc(), 'compare nfrzc'); compare_integers(expected.nirrep(), computed.nirrep(), 'compare nirrep'); compare_integers(expected.nmo(), computed.nmo(), 'compare nmo'); compare_integers(expected.nso(), computed.nso(), 'compare nso'); compare_strings(expected.name(), computed.name(), 'compare name'); compare_values(expected.energy(), computed.energy(), digits, 'compare energy'); compare_values(expected.efzc(), computed.efzc(), digits, 'compare frozen core energy'); compare_values(expected.get_dipole_field_strength()[0],; computed.get_dipole_field_strength()[0], digits, 'compare dipole field strength x'); compare_values(expected.get_dipole_field_strength()[1],; computed.get_dipole_field_strength()[1], digits, 'compare dipole field strength y'); compare_values(expected.get_dipole_field_strength()[2],; computed.get_dipole_field_strength()[2], digits, 'compare dipole field strength z'). compare_strings(expected.basisset().name(), computed.basisset().name(), 'compare basis set name'); compare_integers(expected.basisset().nbf(), computed.basisset().nbf(), 'compare number of basis functions in set'); compare_integers(expected.basisset().nprimitive(),; computed.basisset().nprimitive(), 'compare total number of primitives in basis set'). compare_strings(expected.molecule().name(), computed.molecule().name(), 'compare molecule name'); compare_strings(expected.mole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html:15968,energy,energy,15968,psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,2,['energy'],['energy']
Energy Efficiency,"es, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:53760,energy,energy,53760,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,4,['energy'],['energy']
Energy Efficiency,"es, because they introduce minimal errors; whil providing much faster computations [Hohenstein:2010:184111]; [Hohenstein:2010:014101]. Since we’re using density fitting for the SAPT,; we might as well also use it for the Hartree–Fock computations that are; performed as part of the SAPT. We can specify that with; scf_type DF.; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, PSI4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that PSI4 correctly guesses that we want the jun-cc-pVDZ-JKFIT; auxiliary basis for the Hartree–Fock, and the jun-cc-pVDZ-RI basis set; for the SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons with freeze_core True. The SAPT; procedure is invoked with the simple call, energy('sapt0'). This; call knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in addition; to the total SAPT0 interaction energy. An explanation of the various; energy components can be found in the review by Jeziorski, Moszynski, and; Szalewicz [Jeziorski:1994:1887], and this is discussed in more detail; in the SAPT section later in this manual. For now, we’ll note that most of; the SAPT energy components are negative; this means those are attractive; contributions (the zero of energy in a SAPT computation is defined as; non-interacting monomers). The exchange contributions are positive; (repulsive). In this example, the most attractive contribution between; ethylene and acetylene is an electrostatic term of -2.12 kcal mol-1; (Elst10,r where the 1 indicates the first-order; perturbation theory result with respect to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/tutorial-1.html:11775,energy,energy,11775,psi4manual/4.0b3/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency,"es, because they introduce minimal errors; whil providing much faster computations [Hohenstein:2010:184111]; [Hohenstein:2010:014101]. Since we’re using density fitting for the SAPT,; we might as well also use it for the Hartree–Fock computations that are; performed as part of the SAPT. We can specify that with; scf_type DF.; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, PSI4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that PSI4 correctly guesses that we want the jun-cc-pVDZ-JKFIT; auxiliary basis for the Hartree–Fock, and the jun-cc-pVDZ-RI basis set; for the SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons with freeze_core True. The SAPT; procedure is invoked with the simple call, energy('sapt0')}. This; call knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in addition; to the total SAPT0 interaction energy. An explanation of the various; energy components can be found in the review by Jeziorski, Moszynski, and; Szalewicz [Jeziorski:1994:1887], and this is discussed in more detail; in the SAPT section later in this manual. For now, we’ll note that most of; the SAPT energy components are negative; this means those are attractive; contributions (the zero of energy in a SAPT computation is defined as; non-interacting monomers). The exchange contributions are positive; (repulsive). In this example, the most attractive contribution between; ethylene and acetylene is an electrostatic term of -2.12 kcal mol-1; (Elst10,r where the 1 indicates the first-order; perturbation theory result with respect to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:11748,energy,energy,11748,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency,"es, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). table of contents. energy; energy(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; energy. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.energy.html:38465,energy,energy,38465,psi4manual/master/api/psi4.driver.energy.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.energy.html,16,['energy'],['energy']
Energy Efficiency,"es, specification of fragments, etc., all in a whitespace-tolerant; format. See Molecule and Geometry Specification for details and; cfour/mints5 for examples. When a PSI4-style molecule is; supplied, its geometry is written to ZMAT in Cartesian form and the; CFOUR_COORDINATES=CARTESIAN, CFOUR_UNITS=ANGSTROM,; CFOUR_CHARGE, and CFOUR_MULTIPLICITY keywords are set; appropriately in the *CFOUR(...) directive. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Whenever the molecule is supplied in PSI4 format, the job control; keywords must be too. All Cfour keywords are the usual; ones, prepended by cfour_ to avoid any possible name conflicts. As; detailed in Job Control Keywords, setting keywords is flexible in; format. The previous example translates to:; # UHF-SCF energy calculation. molecule {; 0 2 # multiplicity from the MULT keyword; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0; }. set {; cfour_CALC_level=HF # only full keyword names allowed; cfour_BASIS=qz2p; #MULT=2 # now in molecule {...} block; cfour_REFerence=UHF; cfour_OCCUPATION [[3, 1, 1, 0], [3,0,1,0] ] # arrays in python notation; cfour_SCF_CONV=12; cfour_MEMORY=20000000; }. energy('cfour'). Here, note that none of capitalization, equals sign, or whitespace matter; for the keyword commands. Specification of strings and integers requires no; translation; booleans have extended freedom of; format; arrays must be translated into Python-style (square-bracket; bounded and comma delimited) of appropriate dimension. There are many; sample inputs in psi4/tests/cfour/ starting with sp- that take; examples from the Cfour manual and first run them in sandwich mode and; then run them as translated into PSI4 format. Note; PSI4 only recognizes keywords by their full name, so the common; Cf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:5173,energy,energy,5173,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,9,['energy'],['energy']
Energy Efficiency,"es, specification of fragments, etc., all in a whitespace-tolerant; format. See Molecule and Geometry Specification for details and; cfour/mints5 for examples. When a Psi4-style molecule is; supplied, its geometry is written to ZMAT in Cartesian form and the; CFOUR_COORDINATES=CARTESIAN, CFOUR_UNITS=ANGSTROM,; CFOUR_CHARGE, and CFOUR_MULTIPLICITY keywords are set; appropriately in the *CFOUR(...) directive. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Whenever the molecule is supplied in Psi4 format, the job control; keywords must be too. All Cfour keywords are the usual; ones, prepended by cfour_ to avoid any possible name conflicts. As; detailed in Job Control Keywords, setting keywords is flexible in; format. The previous example translates to:; # UHF-SCF energy calculation. molecule {; 0 2 # multiplicity from the MULT keyword; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0; }. set {; cfour_CALC_level=HF # only full keyword names allowed; cfour_BASIS=qz2p; #MULT=2 # now in molecule {...} block; cfour_REFerence=UHF; cfour_OCCUPATION [[3, 1, 1, 0], [3,0,1,0] ] # arrays in python notation; cfour_SCF_CONV=12; cfour_MEMORY=20000000; }. energy('cfour'). Here, note that none of capitalization, equals sign, or whitespace matter; for the keyword commands. Specifcation of strings and integers requires no; translation; booleans have extended freedom of; format; arrays must be translated into Python-style (square-bracket; bounded and comma delimited) of appropriate dimension. There are many; sample inputs in psi4/tests/cfour/ starting with sp- that take; examples from the Cfour manual and first run them in sandwich mode and; then run them as translated into Psi4 format. Note; Psi4 only recognizes keywords by their full name, so the common; Cfo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:5187,energy,energy,5187,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"es, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. fd-freq-gradient-large; SCF DZ finite difference frequencies by energies for C4NH4. dft1-alt; DFT Functional Test. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. psimrcc-fd-freq2; Mk-MRCCSD frequencies. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-mat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:3700,energy,energy,3700,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"es. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:242936,energy,energy,242936,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency,"es. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[, return_dict, ...]); Construct Molecule from non-Psi4 schema. from_string(molstr[, dtype, name, fix_com, ...]). fsymbol(self, atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self, atom); Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self); Gets n in Cnv, etc.; If there is no n (e.g. Td) it's the highest-order rotation axis. fx(self, arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self, arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self, arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self, arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:3912,charge,charge,3912,psi4manual/1.8.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html,6,['charge'],['charge']
Energy Efficiency,"es. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. fd-freq-gradient-large; SCF DZ finite difference frequencies by energies for C4NH4. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. freq-isotope; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. cc36; CC2(RHF)/cc-pVDZ energy of H2O. cbs-delta-energy; Extrapolated energies with delta correction. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. cc26; Sin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:11880,energy,energy,11880,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"es. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-step algorithm is tested. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. cc51; EOM-CC3/cc-pVTZ on H2O. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. nbo; Generation of NBO file. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. scf-guess-read3; Test if the the gu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:36269,energy,energy,36269,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"es: Enhancing PSI4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/mrcc-1.html:1113,energy,energy,1113,psi4manual/4.0b4/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html,8,['energy'],['energy']
Energy Efficiency,"es: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS (PSIMRCC)¶PSIMRCC — Do include the terms that couple the reference determinants?. Type: boolean; Default: true. COVALENT_CONNECT (OPTKING)¶OPTKING — When determining connectivity, a bond is assigned if interatomic distance is less than (this number) * sum of covalent radii. Type: double; Default: 1.3. CPHF_MEM_SAFETY_FACTOR (CPHF)¶CPHF — Memory safety factor for allocating JK. Type: double; Default: 0.75. CPHF_TASKS (CPHF)¶CPHF — Which tasks to run CPHF For * Valid choices: * -Polarizability *. Type: array; Default: No Default. CUBEPROP_BASIS_FUNCTIONS (GLOBALS)¶GLOBALS — List of basis function indices for which cube files are generated (1-based). All basis functions computed if empty. Type: array; Default: No Default. CUBEPROP_FILEPATH (GLOBALS)¶GLOBALS — Directory to which to write cube files. Default is the input file directory. Type: string; Default: No Default. CUBEPROP_ISOCONTOUR_THRESHOLD (GLOBALS)¶GLOBALS — Fraction of density captured by adaptive isocontour values. Type: double; Default: 0.85. CUBEPROP_ORBITALS (GLOBALS)¶GLOBALS — List of orbital indices for which cube files are generated (1-based, \(+\) for alpha, \(-\) for beta). All orbitals computed if empty. Type: array; Default: No Default. CUBEPROP_TASKS (GLOBALS)¶GLOBALS — Properties to compute. Valid tasks include: DENSITY - Da, Db, Dt, Ds; ESP - Dt, ESP; ORBITALS - Psi_a_N, Psi_b_N; BASIS_FUNCTIONS - Phi_N; LOL - LOLa, LOLb; ELF - ELFa, ELFb; FRONTIER_ORBITALS - Psi_a_N_HOMO + Psi_a_N_LUMO; DUAL_DESCRIPTOR - DUAL_N_HOMO-M_LUMO. Type: array; Default: No Default. CUBIC_BASIS_TOLERANCE (FISAPT)¶FISAPT (Expert) — CubicScalarGrid basis cutoff. Type: conv double; Default: 1.0e-12. CUBIC_BASIS_TOLERANCE (GLOBALS)¶GLOBALS (Expert) — CubicScalarGrid basis cutoff. Type: conv double; Default: 1.0e-12. CUBIC_BLOCK_MAX_POINTS (FISAPT)¶FISAPT (Expert) — CubicScalarGrid maximum number of grid points per evaluation block. Type: integer; Default: 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:90590,adapt,adaptive,90590,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,8,['adapt'],['adaptive']
Energy Efficiency,"es; can be found in the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. ADCC; BRIANQC; CFOUR; CHEMPS2; COOKBOOK; DFTD3; DKH; LIBEFP; ERD; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. cubeprop; RHF orbitals and density for water. dft1-alt; DFT Functional Test. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. opt-multi-frozen-dimer-c2h; Frozen-fragment opt of C2h methane dimer with user-combined reference points. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. scf3; File retention, docc, socc, and bond distances specified explicitly. options1; check all variety of options parsing. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mom; Maximum Overlap Method (MOM) Test.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/testsuite-1.html:1433,energy,energy,1433,psi4manual/1.4.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/testsuite-1.html,2,['energy'],['energy']
Energy Efficiency,"es; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_boolean>`; :param rlxd: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. :type symm: :ref:`boolean <op_py_boolean>`; :param symm: |dl| ``'on'`` |dr| || ``'off'``. Indicates whether the native symmetry of the database reagents is; employed (``'on'``) or whether it is forced to :math:`C_1` symmetry; (``'off'``). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). :type zpe: :ref:`boolean <op_py_boolean>`; :param zpe: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. :type benchmark: str; :param benchmark: |dl| ``'default'`` |dr| || ``'S22A'`` || etc. Indicates whether a non-default set of reference energies, if; available (See :ref:`sec:availableDatabases`), are employ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:4672,energy,energy,4672,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,14,['energy'],['energy']
Energy Efficiency,"es_symbol()); PsiMod.set_variable('NATOM', molecule.natom()); ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; PsiMod.print_variables(); exec actives; for envv in db_tabulate:; VRGT[rgt][envv] = PsiMod.get_variable(envv); PsiMod.set_global_option(""REFERENCE"", user_reference); PsiMod.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(GEOS[rgt]); freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.print_variables()\n""""""); freagent.write(""""""PsiMod.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""PsiMod.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""PsiMod.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv] = 0.0; exec banners; exec actives; try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database su",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:43802,energy,energy,43802,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"esence of a dipole field. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. cc12; Single point energies of multiple excited states with EOM-CCSD. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. mp2-1; All-electron MP2 6-31G** geometry optimization of water. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. lccd-grad2; LCCD cc-pVDZ gradient for the NO radical. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mp2p5-grad",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:31819,energy,energy,31819,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"esent in delta3_basis and xtpl_highest_1() otherwise. delta4_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:9686,energy,energy,9686,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"eshaped array of `val` with natural dimensions of `key`. """"""; if isinstance(val, (np.ndarray, core.Matrix)):; raise TypeError; elif isinstance(val, list):; tgt = np.asarray(val); else:; # presumably scalar. may be string; return float(val). if key.upper().startswith(""MBIS""):; if key.upper().endswith(""CHARGES""):; reshaper = (-1, ); elif key.upper().endswith(""DIPOLES""):; reshaper = (-1, 3); elif key.upper().endswith(""QUADRUPOLES""):; reshaper = (-1, 3, 3); elif key.upper().endswith(""OCTUPOLES""):; reshaper = (-1, 3, 3, 3); elif key.upper().endswith(""DIPOLE"") or ""DIPOLE -"" in key.upper():; reshaper = (3, ); elif ""QUADRUPOLE POLARIZABILITY TENSOR"" in key.upper():; reshaper = (3, 3, 3); elif any((key.upper().endswith(p) or f""{p} -"" in key.upper()) for p in _multipole_order):; p = [p for p in _multipole_order if (key.upper().endswith(p) or f""{p} -"" in key.upper())]; reshaper = tuple([3] * _multipole_order.index(p[0])); elif key.upper() in [""MULLIKEN_CHARGES"", ""LOWDIN_CHARGES"", ""MULLIKEN CHARGES"", ""LOWDIN CHARGES""]:; reshaper = (-1, ); elif ""GRADIENT"" in key.upper():; reshaper = (-1, 3); elif ""HESSIAN"" in key.upper():; ndof = int(math.sqrt(len(tgt))); reshaper = (ndof, ndof); else:; raise ValidationError(f'Uncertain how to reshape array: {key}'). return tgt.reshape(reshaper). _multipole_order = [""dummy"", ""dummy"", ""QUADRUPOLE"", ""OCTUPOLE"", ""HEXADECAPOLE""]; for order in range(5, 10):; _multipole_order.append(f""{int(2**order)}-POLE""). def _qcvar_reshape_set(key: str, val: np.ndarray) -> np.ndarray:; """"""Reverse :py:func:`_qcvar_reshape_get` for internal; :py:class:`psi4.core.Matrix` storage. """"""; reshaper = None; if key.upper().startswith(""MBIS""):; if key.upper().endswith(""CHARGES""):; return val; elif key.upper().endswith(""DIPOLES""):; reshaper = (-1, 3); return val.reshape(reshaper); elif key.upper().endswith(""QUADRUPOLES""):; val = val.reshape(-1, 3, 3); val = np.array([_multipole_compressor(val[iat], 2) for iat in range(len(val))]); return val; elif key.upper().endswith(""OCTUPO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:29540,CHARGE,CHARGES,29540,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,2,['CHARGE'],['CHARGES']
Energy Efficiency,"esian function.; #define INT_CARTINDEX(am,i,j) (((i) == (am))? 0 : (((((am) - (i) + 1)*((am) - (i)))>>1) + (am) - (i) - (j))). """"""; return 0 if (i == am) else ((((am - i + 1) * (am - i)) >> 1) + am - i - j). [docs]def INT_ICART(a, b, c):; """"""Given a, b, and c compute a cartesian offset.; #define INT_ICART(a, b, c) (((((((a)+(b)+(c)+1)<<1)-(a))*((a)+1))>>1)-(b)-1). """"""; return ((((((a + b + c + 1) << 1) - a) * (a + 1)) >> 1) - b - 1). [docs]def INT_IPURE(l, m):; """"""Given l and m compute a pure function offset.; #define INT_IPURE(l, m) ((l)+(m)). """"""; return l + m. # Lookup array that when you index the angular momentum it returns the corresponding letter; PrimitiveType = ['Normalized', 'Unnormalized']; GaussianType = ['Cartesian', 'Pure'] # Cartesian = 0, Pure = 1. [docs]class ShellInfo(object):; """"""This class has the same behavior as GaussianShell, but implements everything using; slower data structures, which are easier to construct. These are used to build the; basis set, which builds more efficient pointer-based GaussianShell objects.; @param e An array of exponent values.; @param am Angular momentum.; @param pure Pure spherical harmonics, or Cartesian.; @param c An array of contraction coefficients.; @param nc The atomic center that this shell is located on. Must map; back to the correct atom in the owning BasisSet molecule. Used; in integral derivatives for indexing.; @param center The x, y, z position of the shell. This is passed to; reduce the number of calls to the molecule.; @param start The starting index of the first function this shell; provides. Used to provide starting positions in matrices.; @param pt Is the shell already normalized?. """""". def __init__(self, am, c, e, pure, nc, center, start, pt='Normalized'):; # Angular momentum; self.l = am; # Flag for pure angular momentum (Cartesian = 0, Pure = 1); self.puream = pure; # Exponents (of length nprimitives_); self.PYexp = e; # Contraction coefficients (of length nprimitives_); self.PYcoef = c; # ERD no",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html:2925,efficient,efficient,2925,psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsgshell.html,1,['efficient'],['efficient']
Energy Efficiency,"esn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. scf-guess-read; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. fd-freq-gradient-large; SCF DZ finite difference frequencies by energies for C4NH4. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. freq-isotope;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:11059,energy,energy,11059,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"esponds to the rohf-stab test from Psi3. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. nbody-nocp-gradient; Computation of NoCP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. scf6; Tests RHF/ROHF/UHF SCF gradients. casscf-sp; CASSCF/6-31G** energy point. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. scf-auto-cholesky; Cholesky filter a complete basis. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. soscf-dft; Tri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:41820,energy,energy,41820,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"esp}^{(20)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)} + \delta_{HF}^{(2)}\]; In this notation, \(E^{(vw)}\) defines the order in \(V\) and in \(W_A+W_B\); the; subscript, \(resp\), indicates that orbital relaxation effects are included. (2)¶\[E_{SAPT2} = E_{SAPT0} + E_{elst,resp}^{(12)} + E_{exch}^{(11)} +; E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)} + \; ^{t}\!E_{exch-ind}^{(22)}\]. (3)¶\[E_{SAPT2+} = E_{SAPT2} + E_{disp}^{(21)} + E_{disp}^{(22)}\]. (4)¶\[E_{SAPT2+(3)} = E_{SAPT2+} + E_{elst,resp}^{(13)} + E_{disp}^{(30)}\]. (5)¶\[E_{SAPT2+3} = E_{SAPT2+(3)}; + E_{exch-ind}^{(30)} + E_{ind,resp}^{(30)}; + E_{exch-disp}^{(30)} + E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)}; - \delta_{HF}^{(2)} + \delta_{HF}^{(3)}\]; The \(\delta_{HF}^{(2)}\) and \(\delta_{HF}^{(3)}\) terms take into; account higher-order induction effects and are included in the definition; of SAPT terms. They are computed from the Hartree–Fock supermolecular interaction energy; \(E_{int}^{HF}\) and are only available in dimer-centered basis SAPT; computations, which is the default (see below for monomer-centered basis; computations). They are defined by:. (6)¶\[\delta_{HF}^{(2)} = E_{int}^{HF} - (E_{elst}^{(10)} + E_{exch}^{(10)}; + E_{ind,resp}^{(20)} + E_{exch-ind,resp}^{(20)})\]. (7)¶\[\delta_{HF}^{(3)} = \delta_{HF}^{(2)} - (E_{exch-ind}^{(30)}; + E_{ind,resp}^{(30)})\]; Additionally, high-order coupling between induction and dispersion can be; extracted from the supermolecular MP2 interaction energy:. \[\delta_{MP2}^{(2)} = E_{int}^{MP2, corr} - (E_{elst}^{(12)} +; E_{exch}^{(11)} + E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)}; + \; ^{t}\!E_{exch-ind}^{(22)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)})\]. \[\delta_{MP2}^{(3)} = \delta_{MP2}^{(2)} - (E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)})\]; where \(E_{int}^{MP2, corr}\) is the correlation part of the supermolecular MP2; interaction energy. \(\delta_{MP2}^{(2)}\) and \(\delta_{MP2}^{(3)}\) also improve the; description of electrostatically do",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:3699,energy,energy,3699,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,6,['energy'],['energy']
Energy Efficiency,"ess ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously. Elementary Restart¶; The PSI4 intermediate files use the following naming scheme; psi.PID.name.filenumber. where by default, PID is the process number, name the name of the molecule,; and filenumber is listed in content.; For those modules providing restart capabilities, the previous file can; be provided through the``restart_file`` option; energy('scf',restart_file='./psi.PID.name.filenumber'). Only the filenumber is necessary for the driver to appropriately rename the; file and copy it to the scratch directory where PSI4 will expect it.; The restart capabilities of a specific method (if any) are found in that method’s documentation.; To provide multiple files, pass them as arguments of a Python list; energy('scf',restart_file=['./file1.filenumber','./file2.filenumber']). Note that the restart_file options is only available for energy procedures as of now.; Executing PSI4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; psi4 -m. The mechanism for restarting HF/DFT calculations is described in details here. Saving the Wavefunction¶; A core object of PSI4 is the Wavefunction (short wfn) object; energy, wfn = energy('scf',return_wfn=True). This C++/Python object (psi4.core.Wavefunction) contains orbital; data, basis set information, result variables and more.; It can be saved either to a numpy file or converted to a python dictionary; # write the wavefunction to file; wfn.to_file('my_wfn'). # alternatively store the dict representation of the wavefunction in memory; wfn_dict = wfn.to_file(). In either form, its attributes can be set and edited.; This is an expert-level feature, though.; In general, let PSI4 create the Wavefunction, then treat it as read-only.; The back conversion to a Wavefunction object uses the .from_file() functionality; # read wavefun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:8105,energy,energy,8105,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,9,['energy'],['energy']
Energy Efficiency,"ess SCS-CC; mobj = re.search(; r'^\s+' + r'(?P<fullCC>(?P<iterCC>CC(?:\w+))(?:\(T\))?)' + r'\s+(?:energy will be calculated.)\s*' +; r'(?:.*?)' +; r'^\s*' + r'(?:@CCENRG-I, Correlation energies.)' + r'\s+(?:ECCAA)\s+' + NUMBER + r'\s*' +; r'^\s+(?:ECCBB)\s+' + NUMBER + '\s*' +; r'^\s+(?:ECCAB)\s+' + NUMBER + '\s*' +; r'^\s+(?:Total)\s+' + NUMBER + '\s*',; outtext, re.MULTILINE | re.DOTALL); if mobj: # PRINT=2 to get SCS-CC components; print('matched scscc'); psivar['%s SAME-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = Decimal(mobj.group(3)) + Decimal(mobj.group(4)); psivar['%s OPPOSITE-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(5); psivar['%s CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(6). mobj = re.search(; r'^\s+' + r'(?P<fullCC>(?P<iterCC>CC(?:\w+))(?:\(T\))?)' + r'\s+(?:energy will be calculated.)\s*' +; r'(?:.*?)' +; r'^\s+' + r'Amplitude equations converged in' + r'\s*\d+\s*' + r'iterations.\s*' +; r'^\s+' + r'The AA contribution to the correlation energy is:\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'The BB contribution to the correlation energy is:\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'The AB contribution to the correlation energy is:\s+' + NUMBER + r'\s+a.u.\s*' +; r'^\s+' + r'The total correlation energy is\s+' + NUMBER + r'\s+a.u.\s*' +; r'(?:.*?)' +; #r'^\s+' + r'The CC iterations have converged.' + r'\s*$',; r'^\s+' + r'(?:A miracle come to pass. )?' + r'The CC iterations have converged.' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj: # PRINT=2 to get SCS components; print('matched scscc2'); psivar['%s SAME-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = Decimal(mobj.group(3)) + Decimal(mobj.group(4)); psivar['%s OPPOSITE-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(5); psivar['%s CORRELATION ENERGY' % (mobj.group('iterCC'))] = mobj.group(6). # Process gradient; mobj = re.search(; r'\s+' + r'Molecular gradient' + r'\s*' +; r'\s+' + r'------------------' + r'\s*' +; r'\s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:15131,energy,energy,15131,psi4manual/1.0.0/_modules/qcdb/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html,1,['energy'],['energy']
Energy Efficiency,"ess for the variationally orbital-optimized DFT methods. Currently only available for ALGORITHM = SIMULTANEOUS. Type: conv double; Default: 1e-3. GUESS_VECTOR (DETCI)¶DETCI (Expert) — Guess vector type. Accepted values are UNIT for a unit vector guess (NUM_ROOTS and NUM_INIT_VECS must both be 1); H0_BLOCK to use eigenvectors from the H0 BLOCK submatrix (default); DFILE to use NUM_ROOTS previously converged vectors in the D file;. Type: string; Possible Values: UNIT, H0_BLOCK, DFILE; Default: H0_BLOCK. H0_BLOCK_COUPLING (DETCI)¶DETCI (Expert) — Do use coupling block in preconditioner?. Type: boolean; Default: false. H0_BLOCK_COUPLING_SIZE (DETCI)¶DETCI (Expert) — Parameters which specifies the size of the coupling block within the generalized davidson preconditioner. Type: integer; Default: 0. H0_BLOCKSIZE (DETCI)¶DETCI (Expert) — This parameter specifies the size of the H0 block of the Hamiltonian which is solved exactly. The n determinants with the lowest SCF energy are selected, and a submatrix of the Hamiltonian is formed using these determinants. This submatrix is used to accelerate convergence of the CI iterations in the OLSEN and MITRUSHENKOV iteration schemes, and also to find a good starting guess for the SEM method if GUESS_VECTOR is H0_BLOCK. Defaults to 1000. Note that the program may change the given size for Ms=0 cases (MS0 is TRUE) if it determines that the H0 block includes only one member of a pair of determinants related by time reversal symmetry. For very small block sizes, this could conceivably eliminate the entire H0 block; the program should print warnings if this occurs. Type: integer; Default: 1000. H0_GUESS_SIZE (DETCI)¶DETCI (Expert) — size of H0 block for initial guess. Type: integer; Default: 1000. H_BOND_CONNECT (OPTKING)¶OPTKING — For now, this is a general maximum distance for the definition of H-bonds. Type: double; Default: 4.3. H_GUESS_EVERY (OPTKING)¶OPTKING — Re-estimate the Hessian at every step, i.e., ignore the currently stored ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:140944,energy,energy,140944,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['energy'],['energy']
Energy Efficiency,ess() GetkwParser method. set_com_fixed() LibmintsMolecule method. set_coordinates() CartesianEntry method. ZMatrixEntry method. set_fixed() CoordValue method. set_full_geometry() LibmintsMolecule method. set_full_point_group() LibmintsMolecule method. set_geometry() LibmintsMolecule method. set_ghost_fragment() LibmintsMolecule method. set_ghost_fragments() LibmintsMolecule method. set_ghosted() CoordEntry method. set_has_zmatrix() LibmintsMolecule method. set_memory() in module p4util.util. set_molecular_charge() LibmintsMolecule method. set_multiplicity() LibmintsMolecule method. set_name() LibmintsMolecule method. set_num_threads() in module p4util.util. set_point_group() LibmintsMolecule method. set_status() Keyword method. Section method. set_units() LibmintsMolecule method. set_variable() LibmintsMolecule method. setkw() Getkw method. Keyword method. Section method. setting; . keywords C-side. keywords anharmonicity(). keywords cbs(). keywords cp(). keywords database(). keywords energy(). keywords molecule. keywords optimize(). keywords property(). setup_keywords() in module pcmpreprocess. SF_RESTRICT (DETCI). sherrill_gold_standard() in module aliases. show() in module qcdb.vecutil. SIGMA_OVERLAP (DETCI). single-point. SINGLES_PRINT (CCEOM). SMALL_CUTOFF (PSIMRCC). SO_S_FILE (TRANSQT). SO_T_FILE (TRANSQT). SO_TEI_FILE (TRANSQT). SO_V_FILE (TRANSQT). SOCC (GLOBALS). (MCSCF). SOLVER_CONVERGENCE (CPHF). SOLVER_EXACT_DIAGONAL (CPHF). SOLVER_MAX_SUBSPACE (CPHF). SOLVER_MAXITER (CPHF). SOLVER_MIN_SUBSPACE (CPHF). SOLVER_N_GUESS (CPHF). SOLVER_N_ROOT (CPHF). SOLVER_NORM (CPHF). SOLVER_PRECONDITION (CPHF). SOLVER_PRECONDITION_MAXITER (CPHF). SOLVER_PRECONDITION_STEPS (CPHF). SOLVER_QUANTITY (CPHF). SOLVER_TYPE (CPHF). SORTED_TEI_FILE (TRANSQT). SOS_TYPE (OCC). SPINADAPT_ENERGIES (CCENERGY). split_menial() in module wrappers. SS_E_CONVERGENCE (CCEOM). SS_R_CONVERGENCE (CCEOM). SS_SKIP_DIAG (CCEOM). SS_VECS_PER_ROOT (CCEOM). STABILITY_ADD_VECTORS (DCFT). STABILITY_ANAL,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/genindex.html:45605,energy,energy,45605,psi4manual/4.0b5/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/genindex.html,1,['energy'],['energy']
Energy Efficiency,"ess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. cbs-delta-energy; Extrapolated energies with delta correction. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. frac-sym; Fractional occupation with symmetry. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. sapt-ecp; sapt0 of charged system in ECP basis set. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. dfremp-1; density fitted REMP/cc-pVDZ energies for the CO2 molecule. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:33708,energy,energy,33708,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. fnocc5; Test FNO-DF-CCSD(T) energy. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. dft-smoke; DFT Functional Smoke Test. ao-casscf-sp; CASSCF/6-31G** energy point. cepa-module; routing check on lccd, lccsd, cepa(0). dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. cbs-xtpl-alpha; Extrapolated water energies. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. nbody-nocp-gradient; Computation of NoCP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. sapt-exch-ind30-inf; SAPT2+3 with S^inf exch-ind30 Geometries taken from the S66x10 database, the shortest-range point (R = 0.7 R_e). cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega= (589 355 nm). fci-h2o; 6-31G H2O Test FCI Energy Point. dfremp-1; density fitted REMP/cc-pVDZ energies for the CO2 molecule. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:7860,energy,energy,7860,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"essian How did you end up here?""). def _print_nbody_energy(energy_body_dict, header, embedding=False):; core.print_out(""""""\n ==> N-Body: %s energies <==\n\n"""""" % header); core.print_out("""""" n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]\n""""""); previous_e = energy_body_dict[1]; if previous_e == 0.0:; tot_e = False; else:; tot_e = True; nbody_range = list(energy_body_dict); nbody_range.sort(); for n in nbody_range:; delta_e = (energy_body_dict[n] - previous_e); delta_e_kcal = delta_e * constants.hartree2kcalmol; int_e_kcal = (; energy_body_dict[n] - energy_body_dict[1]) * constants.hartree2kcalmol if not embedding else np.nan; if tot_e:; core.print_out("""""" %4s %20.12f %20.12f %20.12f\n"""""" % (n, energy_body_dict[n], int_e_kcal,; delta_e_kcal)); else:; core.print_out("""""" %4s %20s %20.12f %20.12f\n"""""" % (n, ""N/A"", int_e_kcal,; delta_e_kcal)); previous_e = energy_body_dict[n]; core.print_out(""\n""). [docs]def nbody_gufunc(func: Union[str, Callable], method_string: str, **kwargs):; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type func: Callable; :param func: ``energy`` || etc. Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. :type method_string: str; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indica",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:3867,energy,energy,3867,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,4,['energy'],['energy']
Energy Efficiency,"essian""] = H0. D0 = assembled_results[""dipole""]; if D0 is not None:; qcvars[""CURRENT DIPOLE""] = D0; qcvars[""CBS DIPOLE""] = D0. DD0 = assembled_results[""dipole gradient""]; if DD0 is not None:; qcvars[""CURRENT DIPOLE GRADIENT""] = DD0; qcvars[""CBS DIPOLE GRADIENT""] = DD0. cbs_model = AtomicResult(; **{; 'driver': self.driver,; #'keywords': self.keywords,; 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__, module=assembled_results[""module""]),; 'extras': {; 'qcvars': qcvars,; 'cbs_record': copy.deepcopy(self.cbsrec),; },; 'return_result': assembled_results['ret_ptype'],; 'success': True,; }). logger.debug('CBS QCSchema:\n' + pp.pformat(cbs_model.dict())). return cbs_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables; - module if simple. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; cbs_model = self.get_results(client=client). if cbs_model.driver == 'energy':; ret_ptype = cbs_model.return_result; else:; ret_ptype = core.Matrix.from_array(cbs_model.return_result); wfn = _cbs_schema_to_wfn(cbs_model). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _cbs_schema_to_wfn(cbs_model):; """"""Helper function to produce Wavefunction from a Composite-flavored AtomicResult."""""". mol = core.Molecule.from_schema(cbs_model",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:60838,Energy,EnergyGradientHessianWfnReturn,60838,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,3,['Energy'],['EnergyGradientHessianWfnReturn']
Energy Efficiency,"essian(), and much other computation; info through psi4.core.Wavefunction.frequency_analysis; (note no parentheses). Examples of using this data; structure can be found fd-freq-gradient and; psi4/tests/pytests/test_vibanalysis.py. Formatted printing of vibrational; results is available through psi4.driver.qcdb.vib.print_vibs(). Results accessible through psi4.core.Wavefunction.frequency_analysis¶. key; description (lbl & comment); units; data (real/imaginary modes). omega; frequency; cm^-1; ndarray(ndof) complex (real/imag). q; normal mode, normalized mass-weighted; a0 u^1/2; ndarray(ndof, ndof) float. w; normal mode, un-mass-weighted; a0; ndarray(ndof, ndof) float. x; normal mode, normalized un-mass-weighted; a0; ndarray(ndof, ndof) float. degeneracy; degree of degeneracy. ndarray(ndof) int. TRV; translation/rotation/vibration. ndarray(ndof) str ‘TR’ or ‘V’ or ‘-’ for partial. gamma; irreducible representation. ndarray(ndof) str irrep or None if unclassifiable. mu; reduced mass; u; ndarray(ndof) float (+/+). k; force constant; mDyne/A; ndarray(ndof) float (+/-). DQ0; RMS deviation v=0; a0 u^1/2; ndarray(ndof) float (+/0). Qtp0; Turning point v=0; a0 u^1/2; ndarray(ndof) float (+/0). Xtp0; Turning point v=0; a0; ndarray(ndof) float (+/0). theta_vib; char temp; K; ndarray(ndof) float (+/0). Visualization of Normal Modes¶; PSI4 has the ability to export a Molden file that stores information about; the harmonic frequencies and normal modes computed via frequency().; This feature can be enabled by setting the option NORMAL_MODES_WRITE to true.; The filename of the Molden file ends in .molden_normal_modes, and the prefix is; determined by WRITER_FILE_LABEL (if set), or else by the name of the; output file plus the name of the current molecule.; The normal coordinates saved in the Molden file are normalized and are not; mass weighted. Molden Interface Keywords¶. NORMAL_MODES_WRITE¶. Do write a file containing the normal modes in Molden format? If so, the filename will end",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/freq-1.html:5530,reduce,reduced,5530,psi4manual/1.4.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/freq-1.html,9,['reduce'],['reduced']
Energy Efficiency,"est -R testname; Run tests excluding those by name: ctest -E testname; Run tests matching by label: ctest -L testlabel; Run tests excluding those by label: ctest -LE testlabel. Pytest has similar commands:. Run tests in parallel with -n flag (if Python package pytest-xdist installed). For maximum parallelism: pytest -n auto; Run full test suite: pytest; Run the quick tests: pytest -m quick; Run the minimal number of tests to ensure Psi4 and any add-ons in working order: pytest -m smoke; Run tests matching by name: pytest -k testname; Run tests excluding those by name: pytest -k ""not testname""; Run tests matching by label: pytest -m testlabel; Run tests excluding those by label: pytest -m ""not testlabel""; Run tests with complicated filtering by name: pytest -k ""cc and not cc4 and not stdsuite""; Run tests and see test names: pytest -v; Run tests and see test names and sometimes more verbose errors: pytest -vv. How to see CTest testing errors¶; >>> ctest; Test project /your/path/2/psi4/build/directory/tests; Start 248: tu1-h2o-energy; 1/2 Test #248: tu1-h2o-energy ................... Passed 1.73 sec; Start 6: cc1; 2/2 Test #6: cc1 ..............................***Failed 0.07 sec; ... When ctest reports that some (or all) tests have failed, look in your; build directory for file; objdir/Testing/Temporary/LastTest.log. It may have a; .tmp extension, depending on whether the last test was interrupted and; a few other factors. Either way, this file should contain CMake’s testing; output, as well as everything that was printed to the screen. How to test a Psi4 installation¶; ctest requires a connection to source files and cmake; machinery and so can only be performed from objdir; (staged installation). To test an installed PSI4 (full or staged; installation), a supplementary test suite is available to be; run via pytest. Running a limited number of “smoke” tests is; generally sufficient to verify an installation. From the executable; # smoke tests only in serial; psi4 --tes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/build_planning.html:54245,energy,energy,54245,psi4manual/1.6.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/build_planning.html,10,['energy'],['energy']
Energy Efficiency,"est CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. freq-isotope; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fnocc4; Test FNO-DF-CCSD(T) energy. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dcft8; DCFT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:27278,energy,energy,27278,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"est CISD Energy Point with subspace collapse. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. extern3; External potential calculation with one Ghost atom and one point charge at the same position. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cbs-xtpl-energy-conv; Extrapolated water energies - conventional integrals version. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. nbody-nocp-gradient; Computation of NoCP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. olccd-grad1; OLCCD cc-pVDZ gradient for the H2O molecule. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:13238,energy,energy-conv,13238,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy-conv']
Energy Efficiency,"est CISD Energy Point. mrcc4; CCSDT cc-pVDZ optimization and frequencies for the H2O molecule using MRCC. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). fci-dipole; 6-31G H2O Test FCI Energy Point. docs_psimod; This test is used to construct the documentation; it is not suitable for emulation by users. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dfmp2_1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. dcft3; DCFT-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. mints3; Test individual integral objects for correctness. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. rasci-h2o; RASCI/6-31G** H2O Ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:9907,energy,energy,9907,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"est for water. cbs-xtpl-energy-conv; Extrapolated water energies - conventional integrals version. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega= (589 355 nm). nbo; Generation of NBO file. cc54; CCSD dipole with user-specified basis set. scf-guess-read3; Test if the the guess read in the same basis converges. scf-upcast-custom-basis; test scf castup with custom basis sets. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. fci-dipole; 6-31G H2O Test FCI Energy Point. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). fnocc5; Test FNO-DF-CCSD(T) energy. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. mints15; check SP basis Fortran exponent parsing. tdscf-5; td-camb3lyp with DiskDF and method/basis specification. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:23500,energy,energy,23500,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"est of external potential in F-SAPT (see fsapt1 for a real example). dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. scf-level-shift-cuhf; SCF level shift on a CUHF computation. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. rasci-h2o; RASCI/6-31G** H2O Energy Point. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. dct-grad4; Unrestricted DF-DCT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. mbis-3; MBIS calculation on OH radical. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. fnocc4; Test FNO-DF-CCSD(T) energy. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. opt7; Vario",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:44372,energy,energy,44372,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"est should match RHF values exactly. scf-level-shift-cuhf; SCF level shift on a CUHF computation. cubeprop; RHF orbitals and density for water. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. fsapt-ext-abc2; FSAPT with external charge on dimer. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. scf-response3; UHF Dipole Polarizability Test. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. cc36; CC2(RHF)/cc-pVDZ energy of H2O. opt11; Transition-state optimizations of HOOH to both torsional transition states. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. sapt11; sapt example with orbital freezing with alkali metal and dMP2. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. cc52; CCSD Response for H2O2. dft-grad2; DF-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:11891,energy,energy,11891,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,4,['energy'],['energy']
Energy Efficiency,"est_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:57095,energy,energy,57095,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,6,['energy'],['energy']
Energy Efficiency,"estartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(psi4.me() == 0):; shutil.copy(restartfile, targetfile); else:; scf_helper(name, **kwargs). psi4.print_out('\n'); p4util.banner('DFMP2'); psi4.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). e_dfmp2 = psi4.dfmp2(); e_scs_dfmp2 = psi4.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; run_mcscf(name, **kwargs); psi4.psimrcc(); return psi4.get_variable(""CURRENT ENERGY""). [docs]def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). psi4.psimrcc(); return psi4.get_variable(""CURRENT ENERGY""). [docs]def run_mp2c(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a coupled MP2 calculation. """"""; optstash = p4util.Option",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:44507,ENERGY,ENERGY,44507,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"estartfile, ); # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; name_split = re.split(r'\.', item); if ""npz"" in item:; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2]; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npz""); else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.get_variable('CURRENT ENERGY'), wfn); else:; return core.get_variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:33210,energy,energy,33210,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"estartfile, ); # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; name_split = re.split(r'\.', item); if ""npz"" in item:; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2]; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npz""); else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); shutil.copy(item, targetfile). wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:35444,energy,energy,35444,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"estartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SCF') == '':; jkbasis = corresponding_jkfit(PsiMod.get_global_option('BASIS')); if jkbasis:; PsiMod.set_global_option('DF_BASIS_SCF', jkbasis); PsiMod.print_out('\nNo DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). run_scf('RHF', **kwargs). PsiMod.print_out('\n'); banner('DFMP2'); PsiMod.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). PsiMod.dfmp2grad(); e_dfmp2 = PsiMod.get_variable('DF-MP2 ENERGY'); e_scs_dfmp2 = PsiMod.get_variable('SCS-DF-MP2 ENERGY'). optstash.restore(). if (name.upper() == 'SCS-DFMP2') or (name.upper() == 'SCS-DF-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2'):; return e_dfmp2. [docs]def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; lowername = name.lower(). optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if (lowername == 'ccsd'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'CCSD'); PsiMod.set_local_option('CCSORT', 'WFN', 'CCSD'); PsiMod.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif (lowername == 'ccsd(t)'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); PsiMod.set_local_option('CCSORT', 'WFN', 'CCSD_T'); PsiMod.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif (lowername == 'cc2'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'CC2'); PsiMod.set_local_option('CCSORT', 'WFN', 'CC2');",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:12105,ENERGY,ENERGY,12105,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ested. Quantity \(E_{\text{-D}}\); in Eqs. (4) and (1).; When dispersion parameters are untweaked for a functional and dispersion; level, labeled QCVariable also defined. DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [Eh] appended to an; underlying functional when a DH-DFT method is requested.; Quantity \(E_{\text{DH}}\) in Eq. (1). DMA DISTRIBUTED MULTIPOLES¶; Distributed multipoles in units given by GDMA_MULTIPOLE_UNITS; with the row index corresponding to the site and the column index; referencing the multipole component. Both indices are zero based,; and the Qlm components of the multipoles are ordered as Q00, Q10,; Q11c, Q11s, Q20, Q21c, Q21s, Q22c, Q22s, etc. DMA TOTAL MULTIPOLES¶; Distributed multipoles as a single row, whose columns are the total; multipoles, translated to GDMA_ORIGIN, and summed. DMRG-SCF TOTAL ENERGY¶; The total DMRG total electonic energy [Eh]. Not unique because oribital spaces vary. DMRG-CASPT2 TOTAL ENERGY¶; The total DMRG plus CASPT2 total electonic energy [Eh] . Not unique because orbital spaces vary. EFP DISP ENERGY¶. EFP ELST ENERGY¶. EFP EXCH ENERGY¶. EFP IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [Eh] for EFP/EFP; computations. The sum of these four components yields; EFP TOTAL ENERGY. EFP TOTAL ENERGY¶; The total electronic interaction energy [Eh] for EFP/EFP computations. EFP TORQUE¶; The torque, not gradient for EFP/EFP computations. ENTHALPY¶; Total enthalpy H [Eh] at given temperature. ENTHALPY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [Eh] to the enthalpy at given temperature. ESP AT CENTER n¶; Property of electrostatic potential [Eh / e] at location, usually atom center, n. FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the full configuration interaction level of theory. GIBBS FREE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:21863,energy,energy,21863,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['energy'],['energy']
Energy Efficiency,"esults block""""""; #-------------; #DIPOLE MOMENT; #-------------; # X Y Z; #Electronic contribution: -0.11359 -0.14669 -0.00000; #Nuclear contribution : 0.61892 0.79867 0.00000; # -----------------------------------------; #Total Dipole Moment : 0.50533 0.65198 -0.00000; # -----------------------------------------; #Magnitude (a.u.) : 0.82489; #Magnitude (Debye) : 2.09670; #; #. dipole_start = find_start(lines, 'DIPOLE MOMENT'). if dipole_start != -1:; # Dipole x, y, z are the last items 6 lines down in the dipole block; dipole_str_list = lines[dipole_start + 6].split()[-3:]; # Convert the dipole to debye; dipole = [float(i)*psi_dipmom_au2debye for i in dipole_str_list]; psivar['CURRENT DIPOLE X'] = dipole[0]; psivar['CURRENT DIPOLE Y'] = dipole[1]; psivar['CURRENT DIPOLE Z'] = dipole[2]. # Dipole magnitude is 8 line down in the dipole block; magnitude = float(lines[dipole_start + 8][-1]). [docs]def harvest_mp2(lines, psivar):; """"""Harvest the MP2 results""""""; """"""Sample MP2 energy line (works for both MP2 and RI-MP2)""""""; #---------------------------------------; #MP2 TOTAL ENERGY: -76.226803665 Eh; #---------------------------------------. """"""Sample MP2 correlation energy line (yes there is a space)""""""; #-----------------------------------------------; # MP2 CORRELATION ENERGY : -0.125436532 Eh; #-----------------------------------------------. """"""Sample RI-MP2 Correlation energy line (yes there is a space)""""""; #-----------------------------------------------; # RI-MP2 CORRELATION ENERGY: -0.125496692 Eh; #-----------------------------------------------. for line in reversed(lines):; if line[:16] == 'MP2 TOTAL ENERGY':; psivar['MP2 TOTAL ENERGY'] = line.split()[-2]; break; for line in reversed(lines):; if line[:23] == ' MP2 CORRELATION ENERGY' or\; line[:26] == ' RI-MP2 CORRELATION ENERGY':; psivar['MP2 CORRELATION ENERGY'] = line.split()[-2]; break. [docs]def harvest_coupled_cluster(lines, psivar):; """"""Harvest coupled cluster results; WARNING: Canonical and DLPNO prin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html:6635,energy,energy,6635,psi4manual/1.0.0/_modules/qcdb/orca.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html,1,['energy'],['energy']
Energy Efficiency,"esults['ret_ptype'],; 'success': True,; }). logger.debug('CBS QCSchema:\n' + pp.pformat(cbs_model.dict())). return cbs_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables; - module if simple. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; cbs_model = self.get_results(client=client). if cbs_model.driver == 'energy':; ret_ptype = cbs_model.return_result; else:; ret_ptype = core.Matrix.from_array(cbs_model.return_result); wfn = _cbs_schema_to_wfn(cbs_model). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _cbs_schema_to_wfn(cbs_model):; """"""Helper function to produce Wavefunction from a Composite-flavored AtomicResult."""""". mol = core.Molecule.from_schema(cbs_model.molecule.dict()); basis = core.BasisSet.build(mol, ""ORBITAL"", 'def2-svp', quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(cbs_model.provenance, ""module""):; wfn.set_module(cbs_model.provenance.module). # wfn.set_energy(cbs_model['extras'['qcvars'].get('CBS TOTAL ENERGY')) # catches Wfn.energy_; for qcv, val in cbs_model.extras['qcvars'].items():; for obj in [core, wfn]:; obj.set_variable(qcv, val). return wfn. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.8.2;  · . PSI4. Module code; psi4.driver.driver_cbs. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:62182,ENERGY,ENERGY,62182,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"esults['ret_ptype'],; 'success': True,; }). logger.debug('CBS QCSchema:\n' + pp.pformat(cbs_model.dict())). return cbs_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.FractalClient""] = None,; *,; return_wfn: bool = False) -> EnergyGradientHessianWfnReturn:; """"""Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: ``(e/g/h, wfn)``. Parameters; ----------; return_wfn; Whether to additionally return the dummy :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. Contents are:. - molecule; - dummy basis, def2-svp; - e/g/h member data; - QCVariables; - module if simple. Returns; -------; ret; Energy, gradient, or Hessian according to self.driver.; wfn; Wavefunction described above when *return_wfn* specified. """"""; cbs_model = self.get_results(client=client). if cbs_model.driver == 'energy':; ret_ptype = cbs_model.return_result; else:; ret_ptype = core.Matrix.from_array(cbs_model.return_result); wfn = _cbs_schema_to_wfn(cbs_model). if return_wfn:; return (ret_ptype, wfn); else:; return ret_ptype. def _cbs_schema_to_wfn(cbs_model):; """"""Helper function to produce Wavefunction from a Composite-flavored AtomicResult."""""". mol = core.Molecule.from_schema(cbs_model.molecule.dict()); basis = core.BasisSet.build(mol, ""ORBITAL"", 'def2-svp', quiet=True); wfn = core.Wavefunction(mol, basis); if hasattr(cbs_model.provenance, ""module""):; wfn.set_module(cbs_model.provenance.module). # wfn.set_energy(cbs_model['extras'['qcvars'].get('CBS TOTAL ENERGY')) # catches Wfn.energy_; for qcv, val in cbs_model.extras['qcvars'].items():; for obj in [core, wfn]:; obj.set_variable(qcv, val). return wfn. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.9.1;  · . PSI4. Module code; psi4.driver.driver_cbs. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html:62030,ENERGY,ENERGY,62030,psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"et Perturbation Theories; PSIMRCC Implementation of Mk-MRCC Theory; CI: Configuration Interaction; SAPT: Symmetry-Adapted Perturbation Theory; ADC: Ab Initio Polarization Propagator; Scalar relativistic Hamiltonians; Geometry Optimization; oeprop() Evaluation of One-Electron Properties; Vibrational and Thermochemical Analysis. Interfaces: Enhancing Psi4 Capabilities; Interface to CFOUR by J. Stanton and J. Gauss; Interface to CheMPS2 by S. Wouters; Interface to DFTD3 by S. Grimme; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Interface to programs through FCHK files, fchk(); Interface to GDMA Distributed Multipole Analysis by A. J. Stone, gdma(); Interface to LIBEFP by I. Kaliman; Interface to PCMSolver; Interface to Molden, molden(); Interface to MRCC by M. Kállay. Psithon Functions: Invoking a Calculation; Notes on Options; Single-Point Energy, energy(); Property; Counterpoise Correct; Geometry Optimization, optimize() and gradient(); Harmonic Vibrational Analysis, frequency() and hessian(); Database, database(); Complete Basis Set; Spectroscopic Constants for Diatomics; Function Intercalls; Embarrassing Parallelism; cubeprop() Generation of cube files; Orbital Visualization with VMD. Customization: Adding Simple Extensions; Defining a Method Alias; Creating a Database. Appendices; Keywords; Keywords by Alpha; Keywords by Module. Basis Sets; Basis Sets by Family; Basis Sets by Element; Auxiliary Basis Sets. PSI Variables; PSI Variables by Alpha; PSI Variables by Module. Miscellaneous; Test Suite and Sample Inputs; DFT Functionals; PSIOH Intermediate Files; Physical Constants; Bibliography. Programmers’ Manual¶. Contributions: Intro to Programming in Psi4; Plugins: Adding New Functionality to Psi4; Best Practices for Python Functions; Documentation; PsiPEP: Plans and Practices to Organize Psi4. Programming: Using the Core Libraries; LibOptions: globals, locals, has_changed and all that; Adding Methods to Driver; BasisSet. Python Driver; wrapper_database; d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/contents.html:2230,energy,energy,2230,psi4manual/1.0.0/contents.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/contents.html,2,['energy'],['energy']
Energy Efficiency,"et during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theore",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/oeprop-1.html:1669,charge,charges,1669,psi4manual/4.0b4/oeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/oeprop-1.html,2,['charge'],['charges']
Energy Efficiency,"et during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Theore",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/oeprop-1.html:1669,charge,charges,1669,psi4manual/4.0b5/oeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/oeprop-1.html,2,['charge'],['charges']
Energy Efficiency,"et during the computation. The unnamed arguments are the; properties to be computed. These can appear in any order, and multiple; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Psithon Functions: Invoking a Calculation; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/oeprop-1.html:1669,charge,charges,1669,psi4manual/4.0b3/oeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/oeprop-1.html,2,['charge'],['charges']
Energy Efficiency,"et of necessary and sufficient N-representability conditions are known,; and some of the known conditions are not easily imposed. In addition, the lack; of separability of the density matrices may result in the loss of; size-consistency and size-extensivity. In DCFT one takes a different route and; replaces the TPDM in favor of its two-particle density cumulant:. The one-particle density matrix is separated into its idempotent part; and a correction :. The idempotent part of the OPDM corresponds to a Hartree-Fock-like density of; non-interacting electrons, while the non-idempotent correction ; depends on the density cumulant and describes the electron correlation effects.; Inserting the above two equations into the energy expression, we obtain:. where the antisymmetrized two-electron integrals and the generalized Fock operator; matrix elements were defined as follows:. Energy functional has several important properties. First,; the energy is now a function of two types of independent parameters, the; idempotent part of OPDM and the density cumulant; . As a result, the energy functional is Hermitian,; which is important for the evaluation of the molecular properties. The additive; separability of the density cumulant guarantees that all of the DCFT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent part of the OPDM is; N-representable by construction. One only needs to worry about the; N-representability of the density cumulant, which is a relatively small part of; the TPDM.; In order to obtain the DCFT energy, two conditions must be satisfied:; 1) The energy must be stationary with respect to the variation of the; idempotent part of the one-particle density matrix . This is; achieved by the self-consistent diagonalization of the generalized Fock; operator matrix defined above, which introduces the relaxation of the orbitals.; 2) The energy must be stationary with respect to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dcft-1.html:2219,energy,energy,2219,psi4manual/4.0b4/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dcft-1.html,4,['energy'],['energy']
Energy Efficiency,"et the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""CURRENT HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html:83215,energy,energy,83215,psi4manual/1.5.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"et(), irrep_labels, dipder=dipder, project_trans=project_trans, project_rot=project_rot); vibrec.update({k: qca.json() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rotor_type(),; rot_const=np.asarray(mol.rotational_constants()),; E0=core.variable('CURRENT ENERGY')) # someday, wfn.energy(); vibrec.update({k: qca.json() for k, qca in therminfo.items()}). core.set_variable(""ZPVE"", therminfo['ZPE_corr'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY CORRECTION"", therminfo['E_corr'].data) # P::e THERMO; core.set_variable(""ENTHALPY CORRECTION"", therminfo['H_corr'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY CORRECTION"", therminfo['G_corr'].data) # P::e THERMO. core.set_variable(""ZERO K ENTHALPY"", therminfo['ZPE_tot'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY"", therminfo['E_tot'].data) # P::e THERMO; core.set_variable(""ENTHALPY"", therminfo['H_tot'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY"", therminfo['G_tot'].data) # P::e THERMO. core.print_out(thermtext); else:; core.print_out(' Thermochemical analysis skipped for partial frequency calculation.\n'). if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".vibrec""; with open(filename, 'w') as handle:; json.dump(vibrec, handle, sort_keys=True, indent=4). if core.get_option('FINDIF', 'NORMAL_MODES_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".molden_normal_modes""; with open(filena",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:90054,ENERGY,ENERGY,90054,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"et, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; from __future__ import print_function; from __future__ import absolute_import; import os; import shutil; import subprocess. import numpy as np. from psi4 import extras; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import constants; from psi4.driver.p4util.exceptions import *; from psi4.driver.molutil import *; # never import driver, wrappers, or aliases into this file. from .roa import *; from . import proc_util; from . import empirical_dispersion; from . import dft_funcs; from . import mcscf; from . import response. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:2026,energy,energy,2026,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['energy'],['energy']
Energy Efficiency,"et. Uses TCSCF orbitals. mp2-1; All-electron MP2 6-31G** geometry optimization of water. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt11; Transition-state optimizations of HOOH to both torsional transition states. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. scf-bs; UHF and broken-symmetry UHF energy for molecular hydrogen. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. mints3; Test individual integral objects for correctness. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:27629,energy,energy,27629,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"et.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:7861,energy,energy,7861,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['energy'],['energy']
Energy Efficiency,"etAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]; class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr passed as keyword argument, e.g., `energy(..., external_potentials=[[0.5, [0, 0, 1]], [-0.5, [0, 0, -1]]])`.'). [docs]; class QMMMbohr():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. To add external charges to a calculation, prefer; passing the array of charges with kwarg ``external_potentials``, as in extern2 example."""""". def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs]; def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs]; def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs]; def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:4102,charge,charges,4102,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,6,['charge'],['charges']
Energy Efficiency,"etLogger(__name__). _zeta_val2sym = {k + 2: v for k, v in enumerate('dtq5678')}; Extrapolatable = Union[float, core.Matrix, core.Vector]. [docs]def xtpl_highest_1(functionname: str, zHI: int, valueHI: Extrapolatable, verbose: int = 1, **kwargs) -> Extrapolatable:; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'mp2') used in summary printing.; zHI; Zeta-level, only used for printing.; valueHI; Energy, gradient, or Hessian value at the basis set.; verbose; Controls volume of printing. Returns; -------; float or ndarray; Returns :math:`E_{total}^{\infty}` which is equal to valueHI.; Eponymous function applied to input zetas and values; type from `valueHI`. Notes; -----; .. math:: E_{total}^X = E_{total}^{\infty}. Examples; --------; >>> # [1] Fancy way to get HF/cc-pCVQZ; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pcvqz', scf_scheme='xtpl_highest_1'). """"""; if isinstance(valueHI, float):. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += f""""""\n ==> {functionname.upper()} <==\n\n""""""; cbsscheme += f"""""" HI-zeta ({zHI}) Energy: {valueHI: 16.12f}\n"""""". core.print_out(cbsscheme); logger.debug(cbsscheme). return valueHI. elif isinstance(valueHI, np.ndarray):. if verbose > 2:; cbsscheme = f""""""\n ==> {functionname.upper()} <==\n\n""""""; cbsscheme += f"""""" HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI); core.print_out(cbsscheme); logger.debug(cbsscheme). return valueHI. [docs]def scf_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using exponential form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:2512,energy,energy,2512,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,2,['energy'],['energy']
Energy Efficiency,"etParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Navigation. Index. modules    .    .  · ; 1.1;  · . PSI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/qmmm.html:4010,charge,charge,4010,psi4manual/1.1.0/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/qmmm.html,1,['charge'],['charge']
Energy Efficiency,"etParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qmmm.html:3944,charge,charge,3944,psi4manual/1.3.2/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qmmm.html,6,['charge'],['charge']
Energy Efficiency,"et_active_molecule()); molecule.update_geometry(); kwargs['molecule'] = molecule. # Allow specification of methods to arbitrary order; lowername = args[0].lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. if ""/"" in lowername:; return driver_cbs._cbs_gufunc(properties, lowername, ptype='properties', **kwargs). return_wfn = kwargs.pop('return_wfn', False); props = kwargs.get('properties', ['dipole', 'quadrupole']). if len(args) > 1:; props += args[1:]. kwargs['properties'] = p4util.drop_duplicates(props); optstash = driver_util._set_convergence_criterion('properties', lowername, 6, 10, 6, 10, 8); wfn = procedures['properties'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: psi4.OptimizationConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type ret",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:47334,energy,energy,47334,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"et_global_option_python = _core_set_global_option_python. ## QCvar helps. _qcvar_transitions = {; # old: (replacement, release after next); ""SCSN-MP2 CORRELATION ENERGY"": (""SCS(N)-MP2 CORRELATION ENERGY"", 1.5),; ""SCSN-MP2 TOTAL ENERGY"": (""SCS(N)-MP2 TOTAL ENERGY"", 1.5),; ""MAYER_INDICES"": (""MAYER INDICES"", 1.5),; ""WIBERG_LOWDIN_INDICES"": (""WIBERG LOWDIN INDICES"", 1.5),; ""LOWDIN_CHARGES"": (""LOWDIN CHARGES"", 1.5),; ""MULLIKEN_CHARGES"": (""MULLIKEN CHARGES"", 1.5),; ""(AT) CORRECTION ENERGY"": (""A-(T) CORRECTION ENERGY"", 1.5),; ""CCSD(AT) TOTAL ENERGY"": (""A-CCSD(T) TOTAL ENERGY"", 1.5),; ""CCSD(AT) CORRELATION ENERGY"": (""A-CCSD(T) CORRELATION ENERGY"", 1.5),; ""CP-CORRECTED 2-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY"", 1.7),; ""CP-CORRECTED 3-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 3-BODY"", 1.7),; ""CP-CORRECTED 4-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 4-BODY"", 1.7),; ""CP-CORRECTED 5-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 5-BODY"", 1.7),; ""NOCP-CORRECTED 2-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY"", 1.7),; ""NOCP-CORRECTED 3-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 3-BODY"", 1.7),; ""NOCP-CORRECTED 4-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 4-BODY"", 1.7),; ""NOCP-CORRECTED 5-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 5-BODY"", 1.7),; ""VMFC-CORRECTED 2-BODY INTERACTION ENERGY"": (""VMFC-CORRECTED INTERACTION ENERGY THROUGH 2-BODY"", 1.7),; ""VMFC-CORRECTED 3-BODY INTERACTION ENERGY"": (""VMFC-CORRECTED INTERACTION ENERGY THROUGH 3-BODY"", 1.7),; ""VMFC-CORRECTED 4-BODY INTERACTION ENERGY"": (""VMFC-CORRECTED INTERACTION ENERGY THROUGH 4-BODY"", 1.7),; ""VMFC-CORRECTED 5-BODY INTERACTION ENERGY"": (""VMFC-CORRECTED INTERACTION ENERGY THROUGH 5-BODY"", 1.7),; ""COUNTERPOISE CORRECTED TOTAL ENERGY"": (""CP-CORRECTED TOTAL ENERGY"", 1.7),; ""COUNTERPOISE CORRECTED INTERACTION E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:19447,ENERGY,ENERGY,19447,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,10,['ENERGY'],['ENERGY']
Energy Efficiency,"et_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'ACPF'; if (lowername == 'fno-aqcc'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'AQCC'; if (lowername == 'fno-sdci'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CISD'; if (lowername == 'fno-dci'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CISD'. psi4.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level). # throw an exception for open-shells; if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""Error: %s requires \""reference rhf\""."" % lowername). psi4.set_local_option('TRANSQT2', 'WFN', 'CCSD'); scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') == 'DF' or psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; if psi4.get_option('FNOCC', 'USE_DF_INTS') == False:; mints = psi4.MintsHelper(); mints.integrals(). if psi4.get_option('FNOCC','NAT_ORBS') == False:; if psi4.get_option('FNOCC', 'USE_DF_INTS') == False:; psi4.set_local_option('TRANSQT2', 'WFN', 'CCSD'); psi4.transqt2(). # run cepa; psi4.fnocc(). # one-electron properties; if psi4.get_option('FNOCC', 'DIPMOM'):; if cepa_level == ""CEPA(1)"" or cepa_level == ""CEPA(3)"":; psi4.print_out(""\n""); psi4.print_out("" Error: one-electron properties not implemented for %s\n"" % lowername); psi4.print_out(""\n""); elif psi4.get_option('FNOCC','NAT_ORBS'):; psi4.print_out(""\n""); psi4.print_out("" Error: one-electron properties not implemented for %s\n"" % lowername); psi4.print_out(""\n""); else:; p4util.oeprop('DIPOLE','QUADRUPOLE','MULLIKEN_CHARGES','NO_OCCUPATIONS',title = cepa_level). # restore options; optstash.restore(). return psi4.get_variable(""CURRENT ENERGY""). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta5] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:75006,ENERGY,ENERGY,75006,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"et_local_option('SCF', 'E_CONVERGENCE', scf_Ec); if verbose >= 2:; print(scf_Ec, end=' '); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', pscf_Ec); if verbose >= 2:; print(pscf_Ec, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'E_CONVERGENCE'), end=' '). if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'D_CONVERGENCE', scf_Dc); if verbose >= 2:; print(scf_Dc, end=' '); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', pscf_Dc); if verbose >= 2:; print(pscf_Dc, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'D_CONVERGENCE'), end=' '). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if procedures['energy'][method_name] not in [proc.run_scf, proc.run_dft]:; psi4.set_global_option('E_CONVERGENCE', gen_Ec); if verbose >= 2:; print(gen_Ec, end=' '); else:; if procedures['energy'][method_name] not in [proc.run_scf, proc.run_dft]:; if verbose >= 2:; print('CUSTOM', psi4.get_global_option('E_CONVERGENCE'), end=' '). if verbose >= 2:; print(''); return optstash. [docs]def parse_arbitrary_order(name):; r""""""Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. """""". name = name.lower(). # matches 'mrccsdt(q)'; if name.startswith('mrcc'):. # avoid undoing fn's good work when called twice; if name == 'mrcc':; return name, None. # grabs 'sdt(q)'; ccfullname = name[4:]. # A negative order indicates perturbative method; methods = {; 'sd' : { 'method': 1, 'order': 2, 'fullname': 'CCSD' },; 'sdt' : { 'method': 1, 'order': 3, 'fullname': 'CCSDT' },; 'sdtq' : { 'method': 1, 'order': 4, 'fullname': 'CCSDTQ' },; 'sdtqp' : { 'method': 1, 'order': 5, 'fullname': 'CCSDTQP' },; 'sdtqph' : { 'method': 1, 'order': 6, 'fullname': 'CCSDTQPH' },; 'sd(t)' : { 'method': ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:4138,energy,energy,4138,psi4manual/1.0.0/_modules/driver_util.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html,1,['energy'],['energy']
Energy Efficiency,"et_num_threads(nthread)[source]¶; Function to reset the number of threads to parallelize across. success(label)[source]¶; Function to print a ‘label...PASSED’ line to screen.; Used by util.compare_values() family when functions pass. basislistdunning¶; Module (auto-generated from make_dunning.pl script); with commands building BasisFamily objects that; encode the Dunning basis set orbital definitions in; psi4/lib/basis/NOTES and fitting bases designed for those; orbital bases. load_basfam_dunning()[source]¶. aliases¶; Module with functions that call upon those in modules; proc, driver, and wrappers. Place in this file quickly defined procedures such as. aliases for complex methods; simple modifications to existing methods. sherrillgroup_gold_standard(name='mp2', **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> energy('sherrillgroup_gold_standard'). qcdb¶; Module to facilitate quantum chemical computations on chemical; databases. Contains Molecule class and physical constants from psi4 suite.; Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. class CartesianEntry(entry_number, Z, charge, mass, symbol, label, x, y, z)[source]¶; Class to hold all information about an atom, including its; coordinate specification as three Cartesians. clone()[source]¶; Returns new, independent CartesianEntry object. compute()[source]¶; Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. everything()[source]¶. invalidate()[source]¶; Flags the current coordinates as being outdated. print_in_input_format()[source]¶; Prints the updated geometry, in the format provided by th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:36824,energy,energy,36824,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency,"et_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; PsiMod.print_out('\n'); PsiMod.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); PsiMod.print_out(' BSSE Treatment: %s\n' % (bsse)); PsiMod.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); PsiMod.print_out(' Compute Total Energy: %s\n' % (do_total)); PsiMod.print_out(' External Field: %s\n' % (has_external)); if (external):; PsiMod.print_out(' External Field Monomers: '); for k in external_indices:; PsiMod.print_out('%-3d ' % (k)); PsiMod.print_out('\n'); PsiMod.print_out('\n'). # Run the total molecule, if required; energies_full = {}; energies_mon = {}; N = molecule.nfragments(); Etotal = 0.0; if do_total or max_n_body == molecule.nfragments():; PsiMod.print_out(' => Total Cluster Energy <=\n'); # Full cluster always gets the external field; if (external):; PsiMod.set_global_option_python(""EXTERN"", external); Etotal = call_function_in_1st_argument(func, **kwargs); if (external):; PsiMod.set_global_option_python(""EXTERN"", None); energies_full[N] = []; energies_full[N].append(Etotal); energies_mon[N] = []; energies_mon[N].append(Etotal); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'); PsiMod.clean(). max_effective = max_n_body; if (max_effective == N):; max_effective = N - 1. # Build the combos for indexing purposes; Ns = []; if (max_n_body == N or do_total):; Ns.append(N); for n in range(max_effective, 0, -1):; Ns.append(n). combos = {}; for n in Ns:. combos[n] = []. # Loop through combinations in lexical order #. # initialize the reals list; reals = []; #setup first combination [3,2,1] lexical ordering; #fragments indexing is 1's based, bloody hell; for index in range(n, 0, -1):; reals.append(index); #start loop through lexical promotion; counter = 0; while True:. counter = counter + 1. # ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:6791,Energy,Energy,6791,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Energy'],['Energy']
Energy Efficiency,"et_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""Error: %s requires \""reference rhf\""."" % lowername). # scf; scf_helper(name,**kwargs). # if the scf type is df/cd, then the ao integrals were never written to disk.; if psi4.get_option('SCF', 'SCF_TYPE') == 'DF' or psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; # do we generate 4-index eri's with 3-index ones, or do we want conventional eri's?; if psi4.get_option('FNOCC', 'USE_DF_INTS') == False:; mints = psi4.MintsHelper(); mints.integrals(). # if this is not cim or FNO-CC, run transqt2. otherwise, libtrans will be used; if psi4.get_option('FNOCC','NAT_ORBS') == False and psi4.get_option('FNOCC','RUN_MP2') == False:; if psi4.get_option('FNOCC', 'USE_DF_INTS') == False:; psi4.set_local_option('TRANSQT2', 'WFN', 'CCSD'); psi4.transqt2(). # run ccsd; psi4.fnocc(). # set current correlation energy and total energy. only need to treat mpn here.; if (lowername == 'fnocc-mp') and (level == 3):; emp3 = psi4.get_variable(""MP3 TOTAL ENERGY""); cemp3 = psi4.get_variable(""MP3 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp3); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp3); elif ( lowername == 'fno-mp3' ):; emp3 = psi4.get_variable(""MP3 TOTAL ENERGY""); cemp3 = psi4.get_variable(""MP3 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp3); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp3); elif ( lowername == 'mp4(sdq)'):; emp4sdq = psi4.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4(sdq)'):; emp4sdq = psi4.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4'):; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:70688,ENERGY,ENERGY,70688,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"et_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in; addition to the total SAPT0 interaction energy. An explanation of the; various energy components can be found in the review by Jeziorski,; Moszynski, and Szalewicz; (Jeziorski:1994:1887),; and this is discussed in more detail in the SAPT; section of the Psi4; manual.; For now, we’ll note that most of the SAPT energy components are; negative; this means those are attractive contributions (the zero of; energy in a SAPT computation is defined as non-interacting monomers).; The exchange contributions are positive (repulsive). In this example,; the most attractive contribution between ethylene and acetylene is an; electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1; indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with; respect to the intramolecular electron correlation). The next most; attractive contribution is the Disp20 term (second order; intermolecular dispersion, which looks ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:15211,energy,energy,15211,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,8,['energy'],['energy']
Energy Efficiency,"et_variable(""MP4(SDQ) CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4sdq); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4(sdq)':; emp4sdq = core.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = core.get_variable(""MP4(SDQ) CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4sdq); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4':; emp4 = core.get_variable(""MP4 TOTAL ENERGY""); cemp4 = core.get_variable(""MP4 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4); elif name == 'mp4':; emp4 = core.get_variable(""MP4 TOTAL ENERGY""); cemp4 = core.get_variable(""MP4 CORRELATION ENERGY""); core.set_variable(""CURRENT ENERGY"", emp4); core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_level = 'acpf'; elif name in ['aqcc', 'fno-aqcc']:; cepa_level = 'aqcc'; elif name in ['cisd', 'fno-cisd']:; cepa_level = 'cisd'; else:; raise ValidationError(""""""Error: %s not implemented\n"""""" % name). c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:121423,energy,energy,121423,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,2,['energy'],['energy']
Energy Efficiency,"et_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(banners). tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables). return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc steps.; [docs]def run_plugin_omega(name, **kwargs):; r""""""Function encoding sequence of PSI module and plugin calls, as well; as typical options, to access Rob Parrish's omega plugin. >>> energy('plugin_omega'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). plugfile = PsiMod.Process.environment[""PSIDATADIR""] + ""/../tests/plugin_omega/plugin_omega.so""; PsiMod.plugin_load(""%s"" % (plugfile)). PsiMod.set_global_option('BASIS', 'AUG-CC-PVDZ'); PsiMod.set_global_option('DF_BASIS_SCF', 'AUG-CC-PVDZ-RI'); PsiMod.set_global_option('REFERENCE', 'U",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html:3787,energy,energy,3787,psi4manual/4.0b3/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html,2,['energy'],['energy']
Energy Efficiency,"et_{ptype}""]. return results. [docs]; class ManyBodyComputer(BaseComputer):; # user kwargs (all but levels become fields); # ------------------------------------------; # * bsse_type; # * levels; # * max_nbody; # * molecule -- general; # * return_total_data; # * return_wfn -- general. # fields set in construction; # --------------------------; # * nfragments (<- max_frag) -- from molecule. # fields set in task_planner; # --------------------------; # * max_nbody -- from levels; # * nbodies_per_mc_level -- from levels. # TODO perhaps rework levels kwarg so that it's processed in class init into nbodies_per_mc_level. Right now, levels resets max_nbody.; # TODO also, perhaps change nbodies_per_mc_level into dict of lists so that pos'n/label indexing coincides. molecule: Any = Field(..., description=""The target molecule, if not the last molecule defined.""); basis: str = ""(auto)""; method: str = ""(auto)""; driver: DriverEnum = Field(..., description=""The computation driver; i.e., energy, gradient, hessian.""); keywords: Dict[str, Any] = Field({}, description=""The computation keywords/options.""). bsse_type: List[BsseEnum] = Field([BsseEnum.cp], description=""Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.""); nfragments: int = Field(-1, description=""Number of distinct fragments comprising full molecular supersystem."") # formerly max_frag; max_nbody: int = Field(-1, description=""Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments.""). nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]] = Field([], description=""Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:32229,energy,energy,32229,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,6,['energy'],['energy']
Energy Efficiency,"eta Density subset. Fa(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Fock Matrix. Fb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Fock Matrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. Hd_vector(self: psi4.core.CIWavefunction, arg0: int) → psi::detci::CIvect¶; docstring. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. build(mol, basis=None)¶. ci_nat_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_dpd(self: psi4.core.CIWavefunction) → None¶; docstring. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. com",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:8190,charge,charges,8190,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['charge'],['charges']
Energy Efficiency,"eta Density subset. Fa(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Fock Matrix. Fb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Fock Matrix. H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. Hd_vector(self: psi4.core.CIWavefunction, arg0: int) → psi::detci::CIvect¶; docstring. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. ci_nat_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None¶; docstring. cleanup_dpd(self: psi4.core.CIWavefunction) → None¶; docstring. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:11318,charge,charges,11318,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['charge'],['charges']
Energy Efficiency,"eta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Test Suite and Sample Inputs ». Input File; Description. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in CH2. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. min_input; This checks that all energy methods can run with a minimal input and set symmetry. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. fd-gradient; SCF STO-3G finite-difference tests. scf6; Tests RHF/ROHF/UHF SCF gradients. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. mcscf1; ROHF 6-31G** energy of the state of CH2, with Z-matrix input. The occupations are specified explicitly. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dcft2; DCFT-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc32; CC3/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. dcft4; DCFT calculation for the HF+ using DCFT-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:1010,energy,energy,1010,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,2,['energy'],['energy']
Energy Efficiency,"etadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """"""; import psi4; if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). # Note: HF and MP2 steps (which don't need MRCC and indeed can't be; # run directly in MRCC through the Psi4 interface) nevertheless have; # qc_module=mrcc set here so that options sets (below, `""options""`; # and `""options_lo""`) are the same and the cbs() driver knows it's; # safe (that is, consistent) to use the ""free"" values (e.g.,; # HF from CCSD) resulting from; # MRCC CCSD calcs. This logic can be made smarter if needed. scf = { # HF; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'cc-pV[Q56]Z'),; 'scheme': kwargs.pop('scf_scheme', 'scf_xtpl_helgaker_3'),; 'options': {""qc_module"": ""mrcc""},; }; corl = { # MP2 - HF; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/aliases.html:5205,energy,energy,5205,psi4manual/1.7.x/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/aliases.html,16,['energy'],['energy']
Energy Efficiency,"etadata['ptype'] != 'energy':; cp_ptype_body_dict[n][:] = cp_ptype_by_level[n] - bsse_ptype; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = cp_energy_by_level[k]; cp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = cp_ptype_by_level[k]; cp_ptype_body_dict[n] += take_nk * sign * value. if n == 1:; bsse = cp_energy_body_dict[n] - monomer_energies; cp_energy_body_dict[n] = monomer_energies; if metadata['ptype'] != 'energy':; bsse_ptype = cp_ptype_body_dict[n] - monomer_ptype; cp_ptype_body_dict[n] = monomer_ptype.copy(). else:; cp_energy_body_dict[n] -= bsse; if metadata['ptype'] != 'energy':; cp_ptype_body_dict[n] -= bsse_ptype. cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. for n in nbody_range[1:]:; var_key = 'CP-CORRECTED %d-BODY INTERACTION ENERGY' % n; nbody_dict[var_key] = cp_energy_body_dict[n] - cp_energy_body_dict[1]. _print_nbody_energy(cp_energy_body_dict, ""Counterpoise Corrected (CP)"", metadata['embedding_charges']); cp_interaction_energy = cp_energy_body_dict[metadata['max_nbody']] - cp_energy_body_dict[1]; if monomer_energies != 0.0:; nbody_dict['Counterpoise Corrected Total Energy'] = cp_energy_body_dict[metadata['max_nbody']]; nbody_dict['Counterpoise Corrected Interaction Energy'] = cp_interaction_energy. # Compute nocp energy and ptype; if 'nocp' in metadata['bsse_type_list']:; for n in nbody_range:; if n == metadata['max_frag']:; nocp_energy_body_dict[n] = nocp_energy_by_level[n]; if metadata['ptype'] != 'energy':; nocp_ptype_body_dict[n][:] = nocp_ptype_by_level[n]; continue. for k in range(1, n + 1):; take_nk = nCr(metadata['max_frag'] - k - 1, n - k); sign = ((-1)**(n - k)); value = nocp_energy_by_level[k]; nocp_energy_body_dict[n] += take_nk * sign * value. if metadata['ptype'] != 'energy':; value = nocp_ptyp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:26362,ENERGY,ENERGY,26362,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:57687,energy,energy,57687,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,6,['energy'],['energy']
Energy Efficiency,"etc. Indicates which properties should be computed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); #psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); # SCF properties have been set as 6/5 so as to match those; # run normally through OEProp so subject to change; if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 6); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 10); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 6); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 8). returnvalue = procedures['property'][lowername](lowername, **kwargs). except KeyError:; raise",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:44039,energy,energy,44039,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string) – \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string) – \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string) – \(\Rightarrow\) delta4_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:5675,energy,energy,5675,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,14,['energy'],['energy']
Energy Efficiency,"etch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). fnocc2; Test G2 method for H2O. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. freq-isotope; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. props1; RHF STO-3G dipole moment computation, performed by applying",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:26412,energy,energy,26412,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"etci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/proc_py-1.html:6378,energy,energy,6378,psi4manual/1.4.0/proc_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/proc_py-1.html,6,['energy'],['energy']
Energy Efficiency,"etci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/proc_py-1.html:6378,energy,energy,6378,psi4manual/1.5.0/proc_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/proc_py-1.html,6,['energy'],['energy']
Energy Efficiency,"eter('B97_gamma', 0.004); X.set_parameter('B97_a0', 8.42294E-1); X.set_parameter('B97_a1', 7.26479E-1); X.set_parameter('B97_a2', 1.04760E0); X.set_parameter('B97_a3', -5.70635E0); X.set_parameter('B97_a4', 1.32794E1). C = build_functional('B_C'); C.set_name('wB97X_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 1.0); C.set_parameter('B97_os_a1', 2.37031E0); C.set_parameter('B97_os_a2', -1.13995E1); C.set_parameter('B97_os_a3', 6.58405E0); C.set_parameter('B97_os_a4', -3.78132E0). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.0); C.set_parameter('B97_ss_a1', -4.33879E0); C.set_parameter('B97_ss_a2', 1.82308E1); C.set_parameter('B97_ss_a3', -3.17430E1); C.set_parameter('B97_ss_a4', 1.72901E1). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.157706); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb97xd_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB97X-D'); # Tab in, trailing newlines; sup.set_description(' Parameterized Hybrid LRC B97 GGA XC Functional with Dispersion\n'); # Tab in, trailing newlines; sup.set_citation(' J.-D. Chai and M. Head-Gordon, Phys. Chem. Chem. Phys., 10, 6615-6620, 2008\n'). # Add member functionals; alpha = 2.22036E-1; omega = 0.2; X = build_functional('wB97_X'); X.set_name('wB97X_X'); X.set_alpha(1.0 / (1.0 - alpha)). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 7.77964E-1) # Table 1: c_{x\sigma,0}; X.set_parameter('B97_a1', 6.61160E-1) # Table 1: c_{x\sigma,1}; X.set_parameter('B97_a2', 5.74541E-1) # Table 1: c_{x\sigma,2}; X.set_parameter('B97_a3', -5.25671E0) # Table 1: c_{x\sigma,3}; X.set_parameter('",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/functional.html:58620,allocate,allocate,58620,psi4manual/4.0b4/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency,"eter('B97_gamma', 0.004); X.set_parameter('B97_a0', 8.42294E-1); X.set_parameter('B97_a1', 7.26479E-1); X.set_parameter('B97_a2', 1.04760E0); X.set_parameter('B97_a3', -5.70635E0); X.set_parameter('B97_a4', 1.32794E1). C = build_functional('B_C'); C.set_name('wB97X_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 1.0); C.set_parameter('B97_os_a1', 2.37031E0); C.set_parameter('B97_os_a2', -1.13995E1); C.set_parameter('B97_os_a3', 6.58405E0); C.set_parameter('B97_os_a4', -3.78132E0). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.0); C.set_parameter('B97_ss_a1', -4.33879E0); C.set_parameter('B97_ss_a2', 1.82308E1); C.set_parameter('B97_ss_a3', -3.17430E1); C.set_parameter('B97_ss_a4', 1.72901E1). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.157706); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb97xd_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB97X-D'); # Tab in, trailing newlines; sup.set_description(' Parameterized Hybrid LRC B97 GGA XC Functional with Dispersion\n'); # Tab in, trailing newlines; sup.set_citation(' J.-D. Chai and M. Head-Gordon, Phys. Chem. Chem. Phys., 10, 6615-6620, 2008\n'). # Add member functionals; alpha = 2.22036E-1;; omega = 0.2;; X = build_functional('wB97_X'); X.set_name('wB97X_X'); X.set_alpha(1.0 / (1.0 - alpha)). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 7.77964E-1) # Table 1: c_{x\sigma,0}; X.set_parameter('B97_a1', 6.61160E-1) # Table 1: c_{x\sigma,1}; X.set_parameter('B97_a2', 5.74541E-1) # Table 1: c_{x\sigma,2}; X.set_parameter('B97_a3', -5.25671E0) # Table 1: c_{x\sigma,3}; X.set_parameter",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:47288,allocate,allocate,47288,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,4,['allocate'],['allocate']
Energy Efficiency,"eter('B97_gamma', 0.004); X.set_parameter('B97_a0', 8.42294E-1); X.set_parameter('B97_a1', 7.26479E-1); X.set_parameter('B97_a2', 1.04760E0); X.set_parameter('B97_a3', -5.70635E0); X.set_parameter('B97_a4', 1.32794E1). C = build_functional('B_C'); C.set_name('wB97X_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 1.0); C.set_parameter('B97_os_a1', 2.37031E0); C.set_parameter('B97_os_a2', -1.13995E1); C.set_parameter('B97_os_a3', 6.58405E0); C.set_parameter('B97_os_a4', -3.78132E0). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.0); C.set_parameter('B97_ss_a1', -4.33879E0); C.set_parameter('B97_ss_a2', 1.82308E1); C.set_parameter('B97_ss_a3', -3.17430E1); C.set_parameter('B97_ss_a4', 1.72901E1). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.157706); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb97xd_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB97X-D'); # Tab in, trailing newlines; sup.set_description(' Parameterized Hybrid LRC B97 GGA XC Functional with Dispersion\n'); # Tab in, trailing newlines; sup.set_citation(' J.-D. Chai and M. Head-Gordon, Phys. Chem. Chem. Phys., 10, 6615-6620, 2008\n'). # Add member functionals; alpha = 2.22036E-1; omega = 0.2; X = build_functional('wB97_X'); X.set_name('wB97X_X'); X.set_alpha(1.0 / (1.0 - alpha)). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 7.77964E-1) # Table 1: c_{x\sigma,0}; X.set_parameter('B97_a1', 6.61160E-1) # Table 1: c_{x\sigma,1}; X.set_parameter('B97_a2', 5.74541E-1) # Table 1: c_{x\sigma,2}; X.set_parameter('B97_a3', -5.25671E0) # Table 1: c_{x\sigma,3}; X.set_parameter('B9",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:59264,allocate,allocate,59264,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,3,['allocate'],['allocate']
Energy Efficiency,"eters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). If only dispersion corrections (rather than total energies) are of; interest, the dftd3 program can be run independently of the scf; through the python function run_dftd3(). (This function; is the same PSI4/dftd3 interface that is called during an scf job.); This route is much faster than running a DFT-D energy. Some set-up:; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; >>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]. >>> E, G = nene.run_dftd3('b3lyp', 'd2', {'s6': 1.20}); >>> print E; -8.84e-05. >>> E, G = nene.run_dftd3(dashlvl='d3', dashparam={'s8': 2.0, 'alpha6': 14.0, 'sr6': 1.261, 's6': 1.0}); >>> print E; -0.00024762. run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None)[source]¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in ; PATH. Table Of Contents. Interface to DFTD3 by S. Grimme; Installation; Theory; Running DFTD3. Previous topic; Interface to MRCC by M. Kállay; Next topic; Interface to Molden; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dftd3-1.html:6938,energy,energy,6938,psi4manual/4.0b4/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dftd3-1.html,4,['energy'],['energy']
Energy Efficiency,"eters:; scf_scheme (function) – highest_1 || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy. corl_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy. delta_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. delta2_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('conv-mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('conv-mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, del",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cbs-1.html:6203,energy,energy,6203,psi4manual/4.0b3/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"eters:; scf_scheme (function) – highest_1 || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy. corl_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy. delta_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. delta2_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cbs-1.html:6038,energy,energy,6038,psi4manual/4.0b2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"eters; ----------; x_0; Center of the Lorentzian, i.e. its maximum. """"""; return 2.0 / (np.pi * self.gamma(x_0)). [docs]; def prefactor_opa() -> float:; r""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in one-photon absorption. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{4\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1.; """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hbar = constants.get(""Planck constant over 2 pi""); e_0 = constants.get(""electric constant""); au_to_Coulomb_centimeter = constants.get(""elementary charge"") * constants.get(; ""Bohr radius"") * constants.conversion_factor(""m"", ""cm""). numerator = 4.0 * np.pi**2 * N_A; denominator = 3 * 1000 * np.log(10) * (4 * np.pi * e_0) * hbar * c. return (numerator / denominator) * au_to_Coulomb_centimeter**2. [docs]; def prefactor_ecd() -> float:; r""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in electronic circular dichroism. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{16\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c^{2}}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1. """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hb",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html:4955,charge,charge,4955,psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html,6,['charge'],['charge']
Energy Efficiency,"ethod for H2O. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. remp-energy2; integral conventional unrestricted REMP/cc-pVDZ energies for the H2O+ molecule. results were independently verified against the initial wavels implementation. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. fcidump; test FCIDUMP functionality for rhf/uhf. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. dfccsdat2; DF-A-CCSD(T) cc-pVDZ energy for the NH molecule. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. opt15; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Test Suite and Sample Inputs; <no title>. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:48487,energy,energy,48487,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ethod formed by reweighting OMP2 DOUBLES ENERGY; by 1.2 opposite-spin and 0 same-spin contributions, with; any singles carried along. SOS-OMP3 TOTAL ENERGY¶. SOS-OMP3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the OMP3-like method formed by reweighting the difference between; OMP3 DOUBLES ENERGY and OMP2 DOUBLES ENERGY; by 0.25, atop the SOS-OMP2; energy using non-canonical weighting, with any singles carried along. SOS-PI-MP2 TOTAL ENERGY¶. SOS-PI-MP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 1.4 opposite-spin and 0 same-spin contributions, with; any singles carried along. TDDFT ROOT 0 -> ROOT m EXCITATION ENERGY - h SYMMETRY¶. TD-fctl ROOT 0 -> ROOT m EXCITATION ENERGY - h SYMMETRY¶. ADC ROOT 0 -> ROOT m EXCITATION ENERGY - h SYMMETRY¶. EOM-CCSD ROOT 0 -> ROOT m EXCITATION ENERGY - h SYMMETRY¶; The excitation energy of given method from ground state to root m; in h symmetry (if available). DFT functional labeled if canonical. TDDFT ROOT n TOTAL ENERGY - h SYMMETRY¶. TD-fctl ROOT n TOTAL ENERGY - h SYMMETRY¶. ADC ROOT n TOTAL ENERGY - h SYMMETRY¶. EOM-CCSD ROOT n TOTAL ENERGY - h SYMMETRY¶; The total energy of given method from ground state to root m in h symmetry. ADC ROOT 0 -> ROOT m CORRELATION ENERGY - h SYMMETRY¶. EOM-CCSD ROOT 0 -> ROOT m CORRELATION ENERGY - h SYMMETRY¶; The correlation energy of given method from ground state reference energy to root m in h symmetry. TD-fctl ROOT 0 -> ROOT m OSCILLATOR STRENGTH (LEN) - h SYMMETRY¶. TD-fctl ROOT 0 -> ROOT m OSCILLATOR STRENGTH (VEL) - h SYMMETRY¶; The oscillator strength in length or velocity gauge of named method; from ground state to root m in h symmetry (if available). DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT m ROTATORY STRENGTH (LEN) - h SYMMETRY¶. TD-fctl ROOT 0 -> ROOT m ROTATORY STRENGTH (VEL) - h SYMMETRY¶; Th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:47729,energy,energy,47729,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency,"ethod is to be used in diagonalizing the Hamiltonian. The valid options are: RSP, to form the entire H matrix and diagonalize using libciomr to obtain all eigenvalues (n.b. requires HUGE memory); OLSEN, to use Olsen’s preconditioned inverse subspace method (1990); MITRUSHENKOV, to use a 2x2 Olsen/Davidson method; and DAVIDSON (or SEM) to use Liu’s Simultaneous Expansion Method, which is identical to the Davidson method if only one root is to be found. There also exists a SEM debugging mode, SEMTEST. The SEM method is the most robust, but it also requires \(2NM+1\) CI vectors on disk, where \(N\) is the maximum number of iterations and \(M\) is the number of roots. Type: string; Possible Values: RSP, DAVIDSON, SEM; Default: SEM. LSE¶. Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE¶. Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE¶. Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. PRECONDITIONER¶. This specifies the type of preconditioner to use in the selected diagonalization method. The valid options are: DAVIDSON which approximates the Hamiltonian matrix by the diagonal elements; H0BLOCK_INV which uses an exact Hamiltonian of H0_BLOCKSIZE and explicitly inverts it; GEN_DAVIDSON which does a spectral decomposition of H0BLOCK; ITER_INV using an iterative approach to obtain the correction vector of H0BLOCK. The H0BLOCK_INV, GEN_DAVIDSON, and ITER_INV approaches are all formally equivalent but the ITER_INV is less computationally expensive. Default is DAVIDSON. Type: string; Possible Values: LANCZOS, DAVIDSON, GEN_DAVIDSON, H0BLOCK, H0BLOCK_INV, ITER_INV, H0BLOCK_COUPLING, EVANGELISTI; Default: DAVIDSON. UPDATE¶. The update or correction vector formula, either DAVIDSON (default) or OLSEN. Type: string; Possible Values: DAVIDSON, OLSEN; Default: DAVIDSON. Density Matrices¶. DIPMOM¶. Do compute th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__detci-1.html:4825,energy,energy,4825,psi4manual/1.1.0/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__detci-1.html,2,['energy'],['energy']
Energy Efficiency,"ethod is to be used in diagonalizing the Hamiltonian. The valid options are: RSP, to form the entire H matrix and diagonalize using libciomr to obtain all eigenvalues (n.b. requires HUGE memory); OLSEN, to use Olsen’s preconditioned inverse subspace method (1990); MITRUSHENKOV, to use a 2x2 Olsen/Davidson method; and DAVIDSON (or SEM) to use Liu’s Simultaneous Expansion Method, which is identical to the Davidson method if only one root is to be found. There also exists a SEM debugging mode, SEMTEST. The SEM method is the most robust, but it also requires \(2NM+1\) CI vectors on disk, where \(N\) is the maximum number of iterations and \(M\) is the number of roots. Type: string; Possible Values: RSP, DAVIDSON, SEM; Default: SEM. LSE¶. Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE¶. Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE¶. Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. PRECONDITIONER¶. This specifies the type of preconditioner to use in the selected diagonalization method. The valid options are: DAVIDSON which approximates the Hamiltonian matrix by the diagonal elements; H0BLOCK_INV which uses an exact Hamiltonian of H0_BLOCKSIZE and explicitly inverts it; GEN_DAVIDSON which does a spectral decomposition of H0BLOCK; ITER_INV using an iterative approach to obtain the correction vector of H0BLOCK. The H0BLOCK_INV, GEN_DAVIDSON, and ITER_INV approaches are all formally equivalent but the ITER_INV is less computationally expensive. Default is DAVIDSON. Type: string; Possible Values: LANCZOS, DAVIDSON, GEN_DAVIDSON, H0BLOCK, ITER_INV, EVANGELISTI; Default: DAVIDSON. UPDATE¶. The update or correction vector formula, either DAVIDSON (default) or OLSEN. Type: string; Possible Values: DAVIDSON, OLSEN; Default: DAVIDSON. Density Matrices¶. DIPMOM¶. Do compute the dipole moment?. Type: boolean",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html:4827,energy,energy,4827,psi4manual/1.3.2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html,14,['energy'],['energy']
Energy Efficiency,"ethod, [1], [2]. pitzer_to_ci_order_twoel() psi4.core.CIWavefunction method, [1], [2]. PitzerOrder psi4.core.IntegralTransform.MOOrdering attribute, [1]. PK_ALGO (SCF). PK_ALL_NONSYM (SCF). PK_MAX_BUCKETS (SCF). PK_NO_INCORE (SCF). play() psi4.core.MintsHelper method, [1], [2]. plugin() in module psi4.core, [1]. plugin_close() in module psi4.core, [1]. plugin_close_all() in module psi4.core, [1]. plugin_load() in module psi4.core, [1]. PMLocalizer class in psi4.core, [1]. point_group() psi4.core.Molecule method, [1], [2]. point_values() psi4.core.PointFunctions method, [1], [2]. psi4.core.RKSFunctions method, [1]. psi4.core.UKSFunctions method, [1]. PointFunctions class in psi4.core, [1]. PointGroup class in psi4.core, [1]. POINTS (FINDIF). POLE_MAXITER (ADC). pop() psi4.core.BSVec method, [1], [2]. psi4.core.VectorMatrix method, [1], [2]. populateExtern() psi4.driver.QMMM method, [1]. potential_grad() psi4.core.MintsHelper method, [1], [2]. PotentialInt class in psi4.core, [1]. power() psi4.core.Matrix method, [1], [2]. PPL_TYPE (DFOCC). PR (ADC). PRECONDITIONER (DETCI). prepare_options_for_module() in module psi4.core, [1]. prerequisites. presort_so_tei() psi4.core.IntegralTransform method, [1], [2]. PrimitiveType class in psi4.core, [1]. PRINT (CPHF). (EFP). (GLOBALS). (SAPT). print() psi4.core.DFTGrid method, [1]. psi4.core.MolecularGrid method, [1], [2]. psi4.core.PetiteList method, [1], [2]. print_atom_vector() psi4.core.Matrix method, [1], [2]. PRINT_BASIS (SCF). print_bond_angles() psi4.core.Molecule method, [1], [2]. print_cluster() psi4.core.Molecule method, [1], [2]. print_detail() psi4.core.Functional method, [1], [2]. psi4.core.LibXCFunctional method, [1]. psi4.core.SuperFunctional method, [1], [2]. print_detail_out() psi4.core.BasisSet method, [1], [2]. print_distances() psi4.core.Molecule method, [1], [2]. print_dpd_lookup() psi4.core.IntegralTransform method, [1], [2]. print_energies() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:106758,power,power,106758,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['power'],['power']
Energy Efficiency,"ethod, [1], [2]. pitzer_to_ci_order_twoel() psi4.core.CIWavefunction method, [1], [2]. PitzerOrder psi4.core.IntegralTransform.MOOrdering attribute, [1]. PK_ALGO (SCF). PK_ALL_NONSYM (SCF). PK_MAX_BUCKETS (SCF). PK_NO_INCORE (SCF). play() psi4.core.MintsHelper method, [1], [2]. plugin() in module psi4.core, [1]. plugin_close() in module psi4.core, [1]. plugin_close_all() in module psi4.core, [1]. plugin_load() in module psi4.core, [1]. PMLocalizer class in psi4.core, [1]. point_group() psi4.core.Molecule method, [1], [2]. point_values() psi4.core.PointFunctions method, [1], [2]. psi4.core.RKSFunctions method, [1]. psi4.core.UKSFunctions method, [1]. PointFunctions class in psi4.core, [1]. PointGroup class in psi4.core, [1]. POINTS (FINDIF). POLE_MAXITER (ADC). pop() psi4.core.BSVec method, [1], [2]. psi4.core.VectorMatrix method, [1], [2]. populateExtern() psi4.driver.QMMM method, [1]. potential_grad() psi4.core.MintsHelper method, [1], [2]. PotentialInt class in psi4.core, [1]. power() psi4.core.Matrix method, [1], [2]. PPL_TYPE (DFOCC). PR (ADC). PRECONDITIONER (DETCI). prepare_options_for_module() in module psi4.core, [1]. prerequisites. presort_so_tei() psi4.core.IntegralTransform method, [1], [2]. PrimitiveType class in psi4.core, [1]. PRINT (CPHF). (EFP). (GLOBALS). (SAPT). print() psi4.core.DFTGrid method, [1]. psi4.core.MolecularGrid method, [1], [2]. psi4.core.PetiteList method, [1], [2]. print_atom_vector() psi4.core.Matrix method, [1], [2]. PRINT_BASIS (SCF). print_bond_angles() psi4.core.Molecule method, [1], [2]. print_cluster() psi4.core.Molecule method, [1], [2]. print_detail() psi4.core.Functional method, [1], [2]. psi4.core.LibXCFunctional method, [1]. psi4.core.SuperFunctional method, [1], [2]. print_detail_out() psi4.core.BasisSet method, [1], [2]. print_distances() psi4.core.Molecule method, [1], [2]. print_dpd_lookup() psi4.core.IntegralTransform method, [1], [2]. print_energy() psi4.core.Dispersion method, [1], [2]. print_global_options() in mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:91826,power,power,91826,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['power'],['power']
Energy Efficiency,"ethod; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; # beware if geomeTRIC and psi4 choose different sets of constants; molecule.xyzs = [p4_mol.geometry().np * constants.bohr2angstroms]; molecule.build_bonds(); ; super(Psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html:53953,ENERGY,ENERGY,53953,psi4manual/1.9.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"ethod; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i).capitalize() for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:53386,ENERGY,ENERGY,53386,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ethod; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i) for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname):; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:46853,ENERGY,ENERGY,46853,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ethod; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic property. # Commit to procedures['properties'] call hereafter; core.clean_variables(). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((""prop"", ""prop""), lowername, return_optstash=True). logger.info(f""Compute properties(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures[""properties""][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return properties(): {core.variable('CURRENT ENERGY')}""). basisstash.restore(); optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize_geometric(name, **kwargs):. import qcelemental as qcel; from qcelemental.util import which_import. if not which_import('geometric', return_bool=True):; raise ModuleNotFoundError('Python module geometric not found. Solve by installing it: `conda install -c conda-forge geometric` or `pip install geometric`'); import geometric. class Psi4NativeEngine(geometric.engine.Engine):; """"""; Internally run an energy and gradient calculation for geometric ; """"""; def __init__(self, p4_name, p4_mol, p4_return_wfn, **p4_kwargs):; ; self.p4_name = p4_name; self.p4_mol = p4_mol; self.p4_return_wfn = p4_return_wfn; self.p4_kwargs = p4_kwargs; ; molecule = geometric.molecule.Molecule(); molecule.elem = [p4_mol.symbol(i) for i in range(p4_mol.natom())]; molecule.xyzs = [p4_mol.geometry().np * qcel.constants.bohr2angstroms] ; molecule.build_bonds(); ; super(Psi4NativeEngine, self).__init__(molecule); ; def calc(self, coords, dirname, re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:53378,ENERGY,ENERGY,53378,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ethod; scf_Dc - D convergence criterion for scf target method; pscf_Dc - D convergence criterion for scf of post-scf target method; gen_Ec - E convergence criterion for post-scf target method. """"""; optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Kind of want to move this out of here; _method_exists(ptype, method_name). if verbose >= 2:; print(' Setting convergence', end=' '); # Set method-dependent scf convergence criteria, check against energy routines; if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'E_CONVERGENCE', scf_Ec); if verbose >= 2:; print(scf_Ec, end=' '); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', pscf_Ec); if verbose >= 2:; print(pscf_Ec, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'E_CONVERGENCE'), end=' '). if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'D_CONVERGENCE', scf_Dc); if verbose >= 2:; print(scf_Dc, end=' '); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', pscf_Dc); if verbose >= 2:; print(pscf_Dc, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'D_CONVERGENCE'), end=' '). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if procedures['energy'][method_name] not in [proc.run_scf, proc.run_dft]:; psi4.set_global_option('E_CONVERGENCE', gen_Ec); if verbose >= 2:; print(gen_Ec, end=' '); else:; if procedures['energy'][method_name] not in [proc.run_scf, proc.run_dft]:; if verbose >= 2:; print('CUSTOM', psi4.get_global_option('E_CONVERGENCE'), end=' '). if verbose >= 2:; print(''); return optstash. [docs]def parse_arbitrary_order(name):; r""""""Function to parse name string into a method family like CI or MRCC and spec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:3462,energy,energy,3462,psi4manual/1.0.0/_modules/driver_util.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html,1,['energy'],['energy']
Energy Efficiency,"ethods in the limit of zero non-idempotency of . This option has a limited; functionality and should only be used for test purposes. For the production-level CEPA0 code, see the; description of the OCC section of the manual. The DCFT code can also be used to; compute the energy correction that perturbatively accounts; for three-particle correlation effects, similarly to the (T) correction in coupled; cluster theory. Computation of the correction can be; requested by setting the THREE_PARTICLE option to PERTURBATIVE. A; combination of the ODC-13 functional with the correction; [denoted as ] has been shown to provide highly; accurate results for open-shell molecules near equilibrium geometries.; At the present moment, all of the DCFT methods support unrestricted reference; orbitals (REFERENCE = UHF), which can be used to perform energy and; gradient computations for both closed- and open-shell molecules. In addition,; the ODC-06 and ODC-12 methods support restricted reference orbitals; (REFERENCE = RHF) for the energy and gradient computations of; closed-shell molecules. Note that in this case restricted reference orbitals; are only available for ALGORITHM = SIMULTANEOUS. Iterative Algorithms¶; As explained in the Theory section, in order to obtain the DCFT energy one; needs to solve a system of coupled equations for orbitals and density; cumulant. At the present moment three iterative algorithms for the solution of the; equations are available. The choice of the algorithm is controlled using the; ALGORITHM option.; 1) Simultaneous algorithm (ALGORITHM = SIMULTANEOUS, currently the default).; In this algorithm the DCFT equations are solved in macroiterations.; Each macroiteration consists of a single iteration of the cumulant update; followed by a single iteration of the orbital update and orbital transformation; of the integrals. The macroiterations are repeated until the simultaneous; convergence of the cumulant and orbitals is achieved.; Convergence of the simultan",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:6996,energy,energy,6996,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['energy'],['energy']
Energy Efficiency,"etical list over i, j, …, k enumerates; molecular fragments included in the computation in 1-indexed,; input-file order, while the second enumerates list over a, b,; …, c enumerates which fragments contribute basis functions to the; computation. For example, (1, 2)@(1, 2, 3, 4) indicates that the; fragments 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included in; the basis set. Therefore, the basis functions from fragments 3 and 4; are included as ghost functions within the energy computation. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶; The total electronic interaction ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html:17327,energy,energy,17327,psi4manual/1.2.1/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency,"etric modes.; ``-1`` indicates a full frequency calculation. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] <example description>; >>> <example python command>. >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> frequencies('scf', dertype=1, irrep=4). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 2. optstash = OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['hessian']:; dertype = 2; elif lowername in procedures['gradient']:; dertype = 1; func = gradient; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; freq_dertype = kwargs['dertype']. if der0th.match(str(freq_dertype)):; dertype = 0; func = energy; elif der1st.match(str(freq_dertype)):; dertype = 1; func = gradient; elif der2nd.match(str(freq_dertype)):; dertype = 2; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function frequency.' % (freq_dertype)). # 3. if the user provides a custom function THAT takes precedence; if ('freq_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['freq_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['freq_func']. # Summary validation; if (dertype == 2) and (lowername in procedures['hessian']):; pass; elif (dertype == 1) and (func is gradient) and (lowername in procedures['gradient']):; pass; elif (dertype == 1) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:60095,energy,energy,60095,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,4,['energy'],['energy']
Energy Efficiency,"etrically displaced ozone, with Z-matrix input. extern4; External potential calculation involving a TIP3P water and a QM water. Gradient on the external charges is compared to gradient on the QM atoms to validate the gradient on the charges. tdscf-7; TD-HF test variable access. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). mom-h2o-3; MOM excitation from LUMO HOMO+3. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. fsapt-ext-abc; FSAPT with external charge on trimer. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. mp2-h; check that methods can act on single atom. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. mp2-1; All-electron MP2 6-31G** geometry optimization of water. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:18052,charge,charge,18052,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['charge'],['charge']
Energy Efficiency,"etries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.compute_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_parent_symmetry(''); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:68800,energy,energy,68800,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"etries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/opt-1.html:2730,energy,energy,2730,psi4manual/1.2.1/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/opt-1.html,6,['energy'],['energy']
Energy Efficiency,"etry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. cubeprop; RHF orbitals and density for water. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. dcft1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. dfcasscf-sp; CASSCF/6-31G** energy point. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:17276,energy,energy,17276,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ets *. Type: array; Default: No Default. COLLAPSE_SIZE (DETCI); DETCI — Gives the number of vectors to retain when the Davidson subspace is collapsed (see MAX_NUM_VECS). If greater than one, the collapsed subspace retains the best estimate of the CI vector for the previous n iterations. Defaults to 1. Type: integer; Default: 1. COLLAPSE_WITH_LAST (CCEOM); CCEOM — Do collapse with last vector?. Type: boolean; Default: true. COMPLEX_TOLERANCE (CCEOM); CCEOM — Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. CONSECUTIVE_BACKSTEPS (OPTKING); OPTKING — Set number of consecutive backward steps allowed in optimization. Type: integer; Default: 0. CORR_ANSATZ (PSIMRCC); PSIMRCC — The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T (PSIMRCC); PSIMRCC — The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE (PSIMRCC); PSIMRCC — The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP (PSIMRCC); PSIMRCC — The multiplicity, , of the target state. Must be specified if different from the reference . Type: integer; Default: 1. CORR_WFN (PSIMRCC); PSIMRCC — The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COUPLING (PSIMRCC); PSIMRCC — The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS (PSIMRCC); PSIMRCC — Do include the terms that couple the reference determinants?. Type: boolean; Default: true. COVALENT_CONNECT (OPTKING); OPTKING — When determining connectivity, a bond is assigned if interatomic distance is less than (this number) * sum of covalent radii. Type: double; Default: 1.3. CPHF_MEM_SAFETY_FACTOR (CPHF); CPHF — Memory safety factor for allocating JK. Type: double; Default: 0.75. CPHF_TASKS (CPHF); CPHF — Which tasks to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:18533,charge,charge,18533,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['charge'],['charge']
Energy Efficiency,"ets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cbs-xtpl-energy-conv; Extrapolated water energies - conventional integrals version. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega= (589 355 nm). nbo; Generation of NBO file. cc54; CCSD dipole with user-specified basis set. scf-guess-read3; Test if the the guess read in the same basis converges. scf-upcast-custom-basis; test scf castup with custom basis sets. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. fci-dipole; 6-31G H2O Test FCI Energy Point. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). fnocc5; Test FNO-DF-CCSD(T) energy. opt4; SCF cc-pVTZ geometry optimzatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:22513,energy,energy-conv,22513,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy-conv']
Energy Efficiency,"ets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'highest_1'``, which uses the best basis; set available. See `Extrapolation Schemes`_ for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:56616,energy,energy,56616,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,6,['energy'],['energy']
Energy Efficiency,"ets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]]=[0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, dipole_field: List[float[3]]=[0.0, 0.0, 0.0]) → psi4.core.Matrix¶; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule) → psi4.core.PointGroup¶; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule) → None¶; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule) → None¶; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule) → None¶; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self: psi4.core.Molecule) → None¶; Prints the m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:25416,energy,energy,25416,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,3,['energy'],['energy']
Energy Efficiency,"ets of the requested database, either; 'small', a few of the smallest database members,; 'large', the largest of the database members, or; 'equilibrium', the equilibrium geometries for a database; composed of dissociation curves. 'BzBz_S' || 'FaOOFaON' || 'ArNe' || 'HB' || etc.; For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive). [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. Examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/db-1.html:5520,energy,energy,5520,psi4manual/1.3.2/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/db-1.html,4,['energy'],['energy']
Energy Efficiency,"ets the specified list arg2 of fragments to be Real. set_basis_all_atoms(self: psi4.core.Molecule, arg0: str, arg1: str) → None¶; Sets basis set arg2 to all atoms. set_basis_by_label(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str) → None¶; Sets basis set arg3 to all atoms with label (e.g., H4) arg2. set_basis_by_symbol(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str) → None¶; Sets basis set arg3 to all atoms with symbol (e.g., H) arg2. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix) → None¶; Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self: psi4.core.Molecule, arg0: int) → None¶; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: list) → None¶; Sets the specified list arg2 of fragments to be Ghost. set_mass(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Gets mass of atom arg1. set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None¶; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg2. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str¶; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg1. units¶; Units (Angstrom or Bohr) used to define the geometry. u",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:88769,charge,charge,88769,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['charge'],['charge']
Energy Efficiency,"ets the specified list arg2 of fragments to be Real. set_basis_all_atoms(self: psi4.core.Molecule, arg0: str, arg1: str) → None¶; Sets basis set arg2 to all atoms. set_basis_by_label(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str) → None¶; Sets basis set arg3 to all atoms with label (e.g., H4) arg2. set_basis_by_symbol(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str) → None¶; Sets basis set arg3 to all atoms with symbol (e.g., H) arg2. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix) → None¶; Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self: psi4.core.Molecule, arg0: int) → None¶; Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: list) → None¶; Sets the specified list arg2 of fragments to be Ghost. set_mass(self: psi4.core.Molecule, arg0: int, arg1: float) → None¶; Gets mass of atom arg1. set_molecular_charge(self: psi4.core.Molecule, arg0: int) → None¶; Sets the molecular charge. set_multiplicity(self: psi4.core.Molecule, arg0: int) → None¶; Sets the multiplicity (defined as 2Ms + 1). set_name(self: psi4.core.Molecule, arg0: str) → None¶; Sets molecule name. set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup) → None¶; Sets the molecular point group to the point group object arg2. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None¶; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str¶; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg1. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:18987,charge,charge,18987,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"ets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). 1; 2>>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). 1; 2; 3>>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). 1; 2>>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). 1; 2>>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). 1; 2>>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:11265,energy,energy,11265,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,14,['energy'],['energy']
Energy Efficiency,"etter potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp2] and [Bozkaya:2011:omp3]. Methods¶; The orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. omp2; Orbital-Optimized MP2; Y; Y; RHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp2; A special version of SCS-OMP2 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp2; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/ompn-1.html:3878,energy,energy,3878,psi4manual/4.0b3/ompn-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html,2,['energy'],['energy']
Energy Efficiency,"eturn f"""""" Computing gradient from energies.; Using {findifrec[""stencil_size""]}-point formula.; Energy without displacement: {findifrec[""reference""][""energy""]:15.10f}; Check energies below for precision!; Forces are for mass-weighted, symmetry-adapted cartesians [a0].\n"""""". data = _initialize_findif(mol, -1, ""1_0"", findifrec['stencil_size'], findifrec['step']['size'], init_string,; findifrec['project_translations'], findifrec['project_rotations'], False); salc_indices = data[""salc_indices_pi""][0]. # Extract the energies, and turn then into an ndarray for easy manipulating; # E(i, j) := Energy on displacing the ith SALC we care about in the jth step; # Steps are ordered, for example, -2, -1, 1, 2; max_disp = (findifrec[""stencil_size""] - 1) // 2 # The numerator had better be divisible by two.; e_per_salc = 2 * max_disp; E = np.zeros((len(salc_indices), e_per_salc)). for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = findifrec[""displacements""][f""{salc_index}: {-j}""][""energy""]; E[i, max_disp + j - 1] = findifrec[""displacements""][f""{salc_index}: {j}""][""energy""]. # Perform the finite difference.; if findifrec[""stencil_size""] == 3:; g_q = (E[:, 1] - E[:, 0]) / (2.0 * findifrec[""step""][""size""]); elif findifrec[""stencil_size""] == 5:; g_q = (E[:, 0] - 8.0 * E[:, 1] + 8.0 * E[:, 2] - E[:, 3]) / (12.0 * findifrec[""step""][""size""]); else: # This error SHOULD have already been caught, but just in case...; raise ValidationError(""FINDIF: {} is an invalid number of points."".format(findifrec[""stencil_size""])); g_q = np.asarray(g_q). if data[""print_lvl""]:; energy_string = """"; for i in range(1, max_disp + 1):; energy_string = f""Energy(-{i}) "" + energy_string + f""Energy(+{i}) ""; info = ""\n Coord "" + energy_string + "" Force""; for salc in range(data[""n_salc""]):; print_str = ""\n {:5d}"" + "" {:17.10f}"" * (e_per_salc) + "" {force:17.10f}""; energies = E[salc]; info += print_str.format(salc, force=g_q[salc], *energies); core.print_out(info); logg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:21553,energy,energy,21553,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,16,['energy'],['energy']
Energy Efficiency,"eturn statement. else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print(info). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 10); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 11); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 10); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 11). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 10). # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed.' % ndisp); energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=''); sys.stdout.flush(). # Load in displacement into the active molecule; molecule.set_geometry(displacement). # Perform the energy calculation; E = func(lowername, **kwarg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:65685,energy,energy,65685,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,4,['energy'],['energy']
Energy Efficiency,"eturn valueHI. elif isinstance(valueHI, np.ndarray):. if verbose > 2:; cbsscheme = f""""""\n ==> {functionname.upper()} <==\n\n""""""; cbsscheme += f"""""" HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI); core.print_out(cbsscheme); logger.debug(cbsscheme). return valueHI. [docs]def scf_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using exponential form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Fitted 2-point parameter. Overrides the default :math:`\alpha = 1.63`. Returns; -------; float or ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [1]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63`. References; ----------. .. [1] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DT]Z', scf_scheme='scf_xtpl_helgaker_2'). """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_helgaker_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 1.63. beta_division = 1 / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:3846,Energy,Energy,3846,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Energy'],['Energy']
Energy Efficiency,"eturning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int) → None¶; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int¶; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int) → float¶; Gets charge of atom arg1 (0-indexed). clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg0. create_molecule_from_string(arg0: str) → psi4.core.Molecule¶; Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(self: psi4.core.Molecule) → str¶; Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs)¶; Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: int) -> psi4.core.Molecule. Returns ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:78968,charge,charge,78968,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,3,['charge'],['charge']
Energy Efficiency,"eturns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Beta orbital energies subset. Parameters. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbital energies should be returned?. Returns; A Pitzer-ordered vector of the orbitals. Return type; Vector. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. external_pot(self: psi4.core.Wavefunction) → psi4.core.ExternalPotential¶; Gets the requested external potential. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s temporary data. finalize_energy()¶; Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF) → None¶; docstring. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_C(self: psi4.core.HF, shift: float = 0.0) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → No",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:22072,energy,energy,22072,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,20,['energy'],['energy']
Energy Efficiency,"eturns the degenercy of the irrep. group(*args, **kwargs)¶; Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. Returns higher order point group. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. Returns the higher order point group. n(self: psi4.core.CorrelationTable) → int¶; Returns the number of irreps in high order group. ngamma(self: psi4.core.CorrelationTable, arg0: int) → int¶; Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self: psi4.core.CorrelationTable, arg0: int) → int¶; Returns the degeneracy of the subgroup irrep. subgroup(self: psi4.core.CorrelationTable) → psi4.core.PointGroup¶; Returns lower order pointgroup. subn(self: psi4.core.CorrelationTable) → int¶; Returns number of irreps in subgroup. degen(self: psi4.core.CorrelationTable, arg0: int) → int; Returns the degenercy of the irrep. group(*args, **kwargs); Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. Returns higher order point group. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. Returns the higher order point group. n(self: psi4.core.CorrelationTable) → int; Returns the number of irreps in high order group. ngamma(self: psi4.core.CorrelationTable, arg0: int) → int; Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self: psi4.core.CorrelationTable, arg0: int) → int; Returns the degeneracy of the subgroup irrep. subgroup(self: psi4.core.CorrelationTable) → psi4.core.PointGroup; Returns lower order pointgroup. subn(self: psi4.core.CorrelationTable) → int; Returns number of irreps in subgroup. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.correlationtable.html:2275,reduce,reduced,2275,psi4manual/1.3.2/api/psi4.core.correlationtable.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.correlationtable.html,1,['reduce'],['reduced']
Energy Efficiency,"eturns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. potential_variable(self, key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self, arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key, val). Deprecated since version 1.4. set_array_variable(self, arg0, arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self, arg0, arg1); Sets the requested auxiliary basis. set_energy(self, arg0); Sets the Wavefunction’s energy. set_external_potential(self, arg0); Sets the requested external potential. set_frequencies(val). Deprecated since version 1.4. set_gradient(self, arg0); Sets the Wavefunction’s gradient. set_hessian(self, arg0); Sets the Wavefunction’s Hessian. set_lagrangian(self, arg0); Sets the orbital Lagrangian matrix. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:6608,energy,energy,6608,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,4,['energy'],['energy']
Energy Efficiency,"eturns the requested Beta orbital energies subset. Parameters. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbital energies should be returned?. Returns; A Pitzer-ordered vector of the orbitals. Return type; Vector. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. external_pot(self: psi4.core.Wavefunction) → psi4.core.ExternalPotential¶; Gets the requested external potential. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s temporary data. finalize_energy()¶; Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF) → None¶; docstring. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_C(self: psi4.core.HF, shift: float = 0.0) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_FDSmSDF(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → psi4.core.Matrix",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:22140,energy,energy,22140,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,20,['energy'],['energy']
Energy Efficiency,"etween iterations. If the occupations are known a priori,; they may be clamped throughout the procedure by using the DOCC and; SOCC options. For instance, all good quantum chemists know that; \(C_{2v}\) water is; actually,:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; docc [3, 0, 1, 1] # 1A1 2A1 1B1 3A1 1B2; basis cc-pvdz; }. energy('scf'). Broken Symmetry¶; For certain problems, such diradicals, allowing the spin-up and spin-down; orbitals to differ in closed-shell computations can be advantageous;; this is known as symmetry breaking. The resulting unrestricted wavefunction; will often provide superior energetics, due to the increased flexibility,; but it will suffer non-physical spin contamination from higher multiplicity states.; A convenient approach to break symmetry is to perform a UHF or UKS calculation; with the guess HOMO and LUMO orbitals mixed.; Mixing of the guess orbitals can be requested by setting the GUESS_MIX; keyword to true:; 1; 2; 3set reference uhf; set guess_mix true; energy('scf'). Orthogonalization¶; One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital basis (known; as the AO basis). The Molecular Orbital basis (MO basis) is then built as a; particular unitary transformation of the OSO basis. In PSI4, the; determination of the OSO basis is accomplished via either symmetric or canonical; orthogonalization. Symmetric orthogonalization uses the symmetric inverse square; root of the overlap matrix for the orthogonalization matrix. Use of symmetric; orthogonalization always yields the same number of OSO functions (and thereby; MOs) as AO functions. However, this may lead to numerical problems if the; overlap matrix has small eigenvalues, which may occur for large systems or for; systems where diffuse basis sets are used. This problem may be avoided by using; canonical orthogonalization, in which an asymmetri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:11506,energy,energy,11506,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['energy'],['energy']
Energy Efficiency,"ety factor for allocating JK. Type: double; Default: 0.75. TDM (DETCI); DETCI — Do compute the transition density? Note: only transition densities between roots of the same symmetry will be evaluated. DETCI does not compute states of different irreps within the same computation; to do this, lower the symmetry of the computation. Type: boolean; Default: false. TDM_PRINT (DETCI); DETCI — Do print the transition density?. Type: boolean; Default: false. TDM_WRITE (DETCI); DETCI — Do write the transition density?. Type: boolean; Default: false. TEST_B (OPTKING); OPTKING — Do test B matrix?. Type: boolean; Default: false. TEST_DERIVATIVE_B (OPTKING); OPTKING — Do test derivative B matrix?. Type: boolean; Default: false. THETA_POINTS (SCF); SCF — Number of colatitude grid points for sphereical potential integration. Type: integer; Default: 360. THICKNESS (SCF); SCF — Thickness (bohr) of a hard-sphere external potential. Type: double; Default: 20.0. THREE_PARTICLE (DCFT); DCFT — Whether to compute three-particle energy correction or not. Type: string; Possible Values: NONE, PERTURBATIVE; Default: NONE. TIKHONOW_MAX (PSIMRCC); PSIMRCC — The cycle after which Tikhonow regularization is stopped. Set to zero to allow regularization in all iterations. Type: integer; Default: 5. TIKHONOW_OMEGA (DCFT); DCFT (Expert) — The shift applied to the denominator in the density cumulant update iterations. Type: double; Default: 0.0. TIKHONOW_OMEGA (PSIMRCC); PSIMRCC — The shift to apply to the denominators, {it c.f.} Taube and Bartlett, JCP, 130, 144112 (2009). Type: double; Default: 0.0. TIKHONOW_TRIPLES (PSIMRCC); PSIMRCC (Expert) — Do use Tikhonow regularization in (T) computations?. Type: boolean; Default: false. TILE_SZ (SCF); SCF (Expert) — The tile size for the distributed matrices. Type: integer; Default: 512. TPDM (DETCI); DETCI (Expert) — Do compute two-particle density matrix if not otherwise required? Warning: This will hold 4 dense active TPDM’s in memory. Type: boolean; Defau",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:213295,energy,energy,213295,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"ety of quantum chemical methods using; state-of-the-art numerical methods and algorithms. Several parts of; the code feature shared-memory parallelization to run efficiently on; multi-core machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:1150,efficient,efficient,1150,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,15,['efficient'],['efficient']
Energy Efficiency,"et¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:218309,energy,energy,218309,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,3,['energy'],['energy']
Energy Efficiency,"evel of theory and root. CCD TOTAL ENERGY¶. CCD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the coupled-cluster doubles level of theory. CCSD PAIR ENERGIES¶; The restricted-reference pair energies for coupled-cluster singles and doubles; level of theory. Size number of active doubly occupied orbitals, square. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSD(AT) TOTAL ENERGY¶. CCSD(AT) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the perturbatively corrected coupled-cluster (CCSD(T), CCSD(AT), CCSDT(Q),; up to CC(n-1)(n) level of theory. CCSDT-1a TOTAL ENERGY¶. CCSDT-1a CORRELATION ENERGY¶. CCSDTQ-1a TOTAL ENERGY¶. CCSDTQ-1a CORRELATION ENERGY¶. CCn-1a TOTAL ENERGY¶. CCn-1a CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the appr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:6612,energy,energy,6612,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency,"evel of theory. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc33; CC3(UHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). casscf-sp; CASSCF/6-31G** energy point. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. pywrap-cbs1; Various basis set extrapolation tests. dcft-grad3; Restricted DF-DCFT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. psimrcc-fd-freq2; Mk-MRCCSD frequencies. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. mp2-1; All-electron MP2 6-31G** geometry optimization of water. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt11; Transition-state optimizations of HOOH to both torsional transition states. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. scf-bs; UHF and broken-symmetry UHF energy for molecular hydrogen. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. dft-b2plyp; Doub",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:26736,energy,energy,26736,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"evel shift on a CUHF computation. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. rasci-h2o; RASCI/6-31G** H2O Energy Point. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. dct-grad4; Unrestricted DF-DCT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. mbis-3; MBIS calculation on OH radical. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. fnocc4; Test FNO-DF-CCSD(T) energy. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. dft-omega; Test omega is ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:44543,energy,energy,44543,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"eveloped by; Justin M. Turney, with incremental improvements by other; psi4 developers. class CartesianEntry(entry_number, Z, charge, mass, symbol, label, x, y, z)[source]¶; Class to hold all information about an atom, including its; coordinate specification as three Cartesians. clone()[source]¶; Returns new, independent CartesianEntry object. compute()[source]¶; Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. everything()[source]¶. invalidate()[source]¶; Flags the current coordinates as being outdated. print_in_input_format()[source]¶; Prints the updated geometry, in the format provided by the user. set_coordinates(x, y, z)[source]¶; Given the current set of coordinates, updates the values of this; atom’s coordinates and any variables that may depend on it. type()[source]¶; The type of CoordEntry specialization. class CoordEntry(entry_number, Z, charge, mass, symbol, label='')[source]¶; Class to. Z()[source]¶; The nuclear charge of the current atom (0 if ghosted). static a(a1, a2, a3)[source]¶; Computes the angle (in rad.) between three sets of coordinates. charge()[source]¶; The “atomic charge” of the current atom (for SAD purposes). static d(a1, a2, a3, a4)[source]¶; Computes the dihedral (in rad.) between four sets of coordinates. entry_number()[source]¶; The order in which this appears in the full atom list. everything()[source]¶. is_computed()[source]¶; Whether the current atom’s coordinates are up-to-date. is_equivalent_to(other)[source]¶; Whether this atom has the same mass and ghost status as atom other.; Unlike the libmints version, this does not compare basisset assignment. is_ghosted()[source]¶; Whether the current atom is ghosted or not. label()[source]¶; The atom label. mass()[source]¶; The atomic mass of the current atom. static r(a1, a2)[source]¶; Computes the distance between two sets of coordinates. set_ghosted(gh)[source]¶; Flag the atom as either ghost or real. symbol()[source]¶; The atomic s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:35879,charge,charge,35879,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,6,['charge'],['charge']
Energy Efficiency,"every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:33383,energy,energy,33383,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,20,['energy'],['energy']
Energy Efficiency,"every later one is ```corl```.; * ```stage```: tag for the stage used in tables. | The next items in the ```cbs_metadata``` array extrapolate correlation. All of the above parameters are available, with only the ```wfn``` and ```basis``` keywords required. Other supported parameters are:. * ```wfn_lo```: the lower method from which the delta correction is to be calculated. By default, it is set to ```wfn``` from the previous field in the ```cbs_metadata``` array.; * ```basis_lo```: basis set to be used for the delta correction. By default, it is the same as the ```basis``` specified above. * Others. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:45592,energy,energy,45592,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,8,['energy'],['energy']
Energy Efficiency,"evious orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. This becomes the; default for the second and later iterations of geometry optimizations. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; BASIS_GUESS = SMALL_BASIS to the options list. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). Convergence Stabilization¶; With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via options.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbita",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:18010,energy,energy,18010,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['energy'],['energy']
Energy Efficiency,"ew features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; He; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('scf'). Table Of Contents. HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. Previous topic; Notes on Options; Next topic; DFT: Density Functional Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/scf-1.html:21658,energy,energy,21658,psi4manual/4.0b3/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/scf-1.html,2,['energy'],['energy']
Energy Efficiency,"eweighting the difference between; OMP3 DOUBLES ENERGY and OMP2 DOUBLES ENERGY; by 0.25, atop the SCS-OMP2 energy, with any singles carried along. SOS-MP2 TOTAL ENERGY¶. SOS-MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 1.3 opposite-spin and 0 same-spin contributions, with; any singles carried along. SOS-OMP2 TOTAL ENERGY¶. SOS-OMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP2-like method formed by reweighting OMP2 DOUBLES ENERGY; by 1.2 opposite-spin and 0 same-spin contributions, with; any singles carried along. SOS-OMP3 TOTAL ENERGY¶. SOS-OMP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the OMP3-like method formed by reweighting the difference between; OMP3 DOUBLES ENERGY and OMP2 DOUBLES ENERGY; by 0.25, atop the SOS-OMP2; energy using non-canonical weighting, with any singles carried along. SOS-PI-MP2 TOTAL ENERGY¶. SOS-PI-MP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by reweighting MP2 DOUBLES ENERGY; by 1.4 opposite-spin and 0 same-spin contributions, with; any singles carried along. TD-fctl ROOT 0 -> ROOT n ELECTRIC TRANSITION DIPOLE MOMENT (VEL)¶; The electric transition dipole moment [e a0] in velocity gauge, for the transition; from the ground state to root m.; DFT functional labeled if canonical. TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) ELECTRIC TRANSITION DIPOLE MOMENT (VEL)¶; The electric transition dipole moment [e a0] in velocity gauge, for the transition; from the ground state, which is of irrep h, to root n within irrep i.; DFT functional labeled if canonical. TD-fctl ROOT 0 (h) -> ROOT n (i) ELECTRIC TRANSITION DIPOLE MOMENT (VEL)¶; The electric transition dipole moment [e a0] in velocity gauge, for the transition; from the ground ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:57403,energy,energy,57403,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"ex. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Interfaces: Enhancing Psi4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; Psi4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by Psi4, ensure that the program binary (dmrcc) can be; found in your PATH. If Psi4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in Psi4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs Psi4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, Psi4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Note that perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are not available with REFERENCE ROHF. name; calls method in Kallay’s MRCC program [manual]. mrccsd; CC through doubles. mrccsdt; CC through triples. mrccsdtq; CC through quadruples. mrccsdtqp; CC through quintuples. mrccsdtqph; CC through sextuples. mrccsd(t); CC through doubl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/mrcc-1.html:1085,energy,energy,1085,psi4manual/1.0.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/mrcc-1.html,2,['energy'],['energy']
Energy Efficiency,"ex. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential¶. class psi4.core.ExternalPotential¶; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self, basis, coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). appendCharges(self, arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: list[tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html:1064,charge,charges,1064,psi4manual/master/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html,2,['charge'],['charges']
Energy Efficiency,"ex. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Theoretical Methods: SCF to FCI; Vibrational and Thermochemical Analysis. Vibrational and Thermochemical Analysis¶; Code author: Rollin A. King and Lori A. Burns; Section author: Lori A. Burns; Module: Keywords, PSI Variables, THERMO. Caution; It is important to know that PSI4, like any other; quantum chemistry program, does not compute the usual enthalpies,; entropies, or Gibbs free energies of formation provided by most; reference books. Instead, quantum chemistry programs compute “absolute”; thermodynamic properties relative to infinitely separated nuclei and; electrons, not “formation” values relative to elements in their standard; states. If you are computing thermodynamic differences, like a reaction; enthalpy computed as the enthalpy of the products minus the enthalpy; of the reactants, then these “absolute” enthalpies are perfectly valid; and usable. However, they cannot be mixed and matched with enthalpies of; formation from reference books, since the zero of energy is not the same.; Additionally, the “thermal energies” reported in kcal/mol are the; finite-temperature corrections to the electronic total energy, and; not the overall thermal energies themselves. If in doubt, use the; reported Total Energies in Hartree/particle. Keywords¶. T¶. Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. P¶. Pressure in Pascal for thermodynamic analysis. Note that 100000. is the value for IUPAC STP. Type: double; Default: 101325. ROTATIONAL_SYMMETRY_NUMBER¶. Rotational symmetry number for thermodynamic analysis. Default is set from the full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this option is the sole way to influence the symmetry-d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/thermo.html:1104,energy,energy,1104,psi4manual/master/thermo.html,https://psicode.org,https://psicode.org/psi4manual/master/thermo.html,1,['energy'],['energy']
Energy Efficiency,"example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:12049,energy,energy,12049,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,7,['energy'],['energy']
Energy Efficiency,"except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_geometry(). # Flag to stop listening for MDI commands; self.stop_listening = False. # Dictionary of all supported MDI commands; self.commands = {; ""<NATOMS"": self.send_natoms,; ""<COORDS"": self.send_coords,; ""<CHARGES"": self.send_charges,; ""<ELEMENTS"": self.send_elements,; ""<MAS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html:2524,charge,chargefield,2524,psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,2,['charge'],['chargefield']
Energy Efficiency,"excited state of H2O+ (B1 excitation). opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For the “frozen” bonds, angles and dihedrals, these coordinates are constrained to remain at their initial values. For “fixed” bonds, angles, or dihedrals, the equilibrium (final) value of the coordinate is provided by the user. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. omp2_5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mrcc3; CCSD(T) cc-pVDZ geometry optimization for the H2O molecule using MRCC. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. omp2_5-2; OMP2 cc-pVDZ energy for the H2O molecule. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cc51; EOM-CC3/cc-pVTZ on H2O. fci-h2o-2; 6-31G H2O Test FCI Energy Point. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc33; CC3(UHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). dft-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. tu6-cp-ne2; Example potential energy surf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:16792,energy,energy,16792,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"excited states per irrep. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. dft2; DFT Functional Test. scf6; Tests RHF/ROHF/UHF SCF gradients. scf-guess-read3; Test if the the guess read in the same basis converges. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. tdscf-1; td-uhf test on triplet states of methylene (rpa). mbis-4; MBIS calculation on NaCl. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. mom-h2o-4; MOM excitation from LUMO HOMO+4. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. matrix2; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. cdremp-2; Cholesky decomposed REMP/cc-pVDZ energies for the CH3 radical. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. opt16; SCF 6-31G(d) optimization of TS for HCN to HNC Performs finite difference hessian calculation. Then optimizes using previous orbitals for scf guess, in subsequent calculations. The last two displacements of the hessian break the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:15440,energy,energy,15440,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; core.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; core.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); core.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); core.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:23960,energy,energy,23960,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,1,['energy'],['energy']
Energy Efficiency,"exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; core.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; core.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); core.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); core.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; if not allowoptexceeded:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For ea",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:23867,energy,energy,23867,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,2,['energy'],['energy']
Energy Efficiency,"exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); psi4.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:46965,energy,energy,46965,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); psi4.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); for i in range(len(ACTV[db_rxn])):; if abs(ERGT[ACTV[db_rxn][i]]) < 1.0e-12:; FAIL[rxn] = 1. # tabulate requested process::environment variables; tables += """""" For each VARIABLE requested by t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:23834,energy,energy,23834,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['energy'],['energy']
Energy Efficiency,"executable must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; optimize('pbeh3c'). HF-3c with non-standard basis; set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.Molecule.run_gcp(self, func=None, dertype=None, verbose=1)¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/gcp-1.html:2659,energy,energy,2659,psi4manual/1.4.0/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/gcp-1.html,5,['energy'],['energy']
Energy Efficiency,"executed and geometry optimization will be performed. Recommendations¶; Here is a list of recommendations for the DCFT module:. Generally, the use of the simultaneous algorithm together with the; AO_BASIS = DISK option is recommended (set by default).; In cases when available memory is insufficient, the use of the AO_BASIS = DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In cases when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by setting the; DIIS_START_CONVERGENCE option to the value greater than; by one or two orders of magnitude (e.g. or; ). This can be particularly useful for computions using the; ODC methods, because it can greatly reduce the number of iterations.; If oscillatory convergence is observed for atoms or molecules with high; symmetry, it is recommended to use the quadratically-convergent algorithm.; When using the quadratically-convergent algorithm for the closed-shell molecules, it; is recommended to set the QC_COUPLING option to FALSE for efficiency; reasons (set by default).; For the ODC computations, the user has a choice of performing the computation of the guess orbitals and cumulants; using the corresponding DC method (set ODC_GUESS to TRUE). This can often lead to; significant computational savings, since the orbital update step in the DC methods is cheap.; Convergence of the guess orbitals and cumulants can be controlled using the; GUESS_R_CONVERGENCE option. Table Of Contents. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Methods Summary; Minimal Input; Recommendations. Previous topic; DFT: Density Function",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:14410,reduce,reduce,14410,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['reduce'],['reduce']
Energy Efficiency,"exotic calls to energy() like zapt4, mp2.5, and cisd are working. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. cdremp-2; Cholesky decomposed REMP/cc-pVDZ energies for the CH3 radical. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. dlpnomp2-3; comparison of DF-MP2 and DLPNO-MP2 with a cartesian basis set. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. This test should match RHF values exactly. scf-level-shift-cuhf; SCF level shift on a CUHF computation. cubeprop; RHF orbitals and density for water. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:10300,energy,energy,10300,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"expert; options. Really avoid using JOBTYPE.; You’re not welcome to add CHARGE or MULTP options. Plan to get; these quantities from the molecule object. Since we frequently use subsets; of systems (with their own charge and multiplicity), this is safer.; Conform. Just grep 'add' psi4/src/read_options.cc to get a list of; all the option names in PSI4 and try to match any conventions you; find.; If you have a quantity you’d like to call a cutoff, a threshold, a; tolerance, or a convergence, consider the following guidelines in naming; it. If its value is typically greater than ~0.001, give it a name with CUTOFF.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with larger values (e.g.,; integrals, occupations, eigenvectors), give it a name with TOLERANCE.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with smaller values (e.g., energy; changes, residual errors, gradients), give it a name with; CONVERGENCE. In deciding how to arrange words in an option name, place the context; first (e.g., MP2_AMPS_PRINT, TRIPLES_DIIS). This means PRINT; will generally be at the end of an option name.; Use INTS_TOLERANCE (not schwarz_cutoff); H in an option name is reserved for Hamiltonian (or hydrogen).; Hessian should be HESS.; All option names should be all caps and separated by underscores.; If you have an option that instructs your module to do something not too; computationally intensive and then quit, append _EXIT to the option; name.; Scaling terms (like for scs) should follow the pattern MP2_SS_SCALE; and SAPT_OS_SCALE.; FRAG for fragment.; AVG for average.; For level-shifting, let’s try to have it governed by (double); LEVEL_SHIFT only and not a boolean/double combo since the procedure; can be turned on (role of boolean) if the value (role of double) has; changed.; For Tikhonow regularization, use TIKONOW_OMEGA, not regularizer.; SYM for symmetry.; OCC fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/manage_addon-1.html:8926,energy,energy,8926,psi4manual/1.4.0/manage_addon-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/manage_addon-1.html,9,['energy'],['energy']
Energy Efficiency,"ext += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom' if self.units() == 'Angstrom' else 'Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; geom = self.atoms[i].compute(); text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_out_in_bohr(self):; """"""Print the molecule in Bohr. Same as :py:func:`print_out` only in Bohr.; (method name in libmints is print_in_bohr). """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j)); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_out_in_angstrom(self):; """"""Print the molecule in Angstroms. Same as :py:func:`print_out` only always in Angstroms.; (method name in libmints is print_in_angstrom). """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom', self.molecu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:26390,charge,charge,26390,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,2,['charge'],['charge']
Energy Efficiency,"ext += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Angstrom' if self.units() == 'Angstrom' else 'Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; geom = self.atoms[i].compute(); text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (geom[j]); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_out_in_bohr(self):; """"""Print the molecule in Bohr. Same as :py:func:`print_out` only in Bohr.; (method name in libmints is print_in_bohr). """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Bohr', self.molecular_charge(), self.multiplicity()); text += """""" Center X Y Z \n""""""; text += """""" ------------ ----------------- ----------------- -----------------\n"""""". for i in range(self.natom()):; text += """""" %8s%4s """""" % (self.symbol(i), """" if self.Z(i) else ""(Gh)""); for j in range(3):; text += """""" %17.12f"""""" % (self.xyz(i, j)); text += ""\n""; text += ""\n""; else:; text += "" No atoms in this molecule.\n""; print text; # TODO outfile. [docs] def print_out_in_angstrom(self):; """"""Print the molecule in Angstroms. Same as :py:func:`print_out` only always in Angstroms.; (method name in libmints is print_in_angstrom). """"""; text = """"; if self.natom():; if self.pg:; text += """""" Molecular point group: %s\n"""""" % (self.pg.symbol()); # if self.full_pg: TODO symmetry; # text += """""" Full point group: %s\n\n"""""" % (self.full_point_group()) TODO symmetry; text += """""" Geometry (in %s), charge = %d, multiplicity = %d:\n\n"""""" % \; ('Bohr', self.molecular_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:25056,charge,charge,25056,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,4,['charge'],['charge']
Energy Efficiency,"ext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rotor_type(),; rot_const=np.asarray(mol.rotational_constants()),; E0=core.variable('CURRENT ENERGY')) # someday, wfn.energy(); vibrec.update({k: qca.json() for k, qca in therminfo.items()}). core.set_variable(""ZPVE"", therminfo['ZPE_corr'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY CORRECTION"", therminfo['E_corr'].data) # P::e THERMO; core.set_variable(""ENTHALPY CORRECTION"", therminfo['H_corr'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY CORRECTION"", therminfo['G_corr'].data) # P::e THERMO. core.set_variable(""ZERO K ENTHALPY"", therminfo['ZPE_tot'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY"", therminfo['E_tot'].data) # P::e THERMO; core.set_variable(""ENTHALPY"", therminfo['H_tot'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY"", therminfo['G_tot'].data) # P::e THERMO. core.print_out(thermtext); else:; core.print_out(' Thermochemical analysis skipped for partial frequency calculation.\n'). if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".vibrec""; with open(filename, 'w') as handle:; json.dump(vibrec, handle, sort_keys=True, indent=4). if core.get_option('FINDIF', 'NORMAL_MODES_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".molden_normal_modes""; with open(filename, 'w') as handle:; handle.write(qcdb.vib.print_molden_vibs(vibinfo, symbols, geom, standalone=True)). return vibinfo. [docs]; def gdma(wfn, datafile=""""):; """"""Function to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:91833,ENERGY,ENERGY,91833,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"ext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rotor_type(),; rot_const=np.asarray(mol.rotational_constants()),; E0=core.variable('CURRENT ENERGY')) # someday, wfn.energy(); vibrec.update({k: qca.json() for k, qca in therminfo.items()}). core.set_variable(""ZPVE"", therminfo['ZPE_corr'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY CORRECTION"", therminfo['E_corr'].data) # P::e THERMO; core.set_variable(""ENTHALPY CORRECTION"", therminfo['H_corr'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY CORRECTION"", therminfo['G_corr'].data) # P::e THERMO. core.set_variable(""ZERO K ENTHALPY"", therminfo['ZPE_tot'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY"", therminfo['E_tot'].data) # P::e THERMO; core.set_variable(""ENTHALPY"", therminfo['H_tot'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY"", therminfo['G_tot'].data) # P::e THERMO. core.print_out(thermtext); else:; core.print_out(' Thermochemical analysis skipped for partial frequency calculation.\n'). if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".vibrec""; with open(filename, 'w') as handle:; json.dump(vibrec, handle, sort_keys=True, indent=4). if core.get_option('FINDIF', 'NORMAL_MODES_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".molden_normal_modes""; with open(filename, 'w') as handle:; handle.write(qcdb.vib.print_molden_vibs(vibinfo, symbols, geom, standalone=True)). return vibinfo. [docs]def gdma(wfn, datafile=""""):; """"""Function to us",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:83682,ENERGY,ENERGY,83682,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"ext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; rotor_type=mol.rotor_type(),; rot_const=np.asarray(mol.rotational_constants()),; E0=core.variable('CURRENT ENERGY')) # someday, wfn.energy(); vibrec.update({k: qca.json() for k, qca in therminfo.items()}). core.set_variable(""ZPVE"", therminfo['ZPE_corr'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY CORRECTION"", therminfo['E_corr'].data) # P::e THERMO; core.set_variable(""ENTHALPY CORRECTION"", therminfo['H_corr'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY CORRECTION"", therminfo['G_corr'].data) # P::e THERMO. core.set_variable(""ZERO K ENTHALPY"", therminfo['ZPE_tot'].data) # P::e THERMO; core.set_variable(""THERMAL ENERGY"", therminfo['E_tot'].data) # P::e THERMO; core.set_variable(""ENTHALPY"", therminfo['H_tot'].data) # P::e THERMO; core.set_variable(""GIBBS FREE ENERGY"", therminfo['G_tot'].data) # P::e THERMO. core.print_out(thermtext); else:; core.print_out(' Thermochemical analysis skipped for partial frequency calculation.\n'). if core.get_option('FINDIF', 'HESSIAN_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".vibrec""; with open(filename, 'w') as handle:; json.dump(vibrec, handle, sort_keys=True, indent=4). if core.get_option('FINDIF', 'NORMAL_MODES_WRITE'):; filename = core.get_writer_file_prefix(mol.name()) + "".molden_normal_modes""; with open(filename, 'w') as handle:; handle.write(qcdb.vib.print_molden_vibs(vibinfo, symbols, geom, standalone=True)). return vibinfo. def _hessian_write(wfn):; if core.get_option('FINDIF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:90227,ENERGY,ENERGY,90227,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"ext-abc2; illustrate the use of point charges in F/I-SAPT procedure. Link Orbital Partitioning in I-SAPT¶; The assignment of the A-C and B-C linking electron pairs is controlled by the FISAPT_LINK_ASSIGNMENT; keyword. The default setting fisapt_link_assignment c assigns the entire pair to the linker C together with; a +1 nuclear charge from the connecting atoms of A/B to preserve the electrical neutrality of each fragment.; However, as already noticed in [Parrish:2015:051103], such a partitioning might result in unphysical dipole; moments at the interfragment boundaries. Imagine, for example, that I-SAPT is used to examine the interaction; of two methyl groups connected by some linker fragment. When the linking bonds are assigned to C, the carbon atoms; of the methyl groups are missing electrons on one of their sp^3 hybrid orbitals and a dipole moment appears.; These dipole moments have been observed to lead, in some cases, to I-SAPT energy contributions that do not make; physical sense, for example, to a strongly repulsive electrostatic energy between two fragments connected by an; intramolecular hydrogen bond.; To overcome this issue, Luu and Patkowski proposed a reassignment of the linking electron pairs so that each fragment; (C and A/B) gets one electron [Luu:2023:356]. This electron is placed on a hybrid orbital of the connecting atom; pointing in the direction of the interfragment bond. Several schemes for determining this link hybrid were proposed; in [Luu:2023:356] and they all are implemented in PSI4. We recommend the so-called SIAO1 scheme,; fisapt_link_assignment siao1, as it has been observed to provide consistently meaningful I-SAPT terms and a; smooth basis set convergence. The SIAO1 name implies that the projection to construct the link hybrids happens in the; intrinsic atomic orbital space (as opposed to the SAO1 method where the standard atomic orbital space is used), with; one iteration of fragment orbital optimization and link orbital orthogonaliz",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/fisapt.html:13890,energy,energy,13890,psi4manual/1.8.x/fisapt.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/fisapt.html,6,['energy'],['energy']
Energy Efficiency,"extended by this method, so; 	 either allowed. Alternately, a string that can be instantiated; 	 into a qcdb.Molecule.; func : str or None; 	 Density functional (Psi4, not Turbomole, names) for which to; 	 load parameters from dashcoeff[dashlvl][func]. This is not; 	 passed to DFTD3 and thus may be a dummy or `None`. Any or all; 	 parameters initialized can be overwritten via `dashparam`.; dashlvl : {'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}; 	 Flavor of a posteriori dispersion correction for which to load; 	 parameters and call procedure in DFTD3. Must be a keys in; 	 dashcoeff dict (or a key in dashalias that resolves to one).; dashparam : dict, optional; 	 Dictionary of the same keys as dashcoeff[dashlvl] used to; 	 override any or all values initialized by; 	 dashcoeff[dashlvl][func].; dertype : {None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional; 	 Maximum derivative level at which to run DFTD3. For large; 	 `mol`, energy-only calculations can be significantly more; 	 efficient. Also controls return values, see below.; verbose : bool, optional; When `True`, additionally include DFTD3 output in output. Returns; -------; energy : float, optional; When `dertype` is 0, energy [Eh].; gradient : list of lists of floats or psi4.core.Matrix, optional; When `dertype` is 1, (nat, 3) gradient [Eh/a0].; (energy, gradient) : float and list of lists of floats or psi4.core.Matrix, optional; When `dertype` is unspecified, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; research site: https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/dft-d3; Psi4 mode: When `psi4` the python module is importable at `import qcdb`; time, Psi4 mode is activated, with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o'lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar ""DISPERSION CORRECTION ENERGY"" is set; * `verbose` triggered when PRINT k",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html:3221,energy,energy-only,3221,psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,2,"['efficient', 'energy']","['efficient', 'energy-only']"
Energy Efficiency,"extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real and arg3 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real. fZ(self: psi4.core.Molecule, arg0: int) → float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, arg0: int) → float; Gets charge of atom arg1 (0-indexed including dummies). find_point_group(self: psi4.core.Molecule, arg0: float) → psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool) → None; Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool) → None; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, arg0: int) → str; Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed including dummies). fmass(self: psi4.core.Molecule, arg0: int) → float; Gets mass of atom arg1 (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float) → None; Uses the point group object obtain by calling point_group(). fsymbol(self: psi4.core.Molecule, arg0: int) →",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:23128,charge,charge,23128,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"extrapolation procedures (e.g., DIIS) until the gradient; conditions are met. Note that while the total number of macroiterations will be; less for SOSCF than gradient-based convergence acceleration, the cost of solving; the microiterations typically results in the overall cost being greater for; SOSCF than for gradient-based methods. Therefore, SOSCF should only be used if; it is difficult to locate a stable minimum.; SOSCF is available for all HF and DFT references with the exception of meta-; GGA functionals. To enable, set the option SOSCF to true.; Additional options to modify the number of microiterations taken are as; follows:. SOSCF_START_CONVERGENCE: when to start SOSCF based on the current density RMS; SOSCF_MAX_ITER: the maximum number of SOSCF microiterations per macroiteration; SOSCF_CONV: the relative convergence tolerance of the SOSCF microiterations; SOSCF_PRINT: option to print the microiterations or not. Stability Analysis¶; SCF algorithms attempt to minimize the gradient of the energy with respect; to orbital variation parameters. At convergence, the gradient should be approximately zero; given a convergence criterion. Although this is enough to make sure the SCF converged to a; stationary point, this is not a sufficient condition for a minimal SCF solution. It may be; a saddle point or a maximum.; To ensure that a minimum has been found, the electronic Hessian, i.e. the matrix of second; derivatives of the energy with respect to orbital variation parameters, must be computed.; If one or more eigenvalues of the electronic Hessian are negative, the SCF solution is not a minimum.; In that case, orbital parameters can be varied along the lowest Hessian eigenvector to lower the energy.; Orbital variation parameters are usually constrained. For example, in RHF the; spatial parts of the \(\alpha\) and \(\beta\) orbitals are the same. In; UHF, the orbital coefficients are usually constrained to be real. A stability analysis; can check whether a lower SCF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/scf-1.html:26685,energy,energy,26685,psi4manual/1.3.2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/scf-1.html,11,['energy'],['energy']
Energy Efficiency,"ey = section.get('SolverType'); val = key.get(); if (val not in allowed_types): ; print ""Allowed types are: "", allowed_types; 	sys.exit(1); 	allowed_equations = ('FirstKind', 'SecondKind', 'Full'); key = section.get('EquationType'); val = key.get(); if (val not in allowed_equations): ; print ""Allowed equations are: "", allowed_equations; 	sys.exit(1). [docs]def verify_green(section):; 	required = ('Type',); 	allowed = ('Vacuum', 'UniformDielectric', 'MetalSphere', 'GreensFunctionSum'); 	allowed_der = ('Numerical', 'Derivative', 'Gradient', 'Hessian'). 	green1 = section.fetch_sect('Green<one>'); 	green2 = section.fetch_sect('Green<two>'); 	eps = section.get('Eps'); 	epsimg = section.get('EpsImg'); 	epsre = section.get('EpsRe'). 	convert_length_array(section.get('SpherePosition')); position = section.get('SpherePosition'); 	convert_length_scalar(section.get('SphereRadius')); radius = section.get('SphereRadius'). 	type=section.get('Type'); 	if (type.get() not in allowed):; 		print ""Allowed Green's functions are:"", allowed; 		sys.exit(1). 	type=section.get('Der'); 	if (type.get() not in allowed_der):; 		print ""Allowed Derivatives are:"", allowed; 		sys.exit(1). 	if (type.get() == 'UniformDielectric'):; 		if not eps.is_set():; 			print ""Eps not defined for UniformDielectric""; 			sys.exit(1). 	if (type.get() == 'MetalSphere'):; 		if not (eps.is_set() and epsre.is_set and epsimg.is_set()):; 			print ""Eps and/or EpsImg not defined for MetalSphere""; 			sys.exit(1); 		if not (position.is_set() and radius.is_set()):; 			print ""SpherePosition and/or SphereRadius not defined for MetalSphere""; 			sys.exit(1); 		if (len(position.get()) != 3):; 			print ""SpherePosition error""; 			sys.exit(1); 		if (radius.get() < 0.1):; 			print ""Minimum value allowed for Radius is 0.1""; 			sys.exit(1). 	if (type.get() == 'GreensFunctionSum'):; 		if not (green1.is_set() and green2.is_set()):; 			print ""One or both components not defined for GreensFunctionSum""; 			sys.exit(1). [docs]def verify_spheres(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/pcmpreprocess.html:6867,Green,Green,6867,psi4manual/4.0b5/_modules/pcmpreprocess.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/pcmpreprocess.html,1,['Green'],['Green']
Energy Efficiency,"ey with incremental; improvements by other psi4 developers. Major differences from the C++; class are: no basisset handling, no symmetry, no pubchem. This class; translated so that databases can function independently of psi4. >>> H2OH2O = qcdb.Molecule(\""\""\""; 0 1; O1 -1.551007 -0.114520 0.000000; H1 -1.934259 0.762503 0.000000; H2 -0.599677 0.040712 0.000000; --; 0 1; X 0.000000 0.000000 0.000000; O2 1.350625 0.111469 0.000000; H3 1.680398 -0.373741 -0.758561; H4 1.680398 -0.373741 0.758561; no_com; no_reorient; units angstrom; \""\""\""). >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'); """"""; FullPointGroupList = [""ATOM"", ""C_inf_v"", ""D_inf_h"", ""C1"", ""Cs"", ""Ci"", \; ""Cn"", ""Cnv"", ""Cnh"", ""Sn"", ""Dn"", ""Dnd"", ""Dnh"", ""Td"", ""Oh"", ""Ih""]. def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from string in psi4 format"""""". # <<< Basic Molecule Information >>>. # Molecule (or fragment) name; self.PYname = 'default'; # The molecular charge; self.PYmolecular_charge = 0; # Whether the charge was given by the user UNUSED; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user UNUSED; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; # A list describing how to handle each fragment; self.fragment_types = []; # The charge of each fragment; self.fragment_charges = []; # Th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:1745,charge,charge,1745,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,4,['charge'],['charge']
Energy Efficiency,"ey.upper().endswith(p) or f""{p} -"" in key.upper()) for p in _multipole_order):; p = [p for p in _multipole_order if (key.upper().endswith(p) or f""{p} -"" in key.upper())]; reshaper = tuple([3] * _multipole_order.index(p[0])); elif key.upper() in [""MULLIKEN_CHARGES"", ""LOWDIN_CHARGES"", ""MULLIKEN CHARGES"", ""LOWDIN CHARGES""]:; reshaper = (-1, ); elif ""GRADIENT"" in key.upper():; reshaper = (-1, 3); elif ""HESSIAN"" in key.upper():; ndof = int(math.sqrt(len(tgt))); reshaper = (ndof, ndof); else:; raise ValidationError(f'Uncertain how to reshape array: {key}'). return tgt.reshape(reshaper). _multipole_order = [""dummy"", ""dummy"", ""QUADRUPOLE"", ""OCTUPOLE"", ""HEXADECAPOLE""]; for order in range(5, 10):; _multipole_order.append(f""{int(2**order)}-POLE""). def _qcvar_reshape_set(key: str, val: np.ndarray) -> np.ndarray:; """"""Reverse :py:func:`_qcvar_reshape_get` for internal; :py:class:`psi4.core.Matrix` storage. """"""; reshaper = None; if key.upper().startswith(""MBIS""):; if key.upper().endswith(""CHARGES""):; return val; elif key.upper().endswith(""DIPOLES""):; reshaper = (-1, 3); return val.reshape(reshaper); elif key.upper().endswith(""QUADRUPOLES""):; val = val.reshape(-1, 3, 3); val = np.array([_multipole_compressor(val[iat], 2) for iat in range(len(val))]); return val; elif key.upper().endswith(""OCTUPOLES""):; val = val.reshape(-1, 3, 3, 3); val = np.array([_multipole_compressor(val[iat], 3) for iat in range(len(val))]); return val; elif key.upper().endswith(""DIPOLE"") or ""DIPOLE -"" in key.upper():; reshaper = (1, 3); elif ""QUADRUPOLE POLARIZABILITY TENSOR"" in key.upper():; reshaper = (3, 3, 3); elif any((key.upper().endswith(p) or f""{p} -"" in key.upper()) for p in _multipole_order):; p = [p for p in _multipole_order if (key.upper().endswith(p) or f""{p} -"" in key.upper())]; val = _multipole_compressor(val, _multipole_order.index(p[0])); reshaper = (1, -1); elif key.upper() in [""MULLIKEN_CHARGES"", ""LOWDIN_CHARGES"", ""MULLIKEN CHARGES"", ""LOWDIN CHARGES""]:; reshaper = (1, -1). if reshaper:; retu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:30235,CHARGE,CHARGES,30235,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,1,['CHARGE'],['CHARGES']
Energy Efficiency,"eyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; mp2; mp2.5; mp3; mp4(sdq); mp4; omp2. omp3; ocepa; cepa0; cepa(0); cepa(1); cepa(3); acpf. aqcc; qcisd; cc2; ccsd; fno-df-ccsd; bccd; cc3. qcisd(t); ccsd(t); fno-df-ccsd(t); bccd(t); cisd; cisdt; cisdtq. cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – 'mp2' || 'ccsd' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:3345,energy,energy,3345,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"e}} \left(E_{\text{corl},\; \textbf{delta3_wfn}}^{\textbf{delta3_basis}}\right) - \mathcal{F}_{\textbf{delta3_scheme}} \left(E_{\text{corl},\; \textbf{delta3_wfn_lesser}}^{\textbf{delta3_basis}}\right)\]. \[\delta_{\textbf{delta4_wfn_lesser}}^{\textbf{delta4_wfn}} \; = \mathcal{F}_{\textbf{delta4_scheme}} \left(E_{\text{corl},\; \textbf{delta4_wfn}}^{\textbf{delta4_basis}}\right) - \mathcal{F}_{\textbf{delta4_scheme}} \left(E_{\text{corl},\; \textbf{delta4_wfn_lesser}}^{\textbf{delta4_basis}}\right)\]. \[\delta_{\textbf{delta5_wfn_lesser}}^{\textbf{delta5_wfn}} \; = \mathcal{F}_{\textbf{delta5_scheme}} \left(E_{\text{corl},\; \textbf{delta5_wfn}}^{\textbf{delta5_basis}}\right) - \mathcal{F}_{\textbf{delta5_scheme}} \left(E_{\text{corl},\; \textbf{delta5_wfn_lesser}}^{\textbf{delta5_basis}}\right)\]; A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. \[E_{\text{total}}^{\text{CBS}} = \mathcal{F}_{\text{highest_1}} \left(E_{\text{total},\; \text{SCF}}^{\text{aug-cc-pVQZ}}\right) \; + \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}}\right) \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\]. \[\delta_{\text{MP2}}^{\text{CCSD(T)}} \; = \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{CCSD(T)}}^{\text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation; Complete Basis Set. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs_eqn-1.html:2600,energy,energy,2600,psi4manual/1.2.1/cbs_eqn-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs_eqn-1.html,4,['energy'],['energy']
Energy Efficiency,"e¶; transcribed by D. A. Sirianni. Note: Psithon and PsiAPI refer to two modes of interacting with Psi4. In Psithon mode, you write an input file in our domain-specific language (not quite Python) where commands don’t have psi4. in front, then submit it to the executable psi4 which processes the Psithon into pure Python and runs it internally. In PsiAPI mode, you write a pure Python script with import psi4 at the top, and commands are behind the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the PsiAPI mode. Note: PsiAPI mode has been available since late 2016 and the v1.1 release. While we aim to provide deprecation warnings and upgrade helpers, the API should not be considered completely stable. Most importantly, as we someday deprecate the last of the global variables, options will be added to the method calls (e.g., energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after compilation or How to run Psi4 as a Python module from conda installation for assistance in setting up Psi4. Here, we will explore the basics of using Psi4 in the interactive PsiAPI style where it is loaded directly as a Python module by reproducing the section A Psi4 Tutorial from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your path, feel free to execute each cell as you read along by pressing Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python environment:. [1]:. # Ignore this block -- it's for the documentation build; try:; import os, sys; sys.path.insert(1, os.path.abspath('/home/runner/work/psi4/psi4/code/objdir/stage//usr/local/psi4/lib/')); except ImportError:; pass. # This is the important part; import psi4. Psi4 is now able to be controlled directly from Python. By default, Psi4 will print any output to the screen; this can ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psiapi-1.html:1128,energy,energy,1128,psi4manual/1.4.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psiapi-1.html,8,['energy'],['energy']
Energy Efficiency,"e¶; transcribed by D. A. Sirianni. Note: Psithon and PsiAPI refer to two modes of interacting with Psi4. In Psithon mode, you write an input file in our domain-specific language (not quite Python) where commands don’t have psi4. in front, then submit it to the executable psi4 which processes the Psithon into pure Python and runs it internally. In PsiAPI mode, you write a pure Python script with import psi4 at the top, and commands are behind the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the PsiAPI mode. Note: PsiAPI mode has been available since late 2016 and the v1.1 release. While we aim to provide deprecation warnings and upgrade helpers, the API should not be considered completely stable. Most importantly, as we someday deprecate the last of the global variables, options will be added to the method calls (e.g., energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after compilation or How to run Psi4 as a Python module from conda installation for assistance in setting up Psi4. Here, we will explore the basics of using Psi4 in the interactive PsiAPI style where it is loaded directly as a Python module by reproducing the section A Psi4 Tutorial from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your path, feel free to execute each cell as you read along by pressing Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python environment:. [1]:. # Ignore this block -- it's for the documentation build; try:; import os, sys; sys.path.insert(1, os.path.abspath('/psi/gits/hrw-demo/objdir_docs311cf_make/stage//usr/local/psi4/lib/')); except ImportError:; pass. # This is the important part; import psi4. Psi4 is now able to be controlled directly from Python. By default, Psi4 will print any output to the screen; this can",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psiapi.html:1130,energy,energy,1130,psi4manual/1.8.x/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psiapi.html,1,['energy'],['energy']
Energy Efficiency,"e–Fock method, without; any dispersion correction; the first three (or four, since; \(E_{xc} = 0\)) terms in Eq. (4). Quantity \(E_{\text{HF}}\); in Eq. (4). HF TOTAL GRADIENT¶; The total electronic gradient [E_h/a0] of the Hartree–Fock method, ({nat}, 3). HF DIPOLE GRADIENT¶; The derivative of the Hartree–Fock method dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). HF TOTAL HESSIAN¶; The total electronic second derivative [Eh/a0/a0] for the Hartree-Fock method, (3 * {nat}, 3 * {nat}). LCCD TOTAL ENERGY¶. LCCD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the linearized coupled cluster doubles level of theory. LCCSD TOTAL ENERGY¶. LCCSD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the linearized coupled cluster singles and doubles level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [Eh] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [Eh] for the local CCSD level of theory. LEFT-RIGHT CC2 EIGENVECTOR OVERLAP¶. LEFT-RIGHT CC3 EIGENVECTOR OVERLAP¶. LEFT-RIGHT CCSD EIGENVECTOR OVERLAP¶. LEFT-RIGHT CCSD(T) EIGENVECTOR OVERLAP¶; The overlap between the right-hand coupled coupled cluster eigenvector and the; left-hand eigenvector from the coupled cluster lambda (response) equations. LOWDIN CHARGES¶; Property of partial atomic charges [e] by the method of Löwdin, (nat,). MAYER INDICES¶; Property of Mayer bond indices, (nat, nat). MBIS CHARGES¶. MBIS DIPOLES¶. MBIS OCTUPOLES¶. MBIS QUADRUPOLES¶; Per-atom charges [e], dipoles [e a0], quadrupoles [e a0^2], and octupoles [e a0^3]; resulting from partitioning the total electron density through the Minimal Basis; Iterative Stockholder (MBIS) Charge Partitioning Scheme. MBIS FREE ATOM n VOLUME¶; Free-atom volume [a0^3] for atom n, computed using the MBIS charge; partitioning",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:32789,energy,energy,32789,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['energy'],['energy']
Energy Efficiency,"e–Fock method, without; any dispersion correction; the first three (or four, since; \(E_{xc} = 0\)) terms in Eq. (4). Quantity \(E_{\text{HF}}\); in Eq. (4). HF TOTAL GRADIENT¶; The total electronic gradient [E_h/a0] of the Hartree–Fock method, ({nat}, 3). HF DIPOLE GRADIENT¶; The derivative of the Hartree–Fock method dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). HF TOTAL HESSIAN¶; The total electronic second derivative [Eh/a0/a0] for the Hartree-Fock method, (3 * {nat}, 3 * {nat}). LCCD TOTAL ENERGY¶. LCCD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the linearized coupled cluster doubles level of theory. LCCSD TOTAL ENERGY¶. LCCSD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the linearized coupled cluster singles and doubles level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [Eh] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [Eh] for the local CCSD level of theory. LOWDIN CHARGES¶; Property of partial atomic charges [e] by the method of Löwdin, (nat,). MAYER INDICES¶; Property of Mayer bond indices, (nat, nat). MBIS CHARGES¶. MBIS DIPOLES¶. MBIS OCTUPOLES¶. MBIS QUADRUPOLES¶; Per-atom charges [e], dipoles [e a0], quadrupoles [e a0^2], and octupoles [e a0^3]; resulting from partitioning the total electron density through the Minimal Basis; Iterative Stockholder (MBIS) Charge Partitioning Scheme. MBIS FREE ATOM n VOLUME¶; Free-atom volume [a0^3] for atom n, computed using the MBIS charge; partitioning scheme. Free atom densities are computed at the same; level of theory as the parent MBIS calculation, with UHF turned on; as needed. MBIS RADIAL MOMENTS <R^3>¶; Per-atom expectation value of r^3 [a0^3], equivalent to the volume; of the MBIS-partitioned density. MBIS VALENCE WIDTHS¶; Per-atom density width [",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:24260,energy,energy,24260,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency,"e’re using density fitting for the SAPT, we might as well also; use it for the Hartree-Fock computations that are performed as part of; the SAPT. We can specify that by adding 'scf_type': 'df' to the; dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in; addition to the total SAPT0 interaction energy. An explanation of the; various energy components can be found in the review by Jeziorski,; Moszynski, and Szalewicz; (Jeziorski:1994:1887),; and this is discussed in more detail in the SAPT; section of the Psi4; manual.; For now, we’ll note that most of the SAPT energy components are; negative; this means those are attractive contributions (the zero of; energy in a SAPT computation is defined as non-interacting monomers).; The exchange contributions are positive (repulsive). In this example,; the most attractive contribution between ethylene and acetylene is an; electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1; indicates the first-order perturbation theory result with respect to the; int",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:15007,energy,energy,15007,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['energy'],['energy']
Energy Efficiency,"f (lowername == 'fno-df-ccsd'):; PsiMod.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); PsiMod.set_local_option('FNOCC', 'NAT_ORBS', True); if (lowername == 'fno-df-ccsd(t)'):; PsiMod.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); PsiMod.set_local_option('FNOCC', 'NAT_ORBS', True). # set scf-type to df unless the user wants something else; if PsiMod.has_option_changed('SCF','SCF_TYPE') == False:; PsiMod.set_local_option('SCF','SCF_TYPE', 'DF'). if PsiMod.get_option('FNOCC','DF_BASIS_CC') == '':; basis = PsiMod.get_global_option('BASIS'); dfbasis = corresponding_rifit(basis); PsiMod.set_local_option('FNOCC','DF_BASIS_CC',dfbasis). scf_helper(name,**kwargs); PsiMod.fnocc(). molecule.reset_point_group(user_pg); molecule.update_geometry(). # restore options; optstash.restore(). return PsiMod.get_variable(""CURRENT ENERGY""). [docs]def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); if 'level' in kwargs:; level = kwargs['level']; else:; level = 0; . # stash user options:; optstash = OptionsState(; ['TRANSQT2','WFN'],; ['FNOCC','RUN_MP2'],; ['FNOCC','RUN_MP3'],; ['FNOCC','RUN_MP4'],; ['FNOCC','RUN_CCSD'],; ['FNOCC','COMPUTE_TRIPLES'],; ['FNOCC','COMPUTE_MP4_TRIPLES'],; ['FNOCC','DFCC'],; ['FNOCC','RUN_CEPA'],; ['FNOCC','NAT_ORBS']). PsiMod.set_local_option('FNOCC','DFCC', False); PsiMod.set_local_option('FNOCC','RUN_CEPA', False). # which method?; if (lowername == '_ccsd'):; PsiMod.set_local_option('FNOCC','COMPUTE_TRIPLES', False); PsiMod.set_local_option('FNOCC','RUN_CCSD', True); elif (lowername == '_ccsd(t)'):; PsiMod.set_local_option('FNOCC','COMPUTE_TRIPLES', True); PsiMod.set_local_option('FNOCC','RUN_CCSD', True); elif (lowername == 'fno-ccsd'):; PsiMod.set_local_option('FNOCC','COMPUTE_TRIPLES', False); PsiMod.set_local_option('FNOCC','RUN_CCSD', True); PsiMod.set_local_option('FNO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:70131,energy,energy,70131,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,2,['energy'],['energy']
Energy Efficiency,"f = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Customization: Adding Simple Extensions; Defining a Method Alias. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/quickaddalias-1.html:2983,energy,energy,2983,psi4manual/1.4.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/quickaddalias-1.html,14,['energy'],['energy']
Energy Efficiency,"f = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Customization: Adding Simple Extensions; Defining a Method Alias. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/quickaddalias-1.html:2983,energy,energy,2983,psi4manual/1.5.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/quickaddalias-1.html,14,['energy'],['energy']
Energy Efficiency,"f == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf(name, **kwargs); returnvalue = psi4.get_variable('CURRENT ENERGY'). for ssuper in superfunctional_list():; if ssuper.name().lower() == name.lower():; dfun = ssuper. if dfun.is_c_hybrid():. # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). if dfun.is_c_scs_hybrid():; psi4.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); psi4.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); psi4.dfmp2(); vdh = dfun.c_alpha() * psi4.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; psi4.dfmp2(); vdh = dfun.c_alpha() * psi4.get_variable('MP2 CORRELATION ENERGY'). psi4.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; psi4.set_variable('DFT TOTAL ENERGY', returnvalue); psi4.set_variable('CURRENT ENERGY', returnvalue). optstash.restore(). [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise Validati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:39166,ENERGY,ENERGY,39166,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"f Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. set_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested internal variable. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the map of all internal variables. class psi4.core.CdSalcList¶; Bases: pybind11_builtins.pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory) → List[psi4.core.Matrix]¶; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList) → psi4.core.Matrix¶; Return the SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int) → psi4.core.Matrix¶; Return only the SALCS in irrep h. ncd(self: psi4.core.CdSalcList) → int¶; Return the number of cartesian displacements SALCs. print_out(self: psi4.core.CdSalcList) → None¶; Print the SALC to the output file. salc_name(self: psi4.core.CdSalcList, i: int) → str¶; Return the name of SALC #i. class psi4.core.CorrelationFactor¶; Bases: pybind11_builtins.pybind11_object; docstring. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, exponent: psi4.core.Vector) → None¶; Set coefficient and exponent. class psi4.core.CorrelationTable¶; Bases: pybind11_builtins.pybind11_object; Pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:32387,adapt,adapted,32387,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['adapt'],['adapted']
Energy Efficiency,"f H2O+ with EOM-CCSD. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. sapt11; sapt example with orbital freezing with alkali metal and dMP2. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. cbs-delta-energy; Extrapolated energies with delta correction. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. fd-freq-energy-large; SCF DZ finite difference frequencies by e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:8261,energy,energy,8261,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"f PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T]. The CORR_MULTP option allows you to select the Slater determinants with a particular value. The WFN_SYM keyword is neccesary if you do not want to compute the energy of the all-symmetric state. The FOLLOW_ROOT option may be used to follow different roots of the effective Hamiltonian. A value of 1 instructs PSIMRCC to follow the solution with the lowest energy given a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ccsd # Do Mk-MRCCSD; frozen_docc [1,0,0,0,0,1,0,0] # Frozen MOs; restricted_docc [2,0,0,0,0,1,1,1] # Doubly occupied MOs; active [0,0,1,1,0,0,0,0] # Active MOs; frozen_uocc [0,0,0,0,0,0,0,0] # Frozen virtual MOs; corr_multp 1 # Select the Ms = 0 component; root 1; wfn_sym B1g # Select the B1g state; }; energy('psimrcc'). Note that the oxygen molecule has 16 electrons (including core), while; the docc array contains only 7 doubly-occupied orbitals (or 14; electrons). Hence, two more electrons are available to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:3842,energy,energy,3842,psi4manual/4.0b2/psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html,2,['energy'],['energy']
Energy Efficiency,"f _core_has_variable(key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set in global memory."""""". return core.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(cls: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set on *self* :class:`psi4.core.Wavefunction`."""""". return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from global memory. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:26153,ENERGY,ENERGY,26153,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"f _core_has_variable(key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set in global memory."""""". return core.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(cls: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array QCVariable *key* has been set on *self* :class:`psi4.core.Wavefunction`."""""". return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from global memory. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`numpy.ndarray` of natural dimensionality.; Other array variables are returned as :py:class:`~psi4.core.Matrix` and may have an extra dimension with symmetry information. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(cls: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array QCVariable *key* from *self* :class:`psi4.core.Wavefunction`. Returns; -------; float or numpy.ndarray or Matrix; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as :class:`nu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:28406,ENERGY,ENERGY,28406,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"f _prepare_results(self, client: Optional[""FractalClient""] = None):; results_list = [x.get_results(client=client) for x in self.task_list]. modules = [getattr(v.provenance, ""module"", None) for v in results_list]; if self.driver != ""energy"" and len(set(modules)) == 2 and modules.count(""scf"") == len(modules) / 2:; # signature of ""MP2 GRAD"" - ""HF GRAD"" implementation detail; # * avoid having post-scf single-method gradients/Hessians show up as ""(mixed)"" module just because an outright HF call in the jobs list; modules = set(modules) - {""scf""}; modules = list(set(modules)); modules = modules[0] if len(modules) == 1 else ""(mixed)"". # load results_list numbers into compute_list (task_list is AtomicComputer-s); for itask, mc in enumerate(self.compute_list):; task = results_list[itask]; response = task.return_result. if self.metameta['ptype'] == 'energy':; mc['f_energy'] = response. elif self.metameta['ptype'] == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif self.metameta['ptype'] == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; mc['f_gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; mc['f_dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. if 'CURRENT DIPOLE GRADIENT' in task.extras['qcvars']:; mc['f_dipder'] = task.extras['qcvars']['CURRENT DIPOLE GRADIENT']. # Fill in energies for subsumed methods; if self.metameta['ptype'] == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in self.trove:; if ((wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']); and (mc['f_options'] == job['f_options'])):; job['f_energy'] = task.extras['qcvars'][VARH[wfn][wfn]]. # Copy data from 'run' to 'obtained' table; for mce in self.trove:; if ((mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:56576,ENERGY,ENERGY,56576,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"f all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.set_mass(iatom, masses[jatom]); jatom = jatom + 1. # Set a lattice of point charges; def set_lattice_field(self):; """""" Set a field of lattice point charges using information received through MDI; """"""; self.lattice_field = psi4.QMMM(); unit_conv = self.length_conversion(); for ilat in range(self.nlattice):; latx = self.clattice[3 * ilat + 0] * unit_conv; laty = self.clattice[3 * ilat + 1] * unit_conv; latz = self.clattice[3 * ilat + 2] * unit_conv; self.lattice_field.extern.addCharge(self.lattice[ilat], latx, laty, latz); psi4.core.set_global_option_python('EXTERN', self.lattice_field.extern); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the latti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:9137,charge,charges,9137,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,4,['charge'],['charges']
Energy Efficiency,"f charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.print_out(); ExternalPotential.setName(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:2000,energy,energy,2000,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,2,['energy'],['energy']
Energy Efficiency,"f computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which Psi4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. Table Of Contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; RESTRICTED_DOCC; RESTRICTED_UOCC; FROZEN_UOCC; CI_MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; SAPT: Symmetry-Adapted Perturbation Theory. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Theoretical Methods: SCF to FCI ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Cr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/detci-1.html:11645,energy,energy,11645,psi4manual/1.0.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/detci-1.html,2,['energy'],['energy']
Energy Efficiency,"f dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False)¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule) → str¶; Returns the Schoenflies symbol. set_active_fragment(self: psi4.core.Molecule, arg0: int) → None¶; Sets the specified fragment arg2 to be Real. set_active_fragments(self: psi4.core.Molecule, arg0: list) → None¶; Sets the specified list arg2 of fragments to be Real. set_basis_all_atoms(self: psi4.core.M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:86788,energy,energy,86788,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,6,['energy'],['energy']
Energy Efficiency,"f formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. tdscf-1; td-uhf test on triplet states of methylene (rpa). scf-hess5; DF SCF 6-31G analytical vs finite-difference tests Tests DF UHF hessian code for Ca != Cb. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. scf-ecp2; Water-Argon complex with ECP present; check of RHF Hessian. fnocc7; Test fnocc with linear dependencies. props4; Electrostatic potential and electric field evaluated on a grid around",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:44056,energy,energy,44056,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"f lowername in procedures['energy']:; dertype = 0; func = energy. if (PsiMod.get_global_option('REFERENCE').lower() == 'rks') or (PsiMod.get_global_option('REFERENCE').lower() == 'uks'):; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if input.der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif input.der1st.match(str(opt_dertype)):; dertype = 1; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function optimize.' % (opt_dertype)). # 3. if the user provides a custom function THAT takes precendence; if ('opt_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['opt_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['opt_func']. # Summary validation; if (dertype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:21935,energy,energy,21935,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,6,['energy'],['energy']
Energy Efficiency,"f methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; # Set method-dependent scf convergence criteria; if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 6); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 8); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 6); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 8). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 6). procedures['energy'][lowername](lowername, **kwargs). except KeyError:; raise ValidationError('Energy method %s not available.' % (lowername)). optstash.restore(); return psi4.get_variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs); dertype = 1. optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:31024,energy,energy,31024,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"f mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Capabilities of , including details of overlapping modules. “✓” runs analytically. “∷” runs derivative with internal finite difference. Single underline “✓̲” or “∷̲” is default module when QC_MODULE unspecified. Double underline “✓̳” or “∷̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/proc_py.html:7776,energy,energy,7776,psi4manual/master/proc_py.html,https://psicode.org,https://psicode.org/psi4manual/master/proc_py.html,1,['energy'],['energy']
Energy Efficiency,"f not (lowername in procedures[types[dertype]]):; print('Frequencies: dertype = %d for frequencies is not available, switching to automatic determination.' % dertype); dertype = -1. if 'irrep' in kwargs:; irrep = parse_cotton_irreps(kwargs['irrep']) - 1 # externally, A1 irrep is 1, internally 0; else:; irrep = -1 # -1 implies do all irreps. # By default, set func to the energy function; func = energy; func_existed = False; if 'func' in kwargs:; func = kwargs['func']; func_existed = True. if (not('dertype' in kwargs) or dertype == -1):; if lowername in procedures['hessian']:; dertype = 2; elif lowername in procedures['gradient']:; dertype = 1; else:; dertype = 0. # Does an analytic procedure exist for the requested method?; if (dertype == 2 and func_existed == False):; # We have the desired method. Do it.; procedures['hessian'][lowername](lowername, **kwargs); return PsiMod.reference_wavefunction().energy(); elif (dertype == 1 and func_existed == False):; # Ok, we're doing frequencies by gradients; info = 'Performing finite difference by gradient calculations'; print(info). func = procedures['gradient'][lowername]. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_1(irrep). molecule.reinterpret_coordentry(False); molecule.fix_orientation(True); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print(' %d displacements needed.' % ndisp). #print displacements to output.dat; #for n, displacement in enumerate(displacements):; # displacement.print_out();. gradients = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=""""); sys.stdout.flush(). # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacem",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:48123,energy,energy,48123,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"f not the last molecule defined. Validated by:. set_molecule. field nbodies_per_mc_level: List[List[Union[int, Literal['supersystem']]]] = []¶; Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; [[1], [2]] has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry ‘supersystem’ means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any ‘supersystem’ element is at the end. field nfragments: int = -1¶; Number of distinct fragments comprising full molecular supersystem. Validated by:. set_nfragments. field quiet: bool = False¶; Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted. field return_total_data: Optional[bool] = None¶; When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying return_total_data = True may carry out more computations than return_total_data = False. Validated by:. set_return_total_data. field task_list: Dict[str, Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]] = {}¶. build_tasks(mb_computer, mc_level_idx, **kwargs)[source]¶; Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type mb_compute",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/nbody.html:14376,energy,energy,14376,psi4manual/1.7.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/nbody.html,4,['energy'],['energy']
Energy Efficiency,"f running the I-SAPT0/jun-cc-pVDZ computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups) The SIAO1 link partitioning algorithm is used. An F-SAPT partitioning follows I-SAPT. dfccsd-t-grad2; DF-CCSD(T) cc-pVDZ gradient for the NH molecule. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. scf6; Tests RHF/ROHF/UHF SCF gradients. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. cbs-xtpl-alpha; Extrapolated water energies. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dft-custom; DFT custom functional test. dft2; DFT Functional Test. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cepa-module; routing check on lccd, lccsd, cepa(0). dct12; Spin-restricted DC-06 counterpart of dct1. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:14704,energy,energy,14704,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"f screening used when computing two-electron integrals. Type: string; Possible Values: SCHWARZ, CSAM, DENSITY; Default: CSAM. SOCC¶. An array containing the number of singly-occupied orbitals per irrep (in Cotton order). The value of DOCC should also be set. Type: array; Default: No Default. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. Expert¶. CUBIC_BASIS_TOLERANCE¶. CubicScalarGrid basis cutoff. Type: conv double; Default: 1.0e-12. CUBIC_BLOCK_MAX_POINTS¶. CubicScalarGrid maximum number of grid points per evaluation block. Type: integer; Default: 1000. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. DERTYPE¶. Derivative level. Type: string; Possible Values: NONE, FIRST, SECOND, RESPONSE; Default: NONE. DIE_IF_NOT_CONVERGED¶. Psi4 dies if energy does not converge. Type: boolean; Default: true. DKH_ORDER¶. Order of Douglas-Kroll-Hess. Type: integer; Default: 2. EXTERNAL_POTENTIAL_SYMMETRY¶. Assume external fields are arranged so that they have symmetry. It is up to the user to know what to do here. The code does NOT help you out in any way!. Type: boolean; Default: false. MAT_NUM_COLUMN_PRINT¶. Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. PARENT_SYMMETRY¶. For displacements, symmetry (Schoenflies symbol) of ‘parent’ (undisplaced) reference molecule. Internal use only for finite difference. Type: string; Default: No Default. RAS1¶. An array giving the number of orbitals per irrep for RAS1. Type: array; Default: No Default. RAS2¶. An array giving the number of orbitals per irrep for RAS2. Type: array; Default: No Default. RAS3¶. An array giving the number of orbitals per irrep for RAS3. Type: array; Default: No Default. RAS4¶. An array giving the number of orbitals per irrep for RAS4. Type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__globals-1.html:8624,energy,energy,8624,psi4manual/1.5.0/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__globals-1.html,10,['energy'],['energy']
Energy Efficiency,"f sn == ""scf"" and f""{sn}_basis"" in kwargs:; # or we're at a scf stage which can be implied with a provided scf_basis; stage = {""wfn"": ""hf"", ""basis"": kwargs[f""{sn}_basis""]}; else:; # otherwise go to the next possible stage; continue; # if we made it here, stage exists - parse other keywords; if f""{sn}_scheme"" in kwargs:; stage[""scheme""] = kwargs[f""{sn}_scheme""]; if f""{sn}_wfn_lesser"" in kwargs:; stage[""wfn_lo""] = kwargs[f""{sn}_wfn_lesser""]; if f""cbs_{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""cbs_{sn}_alpha""]; elif f""{sn}_alpha"" in kwargs:; stage[""alpha""] = kwargs[f""{sn}_alpha""]; cbs_metadata.append(stage); if sn == ""corl"":; possible_stages.append(""delta""); elif sn == ""delta"":; possible_stages.append(""delta2""). return _validate_cbs_inputs(cbs_metadata, molecule). ###################################; ## Start of Complete Basis Set ##; ###################################. [docs]def cbs(func, label, **kwargs):; r""""""Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. :aliases: complete_basis_set(). :returns: (*float*) -- Total electronic energy in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CBS TOTAL ENERGY`; * :psivar:`CBS REFERENCE ENERGY`; * :psivar:`CBS CORRELATION ENERGY`; * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - No way to tell function to boost fitting basis size for all calculations. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta1, delta2, ... ) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword, or as a field",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:34101,energy,energy,34101,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,8,['energy'],['energy']
Energy Efficiency,"f ssuper.name().lower() == name.lower():; dfun = ssuper. if dfun.is_c_hybrid():. # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). if dfun.is_c_scs_hybrid():; PsiMod.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); PsiMod.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); PsiMod.dfmp2(); vdh = dfun.c_alpha() * PsiMod.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; PsiMod.dfmp2(); vdh = dfun.c_alpha() * PsiMod.get_variable('MP2 CORRELATION ENERGY'). PsiMod.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; PsiMod.set_variable('DFT TOTAL ENERGY', returnvalue); PsiMod.set_variable('CURRENT ENERGY', returnvalue). optstash.restore(). [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). PsiMod.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = PsiMod.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf_gradient(name, **kwargs). optstash.restore(). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequenc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:37014,ENERGY,ENERGY,37014,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"f test on triplet states of methylene (tda), wfn passing. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. mints-helper; A general test of the MintsHelper function. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. sapt9; usapt example with empty beta. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. fci-dipole; 6-31G H2O Test FCI Energy Point. dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). olccd-grad1; OLCCD cc-pVDZ gradient for the H2O molecule. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:43733,energy,energy,43733,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"f the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF)¶SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. EA_POLES (OCC)¶OCC — Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EFP_DISP (EFP)¶EFP — Do include dispersion energy term in EFP computation?. Type: boolean; Default: true. EFP_DISP_DAMPING (EFP)¶EFP — Fragment-fragment dispersion damping type. TT is a damping formula by Tang and Toennies. OVERLAP is overlap-based dispersion damping. Type: string; Possible Values: TT, OVERLAP, OFF; Default: OVERLAP. EFP_ELST (EFP)¶EFP — Do include electrostatics energy term in EFP computation?. Type: boolean; Default: true. EFP_ELST_DAMPING (EFP)¶EFP — Fragment-fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH (EFP)¶EFP — Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_IND (EFP)¶EFP — Do include polarization energy term in EFP computation? (EFP_POL c. v1.1). Type: boolean; Default: true. EFP_IND_DAMPING (EFP)¶EFP — Fragment-fragment polarization damping type. TT is a damping formula like Tang and Toennies. (EFP_POL_DAMPING c. v1.1). Type: string; Possible Values: TT, OFF; Default: TT. EFP_QM_ELST (EFP)¶EFP — Do include electrostatics energy term in QM/EFP computation? (QMEFP_ELST c. v1.1). Type: boolean; Default: true. EFP_QM_IND (EFP)¶EFP — Do include polarization energy term in QM/EFP computation? (QMEFP_POL c. v1.1). Type: boolean; Default: true. EKT_EA (OCC)¶OCC — Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP (DFOCC)¶DFOCC — Do compute ionization potentials based on ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:119695,charge,charge,119695,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,16,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,"f the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. remp-energy1; integral conventional REMP/cc-pVDZ energies for the H2O molecule. results were independently verified against the initial wavels implementation. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. ddd-function-kwargs; check distributed driver is correctly passing function kwargs. sapt-compare; SAPT0 aug-cc-pVDZ computation of the water-water interaction energy, using the three SAPT codes. mints3; Test individual integral objects for correctness. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cepa1; cc-pvdz H2O Test CEPA(1) Energy. dfcasscf-fzc-sp; CASSCF/6-31G** ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:35634,energy,energy,35634,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"f the original equations. Just as in; the familiar CCSD(T) method, the effects of connected triple excitations; may be included noniteratively to yield the QCISD(T) method. Both the; QCISD(T) and CCSD(T) methods are implemented for closed-shell references; in the FNOCC module. Many-body perturbation theory¶; QCI and CC methods are closely related to perturbation theory, and the; MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are then provided.; The notation MP4(SDQ) indicates that we have included all contribut",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:5609,energy,energy,5609,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,6,['energy'],['energy']
Energy Efficiency,"f the results for a computation run with the call; energy('fno-qcisd') to energy():; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are then provided.; The notation MP4(SDQ) indicates that we have included all contributions to; the correlation energy through fourth order, with the exception of that; from connected triple excitations.; One need not run a full QCISD or CCSD computation to obtain these; perturbation theory results. The keywords for invoking perturbation; theory computations are given below in; Table FNOCC Methods. Full MP4 correlation; energies are also available. Coupled electron pair approximation¶; Coupled-pair methods can be viewed as approximations to CCSD or as; size-extensive modifications of CISD. The methods have ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:6138,energy,energy,6138,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,6,['energy'],['energy']
Energy Efficiency,"f the three thresholds in both cost and accuracy.; This keyword determines screening of negligible one-electron integrals.; COSX_DENSITY_TOLERANCE controls the threshold for significant; shell pairs in the density matrix. Lastly, COSX_BASIS_TOLERANCE is; a cutoff for the value of basis functions at grid points. This keyword is; used to determine the radial extent of the each basis shell, and it is the; COSX analogue to DFT_BASIS_TOLERANCE.; The INCFOCK keyword (defaults to false) increases performance; by constructing the Fock matrix from differences in the density matrix, which; are more amenable to screening. This option is disabled by default because of; potential SCF convergence issues, particularly when using diffuse basis functions.; The COSX_OVERLAP_FITTING keyword (defaults to true) reduces numerical; integration errors using the method described in [Izsak:2011:144105] and is; always recommended. Linear Exchange¶; Large SCF calculations can benefit from specialized screening procedures that further reduce the scaling of the ERI contribution to the Fock matrix.; LinK, the linear-scaling exchange method described in [Ochsenfeld:1998:1663], is available in Psi4 in conjunction with composite algorithms that build J (SCF_TYPE set to J_alg+LINK).; LinK achieves linear-scaling by exploiting shell pair sparsity in the density matrix and overlap sparsity between shell pairs. Specifically, LinK exploits the fact that the Exchange term; requires only a linear-scaling number of significant elements through reformulating the; shell quartet screening process to scale linearly with system size.; LinK is most competitive when used with non-diffuse orbital basis sets, since orbital and density overlaps decay slower with diffuse functions.; LinK is especially powerful when combined with density-matrix based ERI screening (set SCREENING to DENSITY) and incremental Fock builds (set INCFOCK to TRUE), which decrease the number of significant two-electron integrals to calculate.; T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:37827,reduce,reduce,37827,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,3,['reduce'],['reduce']
Energy Efficiency,"f the three thresholds in both cost and accuracy.; This keyword determines screening of negligible one-electron integrals.; COSX_DENSITY_TOLERANCE controls the threshold for significant; shell pairs in the density matrix. Lastly, COSX_BASIS_TOLERANCE is; a cutoff for the value of basis functions at grid points. This keyword is; used to determine the radial extent of the each basis shell, and it is the; COSX analogue to DFT_BASIS_TOLERANCE.; The INCFOCK keyword (defaults to false) increases performance; by constructing the Fock matrix from differences in the density matrix, which; are more amenable to screening. This option is disabled by default because of; potential SCF convergence issues, particularly when using diffuse basis functions.; The COSX_OVERLAP_FITTING keyword (defaults to true) reduces numerical; integration errors using the method described in [Izsak:2011:144105] and is; always recommended. Linear Exchange¶; Large SCF calculations can benefit from specialized screening procedures that further reduce the scaling of the ERI contribution to the Fock matrix.; LinK, the linear-scaling exchange method described in [Ochsenfeld:1998:1663], is available in Psi4 in conjunction with integral-direct density fitting for Coulomb construction (SCF_TYPE set to LINK).; LinK achieves linear-scaling by exploiting shell pair sparsity in the density matrix and overlap sparsity between shell pairs. Specifically, LinK exploits the fact that the Exchange term; requires only a linear-scaling number of significant elements through reformulating the; shell quartet screening process to scale linearly with system size.; LinK is most competitive when used with non-diffuse orbital basis sets, since orbital and density overlaps decay slower with diffuse functions.; LinK is especially powerful when combined with density-matrix based ERI screening (set SCREENING to DENSITY) and incremental Fock builds (set INCFOCK to TRUE), which decrease the number of significant two-electron integrals",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/scf.html:33276,reduce,reduce,33276,psi4manual/1.7.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/scf.html,1,['reduce'],['reduce']
Energy Efficiency,"f the; coupled-pair methods implemented in PSI4. We begin with the CISD wave function. (1); where we have chosen the intermediate normalization, .; The CISD correlation energy is given by. (2); and the amplitudes can be determined by the solution to the coupled set of eqations:. (3); The CISD method is not size-extensive, but this problem can be overcome by making very simple modifications to the amplitude; equations. With malice and forethought, we replace the correlation energy, , with generalized shifts for; the doubles and singles equations, and :. (4); These shifts approximate the effects of triple and quadruple excitations.; The values for and used in several coupled-pair methods are given in Table; CEPA Shifts. Note that these shifts are defined in a spin-free formalism; for closed-shell references only. method. sdci. dci. NA. cepa(0); 0; 0. cepa(1). cepa(3). acpf. aqcc. The pair correlation energy, , is simply a partial sum of the correlation energy. In a spin-free formalism,; the pair energy is given by. (5); Methods whose shifts ( and ) do not explicitly depend on orbitals or ; (CISD, CEPA(0), ACPF, and AQCC); have solutions that render the energy stationary with respect variations in the amplitudes. This convenient property allows; density matrices and 1-electron properties to be evaluated without any additional effort.; The coupled-pair methods currently supported in PSI4 are outlined in Table CEPA Methods. name; calls method; energy; derivatives; 1-electron properties. cepa(0); coupled electron pair approximation, variant 0; Y; N; Y. cepa(1); coupled electron pair approximation, variant 1; Y; N; N. cepa(3); coupled electron pair approximation, variant 3; Y; N; N. acpf; averaged coupled-pair functional; Y; N; Y. aqcc; averaged quadratic coupled-cluster; Y; N; Y. sdci; configuration interaction with single and double excitations; Y; N; Y. dci; configuration interaction with double excitations; Y; N; Y. Basic Coupled Pair Keywords¶. BASIS¶. Primary basis s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cepa-1.html:2058,energy,energy,2058,psi4manual/4.0b3/cepa-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cepa-1.html,2,['energy'],['energy']
Energy Efficiency,"f theory. CFOUR ERROR CODE¶; The non-zero return value from a Cfour execution. CI DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory, (3,). CI QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory, (3, 3). CI ROOT n -> ROOT m DIPOLE¶; Transition dipole array [e a0] between roots n and m for the requested configuration interaction level of theory, (3,). CI ROOT n -> ROOT m QUADRUPOLE¶; Redundant transition quadrupole array [e a0^2] between roots n and m for the requested configuration interaction level of theory, (3, 3). CI ROOT n DIPOLE¶; Dipole array [e a0] for the requested configuration interaction level of theory and root n, (3,). CI ROOT n QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the requested configuration interaction level of theory and root n, (3, 3). CI ROOT n TOTAL ENERGY¶. CI ROOT n CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested configuration interaction level of theory and root; n (numbering starts at 0). CI STATE-AVERAGED TOTAL ENERGY¶. CI STATE-AVERAGED CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for state-averaged CI/CASSCF levels of theory. CI TOTAL ENERGY¶. CI CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested configuration interaction level of theory and root. CISD DIPOLE¶; Dipole array [e a0] for the configuration interaction singles and doubles level of theory, (3,). CISD QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the label",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:22103,energy,energy,22103,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency,"f two sets of independent parameters, the; idempotent part of \(\boldsymbol{\gamma_1}\) (\(\boldsymbol{\kappa}\)) and the density cumulant; (\(\boldsymbol{\lambda_2}\)). As a result, the energy functional is Hermitian,; which is important for the evaluation of the molecular properties. The additive; separability of the density cumulant guarantees that all of the DCT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent part of \(\boldsymbol{\gamma_1}\) is; N-representable by construction. One only needs to worry about the; N-representability of the density cumulant, which is a relatively small part of; \(\boldsymbol{\gamma_2}\).; In order to obtain the DCT energy, two conditions must be satisfied:. The energy must be stationary with respect to a set of orbitals. This can be done by; diagonalizing the generalized Fock operator (as in the DC-06 and DC-12 methods, see below),; which introduces partial orbital relaxation, or by fully relaxing the orbitals and minimizing the entire energy expression; (as in the ODC-06 and ODC-12 methods).; The energy must be stationary with respect to the variation of the density; cumulant \(\boldsymbol{\lambda_2}\), constrained to N-representability conditions. Making the energy stationary requires solution of two sets of coupled; equations for orbitals and density cumulant, respectively (also known as; residual equations). At the present moment, three different algorithms for the; solution of the system of coupled equations are available (see; Iterative Algorithms for details).; Publications resulting from the use of the DCT code should cite contributions; listed here. Methods¶; Currently five DCT methods (functionals) are available: DC-06, DC-12, ODC-06, ODC-12, and ODC-13. The first four; methods use approximate N-representability conditions derived from; second-order perturbation theory and differ in the description of the; correlated (non-idemp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:3982,energy,energy,3982,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,9,['energy'],['energy']
Energy Efficiency,"f two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). Note; Presently",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:10147,energy,energy,10147,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"f two-electron integrals in the evaluation of CCD T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: true. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (i.e., each monomer sees the basis functions on both monomers); vs. the monomer-centere",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:17735,charge,charge-transfer,17735,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['charge'],['charge-transfer']
Energy Efficiency,"f user_reference == 'RKS':; commands += """"""psi4.set_global_option('REFERENCE', 'UKS')\n"""""". commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec(banners); exec(p4util.format_molecule_for_input(GEOS[rgt])); exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, psi4.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); psi4.set_variable('NATOM', molecule.natom()); psi4.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); if re.match(r'^verify', lowername):; compare_values(DATA['NUCLEAR REPULSION ENERGY'][rgt], psi4.get_variable('NUCLEAR REPULSION ENERGY'),; 4, '%s %.4f' % (rgt, psi4.get_variable('NUCLEAR REPULSION ENERGY'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = psi4.get_variable(envv); psi4.set_global_option(""REFERENCE"", user_reference); psi4.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:44147,ENERGY,ENERGY,44147,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"f valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Establish treatment for delta3 correction energy; cbs_delta3_scheme = highest_1; if 'delta3_scheme' in kwargs:; cbs_delta3_scheme = kwargs['delta3_scheme']. # Establish treatment for delta4 correction energy; cbs_delta4_scheme = highest_1; if 'delta4_scheme' in kwargs:; cbs_delta4_scheme = kwargs['delta4_scheme']. # Establish treatment for delta5 correction energy; cbs_delta5_scheme = highest_1; if 'delta5_scheme' in kwargs:; cbs_delta5_scheme = kwargs['delta5_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Setup ')\n""""""; cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calcu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:77731,energy,energy,77731,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"f valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')). # Establish list of valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:76513,energy,energy,76513,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"f you require quartic force constants (for frequency calculations), you must use the ABELIAN option. Moreover, the latter work for only asymmetric tops and linear molecules. Type: string; Possible Values: ABELIAN, NONABELIAN; Default: ABELIAN. CFOUR_ANHARMONIC (CFOUR); CFOUR — Specifies treatment of anharmonic effects by calculating cubic and/or quartic force fields. VIBROT (=3) requests calculation of only those cubic constants of the form \(\phi_{nij}\), where n is a totally symmetric coordinate. These are sufficient to determine the vibration-rotation interaction constants needed to calculate vibrational corrections to rotational constants, but are not sufficient to generate the corresponding cubic constants of isotopologs that have a lower point-group symmetry (i.e. HOD isotopolog of water). VPT2 (=1, note that the old value CUBIC can be still used and is equivalent to VPT2) generates all cubic constants and all quartic constants apart from those of the form \(\phi_{ijkl}\), which is enough for: 1) generation of cubic constants of isotopologs (see manual entries associated with anharmonic calculations for an example); 2) calculation of vibrational energy levels with VPT2. This keyword also directs the program to analyze resonances and calculate intensities of one- and two-quantum transitions. FULLQUARTIC (=2) (not part of the public release) is largely self-explanatory; it directs the program to calculate all quartic constants. This is sufficient (but this has not been implemented) to generate the full quartic force field of all isotopologs. Type: string; Possible Values: CUBIC, VPT2, FULLQUARTIC, VIBROT, OFF; Default: OFF. CFOUR_AO_LADDERS (CFOUR); CFOUR — Can be used to control the algorithm used by CFOUR when terms involving \(\langle ab||cd\rangle\) molecular orbital integrals are calculated in the atomic orbital basis (see CFOUR_ABCDTYPE). MULTIPASS (= 0) uses an approach where the AO integral file is read a number of times in order to ensure maximal vector",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:21330,energy,energy,21330,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['energy'],['energy']
Energy Efficiency,"f' ; Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Moller-Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/opt-1.html:2375,energy,energy,2375,psi4manual/1.0.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/opt-1.html,2,['energy'],['energy']
Energy Efficiency,"f': 'HF TOTAL ENERGY',; 'fci': 'FCI TOTAL ENERGY'}; VARH['ccsdt'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'ccsdt': 'CCSDT TOTAL ENERGY'}; VARH['ccsdt(q)'] = {; 'hf': 'HF TOTAL ENERGY',; 'mp2': 'MP2 TOTAL ENERGY',; 'ccsdt': 'CCSDT TOTAL ENERGY',; 'ccsdt(q)': 'CCSDT(Q) TOTAL ENERGY'}. for cilevel in range(2, 99):; VARH[f'ci{cilevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'ci{cilevel}': 'CI TOTAL ENERGY'}. for mplevel in range(5, 99):; VARH[f'mp{mplevel}'] = {; 'hf': 'HF TOTAL ENERGY',; f'mp{mplevel}': f'MP{mplevel} TOTAL ENERGY'}; for mplevel2 in range(2, mplevel):; VARH[f'mp{mplevel}'][f'mp{mplevel2}'] = f'MP{mplevel2} TOTAL ENERGY'. # Integrate CFOUR methods; VARH.update(cfour_psivar_list()); return VARH; # yapf: enable. VARH = return_energy_components(). [docs]def _get_default_xtpl(nbasis: int, xtpl_type: str) -> Callable:; """""" A helper function to determine default extrapolation type. Parameters; ----------; nbasis; Number of basis sets; xtpl_type; {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; Callable; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return ""xtpl_highest_1""; elif xtpl_type == ""scf"":; if nbasis == 2:; return ""scf_xtpl_helgaker_2""; elif nbasis == 3:; return ""scf_xtpl_helgaker_3""; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return ""corl_xtpl_helgaker_2""; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata: CBSMetadata, molecule: Union[""qcdb.Molecule"", core.Molecule]) -> CBSMetadata:; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_meta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:16407,energy,energy,16407,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"f(cls, arg1, arg2, …):. …. It can be called either on the class (e.g. C.f()) or on an instance; (e.g. C().f()). The instance is ignored except for its class.; If a class method is called for a derived class, the derived class; object is passed as the implied first argument.; Class methods are different than C++ or Java static methods.; If you want those, see the staticmethod builtin. Functions¶. activate(mol); Function to set molecule object mol as the current active molecule. ancestor(dir[, n]); Get the nth ancestor of a directory. banner(text[, type, width, strNotOutfile]); Function to print text to output file in a banner of minimum width width and minimum three-line height for type = 1 or one-line height for type = 2. basis_helper(block[, name, key, set_option]); For PsiAPI mode, forms a basis specification function from block and associates it with keyword key under handle name. cbs(func, label, **kwargs); Function to define a multistage energy method from combinations of basis set extrapolations and delta corrections and condense the components into a minimum number of calculations. check_iwl_file_from_scf_type(scf_type, wfn); Ensures that a IWL file has been written based on input SCF type. compare_arrays(expected, computed, digits, label); Function to compare two numpy arrays. compare_csx(); Function to validate energies in CSX files against PSIvariables. compare_cubes(expected, computed, label); Function to compare two cube files. compare_fcidumps(expected, computed, label); Function to compare two FCIDUMP files. compare_integers(expected, computed, label); Function to compare two integers. compare_matrices(expected, computed, digits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. compare_wavefunctions(expected, computed[, …]); Fu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:308818,energy,energy,308818,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency,"f(cls, arg1, arg2, …):. …. It can be called either on the class (e.g. C.f()) or on an instance; (e.g. C().f()). The instance is ignored except for its class.; If a class method is called for a derived class, the derived class; object is passed as the implied first argument.; Class methods are different than C++ or Java static methods.; If you want those, see the staticmethod builtin. Functions¶. activate(mol); Function to set molecule object mol as the current active molecule. ancestor(dir[, n]); Get the nth ancestor of a directory. banner(text[, type, width, strNotOutfile]); Function to print text to output file in a banner of minimum width width and minimum three-line height for type = 1 or one-line height for type = 2. basis_helper(block[, name, key, set_option]); For PsiAPI mode, forms a basis specification function from block and associates it with keyword key under handle name. cbs(func, label, **kwargs); Function to define a multistage energy method from combinations of basis set extrapolations and delta corrections and condense the components into a minimum number of calculations. check_iwl_file_from_scf_type(scf_type, wfn); Ensures that a IWL file has been written based on input SCF type. compare_arrays(expected, computed, digits, label); Function to compare two numpy arrays. compare_csx(); Function to validate energies in CSX files against PSIvariables. compare_cubes(expected, computed, label); Function to compare two cube files. compare_fcidumps(expected, computed, label); Function to compare two FCIDUMP files. compare_integers(expected, computed, label); Function to compare two integers. compare_matrices(expected, computed, digits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. copy_file_from_scratch(filename, prefix, …); Funct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:257664,energy,energy,257664,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency,"f, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *dimensions* Dimensionality of the system; """"""; dimensions = [1, 1, 1]; MDI_Send(dimensions, 3, MDI_INT, self.comm); return dimensions. # Respond to the <TOTCHARGE command; def send_total_charge(self):; """""" Send the total system charge through MDI. :returns: *charge* Total charge of the system; """"""; charge = self.molecule.molecular_charge(); MDI_Send(charge, 1, MDI_DOUBLE, self.comm); return charge. # Respond to the >TOTCHARGE command; def recv_total_charge(self, charge=None):; """""" Receive the total system charge through MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:10957,charge,charge,10957,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,14,['charge'],['charge']
Energy Efficiency,"f-b3lyp-d'; #'df-b3lyp-d3'; #'df-wb97x-d'. [docs]def muster_cdsgroup_options():; text = ''; options = defaultdict(lambda: defaultdict(dict)); options['GLOBALS']['E_CONVERGENCE']['value'] = 8; options['SCF']['GUESS']['value'] = 'sad'; options['SCF']['MAXITER']['value'] = 200. return text, options. [docs]def muster_modelchem(name, dertype):; """"""Transform calculation method *name* and derivative level *dertype*; into options for cfour. While deliberately requested pieces,; generally |cfour__cfour_deriv_level| and |cfour__cfour_calc_level|,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, like |cfour__cfour_cc_program|, can be; countermanded by keywords in input file ('clobber' set to False).; Occasionally, want these pieces to actually overcome keywords in; input file ('superclobber' set to True). """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)). if dertype == 0:; text += """"""energy('""""""; else:; raise ValidationError(""""""Requested Psi4 dertype %d is not available."""""" % (dertype)). if lowername == 'mp2':; options['GLOBALS']['FREEZE_CORE']['value'] = True; options['SCF']['SCF_TYPE']['value'] = 'direct'; options['MP2']['MP2_TYPE']['value'] = 'conv'; text += """"""mp2')\n\n"""""". elif lowername == 'df-mp2':; options['GLOBALS']['FREEZE_CORE']['value'] = True; options['SCF']['SCF_TYPE']['value'] = 'df'; options['MP2']['MP2_TYPE']['value'] = 'df'; text += """"""mp2')\n\n"""""". elif lowername == 'sapt0':; options['GLOBALS']['FREEZE_CORE']['value'] = True; options['SCF']['SCF_TYPE']['value'] = 'df'; text += """"""sapt0')\n\n"""""". elif lowername == 'sapt2+':; options['GLOBALS']['FREEZE_CORE']['value'] = True; options['SCF']['SCF_TYPE']['value'] = 'df'; options['SAPT']['NAT_ORBS_T2']['value'] = True; options['SAPT']['NAT_ORBS_T3']['value'] = True; options['SAPT']['NAT_ORBS_V4']['value'] = True; options['SAPT']['OCC_TOLERANCE']['value'] = 1.0e-6; text += """"""sapt2+')\n\n"""""". elif lowername == 'sapt2+(3)':; option",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html:6121,energy,energy,6121,psi4manual/1.0.0/_modules/qcdb/psi4.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html,1,['energy'],['energy']
Energy Efficiency,"f-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/kw-2; testing best practices options, part ii. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_cfour-1.html:2434,energy,energy,2434,psi4manual/1.4.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"f-sapt; 0th-order spin-flip SAPT [manual]. sapt(dft); 0th-order SAPT upon KS reference [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispersion [manual]. sapt2+(3)(ccd); SAPT2+(3) with CC-based dispersion [manual]. sapt2+3(ccd); SAPT2+3 with CC-based dispersion [manual]. sapt2+dmp2; SAPT including all 2nd-order terms and MP2 correction [manual]. sapt2+(3)dmp2; SAPT including perturbative triples and MP2 correction [manual]. sapt2+3dmp2; SAPT including all 3rd-order terms and MP2 correction [manual]. sapt2+(ccd)dmp2; SAPT2+ with CC-based dispersion and MP2 correction [manual]. sapt2+(3)(ccd)dmp2; SAPT2+(3) with CC-based dispersion and MP2 correction [manual]. sapt2+3(ccd)dmp2; SAPT2+3 with CC-based dispersion and MP2 correction [manual]. sapt0-ct; 0th-order SAPT plus charge transfer (CT) calculation [manual]. sapt2-ct; SAPT2 plus CT [manual]. sapt2+-ct; SAPT2+ plus CT [manual]. sapt2+(3)-ct; SAPT2+(3) plus CT [manual]. sapt2+3-ct; SAPT2+3 plus CT [manual]. sapt2+(ccd)-ct; SAPT2+(CCD) plus CT [manual]. sapt2+(3)(ccd)-ct; SAPT2+(3)(CCD) plus CT [manual]. sapt2+3(ccd)-ct; SAPT2+3(CCD) plus CT [manual]. adc; 2nd-order algebraic diagrammatic construction (ADC), deprecated [manual]. adc(1); (with ADCC) 1st-order algebraic diagrammatic construction (ADC) [manual]. adc(2); (with ADCC) 2nd-order ADC [manual]. adc(2)-x; (with ADCC) extended 2nd-order ADC [manual]. adc(3); (with ADCC) 3rd-order ADC [manual]. cvs-adc(1); (with ADCC) core-valence separation (CVS) 1st-order ADC [manual]. cvs-adc(2); (with ADCC) CVS 2nd-order ADC [manual]. cvs-adc(2)-x; (with ADCC) CVS extended 2nd-order ADC [manual]. cvs-adc(3); (with ADCC) CVS 3rd-order ADC [manual]. ep2; 2nd-order electron propagator theory. eom-cc2; equation of motion (EOM) CC2 [manual]. eom-ccsd; EOM-CCSD [manual]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.energy.html:7606,charge,charge,7606,psi4manual/1.7.x/api/psi4.driver.energy.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.energy.html,12,['charge'],['charge']
Energy Efficiency,"f.fsymbol(at) == ""X"":; pass; else:; if self.fZ(at):; text += ""%-8s"" % (self.flabel(at)); else:; text += ""%-8s"" % (""Gh("" + self.flabel(at) + "")""); [x, y, z] = self.full_atoms[at].compute(); text += '%17.12f %17.12f %17.12f\n' % \; (x * factor, y * factor, z * factor); text += ""\n"". wtext = 'molecule mol {\n'; for line in text.splitlines():; wtext += ' ' + line + '\n'; wtext += '}\n'; return wtext. def format_molecule_for_molpro(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2angstroms; # TODO keep fix_or? # Jan 2015 turning off fix_or; #self.fix_orientation(True); #self.PYmove_to_com = False; self.update_geometry(). text = """"; text += 'angstrom\n'; text += 'geometry={\n'; dummy = []. for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%-2s %17.12f %17.12f %17.12f\n' % (self.symbol(i),; x * factor, y * factor, z * factor); if not self.Z(i):; dummy.append(str(i + 1)) # Molpro atom number is 1-indexed. text += '}\n\n'; text += 'SET,CHARGE=%d\n' % (self.molecular_charge()); text += 'SET,SPIN=%d\n' % (self.multiplicity() - 1) # Molpro wants (mult-1); if len(dummy) > 0:; text += 'dummy,' + ','.join(dummy) + '\n'; return text. def format_molecule_for_cfour(self):; """"""Function to print Molecule in a form readable by Cfour. """"""; self.update_geometry(); factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2angstroms; #factor = 1.0 if self.PYunits == 'Bohr' else 1.0/psi_bohr2angstroms. text = 'auto-generated by qcdb from molecule %s\n' % (self.tagline). # append atoms and coordentries; for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%-2s %17.12f %17.12f %17.12f\n' % ((self.symbol(i) if self.Z(i) else ""GH""),; x * factor, y * factor, z * factor). #for fr in range(self.nfragments()):; # if self.fragment_types[fr] == 'Absent':; # pass; # else:; # for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; # [x, y, z] = self.atoms[at].compute(); # text += '%-2s %17.12f %",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:15234,CHARGE,CHARGE,15234,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,3,['CHARGE'],['CHARGE']
Energy Efficiency,"f.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_results. [docs] def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Composite-flavored QCSchema."""""". assembled_results = self._prepare_results(client=client); E0 = assembled_results[""energy""]. # load QCVariables & properties; qcvars = {; 'CBS NUMBER': len(self.compute_list),; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. for qcv in ['CBS', 'CURRENT']:; qcvars[qcv + ' REFERENCE ENERGY'] = self.cbsrec[0]['d_energy']; qcvars[qcv + ' CORRELATION ENERGY'] = E0 - self.cbsrec[0]['d_energy']; qcvars[qcv + ('' if qcv == 'CURRENT' else ' TOTAL') + ' ENERGY'] = E0. for idelta in range(int(len(self.cbsrec) / 2)):; if idelta == 0:; continue; dc = idelta * 2 + 1; qcvars[f""CBS {self.cbsrec[dc]['d_stage'].upper()} TOTAL ENERGY""] = self.cbsrec[dc][""d_energy""] - self.cbsrec[dc + 1][""d_energy""]. G0 = assembled_results[""gradient""]; if G0 is not None:; qcvars[""CURRENT GRADIENT""] = G0; qcvars[""CBS TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = assembled_results[""hessian""]; if H0 is not None:; qcvars[""CURRENT HESSIAN""] = H0; qcvars[""CBS TOTAL HESSIAN""] = H0; properties[""return_hessian""] = H0. D0 = assembled_results[""dipole""]; if D0 is not None:; qcvars[""CURRENT DIPOLE""] = D0; qcvars[""CBS DIPOLE""] = D0. DD0 = assembled_results[""dipole gradient""]; if DD0 is not None:; qcvars[""CURRENT DIPOLE GRADIENT""] = DD0; qcvars[""CBS DIPOLE GRADIENT""] = DD0. cbs_model = AtomicResult(; **{; 'driver': self.driver,; #'keywords': self",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:59101,ENERGY,ENERGY,59101,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"f/psi4/core-dot-so:$PYTHONPATH. >>> python -c ""import psi4"". >>> python -c ""import psi4;print(psi4.__file__, psi4.__version__)"". How to run Psi4 as Python module after compilation¶; Substituting the full installation directory prefix and a; suitable scratch directory, issue the following commands directly in your; terminal or place them into your “rc” file and open a new terminal. (To; use a staged installation directory, substitute; objdir/stage for prefix.); # csh, tcsh: add to shell or ~/.tcshrc file; setenv PYTHONPATH {prefix}/lib:$PYTHONPATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PYTHONPATH={prefix}/lib:$PYTHONPATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. How to configure paths for PsiAPI. Run PSI4.; >>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable or Python module from conda installation¶; The configuration commands below are generic versions of the ones printed; to your screen as advice upon installing PSI4 into a Anaconda,; Miniconda, or Psi4conda distribution, condadist =; ana|mini|psi4conda. To see the message again after initial installation,; with the conda environment active, run .psi4-post-link.sh.; If which conda python psi4 points to your; condadist and echo $PSI_SCRATCH is set, skip ahead to the; “Run PSI4"" commands below. Otherwise, issue the following; commands directly in your terminal or place them into your “rc” file and; open a new terminal.; If you installed the Psi4conda distribution or installed the PSI4; conda package into the main environment of an Anaconda or Miniconda; distribution and a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:28467,energy,energy,28467,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,9,['energy'],['energy']
Energy Efficiency,"f: psi4.core.Molecule) → int¶; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int¶; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to a specified origin. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]]=[0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, arg0: List[float[3]]) → psi4.core.Matrix¶; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule) → psi4.core.PointGroup¶; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule) → None¶; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule) → None¶; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule) → None¶; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:136333,energy,energy,136333,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,3,['energy'],['energy']
Energy Efficiency,"f: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diis(self: psi4.core.HF, arg0: float) → bool¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbital energies should be returned?. Returns; A Pitzer-ordered vector of the orbitals. Return type; Vector. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Beta orbital energies sub",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:20344,energy,energy,20344,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,10,['energy'],['energy']
Energy Efficiency,"f; DSD-PBEP86 S22 Ammonia test. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. casscf-sp; CASSCF/6-31G** energy point. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. dft-jk; DFT JK on-disk test. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:1749,energy,energy,1749,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"f; properties to compute. The available properties are shown in the table above.; The syntax above works well for computing properties using the SCF; wavefunction, however, may be difficult (or impossible) to use for some of the; correlated levels of theory. Alternatively, one-electron properties can be; computed using the built-in property() function, e.g.:; property('ccsd', properties=['dipole']). The property() function provides limited functionality, but is a lot easier to; use for correlated methods. For capabilities of property() see the; corresponding section of the manual. Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications¶. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Properties evaluated on a grid¶; Certain properties may be evaluated a user-specified grid points. The grid; points are completely arbitrary and are specified by providing a file called; grid.dat containing the x,y,z values seperated with spaces for each point in order:; x1 y1 z1; x2 y2 z2; ..........; xn yn zn. The grid.dat file is completely free form; any number of spaces and/or newlines; between entries is permitted. The units of the coordinates in grid.dat are the; same as those used to specify the molecule’s geometry, and the output; quantities are always in atomic units. The requested properties will be; written out in the same order as the grid point specification in grid.dat; see; the above table for the format and file name of the output. Table Of Contents. oeprop() Evaluation of One-Electron Properties; Basic Keywords; Properties evaluated on a grid. Previous topic; Geometry Optimization; Next topic; Vibrational and Thermochemical Analysis. Th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/oeprop-1.html:3772,charge,charge,3772,psi4manual/1.0.0/oeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/oeprop-1.html,2,['charge'],['charge']
Energy Efficiency,"f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.8.2;  · . PSI4. Module code; psi4.driver.wrapper_database. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:22060,Energy,Energy,22060,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,1,['Energy'],['Energy']
Energy Efficiency,"f\n"""""" % ('RMS Dev', '', RMSDerror, RMSDerror * constants.cal2J); tables += """""" %s\n"""""" % (table_delimit). core.set_variable('%s DATABASE MEAN SIGNED DEVIATION' % (db_name), MSDerror); core.set_variable('%s DATABASE MEAN ABSOLUTE DEVIATION' % (db_name), MADerror); core.set_variable('%s DATABASE ROOT-MEAN-SQUARE DEVIATION' % (db_name), RMSDerror). core.print_out(tables); finalenergy = MADerror. else:; finalenergy = 0.0. optstash.restore(). DB_RGT.clear(); DB_RGT.update(VRGT); DB_RXN.clear(); DB_RXN.update(VRXN); return finalenergy. def _tblhead(tbl_maxrgt, tbl_delimit, ttype):; r""""""Function that prints the header for the changable-width results tables in db().; *tbl_maxrgt* is the number of reagent columns the table must plan for. *tbl_delimit*; is a string of dashes of the correct length to set off the table. *ttype* is 1 for; tables comparing the computed values to the reference or 2 for simple tabulation; and sum of the computed values. """"""; tbl_str = ''; tbl_str += """""" %s"""""" % (tbl_delimit); if ttype == 1:; tbl_str += """"""\n%23s %19s %21s"""""" % ('Reaction', 'Reaction Energy', 'Reaction Error'); elif ttype == 2:; tbl_str += """"""\n%23s %19s %17s"""""" % ('Reaction', 'Reaction Value', ''); for i in range(tbl_maxrgt):; tbl_str += """"""%20s"""""" % ('Reagent ' + str(i + 1)); if ttype == 1:; tbl_str += """"""\n%23s %8s %8s %10s %10s"""""" % ('', 'Ref', 'Calc', '[kcal/mol]', '[kJ/mol]'); elif ttype == 2:; tbl_str += """"""\n%65s"""""" % (''); for i in range(tbl_maxrgt):; if ttype == 1:; tbl_str += """"""%20s"""""" % ('[Eh] Wt'); elif ttype == 2:; tbl_str += """"""%20s"""""" % ('Value Wt'); tbl_str += """"""\n %s"""""" % (tbl_delimit); return tbl_str. ## Aliases ##; db = database. #######################; ## End of Database ##; #######################. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.9.1;  · . PSI4. Module code; psi4.driver.wrapper_database. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/wrapper_database.html:22038,Energy,Energy,22038,psi4manual/1.9.x/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/wrapper_database.html,1,['Energy'],['Energy']
Energy Efficiency,"f_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy = %20.15f\n"" % scf_e); if ""CI"" in rname:; core.print_out("" Total CI energy = %20.15f\n"" % ci_e); elif ""MP"" in rname:; core.print_out("" Total MP energy = %20.15f\n"" % ci_e); elif ""ZAPT"" in rname:; core.print_out("" Total ZAPT energy = %20.15f\n"" % ci_e); else:; core.print_out("" Total MCSCF energy = %20.15f\n"" % ci_e). # Nothing to be done for ZAPT or MP; if (""MP"" in rname) or (""ZAPT"" in rname):; core.print_out(""\n""); return. # Initial info; ci_nroots = core.get_option(""DETCI"", ""NUM_ROOTS""); irrep_labels = ciwfn.molecule().irrep_labels(). # Grab the D-vector; dvec = ciwfn.D_vector(); dvec.init_io_files(True). for root in range(ci_nroots):; core.print_out(""\n ==> %s root %d information <==\n\n"" % (rname, root)). # Print total energy; root_e = ciwfn.variable(""CI ROOT %d TOTAL ENERGY"" % (root)); core.print_out("" %s Root %d energy = %20.15f\n"" % (rname, root, root_e)). # Print natural occupations; if print_opdm_no:; core.print_out(""\n Active Space Natural occupation numbers:\n\n""). occs_list = []; r_opdm = ciwfn.get_opdm(root, root, ""SUM"", False); for h in range(len(r_opdm.nph)):; if 0 in r_opdm.nph[h].shape:; continue; nocc, rot = np.linalg.eigh(r_opdm.nph[h]); for e in nocc:; occs_list.append((e, irrep_labels[h])). occs_list.sort(key=lambda x: -x[0]). cnt = 0; for value, label in occs_list:; value, label = occs_list[cnt]; core.print_out("" %4s % 8.6f"" % (label, value)); cnt += 1; if (cnt % 3) == 0:; core.print_out(""\n""). if (cnt % 3):; core.print_out(""\n""). # Print CIVector information; ciwfn.print_vector(dvec, root). # True to keep the file; dvec.close_io_files(True). def prepare_sapt_molecule(sapt_dimer: core.Molecule, sapt_basis: str) -> Tuple[core.Molecule, core.Molecule, core.Molecule]:; """"""; Prepares a dimer molecule for a SAPT computations. Returns the dimer, monomerA, and monomerB.; """""". # S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html:5717,energy,energy,5717,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,6,['energy'],['energy']
Energy Efficiency,"f_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; G0 = gradient(lowername, molecule=molecule, **kwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # Does an analytic procedure exist for the requested method?; if dertype == 2:; core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); wfn.set_gradient(G0); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()). elif dertype == 1:; core.print_out(; """"""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_gradient_geometries(molecule, irrep). # Record undisplaced symmetry for projection of displaced point groups; core.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:65779,energy,energy,65779,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"f_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; G0 = gradient(lowername, molecule=molecule, **kwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # Does an analytic procedure exist for the requested method?; if dertype == 2:; core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); wfn.set_gradient(G0); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); wfn.set_variable('CURRENT ENERGY', wfn.energy()). elif dertype == 1:; core.print_out(; """"""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_gradients_geometries(molecule, irrep). # Record undisplaced symmetry for projection of displaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacemen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:78444,energy,energy,78444,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['energy'],['energy']
Energy Efficiency,"f_ints_io = psi4.get_global_option(""DF_INTS_IO""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = psi4.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf'); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. mol.set_molecular_charge(chargem); mol.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if (hf_guess):; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf'); psi4.set_global_option(""REFERENCE"",""UKS""); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True); psi4.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:. psi4.set_global_option(""FRAC_OCC"", [LUMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E = energy('scf'); C = 1; if (E == 0.0):; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = psi4.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = psi4.wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(LUMO)-1]). occs.append(occ); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if (not continuous_guess):; psi4.set_global_option(""GUESS"", old_guess); if (hf_guess):; psi4.set_global_option(""FRAC_START"", 0); psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf'); psi4.set_global_option(""REFERENCE"",""UKS""); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""FRAC_LOAD"", False). psi4.set_global_option(""FRAC_START"", frac_st",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/frac.html:4431,ENERGY,ENERGY,4431,psi4manual/4.0b5/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/frac.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"f_scheme: function; :param scf_scheme: |dl| ``highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy. :type corl_scheme: function; :param corl_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy. :type delta_scheme: function; :param delta_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy. :type delta2_scheme: function; :param delta2_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. :type delta3_scheme: function; :param delta3_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy. :type delta4_scheme: function; :param delta4_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. :type delta5_scheme: function; :param delta5_scheme: |dl| ``highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:61205,energy,energy,61205,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"f_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True,; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom. PSIthonPsiAPImolecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print (""De = %f"" % D_e). h2 = psi4.geometry(""""""; H; H 1 0.9; """"""). psi4.set_options({""basis"": ""cc-pvdz"",; ""reference"": ""rhf""}); h2_energy = psi4.energy('scf'). h = psi4.geometry(""""""; H; """"""). psi4.set_options({""basis"": ""cc-pvdz"",; ""reference"": ""uhf""}); h_energy = psi4.energy('scf'). D_e = psi4.constants.hartree2kcalmol * (2*h_energy - h2_energy); print(""De = %f"" % D_e). The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available. PSIthonPsiAPIe_mp2 = variable('MP2 TOTAL ENERGY'); e_scs_mp2 = variable('SCS-MP2 TOTAL ENERGY'). e_mp2 = psi4.variable('MP2 TOTAL ENERGY'); e_scs_mp2 = psi4.variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:8357,energy,energy,8357,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['energy'],['energy']
Energy Efficiency,f_von_Klitzing_constant; 25812.807; conventional value of von Klitzing constant [ohm] uncertainty=(exact). Cu_x_unit; 1.00207697E-13; Cu x unit [m] uncertainty=0.000 000 28 e-13. deuteron_electron_mag_mom_ratio; -0.0004664345535; deuteron-electron mag. mom. ratio [] uncertainty=0.000 000 026 e-4. deuteron_electron_mass_ratio; 3670.48296785; deuteron-electron mass ratio [] uncertainty=0.000 000 13. deuteron_g_factor; 0.8574382311; deuteron g factor [] uncertainty=0.000 000 0048. deuteron_mag_mom; 4.330735040E-27; deuteron mag. mom. [J T^{-1}] uncertainty=0.000 000 0036 e-26. deuteron_mag_mom_to_Bohr_magneton_ratio; 0.0004669754554; deuteron mag. mom. to Bohr magneton ratio [] uncertainty=0.000 000 0026 e-3. deuteron_mag_mom_to_nuclear_magneton_ratio; 0.8574382311; deuteron mag. mom. to nuclear magneton ratio [] uncertainty=0.000 000 0048. deuteron_mass; 3.343583719E-27; deuteron mass [kg] uncertainty=0.000 000 041 e-27. deuteron_mass_energy_equivalent; 3.005063183E-10; deuteron mass energy equivalent [J] uncertainty=0.000 000 037 e-10. deuteron_mass_energy_equivalent_in_MeV; 1875.612928; deuteron mass energy equivalent in MeV [MeV] uncertainty=0.000 012. deuteron_mass_in_u; 2.013553212745; deuteron mass in u [u] uncertainty=0.000 000 000 040. deuteron_molar_mass; 0.002013553212745; deuteron molar mass [kg mol^{-1}] uncertainty=0.000 000 000 040 e-3. deuteron_neutron_mag_mom_ratio; -0.44820652; deuteron-neutron mag. mom. ratio [] uncertainty=0.000 000 11. deuteron_proton_mag_mom_ratio; 0.3070122077; deuteron-proton mag. mom. ratio [] uncertainty=0.000 000 0015. deuteron_proton_mass_ratio; 1.99900750087; deuteron-proton mass ratio [] uncertainty=0.000 000 000 19. deuteron_rms_charge_radius; 2.1413E-15; deuteron rms charge radius [m] uncertainty=0.0025 e-15. electric_constant; 8.854187817E-12; electric constant [F m^{-1}] uncertainty=(exact). electron_charge_to_mass_quotient; -1.758820024E+11; electron charge to mass quotient [C kg^{-1}] uncertainty=0.000 000 011 e11. el,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:7974,energy,energy,7974,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['energy'],['energy']
Energy Efficiency,"f_wfn (string) – \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as ‘scf’ is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string) – \(\Rightarrow\) delta2_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string) – \(\Rightarrow\) delta3_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:4526,energy,energy,4526,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,14,['energy'],['energy']
Energy Efficiency,"f_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). fnocc_wfn = core.fnocc(ref_wfn). optstash.restore(); return fnocc_wfn. def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); level = kwargs.get('level', 0). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC', 'RUN_CCSD'],; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'COMPUTE_MP4_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'NAT_ORBS']). core.set_local_option('FNOCC', 'DFCC', False); core.set_local_option('FNOCC', 'RUN_CEPA', False); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # which method?; if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'RUN_CCSD', True); elif name == 'ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'RUN_CCSD', True); elif name == 'fno-ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'RUN_CCSD', True); core.set_local_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:120571,energy,energy,120571,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,2,['energy'],['energy']
Energy Efficiency,"f_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:78201,ENERGY,ENERGY,78201,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,21,['ENERGY'],['ENERGY']
Energy Efficiency,"face to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. Table Of Contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; FROZEN_UOCC; MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Previous topic; Interface to MRCC by M. Kállay; Next topic; Geometry Optimization; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/detci-1.html:11158,energy,energy,11158,psi4manual/4.0b3/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/detci-1.html,2,['energy'],['energy']
Energy Efficiency,"fault overwritten by keyword; set cfour_calc_level ccsd; set cfour_cc_program ecc; energy('cfour'). runs in ecc since that’s best practice for the requested ccsd; energy('c4-ccsd'). runs in vcc since hidden default overwritten by keyword; set cfour_cc_program vcc; energy('c4-ccsd'). Specifying certain keywords that are nominally applicable for pure-Psi4 modules directs them to fulfil analogous roles; in the Cfour program (e.g., MAXITER is used to set; CFOUR_SCF_MAXCYC). This keyword translation only takes place; if the keywords are explicitly set in the input file (part of that; contract that you mean it), meaning that Psi4‘s defaults don’t; get imposed on Cfour. Also, in the case where a translatable pure-Psi4 keyword and its translation Cfour keyword are both set,; the value attached to the latter is always used. Below are a few; clarifying examples. uses SCF conv crit since that’s Cfour’s default; for CFOUR_SCF_CONV; energy('c4-scf'). uses SCF conv crit since default overwritten by; keyword; set cfour_scf_conv 6; energy('c4-scf'). uses SCF conv crit since default overwritten by; SCF module keyword; set d_convergence 5; energy('c4-scf'). uses SCF conv crit since default overwritten by; SCF module keyword (local scope works, too) where; the Psi4‘s more flexible float input has been rounded down to; the integer required by Cfour; set scf d_convergence 5e-6; energy('c4-scf'). uses SCF conv crit since default overwritten; and Cfour module keyword trumps Psi4 SCF module keyword; set cfour_scf_conv 6; set d_convergence 8; energy('c4-scf'). The keyword translation feature is still in the proof-of-principle; stage, so only a handful (found here) of keywords participate. Note; Longtime Cfour users who may consider this keyword; translation a flaw rather than a feature can avoid it entirely by; confining keywords to the Cfour module along with; BASIS and PUREAM (opt, too?). Misc. Running¶; Naturally, in Psi4 multiple jobs can be run in succession from the input file.; Contr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:33270,energy,energy,33270,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"fault: No Default. DOMAIN_PRINT (CIS); CIS — Do print the domains?. Type: boolean; Default: false. DOMAIN_PRINT_EXIT (LMP2); LMP2 — Do exit after printing the domains?. Type: boolean; Default: false. DOMAINS (CIS); CIS —. Type: array; Default: No Default. E3_SCALE (OMP3); OMP3 — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-8. E_CONVERGENCE (DETCI); DETCI — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (LMP2); LMP2 — Convergence criterion for energy (change). Type: conv double; Default: 1e-7. E_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (MRCC); MRCC — This becomes tol (option #16) in fort.56. Type: conv double; Default: 1e-8. E_CONVERGENCE (OMP2); OMP2 — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (OMP3); OMP3 — Convergence criterion for energy. Type: conv double; Default: 1e-8. E_CONVERGENCE (PSIMRCC); PSIMRCC — Convergence criterion for energy. Type: conv double; Default: 1e-9. E_CONVERGENCE (SAPT); SAPT — Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. E_CONVERGENCE (SCF); SCF — Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. EOM_GUESS (CCEOM); CCEOM — Specifies a set of single-excitation guess vectors for the EOM-CC procedure. If EOM_GUESS = SINGLES, the guess will be taken from the singles-singles block of the similarity-transformed Hamiltonian, Hbar. If EOM_GUESS = DISK, guess vectors from a previous computation will be read from disk. If EOM_GUESS = INPUT, guess vectors will be specif",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:36181,energy,energy,36181,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"faults to decontracted orbital basis. Type: string; Default: No Default. BENCH¶. Some codes (DFT) can dump benchmarking data to separate output files. Type: integer; Default: 0. BRIANQC_ENABLE¶. Whether to enable using the BrianQC GPU module. Type: boolean; Default: false. CC_TYPE¶. Algorithm to use for CC or CEPA computation (e.g., CCD, CCSD(T), CEPA(3), ACPF). See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: CONV. CI_TYPE¶. Algorithm to use for CI computation (e.g., CID or CISD). See Cross-module Redundancies for details. Type: string; Possible Values: CONV; Default: CONV. CUBEPROP_BASIS_FUNCTIONS¶. List of basis function indices for which cube files are generated (1-based). All basis functions computed if empty. Type: array; Default: No Default. CUBEPROP_FILEPATH¶. Directory to which to write cube files. Default is the input file directory. Type: string; Default: No Default. CUBEPROP_ISOCONTOUR_THRESHOLD¶. Fraction of density captured by adaptive isocontour values. Type: double; Default: 0.85. CUBEPROP_ORBITALS¶. List of orbital indices for which cube files are generated (1-based, \(+\) for alpha, \(-\) for beta). All orbitals computed if empty. Type: array; Default: No Default. CUBEPROP_TASKS¶. Properties to compute. Valid tasks include: DENSITY - Da, Db, Dt, Ds; ESP - Dt, ESP; ORBITALS - Psi_a_N, Psi_b_N; BASIS_FUNCTIONS - Phi_N; LOL - LOLa, LOLb; ELF - ELFa, ELFb; FRONTIER_ORBITALS - Psi_a_N_HOMO + Psi_a_N_LUMO; DUAL_DESCRIPTOR - DUAL_N_HOMO-M_LUMO. Type: array; Default: No Default. CUBIC_GRID_OVERAGE¶. CubicScalarGrid spatial extent in bohr [O_X, O_Y, O_Z]. Defaults to 4.0 bohr each. Type: array; Default: No Default. CUBIC_GRID_SPACING¶. CubicScalarGrid grid spacing in bohr [D_X, D_Y, D_Z]. Defaults to 0.2 bohr each. Type: array; Default: No Default. DF_BASIS_CC¶. The density fitting basis to use in coupled cluster computations. Type: string; Possible Values: basis string; Default: No Default. DOCC¶. An array co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__globals-1.html:1438,adapt,adaptive,1438,psi4manual/1.4.0/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__globals-1.html,10,['adapt'],['adaptive']
Energy Efficiency,"fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/kw-2; testing best practices options, part ii. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/sp-rhf-ccs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_cfour.html:3191,energy,energy,3191,psi4manual/1.8.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_cfour.html,1,['energy'],['energy']
Energy Efficiency,"fchk()¶; Code author: Andrew C. Simmonett; Section author: Andrew C. Simmonett; Many post-processing tools can read information from Gaussian’s formatted; checkpoint (FCHK) files.; To allow interoperability with such tools, PSI4 includes a utility to; generate FCHK files. Wavefunction information, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and use it to create an FCHK writer:; 1; 2; 3energy, wfn = energy('scf', return_wfn=True); fchk_writer = psi4.FCHKWriter(wfn); fchk_writer.write('output.fchk'). The file will be written to the name passed to the FCHK writer’s write(); method. Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree–Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; 1; 2; 3grad, wfn = gradient('mp2', return_wfn=True); fchk_writer = psi4.FCHKWriter(wfn); fchk_writer.write('output.fchk'). psi4.fchk(wfn, filename)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:None. Parameters:; filename (string) – destination file name for FCHK file; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file. Examples:. 1; 2; 3>>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fchk-1.html:1916,energy,energy,1916,psi4manual/1.1.0/fchk-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fchk-1.html,2,['energy'],['energy']
Energy Efficiency,"fchk(wfn, filename, *, debug=False, strict_label=True)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. Added in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., “Total SCF|MP2|CI|CC Density”,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the ‘Orbital Energy’ field contains ambiguous data. Examples:. Parameters:. wfn (Wavefunction); filename (str); debug (bool); strict_label (bool). >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). table of contents. fchk; fchk(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; fchk. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.fchk.html:1496,energy,energy,1496,psi4manual/master/api/psi4.driver.fchk.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.fchk.html,3,"['Energy', 'energy']","['Energy', 'energy']"
Energy Efficiency,"fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. sapt3; SAPT2+3(CCD) aug-cc-pVDZ computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ CH2 single-point energy (fzc, MO-basis ). dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. fd-gradient; SCF STO-3G finite-difference tests. psimrcc-sp1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. pywrap-db3; Test that Python Molecule class processes geometr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:7947,energy,energy,7947,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. fci-h2o; 6-31G H2O Test FCI Energy Point. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. cepa1; cc-pvdz H2O Test CEPA(1) Energy. ao-casscf-sp; CASSCF/6-31G** energy point. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. tdscf-6; td-camb3lyp with DiskDF and method/basis specification. cubeprop; RHF orbitals and density for water. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:13386,energy,energy,13386,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"fective, as the Cfour optimizer is never invoked. Psi4; optimization keywords (e.g., GEOM_MAXITER) instead fill; these roles. Specifying the computational method (through, for instance,; energy('c4-ccsd') instead of energy('cfour')) often; sets additional keywords consistent with best practices (e.g.,; CFOUR_CC_PROGRAM). Since those settings are implicit, any; explicit setting of those those keywords, whether contradicting or; concurring, takes priority (halts never generated). The following are; some concrete examples. For the moment, click the source button at; qcdb.cfour.muster_modelchem() for details of what keywords; get set. runs in vcc since that’s Cfour’s default for cc_program; set cfour_calc_level ccsd; energy('cfour'). runs in ecc since Cfour’s default overwritten by keyword; set cfour_calc_level ccsd; set cfour_cc_program ecc; energy('cfour'). runs in ecc since that’s best practice for the requested ccsd; energy('c4-ccsd'). runs in vcc since hidden default overwritten by keyword; set cfour_cc_program vcc; energy('c4-ccsd'). Specifying certain keywords that are nominally applicable for pure-Psi4 modules directs them to fulfil analogous roles; in the Cfour program (e.g., MAXITER is used to set; CFOUR_SCF_MAXCYC). This keyword translation only takes place; if the keywords are explicitly set in the input file (part of that; contract that you mean it), meaning that Psi4‘s defaults don’t; get imposed on Cfour. Also, in the case where a translatable pure-Psi4 keyword and its translation Cfour keyword are both set,; the value attached to the latter is always used. Below are a few; clarifying examples. uses SCF conv crit since that’s Cfour’s default; for CFOUR_SCF_CONV; energy('c4-scf'). uses SCF conv crit since default overwritten by; keyword; set cfour_scf_conv 6; energy('c4-scf'). uses SCF conv crit since default overwritten by; SCF module keyword; set d_convergence 5; energy('c4-scf'). uses SCF conv crit since default overwritten by; SCF module keyword (local",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:32503,energy,energy,32503,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"fects the “Q” matrix in Helgaker’s language. Defaults to a JKFIT basis. Type: string; Possible Values: basis string; Default: No Default. MCSCF_ALGORITHM¶. Convergence algorithm to utilize. Two-Step, Augmented Hessian. Defaults to TS for RASSCF. Type: string; Possible Values: TS, AH; Default: TS. MCSCF_CI_CLEANUP¶. Cleanup the CI info at the end of a run?. Type: boolean; Default: true. MCSCF_DIIS_ERROR_TYPE¶. DIIS error vector type either, the AO orbital gradient or the orbital rotation update matrix. Type: string; Possible Values: GRAD, UPDATE; Default: GRAD. MCSCF_DIIS_FREQ¶. How often to do a DIIS extrapolation for TS convergence. Type: integer; Default: 1. MCSCF_DIIS_MAX_VECS¶. Maximum number of DIIS vectors for TS convergence. Type: integer; Default: 8. MCSCF_DIIS_START¶. Iteration to turn on DIIS for TS convergence. Type: integer; Default: 3. MCSCF_DPD_CLEANUP¶. Cleanup the DPD MCSCF object at the end of a run?. Type: boolean; Default: true. MCSCF_E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-7. MCSCF_GUESS¶. Initial MCSCF starting guess, MP2 natural orbitals only available for DF-RHF reference. Type: string; Possible Values: MP2, SCF; Default: SCF. MCSCF_MAXITER¶. Maximum number MCSCF of iterations. Type: integer; Default: 30. MCSCF_MAX_ROT¶. Maximum value in the rotation matrix. If a value is greater than this number all values are scaled. Type: double; Default: 0.5. MCSCF_ROTATE¶. Apply a list of 2x2 rotation matrices to the orbitals in the form of [irrep, orbital1, orbital2, theta] where an angle of 0 would do nothing and an angle of 90 would switch the two orbitals. Type: array; Default: No Default. MCSCF_R_CONVERGENCE¶. Convergence criterion for the RMS of the orbital gradient. Type: conv double; Default: 1e-5. MCSCF_SO_START_E¶. Start second-order (AH or OS) orbital-orbital MCSCF based on energy convergence. Type: double; D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__detci.html:10540,energy,energy,10540,psi4manual/1.7.x/autodir_options_c/module__detci.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__detci.html,8,['energy'],['energy']
Energy Efficiency,"fee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4; distribution, add the path to the directory containing the database; to the environment variable PYTHONPATH. Parameters:; name (string) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). db_name (string) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; psi4/lib/databases or PYTHONPATH. Consult that; directory for available databases and literature citations. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; Indicates whether the calculations required to complete the; database are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. cp (boolean) – 'on' || 'off' ; Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the cp(); function for BSSE correction in database(). Option available; (See Available Databases) only for databases of bimolecular complexes. rlxd (boolean) – 'on' || 'off' ; Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See Available Databases) onl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/db-1.html:1912,energy,energy,1912,psi4manual/4.0b5/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/db-1.html,4,['energy'],['energy']
Energy Efficiency,"ference frequencies from energies. dcft5; DCFT-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. opt2; SCF DZ allene geometry optimzation, with Cartesian input. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. opt5; 6-31G** UHF CH2 3B1 optimization. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest state of H2O+ (A1 excitation). cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. docs_dft; This test is used to construct the documentation; it is not suitable for emulation by users. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. cc16; UHF-B-CCD(T)/cc-pVDZ CH2 single-point energy (fzc, MO-basis ). sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. scf3; are specified explicitly. cc52; CCSD Response for H2O2. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. cc12; Single point energies of multiple excited states with EOM-CCSD. cisd-sp; 6-31G** H2O Test CISD Energy Point. mrcc4; CCSDT cc-pVDZ optimization and frequencies for the H2O molecule using MRCC. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). fci-dipole; 6-31G H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:8243,energy,energy,8243,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"ference wavefunction by pre-running scf,; then running the module with the ref_wfn kwarg. Also, if the full; two-electron integrals are necessary for the post-scf, compute them if; only the df integrals were run previously.; 1; 2; 3; 4; 5; 6; 7; 8; 9# Bypass the scf call if a reference wavefunction is given. ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') in ['DF', 'CD']:; psi4.MintsHelper(ref_wfn.basisset()).integrals(). Direct any post-scf modules to be run.; 1; 2; 3; 4# include if further post-scf modules are needed; psi4.transqt2(); psi4.ccsort(); psi4.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; 1; 2# include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; 1; 2# never include; return returnvalue. Managed Methods¶; When functionality overlaps between modules, a pattern is needed to (1); access each route through the code without contrivances like ccsd2,; _ccsd, sdci and (2) apportion defaulting among the modules, taking; into account reference (RHF/UHF/ROHF) and calc type (CONV, DF, CD).; Managed methods handle both these cases through the addition of a new; keyword QC_MODULE and a set of type keywords analogous to; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; 1; 2; 3; 4; 5procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : selec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/proc_py-1.html:3670,energy,energy,3670,psi4manual/1.1.0/proc_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/proc_py-1.html,6,['energy'],['energy']
Energy Efficiency,"ference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). Output¶; At the beginning of a cbs() job is printed a listing of the individual; energy calculations which will be performed. The output snippet below is; from the example job [2] above. It shows first each model chemistry needed; to compute the aggregate model chemistry requested through cbs(). Then,; since, for example, an energy('ccsd(t)') yields CCSD(T), CCSD, MP2,; and SCF energy values, the wrapper condenses this task list into the second; list of minimum number of calculations which will actually be run.; Naive listing of computations required.; scf / aug-cc-pvqz for SCF TOTAL ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY; mp2 / aug-cc-pvdz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY. Enlightened listing of computations required.; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY. At the end of a cbs() job is printed a summary section like the one below. First,; in the components section, are listed the results for each model chemistry available, whether; required for the cbs job (*) or not. Next, in the stages section, are listed the results for; each extrapolation. The energies of this s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:10353,energy,energy,10353,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"ference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displacement['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; displacement['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. # apply finite difference formulas and load derivatives into findifrec[reference]; if self.metameta['mode'] == '1_0':; G0 = assemble_gradient_from_energies(self.findifrec); self.findifrec[""reference""][self.driver.name] = G0. elif self.metameta['mode'] == '2_1':; if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_gradients(self.findifrec, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:47643,energy,energy,47643,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,16,['energy'],['energy']
Energy Efficiency,ference_wavefunction() (built-in function). psi4.RHF.shallow_copy() (built-in function). psi4.RHF.sobasisset() (built-in function). psi4.RHF.soccpi() (built-in function). psi4.RHF.X() (built-in function). psi4.ROHF.add_postiteration_callback() (built-in function). psi4.ROHF.add_preiteration_callback() (built-in function). psi4.ROHF.alpha_orbital_space() (built-in function). psi4.ROHF.aotoso() (built-in function). psi4.ROHF.atomic_point_charges() (built-in function). psi4.ROHF.basisset() (built-in function). psi4.ROHF.beta_orbital_space() (built-in function). psi4.ROHF.Ca() (built-in function). psi4.ROHF.Ca_subset() (built-in function). psi4.ROHF.Cb() (built-in function). psi4.ROHF.Cb_subset() (built-in function). psi4.ROHF.compute_energy() (built-in function). psi4.ROHF.compute_gradient() (built-in function). psi4.ROHF.Da() (built-in function). psi4.ROHF.Db() (built-in function). psi4.ROHF.deep_copy() (built-in function). psi4.ROHF.doccpi() (built-in function). psi4.ROHF.energy() (built-in function). psi4.ROHF.epsilon_a() (built-in function). psi4.ROHF.epsilon_a_subset() (built-in function). psi4.ROHF.epsilon_b() (built-in function). psi4.ROHF.epsilon_b_subset() (built-in function). psi4.ROHF.Fa() (built-in function). psi4.ROHF.Fb() (built-in function). psi4.ROHF.frequencies() (built-in function). psi4.ROHF.frzcpi() (built-in function). psi4.ROHF.frzvpi() (built-in function). psi4.ROHF.gradient() (built-in function). psi4.ROHF.hessian() (built-in function). psi4.ROHF.moFa() (built-in function). psi4.ROHF.moFb() (built-in function). psi4.ROHF.moFeff() (built-in function). psi4.ROHF.molecule() (built-in function). psi4.ROHF.nalpha() (built-in function). psi4.ROHF.nalphapi() (built-in function). psi4.ROHF.name() (built-in function). psi4.ROHF.nbeta() (built-in function). psi4.ROHF.nbetapi() (built-in function). psi4.ROHF.nfrzc() (built-in function). psi4.ROHF.nirrep() (built-in function). psi4.ROHF.nmo() (built-in function). psi4.ROHF.nmopi() (built-in function). psi4.R,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:107834,energy,energy,107834,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['energy'],['energy']
Energy Efficiency,"ferences of 2-1A1 state of H2O with EOM-CCSD. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. cc16; UHF-B-CCD(T)/cc-pVDZ CH2 single-point energy (fzc, MO-basis ). sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. scf3; are specified explicitly. dftd3-energy; Exercises the various DFT-D corrections, both through python directly and through c++. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cc52; CCSD Response for H2O2. pywrap-db2; Database calculation, run in sow/reap mode. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. omp2-2; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cc12; Single point energies of multiple excited states with EOM-CCSD. cisd-sp; 6-31G** H2O Test CISD Energy Point. mrcc4; CCSDT cc-pVDZ optimization and frequencies for the H2O molecule using MRCC. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). fci-dipole; 6-31G H2O Test FCI Energy Point. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimize",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:10759,energy,energy,10759,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"ferences of gradients. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cc51; EOM-CC3/cc-pVTZ on H2O. fci-h2o-2; 6-31G H2O Test FCI Energy Point. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc33; CC3(UHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). dft-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. omp3-3; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. sapt3; SAPT2+3 aug-cc-pVDZ computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). adc1; ADC/6-31G** on H2O. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:15418,energy,energy,15418,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"fficient and flexible; integral-transformation and also the libdpd library to; utilize molecular symmetry in the tensorial manipulations in framework; of the direct-product decomposition algorithm. By this feature, the Ritz; space and intermediate tensors are blocked according to the irreducible; representations of the point group, and the excited states that belong; to different symmetry are sought separately.; In the output of ADC, the ADC(2) results may look as follows:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13-> 1 B1 state : 0.2565095 (a.u.), 6.9799824 (eV); Non-iterative: 0.2565636 (a.u.), 6.9814532 (eV); Occ Vir Coefficient; ---------------------------------------------; 3 0 -0.9017047264; 3 2 0.3038332241; 3 1 0.2907567119; 3 5 -0.0790167706; 3 4 -0.0425829926. Converged in 4 iteration.; Squared norm of the S component: 0.9315336; The S vector is rotated up to 8.102 (deg.). in which the ADC(2) excitation energy is indicated with arrow symbol; and the pseudo-perturbative value, which is calculated in very similar; fashion to the CIS(D) energy, is also presented on the following line. In; this implementation, the ADC(2) secular matrix is treated effectively; by renormalization of the double excitation manifold into the single; excitation manifold. So, the effective secular equation is solved for; several times for the specific state due to the eigenvalue dependence of; the effective response matrix. Only the S component of the transition; amplitude is obtained explicitly and the squared norm of the S block; and the rotation angle from the corresponding CIS vector are given; below the element of the amplitude. The difference between the ADC(2); value and its non-iterative counterpart is mostly negligible if the; mixture among the CIS excited states is small and the quasi-degeneracy; in the excited state is tolerably weak. But if there is a significant; discrepancy in these energies, or the rotation angle is visibly large,; special care may have to be taken for t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/adc-1.html:2815,energy,energy,2815,psi4manual/1.2.1/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/adc-1.html,12,['energy'],['energy']
Energy Efficiency,"fication must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. nbo; Generation of NBO file. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. sapt-compare; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. dft-custom-mgga; updated dldf reference to new BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:22796,energy,energy,22796,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ficient for same spin correlation in SCS methods, forces alpha = 1.0; ""os"": 0.0, coefficient for opposite spin correlation in SCS methods, forces alpha = 1.0; },. ""dispersion"": { definition of dispersion corrections; ""type"": """", dispersion type - ""d2"", ""d3zero"", ""d3bj"" etc., see empirical_dispersion.py; ""params"": {}, parameters for the dispersion correction; ""nlc"": False (optional) logical switch to turn off nlc (e.g. VV10) correction defined by LibXC; ""citation"": """", special reference for the dispersion correction parameters, appended to output; (if defined in driver, not if defined in input file); },. One can also use the dft_functional keyword argument to use the; orbitals generated by DFT for correlated wavefunction methods:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17# MP2 with a PBE0 reference computation. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis 6-31G; dft_spherical_points 302; dft_radial_points 99; reference rks; }. mp2_dft = energy(""MP2"", dft_functional=""PBE0""). Note that this would only update the generic Psi variables (e.g., “CURRENT ENERGY”) and not the MP2 or DFT variables.; Psi4 also supports easy customization and manipulation of DFT functionals. The values of alpha and omega can be adjusted with the DFT_ALPHA; and DFT_OMEGA keywords. For example, for LRC functionals, one can control the fraction of long-range Hartree-Fock and short-range DFA by changing DFT_OMEGA:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22molecule ch2 {; 0 3; C; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set reference uhf; set guess gwh; set basis cc-pvdz; set e_convergence 8. # Override the default value of omega; set dft_omega 2.0. E = energy('wb97x'). # Revoke the change for later computations if needed; revoke_global_option_changed('DFT_OMEGA'). This feature would be useful after finishing the IP fitting procedure, for example. table of contents. DFT: Density Functional Theory; Theory; Minimal Input; Spin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dft-1.html:31604,energy,energy,31604,psi4manual/1.3.2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dft-1.html,2,['energy'],['energy']
Energy Efficiency,"ficient. Analytic gradients are not available for the three-particle energy; correction \((\lambda_3)\). Methods Summary¶; The table below summarizes current DCT code features:. Method; Available algorithms; Energy; Gradient; Reference. ODC-06; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-12; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-13; SIMULTANEOUS, QC; Y; Y; UHF. \(\mbox{ODC-12$(\lambda_3)$}\); SIMULTANEOUS, QC; Y; N; UHF. \(\mbox{ODC-13$(\lambda_3)$}\); SIMULTANEOUS, QC; Y; N; UHF. DC-06; SIMULTANEOUS, QC, TWOSTEP; Y; Y; UHF. DC-12; SIMULTANEOUS, QC, TWOSTEP; Y; N; UHF. Note that for ODC-06 and ODC-12 REFERENCE RHF is only available for; ALGORITHM SIMULTANEOUS. To compute \((\lambda_3)\) correction,; the THREE_PARTICLE option needs to be set to PERTURBATIVE. Minimal Input¶; Minimal input for the DCT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. energy('dct'). The energy('dct') call to energy() executes the DCT; module, which will first call the SCF module and perform the SCF computation; with RHF reference to obtain a guess for the DCT orbitals. After SCF is; converged, the program will perform the energy computation using the ODC-12; method. By default, simultaneous algorithm will be used for the solution of; the equations. One can also request to perform geometry; optimization following example below:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. optimize('dct'). The optimize('dct') call will first perform all of the procedures; described above to obtain the ODC-12 energy. After that, the ODC-12 analytic; gradients code will be executed and geometry optimization will be performed. Recommendations¶; Here is a list of recommendations for the DCT module:. Generally, the use of the simultaneous algorithm together with the; AO_BASIS DISK option is recommended (set by default).; In cases when available memory is insufficient, the use of the AO_BASIS DISK option; is recommended. This will significantly reduce the memory requirements. Ho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:13213,energy,energy,13213,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,18,['energy'],['energy']
Energy Efficiency,"fied explicitly. phi-ao; Test computing values of basis functions (puream and non-puream) at points. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. scf-hess5; DF SCF 6-31G analytical vs finite-difference tests Tests DF UHF hessian code for Ca != Cb. fisapt-siao1; This test case shows an example of running the I-SAPT0/jun-cc-pVDZ computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups) The SIAO1 link partitioning algorithm is used. An F-SAPT partitioning follows I-SAPT. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). opt11; Transition-state optimizations of HOOH to both torsional transition states. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. dforemp-grad1; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O molecule. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. aediis-1; ADIIS test case, from 10.1063/1.3304922. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. scf-guess-read2; Test if the the guess read in the same basis converges. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. dft-grad-meta; meta-GGA gradients of water and ssh molecules reference gradients updated due to new BraggSlater radii. fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. scf-level-shift-cuhf; SCF level shift on a CUHF computation. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:42894,energy,energy,42894,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"fied order; to an array of input function values (fvals) evaluated at given locations (xvals).; See https://doi.org/10.1063/1.4862157, particularly eqn (7) for details. """"""; xpts = np.array(xvals) - localization_point; if weighted:; R = 1.0; p_nu = 1; epsilon = 1e-3; zvals = np.square(xpts/R); weights = np.exp(-zvals) / (zvals**p_nu + epsilon**p_nu); else:; weights = None; fit = np.polynomial.polynomial.polyfit(xpts, fvals, polynomial_order, w=weights); # Remove the 1/n! coefficients; if no_factorials:; scalefac = 1.0; for n in range(2,polynomial_order+1):; scalefac *= n; fit[n] *= scalefac; return fit. [docs]def anharmonicity(rvals: List[float], energies: List[float], plot_fit: str = '', mol = None) -> Dict[str, Any]:; """"""Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact. A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. :param rvals: The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array. :param energies: The energies (Eh) computed at the bond lengths in the rvals list. :param plot_fit: A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to 'screen' to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/diatomic.html:2540,energy,energy,2540,psi4manual/1.7.x/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/diatomic.html,2,['energy'],['energy']
Energy Efficiency,"fied using Cartesian coordinates. cc52; CCSD Response for H2O2. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. soscf2; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. dft1-alt; DFT Functional Test. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. dcft-grad3; Restricted DF-DCFT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. cc13d; Tests analytic CC2 gradi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:4482,energy,energy,4482,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"figuration interaction singles and doubles level of theory, (3,). CISD QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [Eh] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The correlation energy [Eh] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [Eh] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [Eh] of the reference stage corresponding to; the CURRENT ENERGY variable. CURRENT DIPOLE¶; The total dipole [e a0] of the most recent stage of a calculation (frequently overwritten), (3,). CURRENT GRADIENT¶; The total electronic gradient [E_h/a0] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer, ({nat}, 3). CURRENT DIPOLE GRADIENT¶; The derivative of the dipole with respect to nuclear perturbations [E_h a0/u] = [(e a0/a0)^2/u]; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). CURRENT HESSIAN¶; The total electronic Hessian [E_h/a0/a0] of the most recent stage of a; calculation, (3 * {nat}, 3 * {nat}). CUSTOM SCS-MP2 TOTAL ENERGY¶. CUSTOM SCS-MP2 CORRELATION ENERGY¶; Changeable quantities based on options.; The total electroni",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:23426,energy,energy,23426,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['energy'],['energy']
Energy Efficiency,"file is renamed, using the PSIO handler. sapt11; sapt example with orbital freezing with alkali metal and dMP2. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. cbs-delta-energy; Extrapolated energies with delta correction. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. mints15; check SP basis Fortran exponent parsing. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:8636,energy,energy,8636,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False)¶; Return all scalar or array QCVariables from cls. Return type; Dict[str, Union[float, Matrix, ndarray]]. Parameters; include_deprecated_keys (bool) – . write_molden(filename=None, do_virtual=None, use_natural=False)¶; Function to write wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.rhf.html:33483,ENERGY,ENERGY,33483,psi4manual/1.4.0/api/psi4.core.rhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.rhf.html,8,['ENERGY'],['ENERGY']
Energy Efficiency,"file:; molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf') # on H2. clean(). molecule h {; H; }. set basis cc-pvdz; set reference uhf; energy('scf') # on H. Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate command is provided. With it, the above input file can be; equivalently written as follows. Alternatively, the molecule can be specified; directly to the computing function. Below, the third calculation is the same as; the first.; molecule h2 {; H; H 1 0.9; }. molecule h {; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf') # on H2. clean(). activate(h); set basis cc-pvdz; set reference uhf; energy('scf') # on H. # --------------------------------------; # equivalent to previous input ends here. clean(). set reference rhf; energy('scf', molecule=h2) # on H2. Job Control Keywords provides more details about the job control; and calculation keywords used in the above examples. Ghost Atoms¶; While many common computations, particularly SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2-1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Isotopic Substitution¶. Caution; Use of isotopic substitution in PSI4 is not well; developed, and the syntax is subject to change. At present, isotopes can only be specified at creation-time of the molecule; The syntax for a deuterium- and tritium-substituted water is below. Note; that asymmet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html:5697,energy,energy,5697,psi4manual/1.4.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html,9,['energy'],['energy']
Energy Efficiency,"file:; molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf') # on H2. clean(). molecule h {; H; }. set basis cc-pvdz; set reference uhf; energy('scf') # on H. Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate command is provided. With it, the above input file can be; equivalently written as follows. Alternatively, the molecule can be specified; directly to the computing function. Below, the third calculation is the same as; the first.; molecule h2 {; H; H 1 0.9; }. molecule h {; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf') # on H2. clean(). activate(h); set basis cc-pvdz; set reference uhf; energy('scf') # on H. # --------------------------------------; # equivalent to previous input ends here. clean(). set reference rhf; energy('scf', molecule=h2) # on H2. Job Control Keywords provides more details about the job control; and calculation keywords used in the above examples. Ghost Atoms¶; While many common computations, particularly SAPT and counterpoise corrections, can; be greatly simplified using the notation described in Non-Covalently Bonded Molecule Fragments,; manual specification of ghost atoms is sometimes required. Either; molecule he2 {; He; Gh(He) 1 2.0; }. or; molecule he2 {; He; @He 1 2.0; }. will generate a helium dimer with the second atom ghosted, i.e., possessing; basis functions but no electrons or nuclear charge. See dfmp2_1; and ghosts for a demonstration of both mechanisms for specifying; ghost atoms. Isotopic Substitution¶. Caution; Use of isotopic substitution in Psi4 is not well; developed, and the syntax is subject to change. At present, isotopes can only be specified at creation-time of the molecule; The syntax for a deuterium- and tritium-substituted water is below. Note; that asymmet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html:5716,energy,energy,5716,psi4manual/1.0.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html,2,['energy'],['energy']
Energy Efficiency,"filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""CURRENT HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nest",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html:83299,energy,energy,83299,psi4manual/1.5.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"findifrec[""stencil_size""] == 5:; fc = (-offdiag_en(0) - offdiag_en(1) + 9 * offdiag_en(2) - offdiag_en(3) - offdiag_en(4) +; 9 * offdiag_en(5) - offdiag_en(6) - offdiag_en(7) + E[i][0] - 7 * E[i][1] - 7 * E[i][2] +; E[i][3] + E[j][0] - 7 * E[j][1] - 7 * E[j][2] + E[j][3] +; 12 * ref_energy) / (12 * findifrec[""step""][""size""]**2); H_irr[i, j] = fc; H_irr[j, i] = fc. B_pi.append(data[""salc_list""].matrix_irrep(h)); H_pi.append(_process_hessian_symmetry_block(H_irr, B_pi[-1], massweighter, irrep_lbls[h], data[""print_lvl""])). # All blocks of the Hessian are now constructed!; return _process_hessian(H_pi, B_pi, massweighter, data[""print_lvl""]). [docs]class FiniteDifferenceComputer(BaseComputer):. molecule: Any; driver: DriverEnum; metameta: Dict[str, Any] = {}; task_list: Dict[str, BaseComputer] = {}; findifrec: Dict[str, Any] = {}; computer: BaseComputer = AtomicComputer; method: str. [docs] @validator('driver'); def set_driver(cls, driver):; egh = ['energy', 'gradient', 'hessian']; if driver not in egh:; raise ValidationError(f""""""Wrapper is unhappy to be calling function ({driver}) not among {egh}.""""""). return driver. [docs] @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; """"""Initialize FiniteDifference class. data keywords include; * general AtomicInput keys like molecule, driver, method, basis, and keywords.; * specialized findif keys like findif_mode, findif_irrep, and those converted from keywords to kwargs:; findif_stencil_size, findif_step_size, and findif_verbose.; * TODO hangers-on keys present at class initiation get automatically attached to class since `extra = ""allow""` but should be pruned. """"""; findif_stencil_size = data.pop('findif_stencil_size'); findif_step_size = data.pop('findif_step_size'). BaseComputer.__init__(self, **data). translations_projection_sound = (not ""external_potentials"" in data['keywords']['function_kwargs']; and not core.get_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:40804,energy,energy,40804,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,2,['energy'],['energy']
Energy Efficiency,"finite difference data, specified in _geom_generator docstring.; freq_irrep_only; The 0-indexed Cotton ordered irrep to get frequencies for. Choose -1 for all irreps. Returns; -------; hessian; (3 * nat, 3 * nat) Cartesian Hessian [Eh/a0^2].; """""". # This *must* be a Psi molecule at present - CdSalcList generation panics otherwise; mol = core.Molecule.from_schema(findifrec[""molecule""], nonphysical=True, verbose=0). displacements = findifrec[""displacements""]; ref_energy = findifrec[""reference""][""energy""]. def init_string(data):; max_label_len = str(max([len(label) for label in displacements], default=3)); out_str = """"; for label, disp_data in displacements.items():; out_str += ("" {:"" + max_label_len + ""s} : {:20.10f}\n"").format(label, disp_data[""energy""]); return ("" Computing second-derivative from energies using projected, \n""; "" symmetry-adapted, cartesian coordinates.\n\n""; "" {:d} energies passed in, including the reference geometry.\n""; "" Using {:d}-point formula.\n""; "" Energy without displacement: {:15.10f}\n""; "" Check energies below for precision!\n{}"".format(; len(displacements) + 1, findifrec[""stencil_size""], ref_energy, out_str)). data = _initialize_findif(mol, freq_irrep_only, ""2_0"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irrep_lbls = mol.irrep_labels(); max_disp = (findifrec[""stencil_size""] - 1) // 2; e_per_diag = 2 * max_disp. # Unlike in the gradient case, we have no symmetry transformations to worry about.; # We get to the task directly: assembling the force constants in each irrep block.; for h in range(data[""n_irrep""]):; salc_indices = data[""salc_indices_pi""][h]; if not salc_indices: continue. n_salcs = len(salc_indices); E = np.zeros((len(salc_indices), e_per_diag)). # Step One: Diagonals; # For asymmetric irreps, the energy at a + disp is the sam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:37294,Energy,Energy,37294,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,4,['Energy'],['Energy']
Energy Efficiency,"fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:4437,charge,charges,4437,psi4manual/1.0.0/_modules/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html,13,['charge'],"['charge', 'charges']"
Energy Efficiency,"fix orbital coefficients and energies for DFMP2; if module_ in ['DFMP2']:; wfn_ = core.Wavefunction.build(wfn.molecule(), core.get_global_option('BASIS')); wfn_.deep_copy(wfn); refwfn = wfn.reference_wavefunction(); wfn_.set_reference_wavefunction(refwfn) # refwfn not deep_copied; wfn_.Ca().copy(refwfn.Ca()); wfn_.Cb().copy(refwfn.Cb()); wfn_.epsilon_a().copy(refwfn.epsilon_a()); wfn_.epsilon_b().copy(refwfn.epsilon_b()); fw = core.FCHKWriter(wfn_); else:; fw = core.FCHKWriter(wfn). if module_ in ['DCT', 'DFOCC']:; core.print_out(""""""FCHKWriter: Caution! For orbital-optimized correlated methods; the 'Orbital Energy' field contains ambiguous data. \n""""""). # At this point we don't know the method name, so we try to search for it.; # idea: get the method from the variable matching closely the 'current energy'; # for varlist, wfn is long-term and to allow from-file wfns. core is b/c some modules not storing in wfn yet; varlist = {**wfn.scalar_variables(), **core.scalar_variables()}; current = varlist['CURRENT ENERGY']. # delete problematic entries; for key in ['CURRENT ENERGY', 'CURRENT REFERENCE ENERGY']:; varlist.pop(key, None). # find closest matching energy; for (key, val) in varlist.items():; if (np.isclose(val, current, 1e-12)):; method = key.split()[0]; break. # The 'official' list of labels for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-sta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:90023,ENERGY,ENERGY,90023,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,5,['ENERGY'],['ENERGY']
Energy Efficiency,"fix),; plus a ”.out” suffix. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). For your convenience, this example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the User Configuration; section of the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about , so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/tutorial-1.html:1657,energy,energy,1657,psi4manual/4.0b4/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/tutorial-1.html,4,['energy'],['energy']
Energy Efficiency,"fix_orientation(True). # Load in displacement into the active molecule; clone.set_geometry(core.Matrix.from_array(displacement[""geometry""])). # If the user insists on symmetry, weaken it if some is lost when displacing.; # or 'fix_symmetry' in self.findifrec.molecule; logger.debug(f'SYMM {clone.schoenflies_symbol()}'); if self.molecule.symmetry_from_input():; disp_group = clone.find_highest_point_group(); new_bits = parent_group.bits() & disp_group.bits(); new_symm_string = qcdb.PointGroup.bits_to_full_name(new_bits); clone.reset_point_group(new_symm_string). packet = {; ""molecule"": clone,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']. self.task_list[label] = self.computer(**packet, **passalong). # for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; # _process_displacement(energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). [docs] def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs] def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs] def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", Non",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:45815,energy,energy,45815,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,2,['energy'],['energy']
Energy Efficiency,"fixed(_fix=True)[source]¶; NYI Fix the center of mass at its current frame.; Not used in libmints so not implemented. set_full_geometry(geom)[source]¶; Sets the full geometry (dummies included), given a N X 3 array of coordinates geom in Bohr.; >>> H2OH2O.set_full geometry([[1,2,3],[4,5,6],[7,8,9],[0,0,0],[-1,-2,-3],[-4,-5,-6],[-7,-8,-9]]). set_full_point_group(tol=1e-08)[source]¶; Determine and set FULL point group. self.PYfull_pg_n is highest; order n in Cn. 0 for atoms or infinity. set_geometry(geom)[source]¶; Sets the geometry, given a N X 3 array of coordinates geom in Bohr.; >>> H2OH2O.set_geometry([[1,2,3],[4,5,6],[7,8,9],[-1,-2,-3],[-4,-5,-6],[-7,-8,-9]]). set_ghost_fragment(fr)[source]¶; Tags fragment index fr as composed of ghost atoms. set_ghost_fragments(ghosts)[source]¶; Tags the fragments in array ghosts as composed of ghost atoms. set_has_zmatrix(tf)[source]¶; Sets the presence of any zmatrix entry; >>> H2OH2O.set_has_zmatrix(True). set_molecular_charge(charge)[source]¶; Sets the molecular charge; >>> H2OH2O.set_molecular_charge(-2). set_multiplicity(mult)[source]¶; Sets the multiplicity (defined as 2Ms + 1); >>> H2OH2O.set_multiplicity(3). set_name(name)[source]¶; Set molecule name; >>> H2OH2O.set_name('water_dimer'). set_point_group(pg)[source]¶; Set the point group to object pg. set_shell_by_number(number, bshash, role='BASIS')[source]¶; Assigns BasisSet bshash to atom number number (0-indexed, excludes dummies). set_units(units)[source]¶; Sets the geometry units; >>> H2OH2O.set_units('Angstom'). set_variable(vstr, val)[source]¶; Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). sym_label()[source]¶; Returns the symmetry label. symbol(atom)[source]¶; Returns the cleaned up label of the atom (C2 => C, H4 = H) (0-indexed); >>> print H2OH2O.symbol(4); H. symmetrize()[source]¶; Force the molecule to have the symmetry specified in pg.; This is to handle noise coming in from optking. s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:91438,charge,charge,91438,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,4,['charge'],['charge']
Energy Efficiency,"flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). Restarting the SCF¶; Reading orbital data from a previous calculations is done via the restart_file option,; where the actual file is a serialized wfn object (see saving the wfn); By default, the orbital data file of the converged SCF(psi.PID.name.180.npy) is deleted; after PSI4 exits or the clean() function is called. The orbital guess is automatically; set to READ when restart_file is given a wfn file.; To write the orbitals after every iteration and keep the orbitals from the last iteration, the write_orbitals options is available:; energy('scf', write_orbitals='my_mos'),. which writes a Wavefunction object converted (serialized) to a numpy file called my_mos.npy.; The restart can then be done as follows:; energy('scf', restart_file='my_mos'). Specifying the .npy suffix when writing and reading restart files is optional.; Alternatively, the restart can also be done from any previously saved wfn object.; energy, scf_wfn = energy('scf',return_wfn=True); scf_wfn.to_file('my_wfn'); energy('scf', restart_file='my_wfn'). For advanced users manipulating or writing custom wavefunction files, note; that PSI4 expects the numpy file on disk to have the .npy extension, not, e.g., .npz. Convergence Stabilization¶; A summary of Psi’s supported convergence stabilization techniques is presented below:. DIIS [On by Default]DIIS uses previous iterates of the Fock matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished vi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/scf.html:20426,energy,energy,20426,psi4manual/1.6.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/scf.html,5,['energy'],['energy']
Energy Efficiency,"flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). Restarting the SCF¶; Reading orbital data from a previous calculations is done via the restart_file option,; where the actual file is a serialized wfn object (see saving the wfn); By default, the orbital data file of the converged SCF(psi.PID.name.180.npy) is deleted; after PSI4 exits or the clean() function is called. The orbital guess is automatically; set to READ when restart_file is given a wfn file.; To write the orbitals after every iteration and keep the orbitals from the last iteration, the write_orbitals options is available:; energy('scf', write_orbitals='my_mos'),. which writes a Wavefunction object converted (serialized) to a numpy file called my_mos.npy.; The restart can then be done as follows:; energy('scf', restart_file='my_mos'). Specifying the .npy suffix when writing and reading restart files is optional.; Alternatively, the restart can also be done from any previously saved wfn object.; energy, scf_wfn = energy('scf',return_wfn=True); scf_wfn.to_file('my_wfn'); energy('scf', restart_file='my_wfn'). For advanced users manipulating or writing custom wavefunction files, note; that PSI4 expects the numpy file on disk to have the .npy extension, not, e.g., .npz. Convergence Stabilization¶; With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:20410,energy,energy,20410,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,4,['energy'],['energy']
Energy Efficiency,"float,; no_factorials: bool = True,; weighted: bool = True,; polynomial_order: int = 4,; ):; """"""Performs an unweighted least squares fit of a polynomial, with specified order; to an array of input function values (fvals) evaluated at given locations (xvals).; See https://doi.org/10.1063/1.4862157, particularly eqn (7) for details. """"""; xpts = np.array(xvals) - localization_point; if weighted:; R = 1.0; p_nu = 1; epsilon = 1e-3; zvals = np.square(xpts/R); weights = np.exp(-zvals) / (zvals**p_nu + epsilon**p_nu); else:; weights = None; fit = np.polynomial.polynomial.polyfit(xpts, fvals, polynomial_order, w=weights); # Remove the 1/n! coefficients; if no_factorials:; scalefac = 1.0; for n in range(2,polynomial_order+1):; scalefac *= n; fit[n] *= scalefac; return fit. [docs]; def anharmonicity(rvals: List[float], energies: List[float], plot_fit: str = '', mol = None) -> Dict[str, Any]:; """"""Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact. A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. :param rvals: The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array. :param energies: The energies (Eh) computed at the bond lengths in the rvals list. :param plot_fit: A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html:2406,energy,energy,2406,psi4manual/1.8.x/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html,6,['energy'],['energy']
Energy Efficiency,"fmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; dftsapt(...); dftsapt( (Wavefunction)arg1, (Wavefunction)arg2, (Wavefunction)arg3) -> float :; Runs the DFT variant of the symmetry adapted perturbation theory code.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)arg1) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points.; ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; fnocc(...); fnocc() -> float :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; get_global_option(...); get_global_option( (str)arg1) -> object :; Given a string of a keyword name, returns the value associated ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psimod-1.html:106894,energy,energy,106894,psi4manual/4.0b4/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"fn (str) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str) – \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str) – \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters. scf_basis (basis string) – \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html:6810,energy,energy,6810,psi4manual/1.4.0/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html,15,['energy'],['energy']
Energy Efficiency,"fn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – corl_wfn || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – delta_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string) – delta2_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string) – delta3_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string) – delta4_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:4357,energy,energy,4357,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"fn'] = 'ccsd(t)'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis' in kwargs):; kwargs['delta_basis'] = 'aug-cc-pVTZ'; if not ('delta_scheme' in kwargs):; kwargs['delta_scheme'] = highest_1. return cbs(name, **kwargs). [docs]def run_mp2_5(name, **kwargs):; r""""""Function that computes MP2.5 energy from results of a DETCI; MP3 calculation. .. math:: E_{total}^{\text{MP2.5}} = E_{total,\; \text{SCF}} \; + E_{corl,\; \text{MP2}} + E_{corl, \; \text{MP3}}. :PSI variables: . .. hlist:: ; :columns: 1 ; ; * :psivar:`MP2.5 TOTAL ENERGY <MP2.5TOTALENERGY>` ; * :psivar:`MP2.5 CORRELATION ENERGY <MP2.5CORRELATIONENERGY>` . >>> energy('mp2.5'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiM",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html:2874,ENERGY,ENERGY,2874,psi4manual/4.0b2/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"fn'] = 'ccsd(t)'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis' in kwargs):; kwargs['delta_basis'] = 'aug-cc-pVTZ'; if not ('delta_scheme' in kwargs):; kwargs['delta_scheme'] = highest_1. return cbs(name, **kwargs). [docs]def run_mp2_5(name, **kwargs):; r""""""Function that computes MP2.5 energy from results of a DETCI; MP3 calculation. .. math:: E_{total}^{\text{MP2.5}} = E_{total,\; \text{SCF}} \; + E_{corl,\; \text{MP2}} + E_{corl, \; \text{MP3}}. :PSI variables: . .. hlist:: ; :columns: 1 ; ; * :psivar:`MP2.5 TOTAL ENERGY <MP2.5TOTALENERGY>` ; * :psivar:`MP2.5 CORRELATION ENERGY <MP2.5CORRELATIONENERGY>` . >>> energy('mp2.5'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(banners). tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); Psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html:2871,ENERGY,ENERGY,2871,psi4manual/4.0b3/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"fn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; adc_wfn.set_variable(name + "" excitation energies"",; core.Matrix.from_array(state.excitation_energy.reshape(-1, 1))); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:116048,Energy,Energy,116048,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Energy'],['Energy']
Energy Efficiency,"fn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:118325,Energy,Energy,118325,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['Energy'],['Energy']
Energy Efficiency,"fn); refwfn = wfn.reference_wavefunction(); wfn_.set_reference_wavefunction(refwfn) # refwfn not deep_copied; wfn_.Ca().copy(refwfn.Ca()); wfn_.Cb().copy(refwfn.Cb()); wfn_.epsilon_a().copy(refwfn.epsilon_a()); wfn_.epsilon_b().copy(refwfn.epsilon_b()); fw = core.FCHKWriter(wfn_); else:; fw = core.FCHKWriter(wfn). if module_ in ['DCT', 'DFOCC']:; core.print_out(""""""FCHKWriter: Caution! For orbital-optimized correlated methods; the 'Orbital Energy' field contains ambiguous data. \n""""""). # At this point we don't know the method name, so we try to search for it.; # idea: get the method from the variable matching closely the 'current energy'; # for varlist, wfn is long-term and to allow from-file wfns. core is b/c some modules not storing in wfn yet; varlist = {**wfn.scalar_variables(), **core.scalar_variables()}; current = varlist['CURRENT ENERGY']. # delete problematic entries; for key in ['CURRENT ENERGY', 'CURRENT REFERENCE ENERGY']:; varlist.pop(key, None). # find closest matching energy; for (key, val) in varlist.items():; if (np.isclose(val, current, 1e-12)):; method = key.split()[0]; break. # The 'official' list of labels for compatibility.; # OMP2,MP2.5,OCCD, etc get reduced to MP2,CC.; allowed_labels = {; ""HF"": "" SCF Density"",; ""SCF"": "" SCF Density"",; ""DFT"": "" SCF Density"",; ""MP2"": "" MP2 Density"",; ""MP3"": "" MP3 Density"",; ""MP4"": "" MP4 Density"",; ""CI"": "" CI Density"",; ""CC"": "" CC Density"",; }; # assign label from method name; fchk_label = f"" {method} Density""; if strict_label:; in_list = False; for key in allowed_labels:; if key in method:; if key is not method:; core.print_out(f""FCHKWriter: !WARNING! method '{method}'' renamed to label '{key}'.\n""); fchk_label = allowed_labels[key]; in_list = True; if not in_list:; core.print_out(f""FCHKWriter: !WARNING! {method} is not recognized. Using non-standard label.\n""); core.print_out(f""FCHKWriter: Writing {filename} with label '{fchk_label}'.\n""); fw.set_postscf_density_label(fchk_label). fw.write(filename); # needed for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:90171,energy,energy,90171,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,10,['energy'],['energy']
Energy Efficiency,"fn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:85165,ENERGY,ENERGY,85165,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"fn.molecule(), dimer_wfn); ## Monomer dispersion; mon_disp_energy = _disp_functor.compute_energy(monomerA); mon_disp_energy += _disp_functor.compute_energy(monomerB). disp_interaction_energy = dimer_disp_energy - mon_disp_energy; core.set_variable(saptd_name + ""-D DISP ENERGY"", disp_interaction_energy); core.set_variable(""SAPT DISP ENERGY"", disp_interaction_energy); core.set_variable(""DISPERSION CORRECTION ENERGY"", disp_interaction_energy); core.set_variable(saptd_name + ""DISPERSION CORRECTION ENERGY"", disp_interaction_energy). ## Set SAPT0-D3 variables; total = disp_interaction_energy; saptd_en = {}; saptd_en['DISP'] = disp_interaction_energy; for term in ['ELST', 'EXCH', 'IND']:; en = core.variable(' '.join([sapt0_name, term, 'ENERGY'])); saptd_en[term] = en; core.set_variable(' '.join([saptd_name + '-D', term, 'ENERGY']), en); core.set_variable(' '.join(['SAPT', term, 'ENERGY']), en); total += en. core.set_variable(saptd_name + '-D TOTAL ENERGY', total); core.set_variable('SAPT TOTAL ENERGY', total); core.set_variable('CURRENT ENERGY', total). ## Print Energy Summary; units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out(f"" => {saptd_name +'-D'} Energy Summary <=\n""). core.print_out("" "" + ""-"" * 104 + ""\n""); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Electrostatics"", saptd_en['ELST'] * units[0], saptd_en['ELST'] * units[1], saptd_en['ELST'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Exchange"", saptd_en['EXCH'] * units[0], saptd_en['EXCH'] * units[1], saptd_en['EXCH'] * units[2])); core.print_out("" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Induction"", saptd_en['IND'] * units[0], saptd_en['IND'] * units[1], saptd_en['IND'] * units[2])); core.print_out(; "" %-25s % 16.8f [mEh] % 16.8f [kcal/mol] % 16.8f [kJ/mol]\n"" %; (""Dispersion"", saptd_en['DISP'] * units[0], saptd_en['DISP'] * units[1], saptd_en['DISP'] * units[2])); core.p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html:9943,ENERGY,ENERGY,9943,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"fn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_functional_and_disp('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); eli",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:89639,ENERGY,ENERGY,89639,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"fn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:78394,ENERGY,ENERGY,78394,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,7,['ENERGY'],['ENERGY']
Energy Efficiency,"fn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. :type delta4_basis: :ref:`basis string <apdx:basisElement>`; :param delta4_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the fourth d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:58501,energy,energy,58501,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"follow the instructions provided with the source; (essentially, download the freely available tarball, unpack the source,; edit the Makefile to select a; Fortran compiler, and run make). From version 3.1.0 onwards, DFTD3 can; be used as-is; for earlier versions, patches are available:; psi4/psi4/share/psi4/scripts/patch_grimme_dftd3.3.0.2. To be used by PSI4, the program binary (dftd3) must be; found in your PSIPATH or PATH (in that order). If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular dftd3 compilation, simply adjust its; position in the path environment variables. Theory¶; The local or semilocal character of conventional density functionals; necessarily leads to neglect of the long-range correlation interactions; which capture attractive van der Waals forces. Initially proposed by Yang; [Wu:2002:515] and assiduously developed by Grimme, [Grimme:2004:1463]; [Grimme:2006:1787] [Grimme:2010:154104] the DFT+Dispersion method; appends to the base functional a scaled, damped, and fitted leading term; to the well-known dispersion energy series, \(E_{disp} = -C_6/R^6; -C_8/R^8 -C_{10}/R^{10}-\cdots\). The DFT-D2 [Grimme:2006:1787] variant; takes the explicit form below. Here, dispersion coefficients,; \(C_6^{ij}\), obtained from the geometric mean of tabulated elemental; values, are summed over interatomic distances, \(R_{ij}\), modulated; by a damping function, \(f_{damp}(R_{ij})\), that gradually activates; the dispersion correction (at a rate characterized by \(\alpha_6\)); over a distance characterized by the sum of the two atomic vdW radii,; \(R_{vdW}\), while an overall scaling term, \(s_6\), is optimized; to be unique to each \(E_{xc}\) functional. (\(\alpha_6\) is; sometimes allowed to vary as well.). (1)¶\[E_{disp}^{\text{D2}}=-s_6 \sum_{i,j>i}^{N_{at}} \frac{C_6^{ij}}{(R_{ij})^6} f_{damp}(R_{ij})\]. \[f_{damp}(R_{ij}) = \frac{1}{1 + e^{- \alpha_6 (R_{ij}/R_{vdW} - 1)}}\]; Grimme recently presented a refin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dftd3-1.html:2047,energy,energy,2047,psi4manual/1.2.1/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dftd3-1.html,11,['energy'],['energy']
Energy Efficiency,"for Diatomics. Spectroscopic Constants for Diatomics¶; Code author: Andrew C. Simmonett. psi4.driver.diatomic.anharmonicity(rvals, energies, plot_fit='', mol=None)[source]¶; Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. Any number of points greater than 4 may be provided, and they should bracket the minimum.; The data need not be evenly spaced, and can be provided in any order. The data are weighted such that; those closest to the minimum have highest impact.; A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. Parameters:. rvals (List[float]) – The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array; energies (List[float]) – The energies (Eh) computed at the bond lengths in the rvals list; plot_fit (str) – A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to ‘screen’ to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supported file types. Return type:; Dict[str, Any]. Returns:; (dict) Keys: “re”, “r0”, “we”, “wexe”, “nu”, “ZPVE(harmonic)”, “ZPVE(anharmonic)”, “Be”, “B0”, “ae”, “De”; corresponding to the spectroscopic constants in cm-1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon Functions: Invoking a Calculation; Spectroscopic Constants for Diatomics. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/diatomic.html:1436,energy,energy,1436,psi4manual/1.7.x/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/diatomic.html,1,['energy'],['energy']
Energy Efficiency,"for Potassium nitrate (rocket fuel!). fisapt-siao1; This test case shows an example of running the I-SAPT0/jun-cc-pVDZ computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups) The SIAO1 link partitioning algorithm is used. An F-SAPT partitioning follows I-SAPT. dfccsd-t-grad2; DF-CCSD(T) cc-pVDZ gradient for the NH molecule. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. scf6; Tests RHF/ROHF/UHF SCF gradients. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. cbs-xtpl-alpha; Extrapolated water energies. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dft-custom; DFT custom functional test. dft2; DFT Functional Test. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cepa-module; routing check on lccd, lccsd, cepa(0). dct12; Spin-restricted DC-06 counterpart of dct1. dft-b3lyp; Check flavors of B3LYP (b3lyp3/",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:14601,energy,energy,14601,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; # all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:14111,energy,energy,14111,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,12,['energy'],['energy']
Energy Efficiency,"for all SAPT computations. Type: boolean; Default: true. NAT_ORBS_T3¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: true. NAT_ORBS_V4¶. Do use MP2 natural orbital approximations for the \(v^4\) block of two-electron integrals in the evaluation of CCD T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: true. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; 1; 2; 3; 4; 5; 6; 7; 8energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0.; A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; 1; 2; 3; 4; 5 SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:24573,energy,energy,24573,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,6,['energy'],['energy']
Energy Efficiency,"for all SAPT computations. Type: boolean; Default: true. NAT_ORBS_T3¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: true. NAT_ORBS_V4¶. Do use MP2 natural orbital approximations for the \(v^4\) block of two-electron integrals in the evaluation of CCD T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: true. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0.; A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:30600,energy,energy,30600,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['energy'],['energy']
Energy Efficiency,"for all available schemes. :type scf_scheme: Callable; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_karton_2`. :type corl_scheme: Callable; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. :type delta_scheme: Callable; :param delta_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. :type delta2_scheme: Callable; :param delta2_scheme: |dl| ``xtpl_highest_1`` |dr| ||",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:40305,energy,energy,40305,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,4,['energy'],['energy']
Energy Efficiency,"for an already existing module, the labels for other tests of the module will suggest other labels to add.; A test requiring over 15 minutes should be labeled longtests. A short test under 30 seconds used for general bug checking should be labeled quicktests. A test that confirms PSI4 is operational should be labeled smoketests.; The other necessary file is the input file itself, input.dat. The input file should be just a simple input file to run the test, with small additions.; #! RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxiliary basis.; #! Also a bit more to force a second line. nucenergy = 8.801466202085710 #TEST; refenergy = -76.05098402733282 #TEST. molecule h2o {; symmetry c1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pVTZ; scf_type df; df_basis_scf cc-pVTZ-RI; e_convergence 10; }. thisenergy = energy(""hf""). compare_values(nucenergy, h2o.nuclear_repulsion_energy(), 9, ""Nuclear repulsion energy"") #TEST; compare_values(refenergy, thisenergy, 9, ""Reference energy"") #TEST; compare_values(refenergy, get_variable('scf total energy'), 9, ""Reference energy"") #TEST. Of those small modifications, first, note the special comment at the top (starting with the #! comment marker). This should be descriptive since it is inlined into the manual (unless !nosample in the comment) as a sample input.; The reference values are assigned to variables for later use. The compare_values function (along with several relatives in psi4/psi4/driver/p4util/testing.py for comparing strings, matrices, etc.) checks that the computed values match these reference values to suitable precision. This function prints an error message and signals that the test failed to the make system, if the values don’t match. Any lines of the input associated with the validation process should be flagged with #TEST at the end of each line, so that they can be removed when copying from the tests to the samples directory.; Finally, add the directory name to the list of tests in psi4/",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/add_tests-1.html:1732,energy,energy,1732,psi4manual/1.4.0/add_tests-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/add_tests-1.html,16,['energy'],['energy']
Energy Efficiency,"for available; molecular systems (case insensitive). [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. Examples:. 1; 2>>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). 1; 2; 3>>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). 1; 2>>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). 1; 2>>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). 1; 2>>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; 1; 2; 3; 4RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/db-1.html:5956,energy,energy,5956,psi4manual/1.2.1/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/db-1.html,12,['energy'],['energy']
Energy Efficiency,"for computing interaction and total quantities. Returns; return type of func – The data. Returns; (float, Wavefunction) – data and wavefunction with energy/gradient/hessian set appropriately when return_wfn specified. Parameters. func (Union[str, Callable]) – energy || etc.; Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. method_string (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element of a tuple. bsse_type (str or list) – 'cp' || ['nocp', 'vmfc'] || \(\Rightarrow\) None \(\Leftarrow\) || etc.; Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, this function is not called. max_nbody (int) – 3 || etc.; Maximum n-body to compute, cannot exceed the number of fragments in the molecule. ptype (str) – 'energy' || 'gradient' || 'hessian'; Type of the procedure passed in. return_total_data (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is 'off' for energies,; 'on' for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying return_total_data = True; may carry out more computations than return_total_data = False. levels (dict) – {1: 'c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/nbody-1.html:1483,energy,energy,1483,psi4manual/1.4.0/nbody-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/nbody-1.html,4,['energy'],['energy']
Energy Efficiency,"for four-virtual case is avoided. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. dfremp-2; density fitted REMP/cc-pVDZ energies for the CH3 radical. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. sapt-ecp; sapt0 of charged system in ECP basis set. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). cbs-xtpl-energy; Extrapolated water energies - density-fitted version. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. dfccsdat2; DF-A-CCSD(T) cc-pVDZ energy for the NH molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table fu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:25374,charge,charged,25374,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['charge'],['charged']
Energy Efficiency,"for k in range(len(occs)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (occs[k], energies[k], potentials[k], convs[k])); fh.close(). return E . # Pull all the electrons out, one at a time ; [docs]def frac_nuke(mol, **kwargs):; kwargs = kwargs_lower(kwargs). # The molecule is required, and should be the neutral species; mol.update_geometry(); activate(mol); charge0 = mol.molecular_charge(); mult0 = mol.multiplicity() . # By default, we start the frac procedure on the 25th iteration ; # when not reading a previous guess; frac_start = 25; if kwargs.has_key('frac_start'):; frac_start = kwargs['frac_start']. # By default, we occupy by tenths of electrons; foccs = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]; if kwargs.has_key('foccs'):; foccs = kwargs['foccs'] . # By default, HOMO and LUMO are both in alpha; N = 0;; for A in range(mol.natom()):; N += mol.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1)/2); Na = int(N - Nb). charge = charge0; mult = mult0; ; # By default, nuke all the electrons; Nmin = 0;; if (kwargs.has_key('nmax')):; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = True; if kwargs.has_key('frac_diis'):; frac_diis = kwargs['frac_diis']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat' . # => Traverse <= #; PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; energy('scf'). # Determine HOMO; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge, mult, HOMO)). if (HOMO >",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/frac.html:7207,charge,charge,7207,psi4manual/4.0b2/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html,4,['charge'],['charge']
Energy Efficiency,"for k in range(len(occs)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (occs[k], energies[k], potentials[k], convs[k])); fh.close(). return E . # Pull all the electrons out, one at a time ; [docs]def frac_nuke(mol, **kwargs):; kwargs = kwargs_lower(kwargs). # The molecule is required, and should be the neutral species; mol.update_geometry(); activate(mol); charge0 = mol.molecular_charge(); mult0 = mol.multiplicity() . # By default, we start the frac procedure on the 25th iteration ; # when not reading a previous guess; frac_start = 25; if kwargs.has_key('frac_start'):; frac_start = kwargs['frac_start']. # By default, we occupy by tenths of electrons; foccs = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]; if kwargs.has_key('foccs'):; foccs = kwargs['foccs'] . # By default, HOMO and LUMO are both in alpha; N = 0;; for A in range(mol.natom()):; N += mol.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1)/2); Na = int(N - Nb). charge = charge0; mult = mult0; ; # By default, nuke all the electrons; Nmin = 0;; if (kwargs.has_key('nmax')):; Nmin = N - int(kwargs['nmax']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = True; if kwargs.has_key('frac_diis'):; frac_diis = kwargs['frac_diis']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat' . # => Traverse <= #; PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; energy('scf'). # Determine HOMO; ref = PsiMod.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/frac.html:7164,charge,charge,7164,psi4manual/4.0b4/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/frac.html,2,['charge'],['charge']
Energy Efficiency,"for phenol dimer from the S22 database. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. omp2-3; OMP2 cc-pVDZ energy for the NO radical. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). sapt11; sapt example with orbital freezing with alkali metal and dMP2. fci-h2o; 6-31G H2O Test FCI Energy Point. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. dct8; DCT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. dfmp2-grad2; DF-MP2 cc-pVDZ gradient fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:6160,energy,energy,6160,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"for the H2O molecule. fci-dipole; 6-31G H2O Test FCI Energy Point. fnocc3; Test FNO-QCISD(T) computation. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. mints3; Test individual integral objects for correctness. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-fd-freq1; Mk-MRCCSD single point. O2 state described using ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:14292,energy,energy,14292,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"for the H2O molecule. nbo; Generation of NBO file. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. scf-guess-read3; Test if the the guess read in the same basis converges. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cubeprop; RHF orbitals and density for water. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. opt11; Transition-state optimizations of HOOH to both torsional transition states. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. cc13d; Tests analytic CC2 gradients. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. fnocc6; Test method/basis with disk_df. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. cc36; CC2(RHF)/cc-pVDZ energy of H2O. cepa1; cc-pvdz H2O Test CEPA(1) Energy. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:37898,energy,energy,37898,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"for the H2O molecule. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. scf-cholesky-basis; incremental Cholesky filtered SCF. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. ddd-function-kwargs; check distributed driver is correctly passing function kwargs. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc13b; Tests RHF CCSD(T)gradients. cc17; Single point energies of multiple excited states with EOM-CCSD. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. cepa2; cc-pvdz H2O Test ACPF Energy/",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:9831,energy,energy,9831,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"for the H2O molecule. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. nbo; Generation of NBO file. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. sapt-compare; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. dft-custom-mgga; updated dldf reference to new BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. cc26; Single-point gradient, analytic and via finite",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:22958,energy,energy,22958,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"for the NO molecule. cepa-module; routing check on lccd, lccsd, cepa(0). pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cc17; Single point energies of multiple excited states with EOM-CCSD. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). fnocc2; Test G2 method for H2O. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:25587,energy,energy,25587,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"for the NO molecule. cepa-module; routing check on lccd, lccsd, cepa(0). pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cc17; Single point energies of multiple excited states with EOM-CCSD. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). fnocc2; Test G2 method for H2O. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. opt6;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:28553,energy,energy,28553,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"for the NO radical. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. scf-level-shift-uhf; SCF level shift on a UHF computation. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. cbs-parser; mtd/basis syntax examples. options1; check all variety of options parsing. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. dfccsdat2; DF-A-CCSD(T) cc-pVDZ energy for the NH molecule. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. dfccd-grad1;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:14706,energy,energy,14706,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{| \textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn} | }\]. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn}}\]. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\sqrt{\frac{1}{n}\sum_{rxn}^{n}{(\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn})^2}}\]. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (4) or (1). Quantity; \(E_{\text{FCTL}}\) in Eqs. (4) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; \(E_{\text{DFT}}\) in Eq. (1). \begin{align*}; E_{\text{DFT}} & = E_{NN} + E_{1e^-} + E_{2e^-} + E_{xc} + E_{\text{-D}} + E_{\text{DH}} \\; & = E_{\text{FCTL}} + E_{\text{-D}} + E_{\text{DH}} \\; & = E_{\text{SCF}} + E_{\text{DH}}; \end{align*}Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity \(E_{xc}\) in Eqs. (4) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:11220,energy,energy,11220,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,6,['energy'],['energy']
Energy Efficiency,"for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Advanced Functional Use and Manipulation¶; Using the dft_functional keyword argument in the energy procedure call, one is able to use the orbitals generated by DFT for correlated wavefunction methods:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17# MP2 with a PBE0 reference computation. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis 6-31G; dft_spherical_points 302; dft_radial_points 99; reference rks; }. mp2_dft = energy(""MP2"", dft_functional=""PBE0""). Note that this would only update the generic Psi variables (e.g., “CURRENT ENERGY”) and not the MP2 or DFT variables.; Psi4 also supports easy customization and manipulation of DFT functionals. The values of alpha and omega can be adjusted with the DFT_ALPHA; and DFT_OMEGA keywords. For example, for LRC functionals, one can control the fraction of long-range Hartree-Fock and short-range DFA by changing DFT_OMEGA:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22molecule ch2 {; 0 3; C; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set reference uhf; set guess gwh; set basis cc-pvdz; set e_convergence 8. # Override the default va",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:27566,energy,energy,27566,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,2,['energy'],['energy']
Energy Efficiency,"format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]; def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal modes to remove from `vibinfo`. If; None, non-vibrations (R, T, or TR as labeled in `vibinfo['T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:37857,energy,energy,37857,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,2,['energy'],['energy']
Energy Efficiency,"format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 	 0-indexed indices of normal modes to remove from `vibinfo`. If; 	 None, non-vibrations (R, T, or TR as labeled in `vibinfo[",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html:37843,energy,energy,37843,psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html,4,['energy'],['energy']
Energy Efficiency,"format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal modes to remove from `vibinfo`. If; None, non-vibrations (R, T, or TR as labeled in `vibinfo['TRV",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html:37843,energy,energy,37843,psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/vib.html,4,['energy'],['energy']
Energy Efficiency,"format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal modes to remove from `vibinfo`. If; None, non-vibrations (R, T, or TR as labeled in `vibinfo['TRV']`); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/qcdb/vib.html:37777,energy,energy,37777,psi4manual/1.6.x/_modules/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcdb/vib.html,6,['energy'],['energy']
Energy Efficiency,"format_molecule_for_cfour_old(self):; """"""Function to print Molecule in a form readable by Cfour. This; version works as long as zmat is composed entirely of variables,; not internal values, while cartesian is all internal values,; no variables. Cutting off this line of development because,; with getting molecules after passing through libmints Molecule,; all zmats with dummies (Cfour's favorite kind) have already been; converted into cartesian. Next step, if this line was pursued; would be to shift any zmat internal values to external and any; cartesian external values to internal. """""". text = ''; text += 'auto-generated by qcdb from molecule %s\n' % (self.tagline). ## append units and any other non-default molecule keywords; #text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); #if not self.PYmove_to_com:; # text += "" no_com\n""; #if self.PYfix_orientation:; # text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; # text += ""%s %s%d %d\n"" % (; # """" if Pfr == 0 else "" --\n"",; # ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; # self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if type(self.full_atoms[at]) == ZMatrixEntry:; isZMat = True; elif type(self.full_atoms[at]) == CartesianEntry:; isCart = True; if self.fragment_types[fr] == 'Absent':; text += ""%s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += ""%s"" % (self.fsymbol(at)); else:; text += ""%s"" % (""GH"") # atom info is lost + self.fsymbol(at) + "")""); text += ""%s"" % (self.full_atoms[at].print_in_input_format_cfour()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variabl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:22483,charge,charge,22483,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,15,['charge'],['charge']
Energy Efficiency,"formation to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=''); sys.stdout.flush(). # Load in displacement into the active molecule; molecule.set_geometry(displacement). # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). # Obtain the gradient. This function stores the gradient into the reference wavefunction.; PsiMod.fd_freq_0(energies, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to frequency().""""""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); frequencies(name, **kwargs). [docs]def molden(filename):; """"""Function to write wavefunction information in molden; format to *filename*. """"""; m = PsiMod.MoldenWriter(PsiMod.reference_wavefunction()); m.write(filename). [docs]def parse_cotton_irreps(irrep):; r""""""Function to return validated Cotton ordering index from string or integer; irreducible representation *irrep*. """"""; cotton = {; 'c1': {; 'a': 1,; '1': 1; },; 'ci': {; 'ag': 1,; 'au': 2,; '1': 1,; '2': 2; },; 'c2': {; 'a': 1,; 'b': 2,; '1': 1,; '2': 2; },; 'cs': {; 'ap': 1,; 'app': 2,; '1': 1,; '2': 2; },; 'd2': {; 'a': 1,; 'b1': 2,; 'b2': 3,; 'b3': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2v': {; '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:51451,energy,energy,51451,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"formed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. dftd3-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN, calling Grimme’s dftd3 program for -D2 gradients. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. cc36; CC2(RHF)/cc-pVDZ energy of H2O. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mints1; Symmetry tests for a range of molecules. This ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:18548,energy,energy,18548,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"forming a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available. PSIthonPsiAPIe_mp2 = variable('MP2 TOTAL ENERGY'); e_scs_mp2 = variable('SCS-MP2 TOTAL ENERGY'). e_mp2 = psi4.variable('MP2 TOTAL ENERGY'); e_scs_mp2 = psi4.variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. PSIthonPsiAPI# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = psi4.energy(...); E = psi4.optimize(...); E = psi4.frequency(...); G = psi4.gradient(...) # used by optimize(); H = psi4.hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=Tru",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:9955,energy,energy,9955,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,2,['energy'],['energy']
Energy Efficiency,"formulating the; shell quartet screening process to scale linearly with system size.; LinK is most competitive when used with non-diffuse orbital basis sets, since orbital and density overlaps decay slower with diffuse functions.; LinK is especially powerful when combined with density-matrix based ERI screening (set SCREENING to DENSITY) and incremental Fock builds (set INCFOCK to TRUE), which decrease the number of significant two-electron integrals to calculate.; To control the LinK algorithm, here are the list of options provided. LINK_INTS_TOLERANCE: The integral screening tolerance used for sparsity-prep in the LinK algorithm. Defaults to the INTS_TOLERANCE option. Second-order Convergence¶; Second-order convergence takes into account both the gradient and Hessian to; take a full Newton step with respect to the orbital parameters. This results in; quadratic convergence with respect to density for SCF methods. For cases where; normal acceleration methods either fail or take many iterations to converge,; second-order can reduce the total time to solution.; Solving second-order (SO) methods exactly would require an inversion of the; orbital Hessian (an expensive \(\mathbb{N}^6\) operation); however, these; equations are normally solved iteratively where each iteration costs the same; as a normal Fock build (\(\mathbb{N}^4\)). The overall SOSCF operation is; thus broken down into micro- and macroiterations where the microiterations; refer to solving the SOSCF equations and macroiterations are the construction; of a new Fock matrix based on the orbitals from a SOSCF step.; SOSCF requires that all elements of the gradient to be less than one before the; method is valid. To this end, pre-SOSCF SCF iterations use normal; gradient-based extrapolation procedures (e.g., DIIS) until the gradient; conditions are met. Note that while the total number of macroiterations will be; less for SOSCF than gradient-based convergence acceleration, the cost of solving; the microiteratio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/scf.html:34841,reduce,reduce,34841,psi4manual/1.7.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/scf.html,3,['reduce'],['reduce']
Energy Efficiency,"four/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/kw-2; testing best practices options, part ii. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/kw-1; testing best practices options, part i. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/pywrap-db1; Database calculation, so no molecule ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_cfour-1.html:3880,energy,energy,3880,psi4manual/1.5.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"four_abcdtype aobasis; set cfour_scf_conv 12; set cfour_cc_conv 12; set cfour_lineq_conv 12. optimize('c4-ccsd(t)'). The utility of this method specification is that examination can be made; of the reference, the derivative level, the excitation level, etc. and; some options can be set according to best practices. Practically speaking,; CFOUR_CC_PROGRAM (and eventually CFOUR_ABCDTYPE) will; always be set to the fastest safe value.; For example, the input above will run with CFOUR_CC_PROGRAM=ECC; unless explicitly set to VCC.; An advantage of Psi4‘s Python driver is that any number of common; work-up procedures can be automated and wrapped around the the; conventional single-point and optimization procedures at the heart of all; quantum chemistry codes. Three core “wrappers” available in Psi4 are; _nbody_gufunc(),; database(), and; complete_basis_set(); read their respective sections; for details, but an overview is provided here. _nbody_gufunc(); computes the interaction energy of a bimolecular complex (counterpoise-corrected,; not, or both).; molecule dimer {; Ne; --; Ne 1 R; symmetry c1; }. Rvals=[2.5, 3.0, 4.0]; set basis aug-cc-pVDZ. for R in Rvals:; dimer.R = R; ecp = cp('c4-mp2'); print_stdout('R [A] = %.1f IE [kcal/mol] = %.3f\n' % (R, psi_hartree2kcalmol * ecp)). yields; R [A] = 2.5 IE [kcal/mol] = 0.804; R [A] = 3.0 IE [kcal/mol] = 0.030; R [A] = 4.0 IE [kcal/mol] = -0.014. Next, the database() wrapper allows any computational; model chemistry to be applied a predefined collection of molecules. Thus; an input; set {; basis jun-cc-pvdz; d_convergence 9; }. database('c4-mp2','nbc10',cp='on',subset='MeMe'). yields the counterpoise-corrected interaction energy for several points; along the dissociation curve of methane dimer, which is a member of the; NBC10 database:; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//; // Database nbc10 Results //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. For each VARIABLE requested by tabulate, a 'Reaction Value' will be formed from; 'Rea",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:12832,energy,energy,12832,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"fp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. energy('efp'). This computation involves purely EFP/EFP fragment interactions and is; performed entirely by the LIBEFP library. PSI4 can also handle mixed; systems of quantum mechanical (QM) and EFP fragments through the native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/libefp-1.html:6064,energy,energy,6064,psi4manual/1.1.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/libefp-1.html,12,['energy'],['energy']
Energy Efficiency,"fp h2o 4.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. energy('efp'). This computation involves purely EFP/EFP fragment interactions and is; performed entirely by the LIBEFP library. PSI4 can also handle mixed; systems of quantum mechanical (QM) and EFP fragments through the native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/libefp-1.html:6004,energy,energy,6004,psi4manual/1.4.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/libefp-1.html,18,['energy'],['energy']
Energy Efficiency,"fp h2o 4.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. energy('efp'). This computation involves purely EFP/EFP fragment interactions and is; performed entirely by the LIBEFP library. Psi4 can also handle mixed; systems of quantum mechanical (QM) and EFP fragments through the native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, Psi4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/libefp-1.html:5358,energy,energy,5358,psi4manual/1.0.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/libefp-1.html,4,['energy'],['energy']
Energy Efficiency,"frac{1}{n}\sum_{rxn}^{n}{| \textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn} | }\]. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn}}\]. db_name DATABASE ROOT-MEAN-SQUARE DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\sqrt{\frac{1}{n}\sum_{rxn}^{n}{(\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn})^2}}\]. DCT LAMBDA ENERGY¶; An energy term in density cumulant theory [E_h]. This term is the; 2-electron cumulant’s contribution contribution to the reduced; density matrix energy expression. Not recommended for interpretative; use except by reduced density matrix specialists. DCT SCF ENERGY¶; An energy term in density cumulant theory [E_h]. This term is the; 1-electron reduced density matrix (1RDM) contribution to the reduced; density matrix energy expression, plus the contribution of the; antisymmetrized product of 1RDMs. Not recommended for interpretative; use except by reduced density matrix specialists. DCT THREE-PARTICLE ENERGY¶; The three-particle correlation energy correction [E_h] in density cumulant; theory, akin to (T) CORRECTION ENERGY in coupled-cluster. DCT TOTAL ENERGY¶; Total energy [E_h] in density cumulant theory. Sum of DCT SCF ENERGY,; DCT LAMBDA ENERGY, and DCT THREE-PARTICLE ENERGY when present. DETCI AVG DVEC NORM¶; A measure of configuration interaction convergence. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [E_h] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (4) or (1). Quantity; \(E_{\text{FCTL}}\)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:27240,reduce,reduced,27240,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['reduce'],['reduced']
Energy Efficiency,"fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_variable(self, arg0); Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label(self, arg0); Gets the original label of the atom as given in the input file (C2, H4). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self, dipole_field, …); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self, arg0); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separato",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:4064,charge,charge,4064,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Whenever the molecule is supplied in PSI4 format, the job control; keywords must be too. All Cfour keywords are the usual; ones, prepended by cfour_ to avoid any possible name conflicts. As; detailed in Job Control Keywords, setting keywords is flexible in; format. The previous example translates to:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23# UHF-SCF energy calculation. molecule {; 0 2 # multiplicity from the MULT keyword; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0; }. set {; cfour_CALC_level=HF # only full keyword names allowed; cfour_BASIS=qz2p; #MULT=2 # now in molecule {...} block; cfour_REFerence=UHF; cfour_OCCUPATION [[3, 1, 1, 0], [3,0,1,0] ] # arrays in python notation; cfour_SCF_CONV=12; cfour_MEMORY=20000000; }. energy('cfour'). Here, note that none of capitalization, equals sign, or whitespace matter; for the keyword commands. Specification of strings and integers requires no; translation; booleans have extended freedom of; format; arrays must be translated into Python-style (square-bracket; bounded and comma delimited) of appropriate dimension. There are many; sample inputs in psi4/tests/cfour/ starting with sp- that take; examples from the Cfour manual and first run them in sandwich mode and; then run them as translated into PSI4 format. Note; PSI4 only recognizes keywords by their full name, so the common; Cfour keyword abbreviations CALC, REF, etc. must be replaced by their; proper names of CFOUR_CALC_LEVEL, CFOUR_REFERENCE, etc. Whenever the molecule is supplied in PSI4 format, it is possible to; perform geometry optimizations where Cfour supplies the gradient and the; PSI4 module optking drives the structural; changes. Because of the limitations on geometry specification for; optimizations in C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:5645,energy,energy,5645,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,6,['energy'],['energy']
Energy Efficiency,"frame; # TODO self.set_point_group(self.find_point_group()); # TODO self.set_full_point_group(). # Disabling symmetrize for now if orientation is fixed, as it is not; # correct. We may want to fix this in the future, but in some cases of; # finite-differences the set geometry is not totally symmetric anyway.; # Symmetrize the molecule to remove any noise; # TODO self.symmetrize(); #print ""after symmetry:""; #self.print_full(). self.lock_frame = True. # <<< Methods for Miscellaneous >>>. [docs] def clear(self):; """"""Zero it out.""""""; self.lock_frame = False; self.atoms = []; self.full_atoms = []. [docs] def nuclear_repulsion_energy(self):; """"""Computes nuclear repulsion energy. >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. """"""; e = 0.0; for at1 in range(self.natom()):; for at2 in range(self.natom()):; if at2 < at1:; Zi = self.Z(at1); Zj = self.Z(at2); dist = distance(self.xyz(at1), self.xyz(at2)); e += Zi * Zj / dist; return e. [docs] def nuclear_repulsion_energy_deriv1(self):; """"""Computes nuclear repulsion energy derivatives. >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. """"""; de = []; for i in range(self.natom()):; entry = [0.0, 0.0, 0.0]; for j in range(self.natom()):; if i != j:; temp = distance(self.xyz(i), self.xyz(j)) ** 3.0; Zi = self.Z(i); Zj = self.Z(j); entry[0] -= (self.x(i) - self.x(j)) * Zi * Zj / temp; entry[1] -= (self.y(i) - self.y(j)) * Zi * Zj / temp; entry[2] -= (self.z(i) - self.z(j)) * Zi * Zj / temp; de.append(entry); return de. [docs] def nuclear_repulsion_energy_deriv2(self):; """""" **NYI** Computes nuclear repulsion energy second derivatives""""""; raise FeatureNotImplemented('Molecule::nuclear_repulsion_energy_deriv2'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:44325,energy,energy,44325,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,6,['energy'],['energy']
Energy Efficiency,"frec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irrep_lbls = mol.irrep_labels(); max_disp = (findifrec[""stencil_size""] - 1) // 2; e_per_diag = 2 * max_disp. # Unlike in the gradient case, we have no symmetry transformations to worry about.; # We get to the task directly: assembling the force constants in each irrep block.; for h in range(data[""n_irrep""]):; salc_indices = data[""salc_indices_pi""][h]; if not salc_indices: continue. n_salcs = len(salc_indices); E = np.zeros((len(salc_indices), e_per_diag)). # Step One: Diagonals; # For asymmetric irreps, the energy at a + disp is the same as at a - disp; # Just reuse the - disp energy for the + disp energy. for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = displacements[f""{salc_index}: {-j}""][""energy""]; k = -j if h else j # Because of the +- displacement trick; E[i, max_disp + j - 1] = displacements[f""{salc_index}: {k}""][""energy""]; # Now determine all diagonal force constants for this irrep.; if findifrec[""stencil_size""] == 3:; diag_fcs = E[:, 0] + E[:, 1]; diag_fcs -= 2 * ref_energy; diag_fcs /= (findifrec[""step""][""size""]**2); elif findifrec[""stencil_size""] == 5:; diag_fcs = -E[:, 0] + 16 * E[:, 1] + 16 * E[:, 2] - E[:, 3]; diag_fcs -= 30 * ref_energy; diag_fcs /= (12 * findifrec[""step""][""size""]**2); H_irr = np.diag(diag_fcs). # TODO: It's a bit ugly to use the salc indices to grab the off-diagonals but the indices; # within the irrep to grab the diagonals. Is there a better way to do this?. # Step Two: Off-diagonals; # We need off-diagonal energies, diagonal energies, AND the reference energy; # Grabbing off-diagonal energies is a pain, so once we know our SALCs...; # ...define offdiag_en to do that for us.; for i, salc in enumerate(salc_indices):; for j, salc2 in enumerate(salc_indices[:i]):; offdiag_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:38520,energy,energy,38520,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,16,['energy'],['energy']
Energy Efficiency,"freq. freq¶. psi4.driver.freq(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) or LSDA density functional theory (DFT)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.freq.html:1097,energy,energy,1097,psi4manual/1.7.x/api/psi4.driver.freq.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.freq.html,8,['energy'],['energy']
Energy Efficiency,"frequencies from energies for H2O. cbs-xtpl-dict; Extrapolated water energies. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. dfremp-1; density fitted REMP/cc-pVDZ energies for the CO2 molecule. fci-dipole; 6-31G H2O Test FCI Energy Point. pywrap-align-chiral; testing aligner on enantiomers based on Table 1 of 10.1021/ci100219f aka J Chem Inf Model 2010 50(12) 2129-2140. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. linK-1; RHF Linear Exchange Algorithm test for water. stability3; Test LDA stability analysis against QChem. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. extern3; External potential calculation with one Ghost atom and one point charge at the same position. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cbs-xtpl-energy-conv; Extrapolated water energies - conventional integrals version. x2c3; Test of SFX2C-1e on Water uncontracted cc-p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:12353,energy,energy,12353,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"frequencies on methyloxirane. mints3; Test individual integral objects for correctness. dft-custom; DFT custom functional test. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. soscf-large; Second-order SCF convergnece: Benzene. opt16; SCF 6-31G(d) optimization of TS for HCN to HNC Performs finite difference hessian calculation. Then optimizes using previous orbitals for scf guess, in subsequent calculations. The last two displacements of the hessian break the plane of symemtry, This test confirms that only the reference geometry, with the correct symmetry, writes orbitals to disk. SCF will fail (ValidationError) otherwise. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). casscf-fzc-sp; CASSCF/6-31G** energy point. scf-coverage; Lithium test for coverage. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. cisd-sp; 6-31G** H2O Test CISD Energy Point. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:24296,energy,energy,24296,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"frequencies. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; frequencies. frequencies¶. psi4.driver.frequencies(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.frequencies-1.html:994,energy,energy,994,psi4manual/1.4.0/api/psi4.driver.frequencies-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.frequencies-1.html,4,['energy'],['energy']
Energy Efficiency,"frequencies. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; frequencies. frequencies¶. psi4.driver.frequencies(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.frequencies-1.html:994,energy,energy,994,psi4manual/1.5.0/api/psi4.driver.frequencies-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.frequencies-1.html,4,['energy'],['energy']
Energy Efficiency,"frequencies. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; frequencies. frequencies¶. psi4.driver.frequencies(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.frequencies.html:994,energy,energy,994,psi4manual/1.6.x/api/psi4.driver.frequencies.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.frequencies.html,2,['energy'],['energy']
Energy Efficiency,"frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or string; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:70025,energy,energy,70025,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file (``'continuous'``) or are to be farmed out in an; embarrassingly parallel fashion (``'sow'``/``'reap'``)/ For the latter,; run an initial job with ``'sow'`` and follow instructions in its output file.; For maximum flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:81682,energy,energy,81682,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"frequency. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; frequency. frequency¶. psi4.driver.frequency(name, **kwargs)[source]¶; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.frequency-1.html:994,energy,energy,994,psi4manual/1.4.0/api/psi4.driver.frequency-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.frequency-1.html,4,['energy'],['energy']
Energy Efficiency,"frequency. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; frequency. frequency¶. psi4.driver.frequency(name, **kwargs)[source]¶; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.frequency-1.html:994,energy,energy,994,psi4manual/1.5.0/api/psi4.driver.frequency-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.frequency-1.html,4,['energy'],['energy']
Energy Efficiency,"frequency. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; frequency. frequency¶. psi4.driver.frequency(name, **kwargs)[source]¶; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.frequency.html:994,energy,energy,994,psi4manual/1.6.x/api/psi4.driver.frequency.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.frequency.html,2,['energy'],['energy']
Energy Efficiency,"from 1.0 to a larger value to force the radial grid to span a larger extent in space.; The atomic weighting scheme is controlled by the DFT_NUCLEAR_SCHEME; option, which may be one of TREUTLER, BECKE, STRATMANN, NAIVE,; or SBECKE. The last is a smoother variant of the BECKE scheme recently introduced; by Laqua [Laqua:2018:204111] that should behave better for weak interactions.; Pruning of the quadrature grid is controlled by the DFT_PRUNING_SCHEME; option. The options ROBUST and TREUTLER divide the grid into spherical regions; based on the Bragg-Slater radius of each atom and apply different orders to them.; The ROBUST scheme is a less aggressive variant of the TREUTLER approach and; suitable for benchmark-level quality (MAD < 0.002 kcal/mol for the S22 with PBE/aug-cc-pVTZ; for pruned versus unpruned grid). Our implementation of the TREUTLER scheme shows an; error of 0.02 kcal/mol for the same benchmark. Both also reduce the grid order by 1 for H; and He atoms and avoid any pruning of heavy atoms (Z >= 36) Other schemes mentioned in; the keyword documentation (e.g. P_SLATER) are experimental and should be considered expert-only.; Once the molecular quadrature grid is built, the points are partitioned into; blocks of points which are spatially close to each other. We use an octree; algorithm for this procedure, which produces a good balance between spatial; compactness of each block (which helps achieve linear scaling due to the; exponential decay of the basis functions), and retaining a large number of; points in each block (which helps keep the FLOP rate up by allowing for a; reasonably large amount of BLAS3/BLAS2 work to form the densities and potentials; in each block). For each block, a united set of significant basis functions is; determined by the cutoff radius of each shell of basis functions. The size of; this cutoff radius (and thereby the accuracy of the density/potential; evaluation) can be varied by setting the DFT_BASIS_TOLERANCE, which; defaults to 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:21557,reduce,reduce,21557,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,9,['reduce'],['reduce']
Energy Efficiency,"from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']),; jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs] def run_gcp(self, func: Optional[str] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:45574,energy,energy,45574,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,4,['energy'],['energy']
Energy Efficiency,"from pydantic import Field, validator; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core; from psi4.driver import driver_util, p4util, pp; from psi4.driver import qcdb; from psi4.driver.driver_cbs_helper import composite_procedures, register_composite_function, register_xtpl_function, xtpl_procedures # lgtm[py/unused-import]; from psi4.driver.driver_util import UpgradeHelper; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f_hessian', 'f_dipole', 'f_dipder']; _lmh_labels = {; 1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']; }; CBSMetadata = List[Dict[str, Any]]. # remove in 1.8; # these get input files to the point where they raise an UpgradeHelper; def xtpl_highest_1():; pass. def scf_xtpl_helgaker_2():; pass. def scf_xtpl_truhlar_2():; pass. def scf_xtpl_karton_2():; pass. def scf_xtpl_helgaker_3():; pass. def corl_xtpl_helgaker_2():; pass. def _expand_bracketed_basis(basisstring: str, molecule: Union[""qcdb.Molecule"", core.Molecule] = None) -> Tuple[List[str], List[int]]:; """"""Function to transform and validate basis series specification for cbs(). Parameters; ----------; basisstring; A string containing the basis sets to be expanded.; A basis set with no paired square brackets is passed through; with zeta level 0 (e.g., ``'6-31+G(d,p)'`` is returned as; ``([""6-31+G(d,p)""], [0])``). A basis set with square brackets is checked; for sensible sequence and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:5844,energy,energy,5844,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest state of H2O+ (A1 excitation). cc54; CCSD dipole with user-specified basis set. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. cc16; UHF-B-CCD(T)/cc-pVDZ CH2 single-point energy (fzc, MO-basis ). sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. scf3; are specified explicitly. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dftd3-energy; Exercises the various DFT-D corrections, both through python directly and through c++. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cc52; CCSD Response for H2O2. pywrap-db2; Database calculation, run in sow/reap mode. cc50; EOM-CC3(ROHF) on CH rad",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:11496,energy,energy,11496,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,8,['energy'],['energy']
Energy Efficiency,"fs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.print_out(); ExternalPotential.setName(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html:2307,charge,charge,2307,psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.ExternalPotential.html,2,['charge'],['charge']
Energy Efficiency,"fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. cbs-xtpl-alpha; Extrapolated water energies. extern3; External potential calculation with one Ghost atom and one point charge at the same position. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. cbs-delta-energy; Extrapolated energies with delta correction. dft1; DFT Functional Test all values update for new BraggSlater radii. scf-coverage; Lithium test for coverage. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. dft-custom-mgga; updated dldf reference to new BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. numpy-array-interface; Numpy interface testing. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:36334,energy,energy,36334,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"fset = 0; for h, block in enumerate(MO_FZC_B.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = beta_mo_idx(il[0][index] + offset); col = beta_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; alpha_eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), alpha_mo_idx); beta_eigs_dump = write_eigenvalues(wfn.epsilon_b().get_block(mo_slice).to_array(), beta_mo_idx); intdump.write(alpha_eigs_dump + beta_eigs_dump); # Dipole integrals; #core.print_out('Writing dipole moment OEI in FCIDUMP format to ' + fname + '\n'); # Traceless quadrupole integrals; #core.print_out('Writing traceless quadrupole moment OEI in FCIDUMP format to ' + fname + '\n'); # Frozen core + nuclear repulsion energy; core.print_out('Writing frozen core + nuclear repulsion energy in FCIDUMP format to ' + fname + '\n'); e_fzc = ints.get_frozen_core_energy(); e_nuc = molecule.nuclear_repulsion_energy(wfn.get_dipole_field_strength()); intdump.write('{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(e_fzc + e_nuc, 0, 0, 0, 0)); core.print_out('Done generating {} with integrals in FCIDUMP format.\n'.format(fname)). [docs]def write_eigenvalues(eigs, mo_idx):; """"""Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file.; """"""; eigs_dump = ''; iorb = 0; for h, block in enumerate(eigs):; for idx, x in np.ndenumerate(block):; eigs_dump += '{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, mo_idx(iorb), 0, 0, 0); iorb += 1; return eigs_dump. def _irrep_map(wfn):; """"""Returns an array of irrep indices that maps from Psi4's ordering convention to the standard FCIDUMP convention.; """"""; symm = wfn.molecule().point_group().symbol(); psi2d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html:8048,energy,energy,8048,psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html,2,['energy'],['energy']
Energy Efficiency,"fset = 0; for h, block in enumerate(MO_FZC_B.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = beta_mo_idx(il[0][index] + offset); col = beta_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; alpha_eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), alpha_mo_idx); beta_eigs_dump = write_eigenvalues(wfn.epsilon_b().get_block(mo_slice).to_array(), beta_mo_idx); intdump.write(alpha_eigs_dump + beta_eigs_dump); # Dipole integrals; #core.print_out('Writing dipole moment OEI in FCIDUMP format to ' + fname + '\n'); # Traceless quadrupole integrals; #core.print_out('Writing traceless quadrupole moment OEI in FCIDUMP format to ' + fname + '\n'); # Frozen core + nuclear repulsion energy; core.print_out('Writing frozen core + nuclear repulsion energy in FCIDUMP format to ' + fname + '\n'); e_fzc = ints.get_frozen_core_energy(); e_nuc = molecule.nuclear_repulsion_energy(wfn.get_dipole_field_strength()); intdump.write('{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(e_fzc + e_nuc, 0, 0, 0, 0)); core.print_out('Done generating {} with integrals in FCIDUMP format.\n'.format(fname)). def write_eigenvalues(eigs, mo_idx):; """"""Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file.; """"""; eigs_dump = ''; iorb = 0; for h, block in enumerate(eigs):; for idx, x in np.ndenumerate(block):; eigs_dump += '{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, mo_idx(iorb), 0, 0, 0); iorb += 1; return eigs_dump. def _irrep_map(wfn):; """"""Returns an array of irrep indices that maps from Psi4's ordering convention to the standard FCIDUMP convention.; """"""; symm = wfn.molecule().point_group().symbol(); psi2dump = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html:8244,energy,energy,8244,psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html,8,['energy'],['energy']
Energy Efficiency,"fset = 0; for h, block in enumerate(MO_FZC_B.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = beta_mo_idx(il[0][index] + offset); col = beta_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; alpha_eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), alpha_mo_idx); beta_eigs_dump = write_eigenvalues(wfn.epsilon_b().get_block(mo_slice).to_array(), beta_mo_idx); intdump.write(alpha_eigs_dump + beta_eigs_dump); # Dipole integrals; #core.print_out('Writing dipole moment OEI in FCIDUMP format to ' + fname + '\n'); # Traceless quadrupole integrals; #core.print_out('Writing traceless quadrupole moment OEI in FCIDUMP format to ' + fname + '\n'); # Frozen core + nuclear repulsion energy; core.print_out('Writing frozen core + nuclear repulsion energy in FCIDUMP format to ' + fname + '\n'); e_fzc = ints.get_frozen_core_energy(); e_nuc = molecule.nuclear_repulsion_energy(wfn.get_dipole_field_strength()); intdump.write('{:29.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(e_fzc + e_nuc, 0, 0, 0, 0)); core.print_out('Done generating {} with integrals in FCIDUMP format.\n'.format(fname)). [docs]def write_eigenvalues(eigs, mo_idx):; """"""Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file.; """"""; eigs_dump = ''; iorb = 0; for h, block in enumerate(eigs):; for idx, x in np.ndenumerate(block):; eigs_dump += '{:29.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, mo_idx(iorb), 0, 0, 0); iorb += 1; return eigs_dump. def _irrep_map(wfn):; """"""Returns an array of irrep indices that maps from Psi4's ordering convention to the standard FCIDUMP convention.; """"""; symm = wfn.molecule().point_group().symbol(); psi2d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/p4util/fcidump.html:8041,energy,energy,8041,psi4manual/1.5.0/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/p4util/fcidump.html,2,['energy'],['energy']
Energy Efficiency,"fsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; core.set_variable(m + ' TOTAL ENERGY', ene); core.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; core.set_variable('CURRENT ENERGY', ene); core.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:151229,ENERGY,ENERGY,151229,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"fsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; core.set_variable(m + ' TOTAL ENERGY', ene); core.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; core.set_variable('CURRENT ENERGY', ene); core.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:159856,ENERGY,ENERGY,159856,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"fsymbol(at) == ""X"":; pass; else:; if self.fZ(at):; text += ""%-8s"" % (self.flabel(at)); else:; text += ""%-8s"" % (""Gh("" + self.flabel(at) + "")""); [x, y, z] = self.full_atoms[at].compute(); text += '%17.12f %17.12f %17.12f\n' % \; (x * factor, y * factor, z * factor); text += ""\n"". wtext = 'molecule mol {\n'; for line in text.splitlines():; wtext += ' ' + line + '\n'; wtext += '}\n'; return wtext. def format_molecule_for_molpro(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2angstroms; # TODO keep fix_or? # Jan 2015 turning off fix_or; #self.fix_orientation(True); #self.PYmove_to_com = False; self.update_geometry(). text = """"; text += 'angstrom\n'; text += 'geometry={\n'; dummy = []. for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%-2s %17.12f %17.12f %17.12f\n' % (self.symbol(i), \; x * factor, y * factor, z * factor); if not self.Z(i):; dummy.append(str(i + 1)) # Molpro atom number is 1-indexed. text += '}\n\n'; text += 'SET,CHARGE=%d\n' % (self.molecular_charge()); text += 'SET,SPIN=%d\n' % (self.multiplicity() - 1) # Molpro wants (mult-1); if len(dummy) > 0:; text += 'dummy,' + ','.join(dummy) + '\n'; return text. def format_molecule_for_cfour(self):; """"""Function to print Molecule in a form readable by Cfour. """"""; self.update_geometry(); factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2angstroms; #factor = 1.0 if self.PYunits == 'Bohr' else 1.0/psi_bohr2angstroms. text = 'auto-generated by qcdb from molecule %s\n' % (self.tagline). # append atoms and coordentries; for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%-2s %17.12f %17.12f %17.12f\n' % ((self.symbol(i) if self.Z(i) else ""GH""), \; x * factor, y * factor, z * factor). #for fr in range(self.nfragments()):; # if self.fragment_types[fr] == 'Absent':; # pass; # else:; # for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; # [x, y, z] = self.atoms[at].compute(); # text += '%-2s %17.12f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html:15238,CHARGE,CHARGE,15238,psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,2,['CHARGE'],['CHARGE']
Energy Efficiency,"ft matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get_block(self, rows, cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load_mpqc(self, filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read(filename[, prefix]); Reads the data from a NumPy compress file. np_write([filename, prefix]); Writes the irreped matrix to a NumPy zipped file. partial_cholesky_factorize(self, delta, …); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self, alpha, cutoff); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self, RMRoutfile); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self, condition, nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self, a, transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self, h, i, j, theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self, h); Returns the rows in irrep h. save(self, filename, append, …); Saves the matrix in ASCII format to filename, as symmetry blocks or full matrix. scale(self, a); Scales the matrix by the floating point value a. scale_column(self, h, n, a); Scales column n of irrep h by a. scale_row(self, h, m, a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*arg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html:3231,power,power,3231,psi4manual/1.2.1/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html,2,['power'],['power']
Energy Efficiency,"ft_functional wb97; }. # Arguments are molecule object, minimum omega, maximum omega; ip_fitting(h2o, 0.4, 2.0). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized \(\omega\); between 0.1 and 0.5. Fractional Particle Curves¶; The behavior of the electronic energy and HOMO energy across fractional numbers; of electrons is extremely useful for elucidating the MSIE behavior of various; functional technologies. PSI4 features an efficient fractional-particle DFT; code, written into the UKS spin specialization. Due to a combination of DIIS and; reuse of integrals/guess orbitals across a range of fractional occupations, this; code is able to perform fractional occupation curves for systems with up to 60; atoms, across a wide range of the particle number \(N\).; Two python macros exist for this code. The first is frac_traverse(), which is; used to investigate the fractional occupation behavior within one electron above; and below the neutral. An example is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21memory 512 MB; from frac import *. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # FRAC jobs must be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do all kinds of weird stuff; basis aug-cc-pvdz # Augmented functions are very important on the anion side; scf_type df; dft_functional wb97; }. # Argument is the molecule object.; # Many optional arguments are available, see the python file",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dft-1.html:23728,efficient,efficient,23728,psi4manual/1.1.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dft-1.html,2,['efficient'],['efficient']
Energy Efficiency,"ftd3 executable or simple-dftd3 Python module.; gcp_engine (str) – Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp (bool) – Whether to request atomic pairwise analysis. Methods Summary. compute_energy(molecule[, wfn]); Compute dispersion energy based on engine, dispersion level, and parameters in self. compute_gradient(molecule[, wfn]); Compute dispersion gradient based on engine, dispersion level, and parameters in self. compute_hessian(molecule[, wfn]); Compute dispersion Hessian based on engine, dispersion level, and parameters in self. print_out(); Format dispersion parameters of self for output file. Methods Documentation. compute_energy(molecule, wfn=None)[source]¶; Compute dispersion energy based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule) – System for which to compute empirical dispersion correction.; wfn (Wavefunction) – Location to set QCVariables. Returns:; Dispersion energy [Eh]. Return type:; float. Notes. DISPERSION CORRECTION ENERGYDisp always set. Overridden in SCF finalization, but that only changes for “-3C” methods. fctl DISPERSION CORRECTION ENERGYSet if fctldash nonempty. compute_gradient(molecule, wfn=None)[source]¶; Compute dispersion gradient based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule) – System for which to compute empirical dispersion correction.; wfn (Wavefunction) – Location to set QCVariables. Returns:; (nat, 3) dispersion gradient [Eh/a0]. Return type:; Matrix. compute_hessian(molecule, wfn=None)[source]¶; Compute dispersion Hessian based on engine, dispersion level, and parameters in self.; Uses finite difference, as no dispersion engine has analytic second derivatives. Parameters:. molecule (Molecule) – System for which to compute empirical dispersion correction.; wfn (Wavefunction) – Location to set QCVariables. Returns:; (3*nat, 3*nat) dispersion Hessian [Eh/a0/a0]. Return ty",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html:4449,energy,energy,4449,psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html,2,['energy'],['energy']
Energy Efficiency,"ftd4/PSI4 interfaces are transparent, and all corrections are; interfaced exactly alike.; The -D3 interface can use classic or simple-dftd3 programs interchangeably and will prefer the latter.; Starting in v1.9, the classic program is no longer supported or tested, though it isn’t deliberately disabled.; Despite different defaults in these programs when run independently,; when run through PSI4 as EmpiricalDispersion engine, each should; produce the same result. Moreover, PSI4‘s own defaults and aliases; are unchanged by the new engines, so -D continues to mean -D2,; -D3 continues to mean zero-damping without 3-body correction,; and input files should continue producing the same results. Please file; an issue if found otherwise.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, a B3LYP-D3 (zero-damping), and a B3LYP-D4 (Becke-Johnson damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'); energy('b3lyp-d4'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2.; No text output is available from the dftd4 or s-dftd3 programs. Variants of dispersion corrections¶. Extension [1] and Aliases; Variant; Computing Program (engine); DFT_DISPERSION_PARAMETERS [11]. -D; alias to -D2. -D1; -D1 [2]; PSI4‘s libdisp; [\(s_6\)]. -D2; -D2 [3]; PSI4‘s libdisp OR dftd3; [\(s_6\), \(\alpha_6\), \(s_{r,6}\)]. -D3ZERO2B, -D3ZERO, -D32B, -D3; -D3 [4] w/ original zero-damping w/o 3-bo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/dftd3.html:7430,energy,energy,7430,psi4manual/1.9.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/dftd3.html,2,['energy'],['energy']
Energy Efficiency,"ften referred to as Atomic Orbitals; (AOs). The matrix \(C_{\mu i}\) contains the MO coefficients, which are the; constrained variational parameters in Hartree–Fock. The molecular orbitals are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. \[\begin{split}| \Psi_0 \rangle =; \frac{1}{\sqrt{N!}} \left | \begin{array}{cccc}; \psi_1 (\vec x_1) & \psi_2(\vec x_1) & \ldots & \psi_N (\vec x_1) \\; \psi_1 (\vec x_2) & \psi_2(\vec x_2) & \ldots & \psi_N (\vec x_2) \\; \vdots & \vdots & \ddots & \vdots \\; \psi_1 (\vec x_N) & \psi_2(\vec x_N) & \ldots & \psi_N (\vec x_N) \\; \end{array}\right |\end{split}\]; This form for the Hartree–Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; \(\mathbb{R}^6\) instead of a more complicated effect in; \(\mathbb{R}^N\).; Considering the electronic Hamiltonian,. \[\hat H = \sum_{i} -\frac{1}{2} \nabla_i^2 + \sum_{i} \sum_{A} -; \frac{Z_A}{r_{iA}} + \sum_{i>j} \frac{1}{r_{ij}},\]; the Hartree–Fock energy is, by Slater’s rules,. \[E_{\mathrm{HF}} =; \langle \Psi_0 | \hat H | \Psi_0 \rangle; = \sum_{i} \langle i | \hat h | i \rangle; + \frac 1 2 \sum_{i,j} [ii|jj] - [ij|ji]\]. \[=; D_{\mu\nu}^\alpha \left(H_{\mu\nu} + F_{\mu\nu}^{\alpha} \right); + D_{\mu\nu}^\beta \left(H_{\mu\nu} + F_{\mu\nu}^{\beta} \right)\]; Here \(H\) is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. \[H_{\mu\nu} =; \left(\mu \left| -\frac{1}{2} \nabla^2 + \sum_{A} -\frac{Z_A}{r_{1A}} \right; | \nu \right),\]; \(D\) is the AO-basis density matrix, build from the occupied orbital; coefficients,. \[D_{\mu\nu}^{\alpha} =; C_{\mu i}^{\alpha} C_{\nu i}^{\alpha},\]; and \(F\) is the Fock matrix, which is the effective one-body potential at; the current value of the density,. \[F_{\mu\nu}^{\alpha} = H_{\mu\nu}; + \underbrace{\left(D_{\lambda\sigma}^{\alpha} + D_{\lambda\sigma}^{\beta}\right); (\mu\nu|\la",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:5329,energy,energy,5329,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,15,['energy'],['energy']
Energy Efficiency,"ften; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: string; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis to build alpha NO's from (optional). :type density_b: :py:class:`~psi4.core.Matrix`; :param density_b: density in the MO basis to build beta NO's from, assumes restricted if not supplied (optional). :type dovirtual: bool; :param dovirtual: do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO's (false) (optional). :examples:. >>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). >>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). >>> # [3] The following does NOT work, please see below; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). >>> # [4] This WILL work, note the transformation of Da (SO->MO); >>> E, wfn = properties('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> Da_mo = Matrix.triplet(wfn.Ca(), Da_so, wfn.Ca(), True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:97738,energy,energy,97738,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"ften; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: string; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis to build alpha NO's from (optional). :type density_b: :py:class:`~psi4.core.Matrix`; :param density_b: density in the MO basis to build beta NO's from, assumes restricted if not supplied (optional). :type dovirtual: bool; :param dovirtual: do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO's (false) (optional). :examples:. >>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). >>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). >>> # [3] The following does NOT work, please see below; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). >>> # [4] This WILL work, note the transformation of Da (SO->MO); >>> E, wfn = properties('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:82716,energy,energy,82716,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"ften; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :type filename: string; :param filename: destination file name for MOLDEN file (optional). :type density_a: :py:class:`~psi4.core.Matrix`; :param density_a: density in the MO basis to build alpha NO's from (optional). :type density_b: :py:class:`~psi4.core.Matrix`; :param density_b: density in the MO basis to build beta NO's from, assumes restricted if not supplied (optional). :type dovirtual: bool; :param dovirtual: do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO's (false) (optional). :examples:. >>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). >>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). >>> # [3] The following does NOT work, please see below; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). >>> # [4] This WILL work, note the transformation of Da (SO->MO); >>> E, wfn = property('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> Da_mo = Matrix.triplet(wfn.Ca(), Da_so, wfn.Ca(), True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotation",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:90182,energy,energy,90182,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"fter adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pw91_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('PW91'); # Tab in, trailing newlines; sup.set_description(' PW91 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.P. Perdew et. al., Phys. Rev. B., 46(11), 6671-6687, 1992\n'). # Add member functionals; sup.add_x_functional(build_functional('PW91_X')); sup.add_c_functional(build_functional('PW91_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_bp86_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('BP86'); # Tab in, trailing newlines; sup.set_description(' BP86 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Null\n'). # Add member functionals; sup.add_x_functional(build_functional('B88_X')); sup.add_c_functional(build_functional('P86_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_ft97_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:22331,allocate,allocate,22331,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,6,['allocate'],['allocate']
Energy Efficiency,"fth delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~xtpl_highest_1` otherwise. :type corl_scheme: function; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta_scheme: function; :param delta_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta2_scheme: function; :param delta2_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta2_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta3_scheme: function; :param delta3_scheme: |dl| ``xtpl_highest_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:26063,energy,energy,26063,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"fting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). core.set_legacy_gradient(G). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; core.set_global_option('HESSIAN_WRITE', True). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:69949,ENERGY,ENERGY,69949,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"ful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. This becomes the; default for the second and later iterations of geometry optimizations. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; BASIS_GUESS = SMALL_BASIS to the options list. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via the options detailed below.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:15991,energy,energy,15991,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,6,['energy'],['energy']
Energy Efficiency,"ful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets; Inputting effective core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:9831,energy,energy,9831,psi4manual/1.2.1/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html,8,['energy'],['energy']
Energy Efficiency,"full CI) computations to obtain these results, and hence they will only; be possible for very small systems (generally a dozen electrons or less).; The simplest way to run high-order perturbation theory computations is to; call, e.g., energy('mp10') to invoke a MP10 computation or; energy('zapt25') to invoke a ZAPT25 computation. This will; automatically set several additional user options to their appropriate; values. The program uses the Wigner (2n+1) rule to obtain higher-order; energies from lower-order wavefunctions.; For the interested reader, the additional user options that are; automatically set up by the calls above are as follows. A call like; energy('mp10') sets MPN to TRUE.; The program uses the Wigner (2n+1) rule by default; (MPN_WIGNER = TRUE); and figures out what order of wavefunction is; necessary to reach the desired order in the energy. The program then; sets MAX_NUM_VECS to the required order in the; wavefunction.; By default, the requested n-th order energy is saved as the current; energy to the process environment. ZAPTN works essentially the same; way for an ROHF reference. Arbitrary Order Coupled-Cluster Theory¶; This DETCI-based version of this feature is not yet released. However,; the current version of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); howe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/detci-1.html:11410,energy,energy,11410,psi4manual/1.2.1/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/detci-1.html,46,['energy'],['energy']
Energy Efficiency,"full CI) computations to obtain these results, and hence they will only; be possible for very small systems (generally a dozen electrons or less).; The simplest way to run high-order perturbation theory computations is to; call, e.g., energy('mp10') to invoke a MP10 computation or; energy('zapt25') to invoke a ZAPT25 computation. This will; automatically set several additional user options to their appropriate; values. The program uses the Wigner (2n+1) rule to obtain higher-order; energies from lower-order wavefunctions.; For the interested reader, the additional user options that are; automatically set up by the calls above are as follows. A call like; energy('mp10') sets MPN to TRUE.; The program uses the Wigner (2n+1) rule by default; (MPN_WIGNER = TRUE); and figures out what order of wavefunction is; necessary to reach the desired order in the energy. The program then; sets MAX_NUM_VECS to the required order in the; wavefunction.; By default, the requested n-th order energy is saved as the current; energy to the process environment. ZAPTN works essentially the same; way for an ROHF reference. Arbitrary Order Coupled-Cluster Theory¶; This DETCI-based version of this feature is not yet released. However,; the current version of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which Psi4 can interface (see Section; Interface to MRCC by M. Kállay); howe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/detci-1.html:10203,energy,energy,10203,psi4manual/1.0.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/detci-1.html,4,['energy'],['energy']
Energy Efficiency,"full):""]); cp_table[""Complex""] = [e_dimer]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n]]. e_full = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; cp_table[""Interaction""] = [e_full]. PsiMod.set_variable('CP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). else:; cp_table = Table(rows=[""System:""], cols=[""Energy (full):"", ""Energy (monomer):"", ""BSSE:""]); cp_table[""Complex""] = [e_dimer, 0.0, 0.0]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. PsiMod.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). PsiMod.print_out(""\n""); banner(""CP Computation: Results.""); PsiMod.print_out(""\n""). banner(""Hartree"", 2); PsiMod.print_out(""\n""). PsiMod.print_out(str(cp_table)). PsiMod.print_out(""\n""); banner(""kcal*mol^-1"", 2); PsiMod.print_out(""\n""). cp_table.scale(). PsiMod.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##; #################. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABAS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:22021,ENERGY,ENERGY,22021,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"full):""]); cp_table[""Complex""] = [e_dimer]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n]]. e_full = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; cp_table[""Interaction""] = [e_full]. PsiMod.set_variable('CP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). else:; cp_table = Table(rows=[""System:""], cols=[""Energy (full):"", ""Energy (monomer):"", ""BSSE:""]); cp_table[""Complex""] = [e_dimer, 0.0, 0.0]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. PsiMod.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). PsiMod.print_out(""\n""); banner(""CP Computation: Results.""); PsiMod.print_out(""\n""). banner(""Hartree"", 2); PsiMod.print_out(""\n""). PsiMod.print_out(str(cp_table)). PsiMod.print_out(""\n""); banner(""kcal*mol^-1"", 2); PsiMod.print_out(""\n""). cp_table.scale(). PsiMod.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##; #################. #########################; ## Start of Database ##; #########################. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:21956,ENERGY,ENERGY,21956,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"fully quantum mechanical computation, i.e., not QM/MM. HF TOTAL GRADIENT¶; The total electronic gradient [E_h/a0] of the Hartree–Fock method, ({nat}, 3). HF DIPOLE GRADIENT¶; The derivative of the Hartree–Fock method dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). HF TOTAL HESSIAN¶; The total electronic second derivative [E_h/a0/a0] for the Hartree-Fock method, (3 * {nat}, 3 * {nat}). LCCD TOTAL ENERGY¶. LCCD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the linearized coupled cluster doubles level of theory. LCCSD TOTAL ENERGY¶. LCCSD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the linearized coupled cluster singles and doubles level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [E_h] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [E_h] for the local CCSD level of theory. LEFT-RIGHT CC2 EIGENVECTOR OVERLAP¶. LEFT-RIGHT CC3 EIGENVECTOR OVERLAP¶. LEFT-RIGHT CCSD EIGENVECTOR OVERLAP¶. LEFT-RIGHT CCSD(T) EIGENVECTOR OVERLAP¶; The overlap between the right-hand coupled coupled cluster eigenvector and the; left-hand eigenvector from the coupled cluster lambda (response) equations. LOWDIN CHARGES¶; Property of partial atomic charges [e] by the method of Löwdin, (nat,). MAYER INDICES¶; Property of Mayer bond indices, (nat, nat). MBIS CHARGES¶. MBIS DIPOLES¶. MBIS OCTUPOLES¶. MBIS QUADRUPOLES¶; Per-atom charges [e], dipoles [e a0], quadrupoles [e a0^2], and octupoles [e a0^3]; resulting from partitioning the total electron density through the Minimal Basis; Iterative Stockholder (MBIS) Charge Partitioning Scheme. MBIS FREE ATOM n VOLUME¶; Free-atom volume [a0^3] for atom n, computed using the MBIS charge; partitioning scheme. Free atom densities are computed at the same; level of theory as the parent MBIS calcula",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:33597,energy,energy,33597,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [Aug 2022] DF CCSD t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:21387,energy,energy,21387,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['energy'],['energy']
Energy Efficiency,"func']. # Summary validation; if (dertype == 2) and (lowername in procedures['hessian']):; pass; elif (dertype == 1) and (func is gradient) and (lowername in procedures['gradient']):; pass; elif (dertype == 1) and not(func is gradient):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 10); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 8). # Select certain irreps; if 'irrep' in kwargs:; irrep = parse_cotton_irreps(kwargs['irrep']) - 1 # externally, A1 irrep is 1, internally 0; else:; irrep = -1 # -1 implies do all irreps. # Does an analytic procedure exist for the requested method?; if (dertype == 2):; #",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:61790,energy,energy,61790,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,4,['energy'],['energy']
Energy Efficiency,"function psi4.core.set_output_file(); API,; as a string:. In [2]:. psi4.core.set_output_file('output.dat', False). Additionally, output may be suppressed by instead setting; psi4.core.be_quiet(); API. II. Running a Basic Hartree-Fock Calculation¶; In our first example, we will consider a Hartree-Fock SCF computation; for the water molecule using a cc-pVDZ basis set. First, we will set the; available memory for Psi4 to use with the psi4.set_memory(); API; function, which takes either a string like '30 GB' (with units!) or; an integer number of bytes of memory as its argument. Next, our; molecular geometry is passed as a string into psi4.geometry(); API.; We may input this geometry in either Z-matrix or Cartesian format; to; allow the string to break over multiple lines, use Python’s triple-quote; """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s ne",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:3329,energy,energy,3329,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['energy'],['energy']
Energy Efficiency,"function when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element (after *float* energy) of a tuple. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. For maximum; flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:49017,energy,energy,49017,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"function) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. form_C(self: psi4.core.HF) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the frequencies of the Hessian. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Sets the requested internal array. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_variable",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:20289,energy,energy,20289,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,14,['energy'],['energy']
Energy Efficiency,"function; gradient_type = 'custom_function'; elif kwargs.get('bsse_type', None) is not None:; gradient_type = 'nbody_gufunc'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. # Figure out lowername, dertype, and func; # If we have analytical gradients we want to pass to our wrappers, otherwise we want to run; # finite-diference energy or cbs energies; # TODO MP5/cc-pv[DT]Z behavior unkown due to ""levels""; user_dertype = kwargs.pop('dertype', None); if gradient_type == 'custom_function':; if user_dertype is None:; dertype = 0; core.print_out(; ""\nGradient: Custom function passed in without a defined dertype, assuming fd-energy based gradient.\n""; ); else:; core.print_out(""\nGradient: Custom function passed in with a dertype of %d\n"" % user_dertype); dertype = user_dertype. if dertype == 1:; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', 'scf', 8, 10, 8, 10, 8); lowername = name. elif gradient_type == 'nbody_gufunc':; return driver_nbody.nbody_gufunc(gradient, name, ptype='gradient', **kwargs). elif gradient_type == 'cbs_wrapper':; cbs_methods = driver_cbs._cbs_wrapper_methods(**kwargs); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); if dertype == 1:; # Bounce to CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic grad. avail.; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:38129,energy,energy,38129,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"function; gradient_type = 'custom_function'; elif kwargs.get('bsse_type', None) is not None:; gradient_type = 'nbody_gufunc'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. # Figure out lowername, dertype, and func; # If we have analytical gradients we want to pass to our wrappers, otherwise we want to run; # finite-diference energy or cbs energies; # TODO MP5/cc-pv[DT]Z behavior unkown due to ""levels""; user_dertype = kwargs.pop('dertype', None); if gradient_type == 'custom_function':; if user_dertype is None:; dertype = 0; core.print_out(; ""\nGradient: Custom function passed in without a defined dertype, assuming fd-energy based gradient.\n""; ); else:; core.print_out(""\nGradient: Custom function passed in with a dertype of %d\n"" % user_dertype); dertype = user_dertype. if dertype == 1:; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', 'scf', 8, 10, 8, 10, 8); lowername = name. elif gradient_type == 'nbody_gufunc':; return driver_nbody.nbody_gufunc(gradient, name, ptype='gradient', **kwargs). elif gradient_type == 'cbs_wrapper':; cbs_methods = driver_cbs._cbs_wrapper_methods(**kwargs); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); if dertype == 1:; # Bounce to CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic grad. avail.; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; for method in cbs_methods:; _filter_renamed_methods(""gradient"", method); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:40021,energy,energy,40021,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"functional,; }. [docs]def build_functional(alias):; name = alias.lower(); return functionals[name](name). [docs]def functional_list():; val = []; for key in functionals.keys():; val.append(functionals[key](key)); return val. ## ==> SuperFunctionals <== ##. [docs]def build_ws_x_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wS_X'); # Tab in, trailing newlines; sup.set_description(' Slater Short-Range LSDA Exchange\n'); # Tab in, trailing newlines; sup.set_citation(' Adamson et. al., J. Comput. Chem., 20(9), 921-927, 1999\n'). # Add member functionals; sup.add_x_functional(build_functional('wS_X')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe_x_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE_X'); # Tab in, trailing newlines; sup.set_description(' PBE Short-Range GGA Exchange (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBE_X')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbesol_x_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:17279,allocate,allocate,17279,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,6,['allocate'],['allocate']
Energy Efficiency,"functions. GaussianType; 0 if Cartesian, 1 if Pure. GeometryUnits; The units used to define the geometry. HF; docstring. IO; docstring. IOManager; PSIOManager is a class designed to be used as a static object to track all PSIO operations in a given PSI4 computation. IntVector; Class handling vectors with integer values. IntegralFactory; Computes integrals. IntegralTransform; IntegralTransform transforms one- and two-electron integrals within general spaces. JK; docstring. KineticInt; Computes kinetic integrals. LaplaceDenominator; docstring. LibXCFunctional; docstring. Localizer; Class containing orbital localization procedures. MOSpace; Defines orbital spaces in which to transform integrals. MOWriter; Writes the MOs. Matrix; Class for creating and manipulating matrices. MatrixFactory; Creates Matrix objects. MintsHelper; Computes integrals. MoldenWriter; Writes wavefunction information in molden format. MolecularGrid; docstring. Molecule; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. MultipoleInt; Computes arbitrary-order multipole integrals. MultipoleSymmetry; docstring. NBOWriter; The Natural Bond Orbital Writer. NablaInt; Computes nabla integrals. OEProp; docstring. OneBodyAOInt; Basis class for all one-electron integrals. Options; docstring. OrbitalSpace; Contains information about the orbitals. OverlapInt; Computes overlap integrals. PMLocalizer; Performs Pipek-Mezey orbital localization. PetiteList; Handles symmetry transformations. PointFunctions; docstring. PointGroup; Contains information about the point group. PotentialInt; Computes potential integrals. PrimitiveType; May be Normalized or Unnormalized. Prop; docstring. PseudospectralInt; Computes pseudospectral integrals. PsiReturnType; docstring. QuadrupoleInt; Computes quadrupole integrals. RHF; docstring. RKSFunctions; docstring. ROHF; docstring. SADGuess; docstring. SOBasisSet; An SOBasis object describes the transformation from an atomic orbit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:253221,charge,charge,253221,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['charge'],['charge']
Energy Efficiency,"functions."""""". import psi4; from . import optproc. __all__ = ['free_atom_volumes']. [docs]def free_atom_volumes(wfn, **kwargs):; """""" ; Computes free-atom volumes using MBIS density partitioning.; The free-atom volumes are computed for all unique (inc. basis set); atoms in a molecule and stored as wavefunction variables.; Free-atom densities are computed at the same level of theory as the molecule, ; and we use unrestricted references as needed in computing the ground-state. . The free-atom volumes are used to compute volume ratios in routine MBIS computations. Parameters; ----------; wfn : psi4.core.Wavefunction; The wave function associated with the molecule, method, and basis for ; atomic computations; """""". # If we're already a free atom, break to avoid recursion; # We don't ever need volume ratios for free atoms since they; # are by definition 1.0; natom = wfn.molecule().natom(); if natom == 1:; return 0 ; . # the level of theory; current_en = wfn.scalar_variable('CURRENT ENERGY'); total_energies = [k for k, v in wfn.scalar_variables().items() if abs(v - current_en) <= 1e-12]; theory = """"; for var in total_energies:; if 'TOTAL ENERGY' in var:; var = var.split(); if var[0] == 'SCF':; continue; elif var[0] == 'DFT':; theory = wfn.functional().name(); else:; theory = var[0]. # list of reference number of unpaired electrons.; # Note that this is not the same as the; # total spin of the ground state atom; reference_S = [; 0, 1, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 2, 3, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 2, 1, 0,; 1, 0, 1, 2, 5, 6, 5, 4, 3, 0, 1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 0, 3, 4, 5, 6, 7, 8, 5, 4, 3, 2, 1, 0, 1, 2, 3,; 4, 5, 4, 3, 2, 1, 0, 1, 2, 3, 2, 1, 0; ]. # the parent molecule and reference type; mol = wfn.molecule(). # Get unique atoms by input symbol,; # Be to handle different basis sets; unq_atoms = set(); for atom in range(mol.natom()):; symbol = mol.symbol(atom); Z = int(mol.Z(atom)); basis = mol.basis_on_atom(atom); unq_atoms.add((symb",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/prop_util.html:2148,ENERGY,ENERGY,2148,psi4manual/1.6.x/_modules/psi4/driver/p4util/prop_util.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/prop_util.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"functions; """""". import numpy as np. from psi4.driver import p4util; from psi4.driver import constants; from psi4.driver.p4util.exceptions import SCFConvergenceError, ValidationError; from psi4 import core. from .efp import get_qm_atoms_opts, modify_Fock_permanent, modify_Fock_induced. #import logging; #logger = logging.getLogger(""scf.scf_iterator""); #logger.setLevel(logging.DEBUG). # Q: I expect more local settings of options for part of SCF.; # For convcrit, do we want:; # (A) easy to grep; # with p4util.OptionsStateCM(['SCF', 'E_CONVERGENCE'], ['SCF', 'D_CONVERGENCE']):; # core.set_local_option('SCF', 'E_CONVERGENCE', 1.e-5); # core.set_local_option('SCF', 'D_CONVERGENCE', 1.e-4); # self.iterations(); #; # or (B) functional. options never touched; # self.iterations(e_conv=1.e-5, d_conv=1.e-4). def scf_compute_energy(self):; """"""Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). """"""; if core.get_option('SCF', 'DF_SCF_GUESS') and (core.get_global_option('SCF_TYPE') == 'DIRECT'):; # speed up DIRECT algorithm (recomputes full (non-DF) integrals; # each iter) by first converging via fast DF iterations, then; # fully converging in fewer slow DIRECT iterations. aka Andy trick 2.0; core.print_out("" Starting with a DF guess...\n\n""); with p4util.OptionsStateCM(['SCF_TYPE']):; core.set_global_option('SCF_TYPE', 'DF'); self.initialize(); try:; self.iterations(); except SCFConvergenceError:; self.finalize(); raise SCFConvergenceError(""""""SCF DF preiterations"""""", self.iteration_, self, 0, 0); core.print_out(""\n DF guess converged.\n\n""). # reset the DIIS & JK objects in prep for DIRECT; if self.initialized_diis_manager_:; self.diis_manager().reset_subspace(); self.initialize_jk(self.memory_jk_); else:; self.initialize(). try:; self.iterations(); except SCFConvergenceError as e:; if core.get_option(""SCF"", ""FAIL_ON_MAXITER""):; core.print_out("" F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:2140,energy,energy,2140,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['energy'],['energy']
Energy Efficiency,"fuse charges to; resulting density. """"""; basisChanged = psi4.has_option_changed(""BASIS""); ribasisChanged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). psi4.set_global_option(""BASIS"", self.basisname); psi4.set_global_option(""DF_BASIS_SCF"", self.ribasisname); psi4.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); psi4.print_out(""\n""). self.fitGeneral(). psi4.clean(). psi4.set_global_option(""BASIS"", basis); psi4.set_global_option(""DF_BASIS_SCF"", ribasis); psi4.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; psi4.revoke_option_changed(""BASIS""); if not ribasisChanged:; psi4.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; psi4.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; psi4.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = psi4.wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuse",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:2680,charge,charges,2680,psi4manual/4.0b5/_modules/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html,2,['charge'],['charges']
Energy Efficiency,"g (Determines da) <=\n\n""); self.wfn = PsiMod.reference_wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = PsiMod.Gaussian94BasisSetParser(); self.ribasis = PsiMod.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = PsiMod.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / physconst.psi_bohr2angstroms, y / physconst.psi_bohr2angstroms, z / physconst.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.add",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:2993,charge,charge,2993,psi4manual/4.0b2/_modules/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html,4,['charge'],['charge']
Energy Efficiency,"g DIIS. Type: integer; Default: 1. DIPMOM (DETCI); DETCI — Do compute the dipole moment?. Type: boolean; Default: false. DIPMOM (FNOCC); FNOCC — Compute the dipole moment? Note that dipole moments are only available in the FNOCC module for the ACPF, AQCC, CISD, and CEPA(0) methods. Type: boolean; Default: false. DISP_SIZE (FINDIF); FINDIF — Displacement size in au for finite-differences. Type: double; Default: 0.005. DISTRIBUTED_MATRIX (SCF); SCF (Expert) — The dimension sizes of the distributed matrix. Type: array; Default: No Default. DKH_ORDER (GLOBALS); GLOBALS (Expert) — Order of Douglas-Kroll-Hess. Type: integer; Default: 2. DMRG_CASPT2_CALC (DMRG); DMRG — Do calculate the DMRG-CASPT2 energy after the DMRGSCF calculations are done?. Type: boolean; Default: false. DMRG_CASPT2_IMAG (DMRG); DMRG — CASPT2 Imaginary shift. Type: double; Default: 0.0. DMRG_CASPT2_IPEA (DMRG); DMRG — CASPT2 IPEA shift. Type: double; Default: 0.0. DMRG_CASPT2_ORBS (DMRG); DMRG — Whether to calculate the DMRG-CASPT2 energy after the DMRGSCF calculations are done. Type: string; Possible Values: PSEUDOCANONICAL, ACTIVE; Default: PSEUDOCANONICAL. DMRG_DIIS (DMRG); DMRG — Whether or not to use DIIS for DMRG. Type: boolean; Default: false. DMRG_DIIS_WRITE (DMRG); DMRG — Whether or not to store the DIIS checkpoint on disk (convenient for restarting). Type: boolean; Default: true. DMRG_EXCITATION (DMRG); DMRG — Which root is targeted: 0 means ground state, 1 first excited state, etc. Type: integer; Default: 0. DMRG_IRREP (DMRG); DMRG — The DMRG wavefunction irrep uses the same conventions as PSI4. How convenient :-). Just to avoid confusion, it’s copied here. It can also be found on http://sebwouters.github.io/CheMPS2/doxygen/classCheMPS2_1_1Irreps.html . Symmetry Conventions Irrep Number & Name Group Number & Name 0 1 2 3 4 5 6 7 0: c1 A 1: ci Ag Au 2: c2 A B 3: cs A’ A’’ 4: d2 A B1 B2 B3 5: c2v A1 A2 B1 B2 6: c2h Ag Bg Au Bu 7: d2h Ag B1g B2g B3g Au B1u B2u B3u. Type: integer; Default: -1. D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:106638,energy,energy,106638,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,8,['energy'],['energy']
Energy Efficiency,"g a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. cc51; EOM-CC3/cc-pVTZ on H2O. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. mints-benchmark; run some BLAS benchmarks. scf-bs; UHF and broken-symmetry UHF energy for molecular hydrogen. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. «; hide men",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:40436,energy,energy,40436,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"g and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. dft1; DFT Functional Test all values update for new BraggSlater radii. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. nbody-multi-level-2; many-body different levels of theory on each body of helium tetramer. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. ddd-deriv; Sample HF/cc-pVDZ H2O computation all derivatives. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. dft-smoke; DFT Functional Smoke Test.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:38154,energy,energy,38154,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"g automatic counterpoise correction. Monomers are specified using Cartesian coordinates. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. scf6; Tests RHF/ROHF/UHF SCF gradients. casscf-sp; CASSCF/6-31G** energy point. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. scf-auto-cholesky; Cholesky filter a complete basis. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). omp2p5-2; OMP2.5 cc-pVDZ energy for the H2O molecule. dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). cubeprop-esp; RHF orbitals and density for water. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. cc15; RHF-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:42822,energy,energy,42822,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"g computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. dft-smoke; DFT Functional Smoke Test. omp2p5-2; OMP2 cc-pVDZ energy for the H2O molecule. dcft1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. scf-guess-read2; Test if the the guess read in the same basis converges. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:33478,energy,energy,33478,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"g dummies in Bohr). fz(self: psi4.core.Molecule, arg0: int) → float; z position of atom arg1 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule) → psi4.core.Matrix; Gets the geometry as a (Natom X 3) matrix of coordinates (in Bohr). get_full_point_group(self: psi4.core.Molecule) → str; Gets point group name such as C3v or S8. get_variable(self: psi4.core.Molecule, arg0: str) → float; Checks if variable arg2 is in the list, sets it to val and returns true if it is, and returns false if not. irrep_labels(self: psi4.core.Molecule) → List[str]. is_variable(self: psi4.core.Molecule, arg0: str) → bool; Checks if variable arg2 is in the list, returns true if it is, and returns false if not. label(self: psi4.core.Molecule, arg0: int) → str; Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed). mass(self: psi4.core.Molecule, arg0: int) → float; Gets mass of atom arg1 (0-indexed). molecular_charge(self: psi4.core.Molecule) → int; Gets the charge on full molecule. move_to_com(self: psi4.core.Molecule) → None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule) → int; Gets the multiplicity (defined as $2M_s + 1$) of full molecule. nactive_fragments(self: psi4.core.Molecule) → int; Gets the number of active (non-ghosted) fragments in the molecule. nallatom(self: psi4.core.Molecule) → int; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str; Gets molecule name. natom(self: psi4.core.Molecule) → int; Number of real atoms. nfragments(self: psi4.core.Molecule) → int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to a specified origin. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to the origin. nuclear_repulsion_ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:25433,charge,charge,25433,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"g energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. sapt3; SAPT2+3(CCD) aug-cc-pVDZ computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. omp3-3; OMP3 cc-pVDZ energy with B3LYP initial guess for the NO radical. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. props3; DF-SCF cc-pVDZ multipole moments of ben",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:18911,energy,energy,18911,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"g excited state transition data for water with two excited states per irrep. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. soscf2; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. dft1-alt; DFT Functional Test. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. dcft-grad3; Restricted DF-DCFT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. cc13d; Tests analytic CC2 gradients. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. omp2-3; OMP2 cc-pVDZ energy for the NO radical. scf2; RI-SCF cc-pV",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:4688,energy,energy,4688,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"g geometry based on current surface:\n\n"");; if (npoints == 5):; optx = rvals[2]; elif (npoints == 9):; optx = rvals[4]. mol = PsiMod.get_active_molecule(); natoms = mol.natom(); if natoms != 2:; raise Exception(""The current molecule must be a diatomic for this code to work!""); m1 = mol.mass(0); m2 = mol.mass(1). maxit = 30; thres = 1.0e-9; for i in range(maxit):; if (npoints == 5):; grad= first_deriv_5pt(rvals, energies, optx); secd = second_deriv_5pt(rvals, energies, optx); energy = function_5pt(rvals, energies, optx); elif (npoints == 9):; grad = first_deriv_9pt(rvals, energies, optx); secd = second_deriv_9pt(rvals, energies, optx); energy = function_9pt(rvals, energies, optx); PsiMod.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (energy, optx, grad)); if abs(grad) < thres:; break; optx -= grad / secd;; PsiMod.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (function_5pt(rvals, energies, optx), optx, grad));. if optx < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if optx > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""); ; if (npoints == 5):; energy = function_5pt(rvals, energies, optx); first = first_deriv_5pt(rvals, energies, optx); secd = second_deriv_5pt(rvals, energies, optx) * psi_hartree2aJ; third = third_deriv_5pt(rvals, energies, optx) * psi_hartree2aJ; fourth = fourth_deriv_5pt(rvals, energies, optx) * psi_hartree2aJ; elif (npoints == 9):; energy = function_9pt(rvals, energies, optx); first = first_deriv_9pt(rvals, energies, optx); secd = second_deriv_9pt(rvals, energies, optx) * psi_hartree2aJ; third = third_deriv_9pt(rvals, energies, optx) * psi_hartree2aJ; fourth = fourth_deriv_9pt(rvals, energies, optx) * psi_hartree2aJ. PsiMod.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % energy); PsiMod.print_out(""Gradient %20.14f\n"" % first); PsiMod.print_out(""Quadratic Force Const",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/diatomic.html:2694,energy,energy,2694,psi4manual/4.0b3/_modules/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/diatomic.html,4,['energy'],['energy']
Energy Efficiency,"g has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). cc13c; Tests RHF CCSD(T)gradients. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). fcidump; test FCIDUMP functionality for rhf/uhf. fnocc5; Test FNO-DF-CCSD(T) energy. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc12; Single point energies of multiple excited states with EOM-CCSD. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. fnocc4; Test FNO-DF-CCSD(T) energy. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc54; CCSD dipole with user-specified basis set. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. pywrap-alias; Test parsed and exotic calls to e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:7707,charge,charge,7707,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['charge'],['charge']
Energy Efficiency,"g is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are then provided.; The notation MP4(SDQ) indicates that we have included all contributions to; the correlation energy through fourth order, with the exception of that; from connected triple excitations.; One need not run a full QCISD or CCSD computation to obtain these; perturbation theory results. The keywords for invoking perturbation; theory computations are given below in; Table FNOCC Methods. Full MP4 correlation; energies are also available. Coupled electron pair approximation¶; Coupled-pair methods can be viewed as approximations to CCSD or as; size-extensive modifications of CISD. The methods have the same; complexity as CISD, and solving the CISD or coupled-pair equations; requires few",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fnocc-1.html:6190,energy,energy,6190,psi4manual/1.4.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fnocc-1.html,15,['energy'],['energy']
Energy Efficiency,"g reaction, along with dbse and rxn keys; in argument data. The plot is labeled with title and each tier with; an element of labels and plotted at xlimit from the zero-line. If; color is None, slats are black, if ‘sapt’, colors are taken from color; key in data [0, 1]. Summary statistics mae are plotted on the; overbound side and relative statistics mape on the underbound side.; HTML code for mouseover if mousetext or mouselink or mouseimag specified; based on recipe of Andrew Dalke from; http://www.dalkescientific.com/writings/diary/archive/2005/04/24/interactive_html.html. valerr(data, color=None, title='', xtitle='', view=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶. Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. class CartesianEntry(entry_number, Z, charge, mass, symbol, label, x, y, z, basis=None, shells=None)[source]¶; Class to hold all information about an atom, including its; coordinate specification as three Cartesians. clone()[source]¶; Returns new, independent CartesianEntry object. compute()[source]¶; Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. everything()[source]¶. invalidate()[source]¶; Flags the current coordinates as being outdated. print_in_input_format()[source]¶; Prints the updated geometry, in the format provided by the user. print_in_input_format_cfour()[source]¶; Prints the updated geometry, in the format provided by the user.; This, for Cfour, not different from regular version. set_coordinates(x, y, z)[source]¶; Given the current set of coordinates, updates the values of this; atom’s coordinates and any variables that may depend on it. type()[source]¶; The type of CoordEntry specialization. class CoordEntry(entry_number, Z, charge, mass, symbol, label='', basis=None, shells=None)[source]¶; Class to store all the attribu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:113208,charge,charge,113208,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency,"g that program can run multiple instances of DETCI in a single input, without an intervening clean() call. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. fd-freq-gradient-large; SCF DZ finite difference frequencies by energies for C4NH4. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. freq-isotope; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. cc36; CC2(RHF)/cc-pVDZ energy of H2O. cbs-delta-energy; Extrapolated energies with delta correction. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the sin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:11510,energy,energy,11510,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"g the algorithm for a MP2 property call; and directing to specified or best-performance default modules. select_mp2p5(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. select_mp2p5_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. select_mp3(name, **kwargs)[source]¶; Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. select_mp3_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. select_mp4(name, **kwargs)[source]¶; Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. select_olccd(name, **kwargs)[source]¶; Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. select_olccd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. select_omp2(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. select_omp2_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. select_omp2_property(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. select_omp2p5(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. select_omp2p5_gradient(name, **kwargs)[source]¶; Function selecting the algorit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:169339,energy,energy,169339,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency,"g'). >>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). Note; Presently (May 2016), only two of the five delta possibilities are active. Also, temporarily extrapolations are performed on differences of target and scf total energies, rather than on correlation energies directly. This doesn’t affect the extrapolated values of the particular formulas defined here (though it does affect the betas, which are commented out), but it is sloppy and temporary and could affect any user-defined corl extrapolations. Output¶; At the beginning of a cbs() job is printed a listing of the individual; energy calculations which will be performed. The output snippet below is; from the example job [2] above. It shows first each model chemistry needed; to compute the aggregate model chemistry requested through cbs(). Then,; since, for example, an energy('ccsd(t)') yields CCSD(T), CCSD, MP2,; and SCF energy values, the wrapper condenses this task list into the second; list of minimum number of calculations which will actually be run.; Naive listing of computations required.; scf / aug-cc-pvqz for SCF TOTAL ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY; mp2 / aug-cc-pvdz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY. Enlightened listing of computations required.; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY. At the end of a cbs() job is printed a summary section like the one below. First,; in the components section, are listed the results for each model chemistry available, whether; required for the cbs job (*) or not. Next, in the stages section, are listed the results for; each extrapolation. The energies of this s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:12025,energy,energy,12025,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"g, rotating, and atom shuffling ref_mol and checking that the aligner returns the opposite transformation. set_active_fragment(self, arg0); Sets the specified fragment arg2 to be Real. set_active_fragments(self, arg0); Sets the specified list arg2 of fragments to be Real. set_basis_all_atoms(self, arg0, arg1); Sets basis set arg2 to all atoms. set_basis_by_label(self, arg0, arg1, arg2); Sets basis set arg3 to all atoms with label (e.g., H4) arg2. set_basis_by_symbol(self, arg0, arg1, arg2); Sets basis set arg3 to all atoms with symbol (e.g., H) arg2. set_geometry(self, arg0); Sets the geometry, given a (Natom X 3) matrix arg2 of coordinates (in Bohr). set_ghost_fragment(self, arg0); Sets the specified fragment arg2 to be Ghost. set_ghost_fragments(self, arg0); Sets the specified list arg2 of fragments to be Ghost. set_input_units_to_au(self, arg0); Sets unit conversion to [a0] for geometry. set_mass(self, atom, mass); Sets mass of atom (0-indexed) to mass. set_molecular_charge(self, arg0); Sets the molecular charge. set_multiplicity(self, arg0); Sets the multiplicity (defined as 2Ms + 1). set_name(self, arg0); Sets molecule name. set_nuclear_charge(self, arg0, arg1); Set the nuclear charge of the given atom to the value provided. set_point_group(self, arg0); Sets the molecular point group to the point group object arg2. set_units(self, arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self, arg0, arg1); Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self, arg0); Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self, arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays(); Exports coordinate info into NumPy arrays. to_dict([force_c1, force_units, np_out]); Serializes instance into Molecule diction",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:7651,charge,charge,7651,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"g-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the higly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For PSI, the standard number of core orbitals is the number of orbitals in the nearest previous noble gas atom. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE; Default: FALSE. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced Keywords for Higher-order SAPT¶. DO_CCD_DISP¶. Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_MBPT_DISP¶. Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_THIRD_ORDER¶. Do compute third-order corrections?. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:14401,energy,energy,14401,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"g-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the higly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For PSI, the standard number of core orbitals is the number of orbitals in the nearest previous noble gas atom. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE; Default: FALSE. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced Keywords for Higher-order SAPT¶. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. DEBUG¶. The amount of information to print to the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/sapt-1.html:9553,energy,energy,9553,psi4manual/4.0b4/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/sapt-1.html,4,['energy'],['energy']
Energy Efficiency,"g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fragmented. Advanced Python¶; A named molecule in an input file is a full-fledged instance of the; powerful C++ Molecule class. Thus, all member; functions (that have been exported via pybind11) documented thereat; are accessible through the handle option_molecule_name in; molecule optional_molecule_name {...}. The molecular geometry can be got and set and manipulated as a; Matrix object. Below shows how to access; coordinates in an input file in Python.; molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.geometry() # get coordinates in bohr as a psi4.Matrix. geom1psi.print_out() # print coordinates array to output file; geom1py = mat2arr(geom1psi) # get coordinates as a Python array; print geom1py # print coordinates to screen. geom2py = [[ 0.0, 0.0, 0.0],; [ 0.0, 1.5, 0.0],; [-0.8, -0.3, 0.0],; [ 0.8, -0.3, 0.0]] # define alternate coordinates in angstroms as Python array. geom2psi = psi4.Matrix(4, 3) # initialize psi4.Matrix; geom2psi.set(geom2py) # load Python array into psi4.Matrix; geom2psi.scale(1.0/psi_bohr2angstroms) # scale into bohr; geom2psi.print_out() # print alternate coord array to output file. formaldehyde.set_geometry(geom2psi) # load alternate coordinates into molecule; formaldehyde.update_geometry() # update the molecule internals; formaldehyde.print_out() # print new molecule to output file; compare_values(28.9950517332, formaldehyde.nuclear_repulsion_e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html:16763,energy,energy,16763,psi4manual/1.4.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html,9,['energy'],['energy']
Energy Efficiency,"g0); Sets how much more long-range exchange than short-range exchange. set_x_omega(self, arg0); Sets the range-seperation exchange parameter. test_functional(self, arg0, arg1, arg2, …); Quick testing capabilities. value(self, arg0); Returns a given internal value. values(self); Return all internal values. vv10_b(self); The VV10 b parameter. vv10_c(self); The VV10 c parameter. x_alpha(self); Amount of exact HF exchange. x_beta(self); Amount of exact HF exchange. x_functional(self, arg0); Returns the desired X Functional. x_functionals(self); Returns all X Functionals. x_omega(self); Range-seperated exchange parameter. Methods Documentation. static XC_build(arg0: str, arg1: bool) → psi4.core.SuperFunctional¶; Builds a SuperFunctional from a XC string. add_c_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional) → None¶; Add a correlation Functional. add_x_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional) → None¶; Add a exchange Functional. allocate(self: psi4.core.SuperFunctional) → None¶; Allocates the vectors, should be called after ansatz or npoint changes. ansatz(self: psi4.core.SuperFunctional) → int¶; SuperFunctional rung. static blank() → psi4.core.SuperFunctional¶; Initialize a blank SuperFunctional. c_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of MP2 correlation. c_functional(self: psi4.core.SuperFunctional, arg0: str) → psi4.core.Functional¶; Returns the desired C Functional. c_functionals(self: psi4.core.SuperFunctional) → List[psi4.core.Functional]¶; Returns all C Functionals. c_omega(self: psi4.core.SuperFunctional) → float¶; Range-seperated correlation parameter. c_os_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of SS MP2 correlation. c_ss_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of OS MP2 correlation. citation(self: psi4.core.SuperFunctional) → str¶; SuperFunctional citation. compute_functional(self: psi4.core.SuperFunctional, arg0: Dict[str, psi4.core.Vector], arg1: int) → Dic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.superfunctional.html:4262,allocate,allocate,4262,psi4manual/1.4.0/api/psi4.core.superfunctional.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.superfunctional.html,2,['allocate'],['allocate']
Energy Efficiency,"g0, arg1); Sets basis set arg0 to all atoms. set_basis_by_label(self, arg0, arg1, arg2); Sets basis set arg1 to all atoms with label (e.g., H4) arg0. set_basis_by_symbol(self, arg0, arg1, arg2); Sets basis set arg1 to all atoms with symbol (e.g., H) arg0. set_comment(self, arg0); Sets molecule comment. set_connectivity(self, arg0, int, float]]); Sets molecule connectivity. set_full_geometry(self, arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates (in Bohr) (including dummies. set_geometry(self, arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self, arg0); Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self, arg0); Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self, arg0); Sets unit conversion to [a0] for geometry. set_mass(self, atom, mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self, arg0); Change the overall molecular charge. set_multiplicity(self, arg0); Change the multiplicity (defined as 2S + 1). set_name(self, arg0); Sets molecule name. set_nuclear_charge(self, arg0, arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self, arg0); Sets the molecular point group to the point group object arg0. set_provenance(self, arg0, str]); Sets molecule provenance. set_units(self, arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self, arg0, arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self, atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self, arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy, ghost_as_dumm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:9131,charge,charge,9131,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"g0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_amplitudes(self); Get dict of converged T amplitudes. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html:2853,energy,energy,2853,psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,2,['energy'],['energy']
Energy Efficiency,"g0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole fie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.wavefunction.html:2786,energy,energy,2786,psi4manual/1.5.0/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.wavefunction.html,2,['energy'],['energy']
Energy Efficiency,"g0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_amplitudes(self); Get dict of converged T amplitudes. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a vector of lengt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:2853,energy,energy,2853,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,1,['energy'],['energy']
Energy Efficiency,"g0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.wavefunction.html:2786,energy,energy,2786,psi4manual/1.4.0/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.wavefunction.html,2,['energy'],['energy']
Energy Efficiency,"g0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key)¶; Removes scalar or array QCVariable key from self if present.; :rtype: None. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters:. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbital energies should be returned?. Returns:; A Pitzer-ordered vector of the orbitals. Return type:; Vector. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Beta orbital energies subset. Parameters:. basis – {‘AO’, ‘SO’, ‘",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:14389,energy,energy,14389,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html,2,['energy'],['energy']
Energy Efficiency,"g1: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list, arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real and arg3 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real and arg3 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real and arg3 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: list) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of arg1 with arg2 fragment Real. fZ(self: psi4.core.Molecule, arg0: int) → float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, arg0: int) → float; Gets charge of atom arg1 (0-indexed including dummies). find_point_group(self: psi4.core.Molecule, arg0: float) → psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool) → None; Whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self: psi4.core.Molecule, arg0: bool) → None; Fix the orientation at its current frame. flabel(self: psi4.core.Molecule, arg0: int) → str; Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed including dummies). fmass(self: psi4.core.Molecule, arg0: int) → float; Gets mass of atom arg1 (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float) → None; Uses the point group object obtain by calling point_group(). fsymbol(self: psi4.core.Molecule, arg0: int) → str; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed including dummies). fx(self: psi4.core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:23238,charge,charge,23238,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"g2dfp - emp2_6311pg_dp; e_plus = emp4_6311pg_dp - emp4_6311gd; e_2df = emp4_6311g2dfp - emp4_6311gd. eg2 = eqci + e_delta_g2 + e_plus + e_2df; eg2_mp2_0k = eqci + (emp2_big - emp2_6311gd) + hlc + zpe. PsiMod.print_out('\n'); PsiMod.print_out(' ==> G1/G2 Energy Components <==\n'); PsiMod.print_out('\n'); PsiMod.print_out(' QCISD(T): %20.12lf\n' % eqci); PsiMod.print_out(' E(Delta): %20.12lf\n' % e_delta_g2); PsiMod.print_out(' E(2DF): %20.12lf\n' % e_2df); PsiMod.print_out(' E(+): %20.12lf\n' % e_plus); PsiMod.print_out(' E(G1 HLC): %20.12lf\n' % hlc1); PsiMod.print_out(' E(G2 HLC): %20.12lf\n' % hlc); PsiMod.print_out(' E(ZPE): %20.12lf\n' % zpe); PsiMod.print_out('\n'); PsiMod.print_out(' ==> 0 Kelvin Results <==\n'); PsiMod.print_out('\n'); eg2_0k = eg2 + zpe + hlc; PsiMod.print_out(' G1: %20.12lf\n' % (eqci + e_plus + e_2df + hlc1 + zpe)); PsiMod.print_out(' G2(MP2): %20.12lf\n' % eg2_mp2_0k); PsiMod.print_out(' G2: %20.12lf\n' % eg2_0k). PsiMod.set_variable(""G1 TOTAL ENERGY"",eqci + e_plus + e_2df + hlc1 + zpe); PsiMod.set_variable(""G2 TOTAL ENERGY"",eg2_0k); PsiMod.set_variable(""G2(MP2) TOTAL ENERGY"",eg2_mp2_0k). PsiMod.print_out('\n'); T = PsiMod.get_global_option('T'); PsiMod.print_out(' ==> %3.0lf Kelvin Results <==\n'% T); PsiMod.print_out('\n'). internal_energy = eg2_mp2_0k + du - zpe / 0.8929; enthalpy = eg2_mp2_0k + dh - zpe / 0.8929; gibbs = eg2_mp2_0k + dg - zpe / 0.8929. PsiMod.print_out(' G2(MP2) energy: %20.12lf\n' % internal_energy ); PsiMod.print_out(' G2(MP2) enthalpy: %20.12lf\n' % enthalpy); PsiMod.print_out(' G2(MP2) free energy: %20.12lf\n' % gibbs); PsiMod.print_out('\n'). PsiMod.set_variable(""G2(MP2) INTERNAL ENERGY"",internal_energy); PsiMod.set_variable(""G2(MP2) ENTHALPY"",enthalpy); PsiMod.set_variable(""G2(MP2) FREE ENERGY"",gibbs). internal_energy = eg2_0k + du - zpe / 0.8929; enthalpy = eg2_0k + dh - zpe / 0.8929; gibbs = eg2_0k + dg - zpe / 0.8929. PsiMod.print_out(' G2 energy: %20.12lf\n' % internal_energy ); PsiMod.print_out(' G2 enthalpy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/gaussian_n.html:4038,ENERGY,ENERGY,4038,psi4manual/4.0b4/_modules/gaussian_n.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/gaussian_n.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"g6, mass arg7, charge arg8 (optional), and lineno arg9 (optional); C++ signature :. void add_atom(N3psi8MoleculeE {lvalue},i,d,d,d,PKc,d,d,i). psi4.Molecule.atom_at_position()¶; Python Library Documentation: method atom_at_position; atom_at_position(...) unbound psi4.Molecule method. atom_at_position( (Molecule)arg1, (float)arg2, (float)arg3) -> int :. Tests to see if an atom is at the position arg2 with a given tolerance arg3; C++ signature :. i atom_at_position(N3psi8MoleculeE {lvalue},Pd,d). psi4.Molecule.center_of_mass()¶; Python Library Documentation: method center_of_mass; center_of_mass(...) unbound psi4.Molecule method. center_of_mass( (Molecule)arg1) -> Vector3 :. Computes center of mass of molecule (does not translate molecule); C++ signature :. N3psi7Vector3E center_of_mass(N3psi8MoleculeE {lvalue}). psi4.Molecule.charge()¶; Python Library Documentation: method charge; charge(...) unbound psi4.Molecule method. charge( (Molecule)arg1, (int)arg2) -> float :. Gets charge of atom; C++ signature :. d charge(N3psi8MoleculeE {lvalue},i). psi4.Molecule.clone()¶; Python Library Documentation: method clone; clone(...) unbound psi4.Molecule method. clone( (Molecule)arg1) -> Molecule :. Returns a new Molecule identical to arg1; C++ signature :. N3psi8MoleculeE clone(N3psi8MoleculeE {lvalue}). psi4.Molecule.create_molecule_from_string()¶; Python Library Documentation: built-in function create_molecule_from_string; create_molecule_from_string(...). create_molecule_from_string( (str)arg1) -> Molecule :. Returns a new Molecule with member data from the geometry string arg1 in psi4 format; C++ signature :. N5boost10shared_ptrIN3psi8MoleculeEEE create_molecule_from_string(Ss). psi4.Molecule.create_psi4_string_from_molecule()¶; Python Library Documentation: method create_psi4_string_from_molecule; create_psi4_string_from_molecule(...) unbound psi4.Molecule method. create_psi4_string_from_molecule( (Molecule)arg1) -> str :. Gets a string reexpressing in input format the curr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:238111,charge,charge,238111,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['charge'],['charge']
Energy Efficiency,"g: string; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element of a tuple. :type bsse_type: string or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP, NoCP, or VMFC. The first in this; list is returned by this function. By default, this function is not called. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the moleucle. :type ptype: string; :param ptype: ``'energy'`` || ``'gradient'`` || ``'hessian'``. Type of the procedure passed in. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/etc) of the system,; otherwise returns interaction data.; """""". ### ==> Parse some kwargs <==; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); ptype = kwargs.pop('ptype', None); return_total_data = kwargs.pop('return_total_data', False); molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); psi4.clean_variables(). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % ptype). # Figure out BSSE types; do_cp = False; do_nocp = False; do_vmfc = False; return_method = False. # Must be passed bsse_type; bsse_type_list = kwargs.pop('bsse_type'); if bsse_type_list is None:; raise ValidationError(""N-Body GUFunc: M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:5025,energy,energy,5025,psi4manual/1.0.0/_modules/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"g; Omega optimization for LRC functional wB97 on water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. extern3; External potential calculation with one Ghost atom and one point charge at the same position. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc17; Single point energies of multiple excited states with EOM-CCSD. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. scf-coverage; Lithium test for coverage. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. scf-occ; force occupations in scf. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. fd-gradient; SCF STO-3G finite-difference tests. options1; check all variety of options parsing. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). omp2-grad2; OMP2 c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:28725,energy,energy,28725,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"g; Possible Values: EIGENVECTOR, RESIDUAL; Default: RESIDUAL. SOLVER_TYPE (CPHF); CPHF — Solver type (for interchangeable solvers). Type: string; Possible Values: DL, RAYLEIGH; Default: DL. SORTED_TEI_FILE (TRANSQT); TRANSQT — MO-basis sorted two-electron integrals file. Type: integer; Default: PSIF_MO_TEI. SOS_SCALE (OMP2); OMP2 — Spin-opposite scaling (SOS) value for SCF orbitals. Type: double; Default: 1.3. SOS_SCALE (OMP3); OMP3 — Spin-opposite scaling (SOS) value for SCF orbitals. Type: double; Default: 1.3. SOS_SCALE2 (OMP2); OMP2 — Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. SOS_SCALE2 (OMP3); OMP3 — Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. SOS_TYPE (OMP2); OMP2 — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOS_TYPE (OMP3); OMP3 — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SPINADAPT_ENERGIES (CCENERGY); CCENERGY — Do print spin-adapted pair energies?. Type: boolean; Default: false. SS_E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG (CCEOM); CCEOM — Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT (CCEOM); CCEOM — SS vectors stored per root. Type: integer; Default: 5. STABILITY_ADD_VECTORS (DCFT); DCFT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF); SCF — Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:117730,adapt,adapted,117730,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['adapt'],['adapted']
Energy Efficiency,"gSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. linK-2; RKS Linear Exchange Algorithm test for benzene. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. ao-dfcasscf-sp; CASSCF/6-31G** energy point. cbs-parser; mtd/basis syntax examples. dlpnomp2-3; comparison of DF-MP2 and DLPNO-MP2 with a cartesian basis set. fisapt-siao1; This test case shows an example of running the I-SAPT0/jun-cc-pVDZ computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups) The SIAO1 link partitioning algorithm is used. An F-SAPT partitioning follows I-SAPT. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. dft-jk; DFT JK on-disk test. cubeprop-esp; RHF orbitals and density for water. cbs-delta-energy; Extrapolated energies with delta correction. dfcasscf-sp; CASSCF/6-31G** energy point. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. dforemp-grad1; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O molecule. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. dct-grad4; Unrestricted DF-DCT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. cc12; Single",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:31560,energy,energy,31560,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"g_{pq}^{sr}\]. \[f_p^q = h_p^q + \bar{g}_{pr}^{qs} \gamma_{s}^{r}\]; Energy functional \(E_{DCT}\) has several important properties. First,; the energy is now a function of two sets of independent parameters, the; idempotent part of \(\boldsymbol{\gamma_1}\) (\(\boldsymbol{\kappa}\)) and the density cumulant; (\(\boldsymbol{\lambda_2}\)). As a result, the energy functional is Hermitian,; which is important for the evaluation of the molecular properties. The additive; separability of the density cumulant guarantees that all of the DCT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent part of \(\boldsymbol{\gamma_1}\) is; N-representable by construction. One only needs to worry about the; N-representability of the density cumulant, which is a relatively small part of; \(\boldsymbol{\gamma_2}\).; In order to obtain the DCT energy, two conditions must be satisfied:. The energy must be stationary with respect to a set of orbitals. This can be done by; diagonalizing the generalized Fock operator (as in the DC-06 and DC-12 methods, see below),; which introduces partial orbital relaxation, or by fully relaxing the orbitals and minimizing the entire energy expression; (as in the ODC-06 and ODC-12 methods).; The energy must be stationary with respect to the variation of the density; cumulant \(\boldsymbol{\lambda_2}\), constrained to N-representability conditions. Making the energy stationary requires solution of two sets of coupled; equations for orbitals and density cumulant, respectively (also known as; residual equations). At the present moment, three different algorithms for the; solution of the system of coupled equations are available (see; Iterative Algorithms for details).; Publications resulting from the use of the DCT code should cite contributions; listed here. Methods¶; Currently five DCT methods (functionals) are available: DC-06, DC-12, ODC-06, ODC-12, and ODC-13. The f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:3702,energy,energy,3702,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,9,['energy'],['energy']
Energy Efficiency,"ga optimization for LRC functional wB97 on water. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:17170,energy,energy,17170,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ga optimization for LRC functional wB97 on water. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:17919,energy,energy,17919,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ga(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_blyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('BLYP'); # Tab in, trailing newlines; sup.set_description(' BLYP GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n B. Miehlich et. al., Chem. Phys. Lett., 157(3), 200-206 1989\n'). # Add member functionals; sup.add_x_functional(build_functional('B88_X')); sup.add_c_functional(build_functional('LYP_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_pw91_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('PW91'); # Tab in, trailing newlines; sup.set_description(' PW91 GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' J.P. Perdew et. al., Phys. Rev. B., 46(11), 6671-6687, 1992\n'). # Add member functionals; sup.add_x_functional(build_functional('PW91_X')); sup.add_c_functional(build_functional('PW91_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_bp86_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:24643,allocate,allocate,24643,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,3,['allocate'],['allocate']
Energy Efficiency,"ga(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE'); # Tab in, trailing newlines; sup.set_description(' PBE SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBE_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe0_superfunctional(name, npoints, deriv):. sup = build_wpbe_superfunctional(name, npoints, deriv); sup.set_name('wPBE0'); sup.set_description(' PBE0 SR-XC Functional (HJS Model)\n'); sup.set_x_omega(0.3); sup.set_x_alpha(0.25); return sup. [docs]def build_wpbesol_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBEsol'); # Tab in, trailing newlines; sup.set_description(' PBEsol SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBEsol_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup.s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:53722,allocate,allocate,53722,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency,"ga(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE'); # Tab in, trailing newlines; sup.set_description(' PBE SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBE_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbed3zero_superfunctional(name, npoints, deriv):. sup = build_wpbe_superfunctional(name, npoints, deriv); sup.set_name('wPBE-D3ZERO'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('lcwpbe', 'd3zero'))). return sup. [docs]def build_wpbed3bj_superfunctional(name, npoints, deriv):. sup = build_wpbe_superfunctional(name, npoints, deriv); sup.set_name('wPBE-D3BJ'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('lcwpbe', 'd3bj'))). return sup. [docs]def build_wpbed3mzero_superfunctional(name, npoints, deriv):. sup = build_wpbe_superfunctional(name, npoints, deriv); sup.set_name('wPBE-D3MZERO'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('lcwpbe', 'd3mzero'))). return sup. [docs]def build_wpbed3mbj_superfunctional(name, npoints, deriv):. sup = build_wpbe_superfunctional(name, npoints, deriv); sup.set_name('wPBE-D3MBJ'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('lcw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:61037,allocate,allocate,61037,psi4manual/1.0.0/_modules/procedures/functional.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html,1,['allocate'],['allocate']
Energy Efficiency,"gaker_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True)[source]¶; Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by cbs().; Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson, Chem. Phys. Lett. 286 (1998) 243-252. \[E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}\]. Aliases¶; When a particular composite method or its functional form is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/psi4/driver/aliases.py; (source location) or psi4/lib/psi4/driver/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. psi4.driver.aliases.sherrill_gold_standard(func, label, **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; 1; 2>>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). 1; 2>>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). 1; 2>>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). psi4.driver.aliases.allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; complete_basis_set() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cbs-1.html:18424,energy,energy,18424,psi4manual/1.1.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"gaker_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None)[source]¶; Extrapolation scheme using exponential form for reference energies with two adjacent; zeta-level bases. Used by cbs(). Parameters:; functionname (string) – Name of the CBS component.; zLO (int) – Lower zeta level.; valueLO (float) – Lower value used for extrapolation.; zHI (int) – Higher zeta level. Should be equal to zLO + 1.; valueHI (float) – Higher value used for extrapolation.; alpha (float, optional) – Overrides the default \(\alpha = 1.63\). Returns:Returns \(E_{total}^{\infty}\), see below. Return type:float. Notes; The extrapolation is calculated according to [1]:; \(E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63\); References. [1]Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. psi4.driver.driver_cbs.scf_xtpl_truhlar_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None)[source]¶; Extrapolation scheme using power form for reference energies with two adjacent; zeta-level bases. Used by cbs(). Parameters:; functionname (string) – Name of the CBS component.; zLO (int) – Lower zeta level.; valueLO (float) – Lower value used for extrapolation.; zHI (int) – Higher zeta level. Should be equal to zLO + 1.; valueHI (float) – Higher value used for extrapolation.; alpha (float, optional) – Overrides the default \(\alpha = 3.4\). Returns:Returns \(E_{total}^{\infty}\), see below. Return type:float. Notes; The extrapolation is calculated according to [2]:; \(E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4\); References. [2]Truhlar, Chem. Phys. Lett. 294 (1998) 45-48,; DOI: 10.1016/S0009-2614(98)00866-5. psi4.driver.driver_cbs.scf_xtpl_karton_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None)[source]¶; Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by cbs(). Parameters:; functio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cbs-1.html:16093,power,power,16093,psi4manual/1.3.2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cbs-1.html,2,['power'],['power']
Energy Efficiency,"gation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. DFOCC¶; Performs density-fitted orbital-optimized MPn and CC computations and conventional MPn computations. (AT) CORRECTION ENERGY; (T) CORRECTION ENERGY; CCD CORRELATION ENERGY; CCD TOTAL ENERGY; CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD SINGLES ENERGY; CCSD TOTAL ENERGY; CCSD(AT) TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS(N)-OMP2 CORRELATION ENERGY; SCS(N)-OMP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SCSN-OMP2 CORRELATION ENERGY; SCSN-OMP2 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dfocc-1.html:1021,ENERGY,ENERGY,1021,psi4manual/1.4.0/autodir_psivariables/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_psivariables/module__dfocc-1.html,58,['ENERGY'],['ENERGY']
Energy Efficiency,"gation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. DFOCC¶; Performs density-fitted orbital-optimized MPn and CC computations and conventional MPn computations. (AT) CORRECTION ENERGY; (T) CORRECTION ENERGY; CCD CORRELATION ENERGY; CCD TOTAL ENERGY; CCSD CORRELATION ENERGY; CCSD DOUBLES ENERGY; CCSD SINGLES ENERGY; CCSD TOTAL ENERGY; CCSD(AT) TOTAL ENERGY; CCSD(T) CORRELATION ENERGY; CCSD(T) TOTAL ENERGY; CURRENT CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; LCCD CORRELATION ENERGY; LCCD DOUBLES ENERGY; LCCD OPPOSITE-SPIN CORRELATION ENERGY; LCCD SAME-SPIN CORRELATION ENERGY; LCCD SINGLES ENERGY; LCCD TOTAL ENERGY; MP2 CORRELATION ENERGY; MP2 DOUBLES ENERGY; MP2 OPPOSITE-SPIN CORRELATION ENERGY; MP2 SAME-SPIN CORRELATION ENERGY; MP2 SINGLES ENERGY; MP2 TOTAL ENERGY; MP2.5 CORRELATION ENERGY; MP2.5 DOUBLES ENERGY; MP2.5 OPPOSITE-SPIN CORRELATION ENERGY; MP2.5 SAME-SPIN CORRELATION ENERGY; MP2.5 SINGLES ENERGY; MP2.5 TOTAL ENERGY; MP3 CORRELATION ENERGY; MP3 DOUBLES ENERGY; MP3 OPPOSITE-SPIN CORRELATION ENERGY; MP3 SAME-SPIN CORRELATION ENERGY; MP3 SINGLES ENERGY; MP3 TOTAL ENERGY; NAUX (SCF); OLCCD CORRELATION ENERGY; OLCCD TOTAL ENERGY; OMP2 CORRELATION ENERGY; OMP2 TOTAL ENERGY; OMP2.5 CORRELATION ENERGY; OMP2.5 TOTAL ENERGY; OMP3 CORRELATION ENERGY; OMP3 TOTAL ENERGY; SCS(N)-MP2 CORRELATION ENERGY; SCS(N)-MP2 TOTAL ENERGY; SCS(N)-OMP2 CORRELATION ENERGY; SCS(N)-OMP2 TOTAL ENERGY; SCS-MP2 CORRELATION ENERGY; SCS-MP2 TOTAL ENERGY; SCS-OMP2 CORRELATION ENERGY; SCS-OMP2 TOTAL ENERGY; SCSN-OMP2 CORRELATION ENERGY; SCSN-OMP2 TOTAL ENERGY; SOS-MP2 CORRELATION ENERGY; SOS-MP2 TOTAL ENERGY; SOS-OMP2 CORRELATION ENERGY; SOS-OMP2 TOTAL ENERGY. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; PSI Variables by Module; DFOCC. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_psivariables/module__dfocc-1.html:1021,ENERGY,ENERGY,1021,psi4manual/1.5.0/autodir_psivariables/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_psivariables/module__dfocc-1.html,58,['ENERGY'],['ENERGY']
Energy Efficiency,"gc',; 'ceccsd=eeccsd-eehf',; 'eeccsdt=energy',; 'ceccsdt=eeccsdt-eehf',; 'temp2=emp2_trip',; 'teccsd=ectrip'],. 'mp3': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp3',; 'eemp2=emp2',; 'eemp3=emp3',; 'eemp25=0.5*(eemp2+eemp3)',; 'cemp2=eemp2-eehf',; 'cemp3=eemp3-eehf',; 'cemp25=eemp25-eehf',; 'temp2=emp2_trip',; 'temp3=ectrip'],. 'mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; 'mp2',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf-df-mp2': [; 'gdirect',; 'rhf',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'hf': [; 'rhf',; 'eehf=energy'],. 'mp2-f12': [; 'gdirect',; 'rhf',; 'eehf=energy',; 'mp2-f12',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2-f12': [; 'gdirect',; #'rhf',; '{df-hf,basis=jkfit}',; 'eehf=energy',; #'{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfit,ri_basis=optrib}',; '{df-mp2-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-mp2': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy',; '{df-mp2,basis_mp2=mp2fit}',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'temp2=emp2_trip'],. 'df-hf': [; 'gdirect',; '{df-hf,basis=jkfit}',; 'eehf=energy'],. 'b3lyp-d': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'df-b3lyp-d': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy',; 'dispcorr',; 'eehfd=eehf+edisp'],. 'b3lyp': [; 'gdirect',; 'rks,b3lyp3',; 'eehf=energy'],. 'df-b3lyp': [; 'gdirect',; '{df-rks,b3lyp3,basis=jkfit}',; 'eehf=energy'],. #'mp2c': [ # this job computes one part [E_disp(TDDFT)] of the three parts of a MP2C calculation; # # check that nfrag = 2; # 'gdirect',; # 'ga=1101.2; gb=1102.2',; # 'ca=2101.2; cb=2102.2\n',; #; # $spin = $cgmp{MLPmol1} - 1;; # 'SET,CHARGE=$cgmp{CHGmol1}',; # 'SET,SPIN=$spin',; # 'dummy',; # foreach $at (@",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:5114,energy,energy,5114,psi4manual/1.0.0/_modules/qcdb/molpro.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html,1,['energy'],['energy']
Energy Efficiency,"ge Z at (x,y,z). clear(self); Reset the field to zero (eliminates all entries). computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. print_out(self: psi4.core.ExternalPotential) → None¶; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None¶; Sets the name. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None; Add a charge Z at (x,y,z). clear(self: psi4.core.ExternalPotential) → None; Reset the field to zero (eliminates all entries). computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix; Compute the external potential matrix in the given basis set. print_out(self: psi4.core.ExternalPotential) → None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str) → None; Sets the name. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.externalpotential.html:1724,charge,charge,1724,psi4manual/1.3.2/api/psi4.core.externalpotential.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.externalpotential.html,1,['charge'],['charge']
Energy Efficiency,"ge of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/psi4/driver/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/quickaddalias-1.html:1886,energy,energy,1886,psi4manual/1.4.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/quickaddalias-1.html,9,['energy'],['energy']
Energy Efficiency,"ge(); -2. move_to_com()[source]¶; Moves molecule to center of mass. multiplicity()[source]¶; Get the multiplicity (defined as 2Ms + 1); >>> print H2OH2O.multiplicity(). multiplicity_specified()[source]¶; Whether the multiplicity was given by the user; >>> print H2OH2O.multiplicity_specified(); True. nactive_fragments()[source]¶; The number of active fragments in the molecule.; >>> print H2OH2O.nactive_fragments(); 2. nallatom()[source]¶; Number of all atoms (includes dummies); >>> print H2OH2O.nallatom(); 7. name()[source]¶; Get molecule name; >>> print H2OH2O.name(); water_dimer. natom()[source]¶; Number of atoms; >>> print H2OH2O.natom(); 6. nequivalent(iuniq)[source]¶; NYI Returns the number of atoms equivalent to iuniq. nfragments()[source]¶; The number of fragments in the molecule.; >>> print H2OH2O.nfragments(); 2. nfrozen_core(depth='SMALL')[source]¶; Number of frozen core for molecule given freezing state.; >>> print H2OH2O.nfrozen_core(); 2. nuclear_repulsion_energy()[source]¶; Computes nuclear repulsion energy.; >>> print H2OH2O.nuclear_repulsion_energy(); 36.6628478528. nuclear_repulsion_energy_deriv1()[source]¶; Computes nuclear repulsion energy derivatives; >>> print H2OH2O.nuclear_repulsion_energy_deriv1(); [[3.9020946901323774, 2.76201566471991, 0.0], [1.3172905807089021, -2.3486366050337293, 0.0], [-1.8107598525022435, -0.32511212499256564, 0.0], [-1.217656141385739, -2.6120090867576717, 0.0], [-1.0954846384766488, 1.2618710760320282, 2.1130743287465603], [-1.0954846384766488, 1.2618710760320282, -2.1130743287465603]]. nuclear_repulsion_energy_deriv2()[source]¶; NYI Computes nuclear repulsion energy second derivatives. nunique()[source]¶; NYI Return the number of unique atoms. orientation_fixed()[source]¶; Get whether or not orientation is fixed.; >>> H2OH2O.orientation_fixed(); True. point_group()[source]¶; NYI Returns the point group (object) if set. print_bond_angles()[source]¶; Print the geometrical parameters (bond_angles) of the molecule.; >>> ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:50202,energy,energy,50202,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,4,['energy'],['energy']
Energy Efficiency,"ge; #; # Copyright (c) 2007-2016 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; from __future__ import absolute_import; import re; import os; import math; import warnings; import pickle; import copy; import collections; import p4const; from driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:1231,energy,energy,1231,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['energy'],['energy']
Energy Efficiency,"ged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). psi4.set_global_option(""BASIS"", self.basisname); psi4.set_global_option(""DF_BASIS_SCF"", self.ribasisname); psi4.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); psi4.print_out(""\n""). self.fitGeneral(). psi4.clean(). psi4.set_global_option(""BASIS"", basis); psi4.set_global_option(""DF_BASIS_SCF"", ribasis); psi4.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; psi4.revoke_option_changed(""BASIS""); if not ribasisChanged:; psi4.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; psi4.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; psi4.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = psi4.wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:2747,Charge,Charge,2747,psi4manual/4.0b5/_modules/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html,1,['Charge'],['Charge']
Energy Efficiency,"generate cube files. Examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals ; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). getFromDict(dataDict, mapList)[source]¶. get_memory()[source]¶; Function to return the total memory allocation. get_num_threads()[source]¶; Function to return the number of threads to parallelize across. oeprop(wfn, *args, **kwargs)[source]¶; Evaluate one-electron properties. Returns:None. Parameters:wfn (Wavefunction) – set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. Parameters:title (string) – label prepended to all psivars computed. Examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). set_memory(bytes)[source]¶; Function to reset the total memory allocation. set_num_threads(nthread)[source]¶; Function to reset the number of threads to parallelize across. success(label)[source]¶; Function to print a ‘label...PASSED’ line to screen.; Used by util.compare_values() family when functions pass. xml2dict(filename=None)[source]¶; Read XML filename into nested OrderedDict-s. filename defaults to; active CSX file. array_to_matrix¶; classmethod(function) -> method; Convert a function to be a class method.; A class method receives the class as implicit first argument,; just like an instance method receives the instance.; To declare a class method, use this idiom:. class C:; def f(cls, arg1, arg2, ...): ...; f = classmethod(f). It can be called either on the class (e.g. C.f()) or on an instance; (e.g. C().f()). The instance is ignored except for its class.; If a class method is called for a derived class, th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:136787,energy,energy,136787,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency,"genvalues in the orbital rotation Hessian. A third option, FOLLOW (=2) performs the stability analysis and then proceeds to rotate the SCF orbitals in the direction of a particular negative eigenvalue of the orbital rotation Hessian (see the explanation of keyword CFOUR_ROT_EVEC), after which the SCF is rerun. Type: string; Possible Values: OFF, ON, FOLLOW; Default: OFF. CFOUR_INCORE (CFOUR); CFOUR — This keyword can be used to significantly reduce disk i/o, and should be implemented very soon. The following options are available: OFF (= 0), no special algorithms are used (the default case); ALL (=1) all quantities except the molecular integral lists are held in core; PARTIAL (= 2), the T2 and T1 vectors are held in core throughout the calculation; (=4) all quantities except the and integrals are held in core; (=5) and and two-index quantities are held in core; (=6) all direct access files (MOINTS, GAMLAM, etc.) are held in core. At present, these options have been implemented only in the energy code xvcc and the excitation energy code xvee. (Default: 0). Type: string; Possible Values: OFF, ALL, PARTIAL; Default: OFF. CFOUR_INPUT_MRCC (CFOUR); CFOUR — Specifies whether an input for mrcc is written (ON, =0) or not (OFF, =1) if CFOUR_CC_PROGRAM =EXTERNAL has been specified. Type: boolean; Default: true. CFOUR_INTEGRALS (CFOUR); CFOUR — This keyword defines what type of integral input will be written by xjoda. VMOL (=1) has to be used with the programs of CFOUR. Using ARGOS (=0), input for Pitzer’s ARGOS integral program will be written. (Default: VMOL). Type: string; Possible Values: VMOL, ARGOS; Default: VMOL. CFOUR_JODA_PRINT (CFOUR); CFOUR — Controls amount of debug printing performed by xjoda. The higher the number, the more information is printed. Values of 25 or higher generally do not produce anything of interest to the general user. Do not set JODA_PRINT to 999 as this will cause the core vector to be dumped to disk. Type: integer; Default: 0. CFOUR_LINEQ_CONV",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:52142,energy,energy,52142,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"geometries in Psi4. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. fcidump; test FCIDUMP functionality for rhf/uhf. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). fci-h2o; 6-31G H2O Test FCI Energy Point. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. numpy-array-interface; Numpy interface testing. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. mints-helper; A general test of the MintsHelper function. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. cbs-parser; mtd/basis syntax examples. dft-reference; MP2 with a PBE0 reference computation. mp2p5-grad1; MP2.5 cc-pVDZ gradient f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:20507,energy,energy,20507,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.assemble_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""CURRENT HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction wh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html:82287,energy,energy,82287,psi4manual/1.5.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"ger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]; def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:2990,energy,energy,2990,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,12,['energy'],['energy']
Energy Efficiency,"ger, default = 23); --iso [<isovalue>] the isosurface value (float, default = 0.05); --rx [<angle>] the x-axis rotation angle (float, default = 30.0); --ry [<angle>] the y-axis rotation angle (float, default = 40.0); --rz [<angle>] the z-axis rotation angle (float, default = 15.0); --tx [<length>] the x-axis translation (float, default = 0.0); --ty [<length>] the y-axis translation (float, default = 0.0); --tz [<length>] the z-axis translation (float, default = 0.0); --opacity [<opacity>]; opacity of the isosurface (float, default = 1.0); --scale [<factor>] the scaling factor (float, default = 1.0); --no-montage call montage to combine images. (string, default =; false); --no-labels do not add labels to images. (string, default = false); --imagesize [<integer>]; the size of each image (integer, default = 250); --imagew [<integer>] the width of images (integer, default = 250); --imageh [<integer>] the height of images (integer, default = 250); --fontsize [<integer>]; the font size (integer, default = 20); --interactive run in interactive mode (default = false); --gzip gzip cube files (default = false); --national_scheme use a red/blue color scheme. (string, default = false); --silver_scheme use a gray/white color scheme. (string, default =; false); --bright_scheme use a soft yellow/blue color scheme. (string, default; = false); --electron_scheme use a purple/green color scheme. (string, default =; false). table of contents. Generation of Cube Files — cubeprop(); Introduction; Cubeprop Tasks; Keywords; CUBEPROP_TASKS; CUBEPROP_FILEPATH; CUBEPROP_ORBITALS; CUBEPROP_BASIS_FUNCTIONS; CUBIC_GRID_SPACING; CUBIC_GRID_OVERAGE. Orbital Visualization with VMD; Script Prerequisites; Running the Script; Script Options. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cubeprop-1.html:11432,green,green,11432,psi4manual/1.3.2/cubeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cubeprop-1.html,2,['green'],['green']
Energy Efficiency,"ger}(\omega-; \mathbf{A_{DD}^{(0)}})^{-1}\mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}=; \omega\mathbf{X_{S}}.\]; This form of the ADC(2) equation requires 7–10 iterations for; convergence on only one root. But thanks to Newton-Raphson; acceleration,. \[\omega^{n+1}=\omega^{n}-; \frac{\omega^n-\mathbf{X_{S}}(\omega^n)^{\dagger}; [\mathbf{A_{SS}^{(2)}}+; \mathbf{A_{SD}^{(1)}}^{\dagger}(\omega^n-\mathbf{A_{DD}^{(0)}})^{-1}; \mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}(\omega^n)}{1+\mathbf{X_{S}}; (\omega^n)^{\dagger}[\mathbf{A_{SD}^{(1)}}^{\dagger}; (\omega^n-\mathbf{A_{DD}^{(0)}})^{-2}\mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}; (\omega^n)}\]; the computational time reduces to shorter than half of the simple iterative; procedure. Construction of the denominator of the second term in the above; equation is less computationally expensive than construction of one \(\sigma\)-vector; with respect to the effective response matrix. The non-iterative excitation energy stated; above is calculated as a diagonal element of the Davidson mini-Hamiltonian matrix in the SEM as,. \[\omega^{Non-Iterative}=; \mathbf{X_{CIS}}^{\dagger}[\mathbf{A_{SS}^{(2)}}+; \mathbf{A_{SD}^{(1)}}^{\dagger}(\omega^{CIS}-\mathbf{A_{DD}^{(0)}})^{-1}; \mathbf{A_{DS}^{(1)}}]\mathbf{X_{CIS}}\]; where \(\omega^{CIS}\) and \(\mathbf{X_{CIS}}\) denote the CIS; excitation energy and wave function, respectively. The explicit form of the; σ-vector is provided in a note accompanying the source code,; in the file psi4/psi4/src/psi4/adc/sigma.pdf. table of contents. ADC: Ab Initio Polarization Propagator; Available ADC methods; Running ADC calculations; REFERENCE; R_CONVERGENCE; NUM_GUESSES; CUTOFF_AMPS_PRINT. Interface to adcc; Built-in ADC(2) code. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Theoretical Methods: SCF to FCI; ADC: Ab Initio Polarization Propagator. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/adc-1.html:17388,energy,energy,17388,psi4manual/1.4.0/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/adc-1.html,2,['energy'],['energy']
Energy Efficiency,"ger}(\omega-; \mathbf{A_{DD}^{(0)}})^{-1}\mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}=; \omega\mathbf{X_{S}}.\]; This form of the ADC(2) equation requires 7–10 iterations for; convergence on only one root. But thanks to Newton-Raphson; acceleration,. \[\omega^{n+1}=\omega^{n}-; \frac{\omega^n-\mathbf{X_{S}}(\omega^n)^{\dagger}; [\mathbf{A_{SS}^{(2)}}+; \mathbf{A_{SD}^{(1)}}^{\dagger}(\omega^n-\mathbf{A_{DD}^{(0)}})^{-1}; \mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}(\omega^n)}{1+\mathbf{X_{S}}; (\omega^n)^{\dagger}[\mathbf{A_{SD}^{(1)}}^{\dagger}; (\omega^n-\mathbf{A_{DD}^{(0)}})^{-2}\mathbf{A_{DS}^{(1)}}]\mathbf{X_{S}}; (\omega^n)}\]; the computational time reduces to shorter than half of the simple iterative; procedure. Construction of the denominator of the second term in the above; equation is less computationally expensive than construction of one \(\sigma\)-vector; with respect to the effective response matrix. The non-iterative excitation energy stated; above is calculated as a diagonal element of the Davidson mini-Hamiltonian matrix in the SEM as,. \[\omega^{Non-Iterative}=; \mathbf{X_{CIS}}^{\dagger}[\mathbf{A_{SS}^{(2)}}+; \mathbf{A_{SD}^{(1)}}^{\dagger}(\omega^{CIS}-\mathbf{A_{DD}^{(0)}})^{-1}; \mathbf{A_{DS}^{(1)}}]\mathbf{X_{CIS}}\]; where \(\omega^{CIS}\) and \(\mathbf{X_{CIS}}\) denote the CIS; excitation energy and wave function, respectively. The explicit form of the; σ-vector is provided in a note accompanying the source code,; in the file psi4/psi4/src/psi4/adc/sigma.pdf. table of contents. ADC: Ab Initio Polarization Propagator; Available ADC methods; Running ADC calculations; REFERENCE; R_CONVERGENCE; NUM_GUESSES; CUTOFF_AMPS_PRINT. Interface to adcc; Built-in ADC(2) code. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Theoretical Methods: SCF to FCI; ADC: Ab Initio Polarization Propagator. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/adc-1.html:17388,energy,energy,17388,psi4manual/1.5.0/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/adc-1.html,2,['energy'],['energy']
Energy Efficiency,"ges (Dict[int, List[float]]); keywords (Dict[str, Any]); max_nbody (int); method (str); molecule (Any); nbodies_per_mc_level (List[List[int | Literal['supersystem']]]); nfragments (int); quiet (bool); return_total_data (bool | None); task_list (Dict[str, psi4.driver.task_base.AtomicComputer | psi4.driver.driver_cbs.CompositeComputer | psi4.driver.driver_findif.FiniteDifferenceComputer]). Validators:. set_bsse_type » bsse_type; set_embedding_charges » embedding_charges; set_max_nbody » max_nbody; set_molecule » molecule; set_nfragments » nfragments; set_return_total_data » return_total_data. field basis: str = '(auto)'¶. field bsse_type: List[BsseEnum] = [BsseEnum.cp]¶; Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned. Validated by:. set_bsse_type. field driver: DriverEnum [Required]¶; The computation driver; i.e., energy, gradient, hessian. field embedding_charges: Dict[int, List[float]] = {}¶; Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment. Validated by:. set_embedding_charges. field keywords: Dict[str, Any] = {}¶; The computation keywords/options. field max_nbody: int = -1¶; Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments. Validated by:. set_max_nbody. field method: str = '(auto)'¶. field molecule: Any [Required]¶; The target molecule, if not the last molecule defined. Validated by:. set_molecule. field nbodies_per_mc_level: List[List[Union[int, Literal['supersystem']]]] = []¶; Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/nbody.html:15589,charge,charges,15589,psi4manual/1.8.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/nbody.html,3,['charge'],['charges']
Energy Efficiency,"ges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]¶; Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html:12741,energy,energy,12741,psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,3,['energy'],['energy']
Energy Efficiency,"get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx_state = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # if we're doing MBIS; if 'MBIS_VOLUME_RATIOS' in props:; p4util.free_atom_volumes(scf_wfn). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:56634,ENERGY,ENERGY,56634,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). core.set_legacy_gradient(G). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; core.set_global_option('HESSIAN_WRITE', True). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:58054,energy,energy,58054,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). core.set_legacy_gradient(G). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; core.set_global_option('HESSIAN_WRITE', True). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, ref_gradient = G, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optkin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:70650,energy,energy,70650,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['energy'],['energy']
Energy Efficiency,"get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). core.set_legacy_gradient(G). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; core.set_global_option('HESSIAN_WRITE', True). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, ref_gradient=G, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:65952,energy,energy,65952,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4(sdq)'):; emp4sdq = psi4.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4'):; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variable(""MP4 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4); elif (lowername == 'fnocc-mp') and (level == 4):; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variable(""MP4 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4). # restore options; optstash.restore(). return psi4.get_variable(""CURRENT ENERGY""). [docs]def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; lowername = name.lower(); uppername = name.upper(); kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). psi4.set_local_option('FNOCC','RUN_CEPA', True); psi4.set_local_option('FNOCC','USE_DF_INTS', False). # what type of cepa?; cepa_level = uppername; if (lowername == 'cepa(2)'):; raise ValidationError(""Error: %s not implemented\n"" % lowername); if (lowername == 'dci'):; cepa_level = 'CISD'; if (lowername == 'sdci'):; cepa_level = 'CISD'. if (lowername == 'fno-cepa(0)'):; cepa_level = 'CEPA(0)'; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); if (lowername == 'fno-cepa(1)'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CEPA(1)'; if (lowernam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:72134,ENERGY,ENERGY,72134,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables). return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc steps.; [docs]def run_plugin_omega(name, **kwargs):; r""""""Function encoding sequence of PSI module and plugin calls, as well; as typical options, to access Rob Parrish's omega plugin. >>> energy('plugin_omega'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). plugfile = PsiMod.Process.environment[""PSIDATADIR""] + ""/../tests/plugin_omega/plugin_omega.so""; PsiMod.plugin_load(""%s"" % (plugfile)). PsiMod.set_global_option('BASIS', 'AUG-CC-PVDZ'); PsiMod.set_global_option('DF_BASIS_SCF', 'AUG-CC-PVDZ-RI'); PsiMod.set_global_option('REFERENCE', 'U",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html:3789,energy,energy,3789,psi4manual/4.0b2/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html,2,['energy'],['energy']
Energy Efficiency,"get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Customization: Adding Simple Extensions; Defining a Method Alias. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/quickaddalias.html:2985,energy,energy,2985,psi4manual/1.8.x/quickaddalias.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/quickaddalias.html,7,['energy'],['energy']
Energy Efficiency,"get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Customization: Adding Simple Extensions; Defining a Method Alias. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/quickaddalias.html:2985,energy,energy,2985,psi4manual/1.9.x/quickaddalias.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/quickaddalias.html,7,['energy'],['energy']
Energy Efficiency,"gets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC; Default: No Default. QC_TYPE (DCFT); DCFT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. QCHF (DFOCC); DFOCC — Do perform a QCHF computation?. Type: boolean; Default: false. QCHF (SCF); SCF — Do perform a QCHF computation?. Type: boolean; Default: false. QMEFP (EFP); EFP (Expert) — Do turn on QM/EFP terms?. Type: boolean; Default: false. QMEFP_ELST (EFP); EFP — Do include electrostatics energy term in QM/EFP computation?. Type: boolean; Default: true. QMEFP_POL (EFP); EFP — Do include polarization energy term in EFP computation?. Type: boolean; Default: true. R4S (DETCI); DETCI (Expert) — Do restrict strings with \(e-\) in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-6. R_CONVERGENCE (CCLAMBDA); CCLAMBDA — Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCRESPONSE); CCRESPONSE — Convergence criterion for wavefunction (change)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:188134,energy,energy,188134,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"gets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC; Default: No Default. QC_TYPE (DCFT); DCFT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. QCHF (DFOCC); DFOCC — Do perform a QCHF computation?. Type: boolean; Default: false. QCHF (SCF); SCF — Do perform a QCHF computation?. Type: boolean; Default: false. QMEFP (EFP); EFP (Expert) — Do turn on QM/EFP terms?. Type: boolean; Default: false. QMEFP_ELST (EFP); EFP — Do include electrostatics energy term in QM/EFP computation?. Type: boolean; Default: true. QMEFP_POL (EFP); EFP — Do include polarization energy term in EFP computation?. Type: boolean; Default: true. R4S (DETCI); DETCI (Expert) — Do restrict strings with in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-6. R_CONVERGENCE (CCLAMBDA); CCLAMBDA — Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCRESPONSE); CCRESPONSE — Convergence criterion for wavefunction (change) in per",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:188459,energy,energy,188459,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"gger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:3049,energy,energy,3049,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,8,['energy'],['energy']
Energy Efficiency,"gh care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; An in-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:17462,reduce,reduce,17462,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,4,['reduce'],['reduce']
Energy Efficiency,"gh. If you see labels to add or rename, please do.; A test requiring over 15 minutes should be labeled longtests. A short test under 30 seconds used for general bug checking should be labeled quicktests. A test that confirms PSI4 is operational should be labeled smoketests.; If a test needs extra input files like grid.dat or extra reference files for checking against, like fchk, specify these in the CMakeLists.txt as shown above. Such tests must be run through ctest and don’t usually work when run “by hand” from the objdir via stage/bin/psi4 ../tests/directory_name/input.dat.; If a test is multiple minutes long, load-balancing a parallel CTest run requires the test to be started early. Use the COST line as shown above to set a weighting to about the number of seconds the test takes. input.dat¶; The other necessary file is the input file itself, input.dat. The input file should be just a simple input file to run the test, with small additions.; #! RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxiliary basis.; #! Also a bit more to force a second line. nucenergy = 8.801466202085710 #TEST; refenergy = -76.05098402733282 #TEST. molecule h2o {; symmetry c1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pVTZ; scf_type df; df_basis_scf cc-pVTZ-RI; e_convergence 10; }. thisenergy = energy(""hf""). compare_values(nucenergy, h2o.nuclear_repulsion_energy(), 9, ""Nuclear repulsion energy"") #TEST; compare_values(refenergy, thisenergy, 9, ""Reference energy"") #TEST; compare_values(refenergy, variable('scf total energy'), 9, ""Reference energy"") #TEST. Of those small modifications, first, note the special comment at the top (starting with the #! comment marker). This should be descriptive since it is inlined into the manual (unless !nosample in the comment) as a sample input.; Reference values are often assigned to variables for later use.; The compare_values function (along with several relatives in psi4/psi4/driver/p4util/testing.py for comparing strings, matr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/add_tests.html:6915,energy,energy,6915,psi4manual/1.6.x/add_tests.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/add_tests.html,5,['energy'],['energy']
Energy Efficiency,"ghest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate((self: psi4.core.Molecule, ...); Translates molecule by arg1. update_geometry(...); Reevaluates the geometry with current variable values, orientation directives, etc. x((self: psi4.core.Molecule, arg0: int) -> float); x position of atom arg1 (0-indexed in Bohr). y((self: psi4.core.Molecule, arg0: int) -> float); y position of atom arg1 (0-indexed in Bohr). z((self: psi4.core.Molecule, arg0: int) -> float); z position of atom arg1 (0-indexed in Bohr). Attributes Documentation. units¶; Units (Angstrom or Bohr) used to define the geometry. Methods Documentation. BFS()¶; Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int) → None¶; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int¶; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int) → float¶; Gets charge of atom arg1 (0-indexed). clone(self: psi4.core.Molecule) → psi4.core.Molecule¶; Returns a new Molecule identical to arg0. create_molecule_from_string(arg0: str) → psi4.core.Mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:8432,charge,charge,8432,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"ght)\]. \[\chi_{coup}\left(\mathbf{r},\mathbf{r}'|\omega\right) = \chi_0\left(\mathbf{r},\mathbf{r}'|\omega\right) + \int d\omega d\mathbf{r}_1 d\mathbf{r}_2 \chi_0\left(\mathbf{r},\mathbf{r}_1|\omega\right)\left[\frac{1}{r_{12}} + f_{xc}\left(\mathbf{r}_1,\mathbf{r}_2,\omega\right)\right]\chi\left(\mathbf{r}_2,\mathbf{r}'|\omega\right)\]; The \(\delta_{HF}^{(2)}\) and \(\delta_{HF}^{(3)}\) terms take into; account higher-order induction effects and are included in the definition; of SAPT terms. They are computed from the Hartree–Fock supermolecular interaction energy; \(E_{int}^{HF}\) and are only available in dimer-centered basis SAPT; computations, which is the default (see below for monomer-centered basis; computations). They are defined by:. (7)¶\[\delta_{HF}^{(2)} = E_{int}^{HF} - (E_{elst}^{(10)} + E_{exch}^{(10)}; + E_{ind,resp}^{(20)} + E_{exch-ind,resp}^{(20)})\]. (8)¶\[\delta_{HF}^{(3)} = \delta_{HF}^{(2)} - (E_{exch-ind}^{(30)}; + E_{ind,resp}^{(30)})\]; Additionally, high-order coupling between induction and dispersion can be; extracted from the supermolecular MP2 interaction energy:. \[\delta_{MP2}^{(2)} = E_{int}^{MP2, corr} - (E_{elst}^{(12)} +; E_{exch}^{(11)} + E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)}; + \; ^{t}\!E_{exch-ind}^{(22)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)})\]. \[\delta_{MP2}^{(3)} = \delta_{MP2}^{(2)} - (E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)})\]; where \(E_{int}^{MP2, corr}\) is the correlation part of the supermolecular MP2; interaction energy. \(\delta_{MP2}^{(2)}\) and \(\delta_{MP2}^{(3)}\) also improve the; description of electrostatically dominated complexes. \(\delta_{MP2}^{(2)}\); can be applied to SAPT2+ or SAPT2+(3) energies whereas \(\delta_{MP2}^{(3)}\); should be applied to SAPT2+3 energies.; A thorough analysis of the performance of these truncations of closed-shell SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs],; and a systematic study of the accuracy of these truncations (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:5900,energy,energy,5900,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['energy'],['energy']
Energy Efficiency,"gian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. build(mol, basis=None)¶. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:19209,energy,energy,19209,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,15,['energy'],['energy']
Energy Efficiency,"gies for the CH3 radical. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. opt16; SCF 6-31G(d) optimization of TS for HCN to HNC Performs finite difference hessian calculation. Then optimizes using previous orbitals for scf guess, in subsequent calculations. The last two displacements of the hessian break the plane of symemtry, This test confirms that only the reference geometry, with the correct symmetry, writes orbitals to disk. SCF will fail (ValidationError) otherwise. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. nbody-vmfc-hessian; Computation of VMFC-corrected water trimer Hessian (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. extern4; External potential calculation involving a TIP3P water and a QM water. Gradient on the external charges is compared to gradient on the QM atoms to validate the gradient on the charges. tdscf-7; TD-HF test variable access. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). mom-h2o-3; MOM excitation from LUMO HOMO+3. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. fsapt-ext-abc; FSAPT with exte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:17027,energy,energy,17027,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"gies were independently checked using the original wavels code. oremp-grad1; integral conventional OO-REMP/cc-pVDZ engrad single points for the H2O molecule. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). phi-ao; Test computing values of basis functions (puream and non-puream) at points. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. sapt0-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. scf6; Tests RHF/ROHF/UHF SCF gradients. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. olccd-grad1; OLCCD cc-pVDZ gradient for the H2O molecule. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. mints15; check SP basis Fortran exponent parsing. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. extern4; External potential calculation involving a TIP3P water and a QM water. Gradient on the external charges is compared to gradient on the QM atoms to validate the gradient on the charges. cdoremp-energy1; Cholesky decomposed OO-REMP/cc-pVDZ energy for the H2O molecule. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:41378,energy,energy,41378,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"gies with this scaling,; simply set the keyword exch_scale_alpha true. Alternatively, another value for \(\alpha\); can be specified by setting EXCH_SCALE_ALPHA to a value. For example,; set exch_scale_alpha 1.0. will set \(\alpha = 1.0\) and scale exchange energies with \(p_{EX}(1.0)\).; However, as pointed out by Schaffer and Jansen [Schaffer:2013:2570]; in the context of DFT-based SAPT, the ratios \(E_{exch}^{(1)}(S^{2})/E_{exch}^{(1)}\),; \(E_{\rm exch-ind}^{(2)}(S^2)/E_{\rm exch-ind}^{(2)}\), and; \(E_{\rm exch-disp}^{(2)}(S^2)/E_{\rm exch-disp}^{(2)}\) are not very similar to; each other. Hence, in 2016 universal scaling of all \(S^{2}\) approximated terms; was turned off by default.; Finally, in 2014 Parker et al. [Parker:2014:094106] empirically discovered that; SAPT0 energies for van der Waals dimers with close contacts benefit from a slightly modified; recipe that involves an empirically adjusted exponent \(\alpha = 3.0\).; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]). (9)¶\[E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)}; + \delta_{HF}^{(2)}\]; where \(\delta_{HF}^{(2)}\) is computed without any scaling. Please note that; sSAPT0 is thus not the same as requesting exch_scale_alpha 3.0, and that the; scaling is automatically performed by requesting energy('ssapt0'). A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods,; not all of them).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis aug-cc-pvdz. energy('sapt0'); energy('sapt2'); energy('sapt2+'); en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/sapt.html:11441,energy,energy,11441,psi4manual/1.9.x/sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/sapt.html,2,['energy'],['energy']
Energy Efficiency,"gies, and the metric matrix; \(S\) is the AO-basis overlap matrix. \[S_{\mu\nu} = (\mu | \nu )\]; Note that the Fock Matrix depends on the density (both alpha and beta), and; therefore the orbitals. Because of this, SCF is a nonlinear procedure, which; terminates when the generating orbitals are self-consistent with the Fock matrix; they generate.; The formation of the Coulomb matrix \(J\) and the exchange matrix; \(K^{\alpha}\) dominate the computational effort of the SCF procedure. For; very large systems, diagonalization of the Fock matrix can also present a; significant hurdle. Minimal Input¶; Minimal input for a Hartree–Fock computation is a molecule block, basis set; option, and a call to energy('scf'):; molecule {; He; }. set basis sto-3g. energy('scf'). This will run a Restricted Hartree–Fock (RHF) on neutral singlet Helium in; \(D_{2h}\) spatial symmetry with a minimal STO-3G basis, 1.0E-6; energy and density convergence criteria (since single-point, see; SCF Convergence & Algorithm), a DF ERI algorithm, symmetric; orthogonalization, DIIS, and a core Hamiltonian guess. For more; information on any of these options, see the relevant section below. Spin/Symmetry Treatment¶; PSI4 implements the most popular spin specializations of Hartree–Fock; theory, including:. Restricted Hartree–Fock (RHF) [Default]Appropriate only for closed-shell singlet systems, but twice as efficient; as the other flavors, as the alpha and beta densities are constrained to be; identical. Unrestricted Hartree–Fock (UHF)Appropriate for most open-shell systems and fairly easy to converge.; The spatial parts of the alpha and beta orbitals are fully independent of each; other, which allows a considerable amount of flexibility in the wavefunction.; However, this flexibility comes at the cost of spin symmetry; UHF wavefunctions; need not be eigenfunctions of the \(\hat S^2\) operator. The deviation of; this operator from its expectation value is printed on the output file. If the; deviation is",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:7705,energy,energy,7705,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,9,['energy'],['energy']
Energy Efficiency,"gits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. copy_file_from_scratch(filename, prefix, …); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, …); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation of PSI variables to XML blocks, gathers all available energies from CSX file into returned dictionary. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. filter_comments(string); Remove from string any Python-style comments (‘#’ to end of line). find_approximate_string_matches(seq1, …); Function to compute approximate string matches from a list of options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geometry(geom[, name]); Function to create a molecule object of name name from the geometry in string geom.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:259334,energy,energy,259334,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,4,['energy'],['energy']
Energy Efficiency,"gle and double excitations (CISD), and solving the CISD or coupled-pair equations requires; fewer floating point operations than solving the CC with singles and doubles (CCSD) equations. CISD,; CCSD, and the coupled-pair methods discussed below all scale formally with the sixth power of system size. For a; detailed discussion of the properties of various coupled-pair methods, see Ref. [Wennmohs:2008].; What follows is a very basic description of the practical differences in the equations that define each of the; coupled-pair methods implemented in PSI4. We begin with the CISD wave function. (1); where we have chosen the intermediate normalization, .; The CISD correlation energy is given by. (2); and the amplitudes can be determined by the solution to the coupled set of eqations:. (3); The CISD method is not size-extensive, but this problem can be overcome by making very simple modifications to the amplitude; equations. With malice and forethought, we replace the correlation energy, , with generalized shifts for; the doubles and singles equations, and :. (4); These shifts approximate the effects of triple and quadruple excitations.; The values for and used in several coupled-pair methods are given in Table; CEPA Shifts. Note that these shifts are defined in a spin-free formalism; for closed-shell references only. method. sdci. dci. NA. cepa(0); 0; 0. cepa(1). cepa(3). acpf. aqcc. The pair correlation energy, , is simply a partial sum of the correlation energy. In a spin-free formalism,; the pair energy is given by. (5); Methods whose shifts ( and ) do not explicitly depend on orbitals or ; (CISD, CEPA(0), ACPF, and AQCC); have solutions that render the energy stationary with respect variations in the amplitudes. This convenient property allows; density matrices and 1-electron properties to be evaluated without any additional effort.; The coupled-pair methods currently supported in PSI4 are outlined in Table CEPA Methods. name; calls method; energy; derivatives; 1-elec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cepa-1.html:1527,energy,energy,1527,psi4manual/4.0b3/cepa-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cepa-1.html,2,['energy'],['energy']
Energy Efficiency,"gle points for the H2O molecule. single point energies were independently checked using the original wavels code. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. oremp-grad1; integral conventional OO-REMP/cc-pVDZ engrad single points for the H2O molecule. fnocc6; Test method/basis with disk_df. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. ddd-function-kwargs; check distributed driver is correctly passing function kwargs. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cbs-xtpl-energy; Extrapolated water energies - density-fitted version. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. mbis-5; MBIS calculation on ZnO. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. dft-custom-mgga; updated dldf reference to new BraggSla",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:10552,energy,energy,10552,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"gle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None; Loads a matrix from an ASCII file in MPQC format. name; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int; Returns the number of irreps. np; View without only one irrep. classmethod np_read(filename, prefix=''); Reads the data from a NumPy compress file. np_write(filename=None, prefix=''); Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float=1e-12) → psi4.core.Dimension; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str='outfile') → None; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix) → None; Prints the matrix to the output file. pseudoinverse(self: psi4.core.Matrix, condition: float, nremoved: int) → psi4.core.Matrix; Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) → None; Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self: psi4.core.Matrix) → float; Returns the rms of this matrix. rotate_columns(self: psi4.core.Matrix, h: int, i: int, j: int, theta: float) → None; Rotates columns i and j in irrep h by angle theta. rowdim(self: psi4.core.Matrix) → psi4.core.Dimension; Returns the rows per irrep array. rows(self: psi4.core.Matrix, h: int=0) → int; Returns the rows in irrep h. save(self: psi4.core.Matrix, filename: str, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html:22786,power,power,22786,psi4manual/1.3.2/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html,2,['power'],['power']
Energy Efficiency,"gle-point CCSDT/qz2p on water. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/kw-1; testing best practices options, part i. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on wa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_cfour.html:2459,energy,energy,2459,psi4manual/1.9.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_cfour.html,1,['energy'],['energy']
Energy Efficiency,"gles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Specification Details¶; The above narrative introduction to the P4C4 interface should be; sufficient to get started. Issues of competition between PSI4 and; Cfour specification format are generally resolved behind the scenes:; not according to a simple rule but according to sensible, sometimes; intricate, rules governed by user intent (and integration of Cfour to; behave like a PSI4 module). Much can be gleaned by just running; inputs and inspecting the ZMAT passed to Cfour, but when questions; arise, here are the specifics, the governing laws. Specifying a piece of input in PSI4 format is entering into; a contract that you mean it. In particular this applies to; molecule (including charge/multiplicity through molecule; optional_molecule_name {...}), memory (through memory; value unit), computational method (through . If Cfour keywords; are specified with values that contradict the PSI4 input,; execution is halted.; As an example, the input below is set up to fail in four ways:; contradictory specification of memory, multiplicity, computational; method, and derivative level. Note, though, that the cfour_units; angstrom setting is permissible, since it concurs with the value; implied in the molecule block.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15memory 300 mb. molecule {; H; H 1 0.7; }. set basis 6-31g; set cfour_multiplicity 3 # clash with implicit singlet in molecule {} above; set cfour_units angstrom # no problem, consistent with molecule {} above; set cfour_memory_size 100000000 # clash with 300 mb above; set cfour_calc_level ccsd # clash with 'c4-scf' below; set cfour_deriv_level first # clash with energy() below (use gradient('c4-scf') to achieve this). e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:28206,charge,charge,28206,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,6,['charge'],['charge']
Energy Efficiency,"gles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Specification Details¶; The above narrative introduction to the P4C4 interface should be; sufficient to get started. Issues of competition between PSI4 and; Cfour specification format are generally resolved behind the scenes:; not according to a simple rule but according to sensible, sometimes; intricate, rules governed by user intent (and integration of Cfour to; behave like a PSI4 module). Much can be gleaned by just running; inputs and inspecting the ZMAT passed to Cfour, but when questions; arise, here are the specifics, the governing laws. Specifying a piece of input in PSI4 format is entering into; a contract that you mean it. In particular this applies to; molecule (including charge/multiplicity through molecule; optional_molecule_name {...}), memory (through memory; value unit), computational method (through . If Cfour keywords; are specified with values that contradict the PSI4 input,; execution is halted.; As an example, the input below is set up to fail in four ways:; contradictory specification of memory, multiplicity, computational; method, and derivative level. Note, though, that the cfour_units; angstrom setting is permissible, since it concurs with the value; implied in the molecule block.; memory 300 mb. molecule {; H; H 1 0.7; }. set basis 6-31g; set cfour_multiplicity 3 # clash with implicit singlet in molecule {} above; set cfour_units angstrom # no problem, consistent with molecule {} above; set cfour_memory_size 100000000 # clash with 300 mb above; set cfour_calc_level ccsd # clash with 'c4-scf' below; set cfour_deriv_level first # clash with energy() below (use gradient('c4-scf') to achieve this). energy('c4-scf'). Specifying anything in PSI4 form",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:29252,charge,charge,29252,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,9,['charge'],['charge']
Energy Efficiency,"gles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Specification Details¶; The above narrative introduction to the P4C4 interface should be; sufficient to get started. Issues of competition between Psi4 and; Cfour specification format are generally resolved behind the scenes:; not according to a simple rule but according to sensible, sometimes; intricate, rules governed by user intent (and integration of Cfour to; behave like a Psi4 module). Much can be gleaned by just running; inputs and inspecting the ZMAT passed to Cfour, but when questions; arise, here are the specifics, the governing laws. Specifying a piece of input in Psi4 format is entering into; a contract that you mean it. In particular this applies to; molecule (including charge/multiplicity through molecule; optional_molecule_name {...}), memory (through memory; value unit), computational method (through . If Cfour keywords; are specified with values that contradict the Psi4 input,; execution is halted.; As an example, the input below is set up to fail in four ways:; contradictory specification of memory, multiplicity, computational; method, and derivative level. Note, though, that the cfour_units; angstrom setting is permissible, since it concurs with the value; implied in the molecule block.; memory 300 mb. molecule {; H; H 1 0.7; }. set basis 6-31g; set cfour_multiplicity 3 # clash with implicit singlet in molecule {} above; set cfour_units angstrom # no problem, consistent with molecule {} above; set cfour_memory_size 100000000 # clash with 300 mb above; set cfour_calc_level ccsd # clash with 'c4-scf' below; set cfour_deriv_level first # clash with energy() below (use gradient('c4-scf') to achieve this). energy('c4-scf'). Specifying anything in Psi4 form",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:29277,charge,charge,29277,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['charge'],['charge']
Energy Efficiency,"glet Oxygen energy SOSCF, also tests non-symmetric density matrices. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. freq-masses; check nonphysical masses possible. scf-level-shift-cuhf; SCF level shift on a CUHF computation. dft-freq-analytic1; Analytic SVWN frequencies, compared to finite difference values. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. mbis-2; MBIS calculation on OH- (Expanded Arrays). sapt-sf1; Tests the Psi4 SF-SAPT code. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. cc13d; Tests analytic CC2 gradients. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. fsapt-ext-abc2; FSAPT with external charge on dimer. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. cbs-xtpl-energy; Extrapolated water energies - density-fitted version. dforemp-grad2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:15173,energy,energy,15173,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"glet orbitals. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. fd-freq-gradient-large; SCF DZ finite difference frequencies by energies for C4NH4. dft1-alt; DFT Functional Test. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. psimrcc-fd-freq2; Mk-MRCCSD frequencies. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:3476,energy,energy,3476,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; 1; 2; 3; 4; 5procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dcft' : run_dcft,. Then in psi4/share/python/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default module (e.g., mtd_type ==; 'DETCI' ) or able, default module (e.g., mtd_typd == ['', 'FNOCC'] ).; Don’t worry about ‘else’ statements as anything that falls through will be; caught and a readable error generated.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/proc_py-1.html:5332,energy,energy,5332,psi4manual/1.1.0/proc_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/proc_py-1.html,6,['energy'],['energy']
Energy Efficiency,"global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly. ocepa2; OCEPA cc-pVDZ energy with B3LYP initial guess for the NO radical. dcft5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. fci-dipole; 6-31G H2O Test FCI Energy Point. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. dft1; DFT Functional Test. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. pywrap-cbs1; Various basis set extrapolation tests. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. cubeprop-esp; RHF orbitals and d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:11588,energy,energy,11588,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join([name.upper(), which_ind, 'ENERGY'])):; which_ind='IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = sapt_dimer.extract_subsets(2); monomerBm.set_name('monomerBm'). if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('SAPT requires requires \""reference rhf\"".'). ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:105078,charge,charge-transfer,105078,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['charge'],['charge-transfer']
Energy Efficiency,"global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:139112,ENERGY,ENERGY,139112,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,7,['ENERGY'],['ENERGY']
Energy Efficiency,"global_option(""FRAC_OCC"", [HOMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E = energy('scf'); C = 1; if (E == 0.0):; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = psi4.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = psi4.wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge); mol.set_multiplicity(mult). # Determine HOMO; ref = psi4.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if (E_a >= E_b):; HOMO = Na; else:; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; psi4.print_out('\n ==> Fractional Occupation Nuke Results <==\n\n'); psi4.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; psi4.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. psi4.print_out('\n'); psi4.print_out('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; psi4.print_out(line). psi4.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); psi4.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write('\t%11",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/frac.html:10223,charge,charge,10223,psi4manual/4.0b5/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/frac.html,2,['charge'],['charge']
Energy Efficiency,"global_option('DF_BASIS_SAPT') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_SAPT', ribasis); PsiMod.print_out(' No DF_BASIS_SAPT auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_SAPT is required.'). PsiMod.print_out('\n'); banner('Dimer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespace(PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = PsiMod.sapt(); CTd = PsiMod.get_variable('SAPT CT ENERGY'). PsiMod.print_out('\n'); banner('Monomer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); PsiMod.IO.change_file_namespace(PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = PsiMod.sapt(); CTm = PsiMod.get_variable('SAPT CT ENERGY'); CT = CTd - CTm. PsiMod.print_out('\n\n'); PsiMod.print_out(' SAPT Charge Transfer Analysis\n'); PsiMod.print_out(' -----------------------------------------------------------------------------\n'); line1 = ' SAPT Induction (Dimer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTd * 1000.0, CTd * physconst.psi_hartree2kcalmol); line2 = ' SAPT Induction (Monomer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTm * 1000.0, CTm * physconst.psi_hartree2kcalmol); line3 = ' SAPT Charge Transfer %10.4lf mH %10.4lf kcal mol^-1\n\n' % (CT * 1000.0, CT * physconst.psi_hartree2kcalmol); PsiMod.print_out(line1); PsiMod.print_out(line2); PsiMod.print_out(line3); PsiMod.set_variable('SAPT CT ENERGY', CT). molecule.reset_point_group(user_pg); molecule.update_geometry(). optstash.restore(); return e_sapt. [docs]def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; # TODO: Check to see if we really need to run the SCF code.; scf_helper(name, **kwargs); vscf = PsiMod.get_variable('SCF TOTAL ENERGY'). # ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:62849,Charge,Charge,62849,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Charge'],['Charge']
Energy Efficiency,"gment coordinates are not redundant. Type: string; Possible Values: SINGLE, MULTI; Default: SINGLE. FRAG_REF_ATOMS (OPTKING)¶OPTKING — Which atoms define the reference points for interfragment coordinates?. Type: array; Default: No Default. FREEZE_CORE (GLOBALS)¶GLOBALS — Specifies how many core orbitals to freeze in correlated computations. TRUE or 1 will default to freezing the previous noble gas shell on each atom. In case of positive charges on fragments, an additional shell may be unfrozen, to ensure there are valence electrons in each fragment. With FALSE or 0, no electrons are frozen (with the exception of electrons treated by an ECP). With -1, -2, and -3, the user might request strict freezing of the previous first/second/third noble gas shell on every atom. In this case, when there are no valence electrons, the code raises an exception. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE, 1, 0, -1, -2, -3; Default: FALSE. FREEZE_CORE (SAPT)¶SAPT — The scope of core orbitals to freeze in evaluation of SAPT \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE; Default: FALSE. FREEZE_INTERFRAG (OPTKING)¶OPTKING — Do freeze all interfragment modes?. Type: boolean; Default: false. FREEZE_INTRAFRAG (OPTKING)¶OPTKING — Do freeze all fragments rigid?. Type: boolean; Default: false. FROZEN_BEND (OPTKING)¶OPTKING — Specify angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_CARTESIAN (OPTKING)¶OPTKING — Specify atom and X, XY, XYZ, … to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DIHEDRAL (OPTKING)¶OPTKING — Specify dihedral angles between atoms to b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:133967,energy,energy,133967,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,5,['energy'],['energy']
Energy Efficiency,"gment in basis of 2nd and 3rd fragments |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| ... | | | |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+. """"""; if results is None:; results = {}. # formerly nlevels; mc_level_labels = {i.split(""_"")[0] for i in self.task_list}; if len(mc_level_labels) > 1 and not results:; return driver_nbody_multilevel.prepare_results(self, client). results_list = {k: v.get_results(client=client) for k, v in (results.items() or self.task_list.items())}; trove = { # AtomicResult.properties return None if missing; ""energy"": {k: v.properties.return_energy for k, v in results_list.items()},; ""gradient"": {k: v.properties.return_gradient for k, v in results_list.items()},; ""hessian"": {k: v.properties.return_hessian for k, v in results_list.items()},; }. # TODO: make assemble_nbody_components and driver_nbody_multilevel.prepare_results into class functions.; # note that the former uses metadata as read-only (except for one solveable case) while the latter overwrites self (!).; metadata = {; ""quiet"": self.quiet,; ""nbodies_per_mc_level"": self.nbodies_per_mc_level,; ""bsse_type"": self.bsse_type,; ""nfragments"": self.nfragments,; ""return_total_data"": self.return_total_data,; ""molecule"": self.molecule,; ""embedding_charges"": bool(self.embedding_charges),; ""max_nbody"": self.max_nbody,; }; if self.driver.name == ""energy"":; nbody_results = assemble_nbody_components(""energy"", trove[""energy""], metadata.copy()). elif self.driver.name == ""gradient"":; nbody_results = assemble_nbody_components(""energy"", trov",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:85873,energy,energy,85873,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,10,['energy'],['energy']
Energy Efficiency,"gment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fragmented. Advanced Python¶; A named molecule in an input file is a full-fledged instance of the; powerful C++ Molecule class. Thus, all member; functions (that have been exported via Boost Python) documented thereat; are accessible through the handle option_molecule_name in; molecule optional_molecule_name {...}. The molecular geometry can be got and set and manipulated as a; psi4.Matrix object. Below shows how to access; coordinates in an input file in Python.; molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html:15475,energy,energy,15475,psi4manual/1.0.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html,2,['energy'],['energy']
Energy Efficiency,"gment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). Job Control¶; PSI4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file, detailed in Appendix Keywords by Module, which; control its function. The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; # all equivalent. set globals basis cc-pVDZ. set basis cc-pVDZ. set globals basis = cc-pVDZ. set basis = cc-pVDZ. set globals{; basis cc-pVDZ; }. set {; basis cc-pVDZ; }. set {; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:17279,energy,energy,17279,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['energy'],['energy']
Energy Efficiency,"gments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self, arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self, arg0); Checks if variable arg0 is in the structural variables list. label(self, atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self, atom); Returns mass of atom (0-indexed). mass_number(self, arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(self[, dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[, ...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separato",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:5097,charge,charge,5097,psi4manual/1.7.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html,8,['charge'],['charge']
Energy Efficiency,gneton_ratio; 0.8574382311; deuteron mag. mom. to nuclear magneton ratio [] uncertainty=0.000 000 0048. deuteron_mass; 3.343583719E-27; deuteron mass [kg] uncertainty=0.000 000 041 e-27. deuteron_mass_energy_equivalent; 3.005063183E-10; deuteron mass energy equivalent [J] uncertainty=0.000 000 037 e-10. deuteron_mass_energy_equivalent_in_MeV; 1875.612928; deuteron mass energy equivalent in MeV [MeV] uncertainty=0.000 012. deuteron_mass_in_u; 2.013553212745; deuteron mass in u [u] uncertainty=0.000 000 000 040. deuteron_molar_mass; 0.002013553212745; deuteron molar mass [kg mol^{-1}] uncertainty=0.000 000 000 040 e-3. deuteron_neutron_mag_mom_ratio; -0.44820652; deuteron-neutron mag. mom. ratio [] uncertainty=0.000 000 11. deuteron_proton_mag_mom_ratio; 0.3070122077; deuteron-proton mag. mom. ratio [] uncertainty=0.000 000 0015. deuteron_proton_mass_ratio; 1.99900750087; deuteron-proton mass ratio [] uncertainty=0.000 000 000 19. deuteron_rms_charge_radius; 2.1413E-15; deuteron rms charge radius [m] uncertainty=0.0025 e-15. electric_constant; 8.854187817E-12; electric constant [F m^{-1}] uncertainty=(exact). electron_charge_to_mass_quotient; -1.758820024E+11; electron charge to mass quotient [C kg^{-1}] uncertainty=0.000 000 011 e11. electron_deuteron_mag_mom_ratio; -2143.923499; electron-deuteron mag. mom. ratio [] uncertainty=0.000 012. electron_deuteron_mass_ratio; 0.0002724437107484; electron-deuteron mass ratio [] uncertainty=0.000 000 000 096 e-4. electron_g_factor; -2.00231930436182; electron g factor [] uncertainty=0.000 000 000 000 52. electron_gyromag_ratio; 1.760859644E+11; electron gyromag. ratio [s^{-1} T^{-1}] uncertainty=0.000 000 011 e11. electron_gyromag_ratio_over_2_pi; 28024.95164; electron gyromag. ratio over 2 pi [MHz T^{-1}] uncertainty=0.000 17. electron_helion_mass_ratio; 0.0001819543074854; electron-helion mass ratio [] uncertainty=0.000 000 000 088 e-4. electron_mag_mom; -9.284764620E-24; electron mag. mom. [J T^{-1}] uncertainty=0.000 0057 e,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:8719,charge,charge,8719,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['charge'],['charge']
Energy Efficiency,"gnored. Type: string; Possible Values: NONE, MP2, NEGLECT; Default: NONE. LOCAL_WEAKP (CCLAMBDA); CCLAMBDA — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CCRESPONSE); CCRESPONSE — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CCSORT); CCSORT — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CIS); CIS — Desired treatment of “weak pairs” in the local-CIS method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CIS energy computed with weak pairs ignored. Type: string; Possible Values: MP2, NEGLECT, NONE; Default: MP2. LOCK_OCC (DCFT); DCFT (Expert) — Controls whether to force the occupation to be that of the SCF guess. For practical applications only the default must be used. Type: boolean; Default: true. LOCK_SINGLET (PSIMRCC); PSIMRCC — Do lock onto a singlet root?. Type: boolean; Default: false. LSE (DETCI); DETCI — Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE (DETCI); DETCI — Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE (DETCI); DETCI — Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. M_FILE (TRANSQT); TRANSQT — Output integrals file. Type: integer; Default: 0. MADMP2_SLEEP (DFMP2); DFMP2 (Expert) — A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. MAT_NUM",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:68545,energy,energy,68545,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"gorithm for a MP2 gradient call; and directing to specified or best-performance default modules. select_mp2_property(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. select_mp2p5(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. select_mp2p5_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. select_mp3(name, **kwargs)[source]¶; Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. select_mp3_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. select_mp4(name, **kwargs)[source]¶; Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. select_olccd(name, **kwargs)[source]¶; Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. select_olccd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. select_omp2(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. select_omp2_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. select_omp2_property(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. select_omp2p5(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:169177,energy,energy,169177,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency,"grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_lo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:85211,ENERGY,ENERGY,85211,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"gradient for the NO radical. dlpnomp2-3; comparison of DF-MP2 and DLPNO-MP2 with a cartesian basis set. dft1; DFT Functional Test all values update for new BraggSlater radii. cubeprop-esp; RHF orbitals and density for water. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. dft-custom; DFT custom functional test. cc13b; Tests RHF CCSD(T)gradients. sad-scf-type; Test SAD SCF guesses on noble gas atom. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cc51; EOM-CC3/cc-pVTZ on H2O. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. dforemp-grad2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). mints2-bse; Similar to mints2, but using the BSE to specify the basis sets. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. sapt0-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. nbo; Generation of NBO file. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. dfccsd-t-grad2; DF-CCSD(T) cc-pVDZ gradient for the NH molecule. dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. cubeprop-frontier; ROHF frontier orbitals of CH2(s) and CH2(t). omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:28303,energy,energy,28303,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"gradient for the O2 molecule with cc-pVDZ basis set. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:15038,energy,energy,15038,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; kwargs = p4util.kwargs_lower(kwargs). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif kwargs.get('bsse_type', None) is not None:; gradient_type = 'nbody_gufunc'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. # Figure out lowername, dertype, and func; # If we have analytical gradients we want to pass to our wrappers, otherwise we want to run; # finite-diference energy or cbs energies; # TODO MP5/cc-pv[DT]Z behavior unkown due to ""levels""; user_dertype = kwargs.pop('dertype', None); if gradient_type == 'custom_function':; if user_dertype is None:; dertype = 0; core.print_out(; ""\nGradient: Custom function passed in without a defined dertype, assuming fd-energy based gradient.\n""; ); else:; core.print_out(""\nGradient: Custom function passed in with a dertype of %d\n"" % user_dertype); dertype = user_dertype. if dertype == 1:; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', 'scf', 8, 10, 8, 10, 8); lowername = name. elif gradient_type == 'nbody_gufunc':; return driver_nbody.nbody_gufunc(gradient, name, ptype='gradient', **kwargs). elif gradient_type == 'cbs_wrapper':; cbs_methods = driver_cbs._cbs_wrapper_methods(**kwargs); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:37509,energy,energy,37509,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"gradient of S22 HCN update ref gradient due to new BraggSlater radii. sapt-ecp; sapt0 of charged system in ECP basis set. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cbs-xtpl-alpha; Extrapolated water energies. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. dct8; DCT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. scf-cholesky-basis; incremental Cholesky filtered SCF. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). cisd-sp; 6-31G** H2O Test CISD Energy Point. cdremp-1; Cholesky decomposed REMP/cc-pVDZ energies for the CO2 molecule. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:22770,energy,energy,22770,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"gradient of S22 HCN updated ref gradient due to new BraggSlater radii. props4; Electrostatic potential and electric field evaluated on a grid around water. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cepa1; cc-pvdz H2O Test CEPA(1) Energy. psimrcc-pt2; Mk-MRPT2 single point. \(^1A_1\) F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). explicit-am-basis; Check that basis sets can be input with explicit angular momentum format. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. sapt-sf1; Tests the Psi4 SF-SAPT code. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. scf-guess-read2; Test if the the guess read in the same basis converges. cc13d; Tests analytic CC2 gradients. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dft-custom-gga;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:3958,energy,energy,3958,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"gradient() in module proc. RUN_MP4 (FNOCC). run_mrcc() in module proc. run_ocepa() in module proc. run_ocepa_gradient() in module proc. run_omp2() in module proc. run_omp2_5() in module proc. run_omp2_5_gradient() in module proc. run_omp2_gradient() in module proc. run_omp3() in module proc. run_omp3_gradient() in module proc. run_psimrcc() in module proc. run_psimrcc_scf() in module proc. run_sapt() in module proc. run_sapt_ct() in module proc. run_scf() in module proc. run_scf_gradient() in module proc. run_scf_property() in module proc. run_scs_omp2() in module proc. run_scs_omp3() in module proc. run_sos_omp2() in module proc. run_sos_omp3() in module proc. S. S (DETCI). S22 module, [1]. S22by5 module, [1]. S66 module, [1]. S_ORTHOGONALIZATION (SCF). S_SQUARED (DETCI). S_TOLERANCE (SCF). SAD_CHOL_TOLERANCE (SCF). SAD_D_CONVERGENCE (SCF). SAD_E_CONVERGENCE (SCF). SAD_F_MIX_START (SCF). SAD_MAXITER (SCF). SAD_PRINT (SCF). sanitize_basisname() in module basislist. SAPT. SAPT0. charge-transfer. higher-order. output. theory. SAPT (SCF). SAPT_LEVEL (SAPT). SAPT_MEM_CHECK (SAPT). SAPT_MEM_FACTOR (DFTSAPT). SAPT_MEM_SAFETY (SAPT). SAPT_OS_SCALE (SAPT). SAPT_SS_SCALE (SAPT). SAPTDISPENERGY. SAPTELSTENERGY. SAPTENERGY. SAPTEXCHENERGY. SAPTINDENERGY. SAPTSAPT0ENERGY. SAPTSAPT2+(3)(CCD)ENERGY. SAPTSAPT2+(3)ENERGY. SAPTSAPT2+(CCD)ENERGY. SAPTSAPT2+3(CCD)ENERGY. SAPTSAPT2+3ENERGY. SAPTSAPT2+ENERGY. SAPTSAPT2ENERGY. save() Table method. SAVE_JK (SCF). save_string_for_psi4() Molecule method. save_string_xyz() LibmintsMolecule method. save_to_checkpoint() LibmintsMolecule method. save_xyz() LibmintsMolecule method. SCALE (STABILITY). scale() in module qcdb.vecutil. Table method. SCF. theory. scf_helper() in module proc. SCF_MAXITER (DCFT). SCF_MEM_SAFETY_FACTOR (SCF). SCF_TYPE (CPHF). (SCF). scf_xtpl_helgaker_2() in module wrappers. scf_xtpl_helgaker_3() in module wrappers. SCFDIPOLEX. SCFDIPOLEY. SCFDIPOLEZ. SCFQUADRUPOLEXX. SCFQUADRUPOLEXY. SCFQUADRUPOLEXZ. SCFQUADRUPOLEYY. SCF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/genindex.html:39795,charge,charge-transfer,39795,psi4manual/4.0b4/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/genindex.html,1,['charge'],['charge-transfer']
Energy Efficiency,"gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self, arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self, arg0); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. form_C(self[, shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_FDS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html:4216,energy,energy,4216,psi4manual/1.6.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.HF.html,2,['energy'],['energy']
Energy Efficiency,"gradient, or Hessian as requested. method_string (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element of a tuple. bsse_type (string or list) – 'cp' || ['nocp', 'vmfc'] || \(\Rightarrow\) None \(\Leftarrow\) || etc.; Type of BSSE correction to compute: CP, NoCP, or VMFC. The first in this; list is returned by this function. By default, this function is not called. max_nbody (int) – 3 || etc.; Maximum n-body to compute, cannot exceed the number of fragments in the moleucle. ptype (string) – 'energy' || 'gradient' || 'hessian'; Type of the procedure passed in. return_total_data (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); If True returns the total data (energy/gradient/etc) of the system,; otherwise returns interaction data. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22# Counterpoise corrected CCSD(T) energy for the Helium dimer; molecule mol {; He; --; He 1 3; }. energy('CCSD(T)', bsse_type='cp'). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/nbody-1.html:1847,energy,energy,1847,psi4manual/1.1.0/nbody-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/nbody-1.html,12,['energy'],['energy']
Energy Efficiency,"gradient,; 'dfmp2' : run_dfmp2_gradient,; 'eom-ccsd' : run_eom_cc_gradient,; 'dcft' : run_dcft_gradient; # Upon adding a method to this list, add it to the docstring in optimize() below; },; 'hessian' : {; # Upon adding a method to this list, add it to the docstring in frequency() below; },; 'property' : {; 'scf' : run_scf_property,; 'cc2' : run_cc_property,; 'ccsd' : run_cc_property,; 'eom-cc2' : run_cc_property,; 'eom-ccsd' : run_cc_property,; 'eom_cc2' : run_cc_property,; 'eom_ccsd' : run_cc_property; # Upon adding a method to this list, add it to the docstring in property() below; }}. # Integrate DFT with driver routines; for ssuper in superfunctional_list():; procedures['energy'][ssuper.name().lower()] = run_dft. for ssuper in superfunctional_list():; procedures['gradient'][ssuper.name().lower()] = run_dft_gradient. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: (*float*) Total electronic energy in Hartrees. SAPT returns interaction energy. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. comment In this table immediately below, place methods that should only be called by; .. comment developers at present. This table won't show up in the manual.; .. comment; .. comment .. _`table:energy_devel`:; .. comment; .. comment +-------------------------+---------------------------------------------------------------------------------------+; .. comment | name | calls method |; .. comment +=========================+=======================================================================================+; .. comment | df-cc | coupled cluster with density fitting |; .. comment +-------------------------+---------------------------------------------------------------------------------------+; .. comment | mp2c | coupled MP2 (MP2C) |; .. comment +------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:3761,energy,energy,3761,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"gradient; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; freq_dertype = kwargs['dertype']. if der0th.match(str(freq_dertype)):; dertype = 0; func = energy; elif der1st.match(str(freq_dertype)):; dertype = 1; func = gradient; elif der2nd.match(str(freq_dertype)):; dertype = 2; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function frequency.' % (freq_dertype)). # 3. if the user provides a custom function THAT takes precedence; if ('freq_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['freq_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['freq_func']. # Summary validation; if (dertype == 2) and (lowername in procedures['hessian']):; pass; elif (dertype == 1) and (func is gradient) and (lowername in procedures['gradient']):; pass; elif (dertype == 1) and not(func is gradient):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 10); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:61080,energy,energy,61080,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,6,['energy'],['energy']
Energy Efficiency,"gradient; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; freq_dertype = kwargs['dertype']. if der0th.match(str(freq_dertype)):; dertype = 0; func = energy; elif der1st.match(str(freq_dertype)):; dertype = 1; func = gradient; elif der2nd.match(str(freq_dertype)):; dertype = 2; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function frequency.' % (freq_dertype)). # 3. if the user provides a custom function THAT takes precedence; if ('freq_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['freq_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['freq_func']. # Summary validation; if (dertype == 2) and (lowername in procedures['hessian']):; pass; elif (dertype == 1) and (func is gradient) and (lowername in procedures['gradient']):; pass; elif (dertype == 1) and not(func is gradient):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; freq_mode = 'continuous'; if ('mode' in kwargs) and ((dertype == 0) or (dertype == 1)):; freq_mode = kwargs['mode']. if (freq_mode.lower() == 'continuous'):; pass; elif (freq_mode.lower() == 'sow'):; pass; elif (freq_mode.lower() == 'reap'):; if('linkage' in kwargs):; freq_linkage = kwargs['linkage']; else:; raise ValidationError('Frequency execution mode ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:59780,energy,energy,59780,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,6,['energy'],['energy']
Energy Efficiency,"grals (ERIs); appearing in MP2 are cast onto a linear-scaling auxiliary basis by least-squares; fitting. Substitution of the DF factorization into the MP2 equations results in; a formal scaling and prefactor reduction of MP2, and further speed gains are; possible due to heavy utilization of matrix-multiplication kernels and minimal; storage requirements in a DF approach. The method has been found to be quite; robust and accurate, and it should be preferred unless extreme accuracy is required; or a fitting basis is not defined for the primary basis and atom type; encountered. In particular, we have found excellent efficiency and tractability; gains when using DF-MP2 in concert with a DF-SCF reference. An efficient,; threaded, disk-based DF-MP2 code is available in PSI4 for all single; reference types available in the SCF module.; An example utilization of the code is:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True. energy('df-mp2'). The energy('df-mp2') call to energy() executes; the predefined DF-MP2 procedure, first calling; the SCF module with a default RHF reference and DF algorithm for the; two-electron integrals. When the orbitals are converged, the DF-MP2 module is; launched, which forms the density-fitted integrals and then builds the; full tensor in blocks, evaluating the contributions to the MP2 energy; as it goes. A RHF-MP2 wavefunction is selected automatically due to the RHF; reference. In this example, we freeze the core, both for efficiency and; because split-valence bases like cc-pVDZ do not contain core correlation; functions. The result looks something like:; ----------------------------------------------------------; ====================> MP2 Energies <====================; ----------------------------------------------------------; Reference Energy = -76.0213974789664633 [H]; Singles Energy = -0.0000000000000001 [H]; Same-Spin Energy = -0.0512503261762665 [H]; Opposite-Spin Energy = -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/dfmp2-1.html:1837,energy,energy,1837,psi4manual/4.0b2/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/dfmp2-1.html,8,['energy'],['energy']
Energy Efficiency,"grals use a density-; fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. [4]Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. [5]The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list beginning at E_CONVERGENCE. [6]The R_CONVERGENCE keyword places a convergence check on an internal; residual error measure and is implemented for several post-SCF; modules (see list beginning at R_CONVERGENCE). It is defined; according to the quantum chemical method and so its default value is set; by each module individually. [7](1, 2, 3) For frequency computations by finite difference of energies,; convergence criteria are tightened further still to 10 for; E_CONVERGENCE and D_CONVERGENCE for SCF of HF or DFT, 11; for E_CONVERGENCE and D_CONVERGENCE for SCF of post-HF,; and 10 for E_CONVERGENCE for post-HF of post-HF. Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment. Also, the SAD; UHF guess is very slow in large basis sets, so you may want to cast up for; >TZ.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxilia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:32365,power,powerful,32365,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,6,['power'],['powerful']
Energy Efficiency,"grals) may be held in the cache. Type: integer; Default: 2. CC_MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 50. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 14. DIIS_MAX_VECS¶. Number of vectors used in DIIS. Type: integer; Default: 4. DO_LEVEL_SHIFT¶. Do apply level shifting to aid convergence. Type: boolean; Default: false. DO_SCS¶. Do perform spin-component-scaled OMP3 (SCS-OMP3)? In all computation, SCS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP3, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP3 (SOS-OMP3)? In all computation, SOS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP3, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E3_SCALE¶. Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-8. HESS_TYPE¶. Type Hessian matrix will be used in orbital optimization procedure. Type: string; Possible Values: NONE; Default: NONE. LEVEL_SHIFT¶. Level shift parameter. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ¶. Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_STEP_MAX¶. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE¶. Do write coefficient matrices",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp3-1.html:1663,energy,energy,1663,psi4manual/4.0b3/autodir_options_c/module__omp3-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp3-1.html,4,['energy'],['energy']
Energy Efficiency,"gram correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity \(2S+1 = 3\)).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables (\(R\) and \(A\)), whose values are given; at the end of the Z-matrix specification.; #! Sample UHF/6-31G** CH2 computation. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; 1@UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perfor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:4639,energy,energy,4639,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,6,['energy'],['energy']
Energy Efficiency,"gram correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity \(2S+1 = 3\)).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, PSI4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables (\(R\) and \(A\)), whose values are given; at the end of the Z-matrix specification.; #! Sample UHF/6-31G** CH2 computation. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/tutorial-1.html:4677,energy,energy,4677,psi4manual/1.4.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/tutorial-1.html,9,['energy'],['energy']
Energy Efficiency,"ground state to root n. DFT; functional labeled if canonical. TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state, which is in irrep h, to root n within irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 (h) -> ROOT n (i) RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state, which is in irrep h, to root n, which is in irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT n RIGHT EIGENVECTOR BETA - h TRANSITION¶; The right alpha and beta spin eigenvectors of the named method; from ground state to root n, and the transition is of irrep h. DFT; functional labeled if canonical. THERMAL ENERGY¶; Total thermal energy E [E_h] at given temperature. THERMAL ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the thermal energy at given temperature. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [E_h] to the total SCF energy.; Quantity \(E_{2e^-}\) in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [E_h] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{unCP}}}\]. WIBERG LOWDIN INDICES¶; Property of Wiberg bond indices using orthogonal Löwdin orbitals, (nat, nat). ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. ZERO K ENTHALPY¶; Total electronic and zero-point energy [E_h] at 0 [K]. ZPVE¶; Vibrational zero-point energy [E_h] at 0 [K]. 2-BODY PAIRWISE DISPERSION CORRECTION ANALYSIS¶; The interatomic contributions to the dispersion correction [E_h].; Sums to the dispersion energy. «; hide menu. menu; sidebar; »; . Navigation.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:63325,energy,energy,63325,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency,"group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monome",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:4249,energy,energy,4249,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,4,['energy'],['energy']
Energy Efficiency,"groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. psimrcc-sp1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cc13; UHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. mrcc1; CCSDT cc-pVDZ energy for the H2O molecule using MRCC. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. mints2; A test of the basis specificatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:5248,energy,energy,5248,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"gs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:96301,energy,energypiece,96301,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energypiece']
Energy Efficiency,"gs). psi4.clean(); psi4.set_global_option('DF_INTS_IO', 'LOAD'). # All monomers with ghosts; monomers = extract_clusters(molecule, True, 1); e_monomer_full = []. cluster_n = 0; for cluster in monomers:; activate(cluster); psi4.print_out(""\n""); p4util.banner((""CP Computation: Monomer %d.\n Full Basis Set."" % (cluster_n + 1))); psi4.print_out(""\n""); e_monomer_full.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_full.append(energy(name,**kwargs)); cluster_n = cluster_n + 1; psi4.clean(). psi4.set_global_option('DF_INTS_IO', 'NONE'); if (check_bsse):; # All monomers without ghosts; monomers = extract_clusters(molecule, False, 1); e_monomer_bsse = []. cluster_n = 0; for cluster in monomers:; activate(cluster); psi4.print_out(""\n""); #cluster.print_to_output(); p4util.banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); psi4.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_bsse.append(energy(name,**kwargs)); cluster_n = cluster_n + 1. psi4.set_global_option('DF_INTS_IO', df_ints_io); psioh.set_specific_retention(97, False). activate(molecule). if (check_bsse == False):; cp_table = p4util.Table(rows=[""System:""], cols=[""Energy (full):""]); cp_table[""Complex""] = [e_dimer]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n]]. e_full = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; cp_table[""Interaction""] = [e_full]. psi4.set_variable('CP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). else:; cp_table = Table(rows=[""System:""], cols=[""Energy (full):"", ""Energy (monomer):"", ""BSSE:""]); cp_table[""Complex""] = [e_dimer, 0.0, 0.0]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for clu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:21387,energy,energy,21387,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"gs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY', ; 'mp4corl': 'MP4(SDTQ) CORRELATION ENERGY'} ; VARH['omp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'omp2corl': 'OMP2 CORRELATION ENERGY'}; VARH['omp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY',; 'omp3corl': 'OMP3 CORRELATION ENERGY'}; VARH['ocepa'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ocepacorl': 'OCEPA(0) CORRELATION ENERGY'}; VARH['cepa0'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cepa0corl': 'CEPA(0) COR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:61166,ENERGY,ENERGY,61166,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"gs):; p4out.write('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory); p4out.close(); psi4.reopen_outfile(). psi4.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); psi4.print_variables(); if c4grad:; psi4.get_gradient().print_out(). psi4.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); psi4.print_variables(); if c4grad:; psi4.get_gradient().print_out(). # Quit if Cfour threw error; if psi4.get_variable('CFOUR ERROR CODE'):; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). [docs]def cfour_list():; """"""Form list of Cfour :py:func:`~driver.energy` arguments.""""""; return qcdb.cfour.cfour_list(). [docs]def cfour_gradient_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_gradient_list(). [docs]def cfour_psivar_list():; """"""Form dictionary of :ref:`PSI Variables <apdx:cfour_psivar>` set by Cfour methods.""""""; return qcdb.cfour.cfour_psivar_list(). [docs]def write_zmat(name, dertype):; """"""Returns string with contents of Cfour ZMAT file as gathered from; active molecule, current keyword settings, and cfour {...} block. """"""; # Handle memory; mem = int(0.000001 * psi4.get_memory()); if mem == 256:; memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; molecule = psi4.get_active_molecule(); if molecule.name() == 'blank_molecule_psi4_yo':; molcmd, molkw = '', {}; bascmd, baskw = '', {}; psi4.set_local_option('CFOUR', 'TRANSLATE_PSI4', False); else:; molecule.update_geometry(); #print(molecule.create_psi4_string_from_molecule()); q",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:13432,energy,energy,13432,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html,1,['energy'],['energy']
Energy Efficiency,gs:; db_symm = kwargs['symm']. symmetry_override = 0; if input.no.match(str(db_symm)):; symmetry_override = 1; elif input.yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; #db_mode = 'continuous'; #if(kwargs.has_key('mode')):; # db_mode = kwargs['mode']; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if input.yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif input.no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if input.yes.match(str(db_rlxd)):; if input.yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif input.no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:32634,energy,energy,32634,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"gth gauge, computed at (x) wavelength, (x) rounded to nearest integer. CCD TOTAL ENERGY¶. CCD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the coupled-cluster doubles level of theory. CC ALPHA-ALPHA PAIR ENERGIES¶. CCSD ALPHA-ALPHA PAIR ENERGIES¶. CC2 ALPHA-ALPHA PAIR ENERGIES¶. CC3 ALPHA-ALPHA PAIR ENERGIES¶. MP2 ALPHA-ALPHA PAIR ENERGIES¶; Restricted-reference same-spin pair energies for coupled-cluster theories.; Size number of active doubly occupied orbitals, square. CC ALPHA-BETA PAIR ENERGIES¶. CCSD ALPHA-BETA PAIR ENERGIES¶. CC2 ALPHA-BETA PAIR ENERGIES¶. CC3 ALPHA-BETA PAIR ENERGIES¶. MP2 ALPHA-BETA PAIR ENERGIES¶; Restricted-reference opposite-spin (alpha first) pair energies for coupled-cluster; theories. Size number of active doubly occupied orbitals, square. CC SINGLET PAIR ENERGIES¶. CCSD SINGLET PAIR ENERGIES¶. CC2 SINGLET PAIR ENERGIES¶. CC3 SINGLET PAIR ENERGIES¶. MP2 SINGLET PAIR ENERGIES¶; Restricted-reference singlet-adapted pair energies for coupled-cluster theories.; Size number of active doubly occupied orbitals, square. CC TRIPLET PAIR ENERGIES¶. CCSD TRIPLET PAIR ENERGIES¶. CC2 TRIPLET PAIR ENERGIES¶. CC3 TRIPLET PAIR ENERGIES¶. MP2 TRIPLET PAIR ENERGIES¶; Restricted-reference triplet-adapted pair energies for coupled-cluster theories.; Size number of active doubly occupied orbitals, square. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the requested full coupled-cluster (CCSD, CCSDT, up to CCn); level of theory. CCSD(T) TOTAL ENERGY¶. CCSD(T) CORRELATION ENERGY¶. CCSD(AT) TOTAL ENERGY¶. CCSD(AT) CORRELATION ENERGY¶. A-CCSD(T) TOTAL ENERGY¶. A-CCSD(T) CORRELATION ENERGY¶. CCSDT(Q) TOTAL ENERGY¶. CCSDT(Q) CORRELATION ENERGY¶. CC(n-1)(n) TOTAL ENERGY¶. CC(n-1)(n) CORRELATION E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:17788,adapt,adapted,17788,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['adapt'],['adapted']
Energy Efficiency,"gth, omega = (589 355 nm). omp2_5-1; OMP2 cc-pVDZ energy for the H2O molecule. fci-dipole; 6-31G H2O Test FCI Energy Point. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. fnocc3; Test FNO-QCISD(T) computation. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. mints3; Test individual integral objects for correctness. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to us",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:14235,energy,energy,14235,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"gy (full):""]); cp_table[""Complex""] = [e_dimer]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n]]. e_full = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; cp_table[""Interaction""] = [e_full]. psi4.set_variable('CP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). else:; cp_table = Table(rows=[""System:""], cols=[""Energy (full):"", ""Energy (monomer):"", ""BSSE:""]); cp_table[""Complex""] = [e_dimer, 0.0, 0.0]; for cluster_n in range(0, len(monomers)):; key = ""Monomer %d"" % (cluster_n + 1); cp_table[key] = [e_monomer_full[cluster_n], e_monomer_bsse[cluster_n], \; e_monomer_full[cluster_n] - e_monomer_bsse[cluster_n]]. e_full = e_dimer; e_bsse = e_dimer; for cluster_n in range(0, len(monomers)):; e_full = e_full - e_monomer_full[cluster_n]; e_bsse = e_bsse - e_monomer_bsse[cluster_n]; cp_table[""Totals:""] = [e_full, e_bsse, e_full - e_bsse]. psi4.set_variable('UNCP-CORRECTED 2-BODY INTERACTION ENERGY', e_full). psi4.print_out(""\n""); p4util.banner(""CP Computation: Results.""); psi4.print_out(""\n""). p4util.banner(""Hartree"", 2); psi4.print_out(""\n""). psi4.print_out(str(cp_table)). psi4.print_out(""\n""); p4util.banner(""kcal*mol^-1"", 2); psi4.print_out(""\n""). cp_table.scale(). psi4.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##; #################. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_name",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:22645,ENERGY,ENERGY,22645,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"gy [H] and correlation energy component [H]; for the density-fitted MP2 level of theory. DFT FUNCTIONAL ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eq. (2). DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional; of the requested DFT method, without any dispersion correction,; the first four terms in Eq. (2).; When the requested method includes a dispersion correction, this; quantity is in Eq. (1).; Otherwise, quantity equal to DFT TOTAL ENERGY; and SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (2).; When the method includes a dispersion correction, this quantity; is in Eq. (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (1) and (2). (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html:6560,energy,energy,6560,psi4manual/4.0b2/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency,"gy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'oldmp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY',; 'mp3corl': 'MP3 CORRELATION E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:63702,energy,energy,63702,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,4,['energy'],['energy']
Energy Efficiency,"gy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. props4; Electrostatic potential and electric field evaluated on a grid around water. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. mp2-1; All-electron MP2 6-31G** geometry optimization of water. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. dft2; DFT Functional Test. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. aediis-1; ADIIS test case, from 10.1063/1.3304922. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. fsapt-ext-abc; FSAPT with external charge on trimer. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. dft-reference; MP2 with a PBE0 reference computation. dft1; DFT Functional Test all values update for new BraggSlater radii. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. ddd-deriv; Sample HF/cc-pVDZ H2O computation all derivatives. nbody-multi-level-2; many-body different levels of theory on each body of helium tetramer. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. td",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:26261,energy,energy,26261,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"gy for the BH molecule, with Cartesian input. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. scf-auto-cholesky; Cholesky filter a complete basis. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cisd-sp-2; 6-31G** H2O Test CISD E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:4882,energy,energy,4882,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"gy from results of a DETCI; MP3 calculation. .. math:: E_{total}^{\text{MP2.5}} = E_{total,\; \text{SCF}} \; + E_{corl,\; \text{MP2}} + E_{corl, \; \text{MP3}}. :PSI variables: . .. hlist:: ; :columns: 1 ; ; * :psivar:`MP2.5 TOTAL ENERGY <MP2.5TOTALENERGY>` ; * :psivar:`MP2.5 CORRELATION ENERGY <MP2.5CORRELATIONENERGY>` . >>> energy('mp2.5'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables). return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html:3233,ENERGY,ENERGY,3233,psi4manual/4.0b2/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"gy from results of a DETCI; MP3 calculation. .. math:: E_{total}^{\text{MP2.5}} = E_{total,\; \text{SCF}} \; + E_{corl,\; \text{MP2}} + E_{corl, \; \text{MP3}}. :PSI variables: . .. hlist:: ; :columns: 1 ; ; * :psivar:`MP2.5 TOTAL ENERGY <MP2.5TOTALENERGY>` ; * :psivar:`MP2.5 CORRELATION ENERGY <MP2.5CORRELATIONENERGY>` . >>> energy('mp2.5'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(banners). tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables). return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html:3230,ENERGY,ENERGY,3230,psi4manual/4.0b3/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"gy is; employed in computing interaction energies. Option available; (See Available Databases) only for databases of bimolecular complexes; with non-frozen monomers, e.g., HBC6. symm (boolean) – \(\Rightarrow\) 'on' \(\Leftarrow\) || 'off'; Indicates whether the native symmetry of the database reagents is; employed ('on') or whether it is forced to \(C_1\) symmetry; ('off'). Some computational methods (e.g., SAPT) require no; symmetry, and this will be set by database(). zpe (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether zero-point-energy corrections are appended to; single-point energy values. Option valid only for certain; thermochemical databases. Disabled until Hessians ready. benchmark (str) – \(\Rightarrow\) 'default' \(\Leftarrow\) || 'S22A' || etc.; Indicates whether a non-default set of reference energies, if; available (See Available Databases), are employed for the; calculation of error statistics. tabulate (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['scf total energy', 'natom'] || etc.; Indicates whether to form tables of variables other than the; primary requested energy. Available for any PSI variable. subset (Union[str, List[str]]) – Indicates a subset of the full database to run. This is a very; flexible option and can be used in three distinct ways, outlined; below. Note that two take a string and the last takes an array.; See Available Databases for available values. 'small' || 'large' || 'equilibrium'Calls predefined subsets of the requested database, either; 'small', a few of the smallest database members,; 'large', the largest of the database members, or; 'equilibrium', the equilibrium geometries for a database; composed of dissociation curves. 'BzBz_S' || 'FaOOFaON' || 'ArNe' || 'HB' || etc.For databases composed of dissociation curves, or otherwise; divided into subsets, individual curves and subsets can be; called by name. Consult the database python files for available; molecular systems (case insensitive",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/db-1.html:4059,energy,energy,4059,psi4manual/1.4.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/db-1.html,9,['energy'],['energy']
Energy Efficiency,"gy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cbs-xtpl-energy-conv; Extrapolated water energies - conventional integrals version. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. sapt-exch-ind30-inf; SAPT2+3 with S^inf exch-ind30 Geometries taken from the S66x10 database, the shortest-range point (R = 0.7 R_e). dlpnomp2-2; comparison of DF-MP2 and DLPNO-MP2 with a CBS extrapolation. stability3; Test LDA stability analysis against QChem. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. options1; check all variety of options parsing. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cc13b; Tests RHF CCSD(T)gradients. sapt-sf1; Tests the P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:41654,energy,energy,41654,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"gy with ROHF initial guess for the NO radical. scf-level-shift-rks; SCF level shift on an RKS computation. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cbs-parser; mtd/basis syntax examples. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. dfremp-1; density fitted REMP/cc-pVDZ energies for the CO2 molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. tu2-ch2-energy; Sample UHF/6-3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:9333,energy,energy,9333,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"gy'], GRAND_NEED[8]['d_scheme'].__name__); # if do_delta5:; # tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (GRAND_NEED[10]['d_stage'], GRAND_NEED[10]['d_wfn'] + ' - ' + GRAND_NEED[11]['d_wfn'],; # '/', GRAND_NEED[10]['d_basis'], '', GRAND_NEED[10]['d_energy'] - GRAND_NEED[11]['d_energy'], GRAND_NEED[10]['d_scheme'].__name__); tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. psi4.print_out(tables). psi4.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS TOTAL ENERGY', finalenergy); psi4.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT ENERGY', finalenergy); psi4.set_variable('CBS NUMBER', Njobs). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; wfn = psi4.new_wavefunction(molecule, BSTR[-1]). optstash.restore(). if ptype == 'energy':; finalquantity = finalenergy; elif ptype == 'gradient':; finalquantity = finalgradient; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; psi4.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif ptype == 'hessian':; finalquantity = finalhessian; wfn.set_hessian(finalquantity); if finalquantity.rows(0) < 20:; psi4.print_out('CURRENT HESSIAN'); finalquantity.print_out(). if return_wfn:; return (finalquantity, wfn); else:; return finalquantity. _lmh_labels = {1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']}. def _expand_scheme_orders(scheme, basisname, basiszeta, wfnname, natom):; """"""Check that the length of *basiszeta* array matches the implied degree of; extrapolation in *scheme* name. Return a dictionary of same length as; basiszeta, with *basisname* and *basiszet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:53879,energy,energy,53879,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"gy('scf'); C = 1; if (E == 0.0):; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = psi4.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = psi4.wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge); mol.set_multiplicity(mult). # Determine HOMO; ref = psi4.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if (E_a >= E_b):; HOMO = Na; else:; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(Nintegral-1, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; psi4.print_out('\n ==> Fractional Occupation Nuke Results <==\n\n'); psi4.print_out('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; psi4.print_out('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. psi4.print_out('\n'); psi4.print_out('\t%6s %6s %6s %6s %6s %6s\n' %('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; psi4.print_out(line). psi4.print_out('\n\t""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); psi4.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write('\t%-11s %-24s %-24s %11s\n' %('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write('\t%11.3E %24.16E %24.16E %11d\n' % (Ns[k], energies[k], potentials[k], convs[k])); fh.clos",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/frac.html:10294,charge,charge,10294,psi4manual/4.0b5/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/frac.html,4,['charge'],['charge']
Energy Efficiency,"gy('scf/6-31g**'). [4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options() API, to the input. This function takes a Python dictionary as its argument, which is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization com",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:6733,energy,energy,6733,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,11,['energy'],['energy']
Energy Efficiency,"gy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). adc1; ADC/6-31G** on H2O. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, at the UHF an ROHF levels of theory. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified usin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:16381,energy,energy,16381,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"gy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. cc10; ROHF-CCSD cc-pVDZ energy for the state of the CN radical. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:6882,energy,energy,6882,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"gy. cbs-xtpl-dict; Extrapolated water energies. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mode. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation).",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:22430,energy,energy,22430,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"gy; Extrapolated water energies. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. pywrap-align; apply linear fragmentation algorithm to a water cluster. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. cc13b; Tests RHF CCSD(T)gradients. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. dcft-grad1; DCFT DC-06 gradient for the O2 molecule with cc-pVDZ basis set. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:15084,energy,energy,15084,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"h * constants.c / constants.kb; vib_temperature_K = frequency_cm_1.real * uconv_K; vibinfo['theta_vib'] = Datum('char temp', 'K', vib_temperature_K). return vibinfo, '\n'.join(text). def _br(string):; return '[' + string + ']'. def _format_omega(omega, decimals):; """"""Return complex frequencies in `omega` into strings showing only real or imag (""i""-labeled); to `decimals` precision. """"""; freqs = []; for fr in omega:; if fr.imag > fr.real:; freqs.append(""""""{:.{prec}f}i"""""".format(fr.imag, prec=decimals)); else:; freqs.append(""""""{:.{prec}f}"""""".format(fr.real, prec=decimals)); return np.array(freqs). def print_vibs(vibinfo: Dict[str, Datum], atom_lbl: List[str] = None, *, normco: str = 'x', shortlong: bool = True, groupby: int = None, prec: int = 4, ncprec: int = None) -> str:; """"""Pretty printer for vibrational analysis. Parameters; ----------; vibinfo; Results of a Hessian solution.; atom_lbl; Atomic symbols for printing. If None, integers used.; normco; {'q', 'w', 'x'}; Which normal coordinate definition to print (reduced mass, etc. unaffected by this parameter). Must be. * `q` [a0 u^1/2], the mass-weighted normalized eigenvectors of the Hessian,; * `w` [a0], the un-mass-weighted (Cartesian) of q, or; * `x` [a0], the normalized w.; shortlong; Whether normal coordinates should be in (nat, 3) `True` or (nat * 3, 1) `False` format.; groupby; How many normal coordinates per row. Defaults to 3/6 for shortlong=T/F. Value of `-1` uses one row.; prec; Number of decimal places for frequencies, reduced masses, etc.; ncprec; Number of decimal places for normal coordinates. Defaults to 2 for shortlong=short and 4 for shortlong=long. Returns; -------; str; String suitable for printing. """""". def grouper(iterable, n, fillvalue=None):; ""Collect data into fixed-length chunks or blocks""; # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx""; args = [iter(iterable)] * n; return itertools.zip_longest(*args, fillvalue=fillvalue). if normco not in ['q', 'w', 'x']:; raise ValidationError(""""""Requeste",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/qcdb/vib.html:25190,reduce,reduced,25190,psi4manual/1.9.x/_modules/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/qcdb/vib.html,4,['reduce'],['reduced']
Energy Efficiency,"h CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect PCMSolver and activate dependent code. Previous bullet had details. To build PSI4 from source and use; pcmsolver from conda without thinking, consult sec:condapsi4dev. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option |globals__pcm_scf_type| with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging. Note; At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104].; All ERI algorithms (PK, OUT_OF_CORE, DIRECT, DF, CD) are supported. Warning; The PCMSolver library cannot exploit molecular point group symmetry. Warning; ROHF with PCM is known not to work. See issue #999 on GitHub.; For the adventurous, a fix is available in pull request #953 on GitHub. Warning; Analytic gradients and Hessians are not available with PCM. Finite differences will be used; regardless of the dertype passed to the optimize function.; See pcmsolver/opt-fd for a sample input. The PCM model and molecular cavity are specified in a pcm section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of PSI4 and is fully documented; here; A typical input for a Hartree–Fock calculation with PCM would look like the following:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/pcmsolver-1.html:2113,energy,energy,2113,psi4manual/1.3.2/pcmsolver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/pcmsolver-1.html,2,['energy'],['energy']
Energy Efficiency,"h Df coefficients. addCharge(self, Z, x, y, z); Add a charge Z at (x,y,z). appendCharges(self, arg0, float, float, float]]); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self, arg0, arg1); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential, arg1: bool) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. print_out(self: ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.externalpotential.html:1424,charge,charge,1424,psi4manual/1.4.0/api/psi4.core.externalpotential.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.externalpotential.html,1,['charge'],['charge']
Energy Efficiency,"h MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; psi4.core.set_global_option_python('EXTERN', None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Arguments:; mdi_arg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:12080,charge,charges,12080,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,4,['charge'],['charges']
Energy Efficiency,"h MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; self.kwargs.pop(""external_potentials"", None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Arguments:; mdi_arguments",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html:11954,charge,charges,11954,psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,2,['charge'],['charges']
Energy Efficiency,"h MDI. Arguments:; charge: New charge of the system. If None, receive through MDI.; """"""; if charge is None:; charge = MDI_Recv(1, MDI_DOUBLE, self.comm); self.molecule.set_molecular_charge(int(round(charge))). # Respond to the <ELEC_MULT command; def send_multiplicity(self):; """""" Send the electronic multiplicity through MDI. :returns: *multiplicity* Multiplicity of the system; """"""; multiplicity = self.molecule.multiplicity(); MDI_Send(multiplicity, 1, MDI_INT, self.comm); return multiplicity. # Respond to the >ELEC_MULT command; def recv_multiplicity(self, multiplicity=None):; """""" Receive the electronic multiplicity through MDI. Arguments:; multiplicity: New multiplicity of the system. If None, receive through MDI.; """"""; if multiplicity is None:; multiplicity = MDI_Recv(1, MDI_INT, self.comm); self.molecule.set_multiplicity(multiplicity). # Respond to the EXIT command; def exit(self):; """""" Stop listening for MDI commands; """"""; self.stop_listening = True. # If a lattice of point charges was set, unset it now; if self.set_lattice:; self.kwargs.pop(""external_potentials"", None); . # Enter server mode, listening for commands from the driver; def listen_for_commands(self):; """""" Receive commands through MDI and respond to them as defined by the MDI Standard; """""". while not self.stop_listening:; if self.world_rank == 0:; command = MDI_Recv_Command(self.comm); else:; command = None; if use_mpi4py:; command = self.mpi_world.bcast(command, root=0); if self.world_rank == 0:; psi4.core.print_out('\nMDI command received: ' + str(command) + ' \n'). # Search for this command in self.commands; found_command = False; for supported_command in self.commands:; if not found_command and command == supported_command:; # Run the function corresponding to this command; self.commands[supported_command](); found_command = True; if not found_command:; raise Exception('Unrecognized command: ' + str(command)). def mdi_init(mdi_arguments):; """""" Initialize the MDI Library. Parameters; ----------; m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html:12254,charge,charges,12254,psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html,8,['charge'],['charges']
Energy Efficiency,"h Z-matrix input. dft-dsd; DSD S22 Ammonia test. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C parts. SCF will fail or crash (nans) without screening!. casscf-fzc-sp; CASSCF/6-31G** energy point. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). pywrap-align-chiral; testing aligner on enantiomers based on Table 1 of 10.1021/ci100219f aka J Chem Inf Model 2010 50(12) 2129-2140. cisd-sp; 6-31G** H2O Test CISD Energy Point. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. adc1; ADC(2)/6-31G** on H2O using builtin ADC module. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. dft-grad-meta; meta-GGA gradients of water and ssh molecules reference gradients updated due to new BraggSlater radii. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. fci-h2o-2; 6-31G H2O Test FCI Energy Point. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:9678,energy,energy,9678,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"h a variety of damping functions/parameters. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. opt-multi-frozen-dimer-c2h; Frozen-fragment opt of C2h methane dimer with user-combined reference points. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. mp2-h; check that methods can act on single atom. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. fci-dipole; 6-31G H2O Test FCI Energy Point. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. rasci-h2o; RASCI/6-31G** H2O Energy Point. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. nbody-he-cluster;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:19082,energy,energy,19082,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"h code computes dispersion. See above for allowed; values. Formerly (pre Nov 2022) only relevant for -D2, which can be computed by; libdisp or dftd3. Now (post Nov 2022) also relevant for -D3 variants,; which can be computed by dftd3 executable or simple-dftd3 Python module.; gcp_engine (str) – Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp (bool) – Whether to request atomic pairwise analysis. Methods Summary. compute_energy(molecule[, wfn]); Compute dispersion energy based on engine, dispersion level, and parameters in self. compute_gradient(molecule[, wfn]); Compute dispersion gradient based on engine, dispersion level, and parameters in self. compute_hessian(molecule[, wfn]); Compute dispersion Hessian based on engine, dispersion level, and parameters in self. print_out(); Format dispersion parameters of self for output file. Methods Documentation. compute_energy(molecule, wfn=None)[source]¶; Compute dispersion energy based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule) – System for which to compute empirical dispersion correction.; wfn (Wavefunction) – Location to set QCVariables. Returns:; Dispersion energy [Eh]. Return type:; float. Notes. DISPERSION CORRECTION ENERGYDisp always set. Overridden in SCF finalization, but that only changes for “-3C” methods. fctl DISPERSION CORRECTION ENERGYSet if fctldash nonempty. compute_gradient(molecule, wfn=None)[source]¶; Compute dispersion gradient based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule) – System for which to compute empirical dispersion correction.; wfn (Wavefunction) – Location to set QCVariables. Returns:; (nat, 3) dispersion gradient [Eh/a0]. Return type:; Matrix. compute_hessian(molecule, wfn=None)[source]¶; Compute dispersion Hessian based on engine, dispersion level, and parameters in self.; Uses finite difference, as no dispersion engine has analytic sec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html:4215,energy,energy,4215,psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html,2,['energy'],['energy']
Energy Efficiency,"h files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously. Elementary Restart¶; The PSI4 intermediate files use the following naming scheme; psi.PID.name.filenumber. where by default, PID is the process number, name the name of the molecule,; and filenumber is listed in content.; For those modules providing restart capabilities, the previous file can; be provided through the``restart_file`` option; energy('scf',restart_file='./psi.PID.name.filenumber'). Only the filenumber is necessary for the driver to appropriately rename the; file and copy it to the scratch directory where PSI4 will expect it.; The restart capabilities of a specific method (if any) are found in that method’s documentation.; To provide multiple files, pass them as arguments of a Python list; energy('scf',restart_file=['./file1.filenumber','./file2.filenumber']). Note that the restart_file options is only available for energy procedures as of now.; Executing PSI4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; psi4 -m. The mechanism for restarting HF/DFT calculations is described in details here. Saving the Wavefunction¶; A core object of PSI4 is the Wavefunction (short wfn) object; energy, wfn = energy('scf',return_wfn=True). This C++/Python object (psi4.core.Wavefunction) contains orbital; data, basis set information, result variables and more.; It can be saved either to a numpy file or converted to a python dictionary; # write the wavefunction to file; wfn.to_file('my_wfn'). # alternatively store the dict representation of the wavefunction in memory; wfn_dict = wfn.to_file(). In either form, its attributes can be set and edited.; This is an expert-level feature, though.; In general, let PSI4 create the Wavef",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:7976,energy,energy,7976,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,9,['energy'],['energy']
Energy Efficiency,"h is activated by its; stage_wfn keyword, or as a field in the `cbs_metadata` list, and is only; allowed if all preceding stages are active. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (str) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (str) – \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as ‘scf’ is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str) – \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cbs-1.html:3558,energy,energy,3558,psi4manual/1.3.2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"h it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object()",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:59311,energy,energy,59311,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"h job in task list. -----------------------------------; CompositeComputer.get_psi_results(); -----------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * get_results() for each job in task list; * arrange atomicresult data into e/d/g/h fields in compute_list and copy them into cbs tables. _assemble_cbs_components(); --------------------------; * fill in results from TROVE/trove into GRAND_NEED/cbsrec. _contract_scheme_orders(); -------------------------; * prepare arguments for xtpl fns based on desired E/D/G/H quantity. * form extrapolated values for all available E/D/G/H quantities; * return structure of extrapolated values and filled-in GRAND_NEED/cbsrec. _summary_table(); ----------------; * build string table of cbs results. * form cbs qcvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import copy; import logging; import re; import sys; from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_util, p4util, qcdb; from .constants import pp; from .driver_cbs_helper import ( # lgtm[py/unused-import]; composite_procedures,; register_composite_function,; register_xtpl_function,; xtpl_procedures,; ); from .driver_util import UpgradeHelper; from .p4util.exceptions import ValidationError; from .procrouting.interface_cfour import cfour_psivar_list; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html:4589,energy,energy,4589,psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html,4,['energy'],['energy']
Energy Efficiency,"h job in task list. -----------------------------------; CompositeComputer.get_psi_results(); -----------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * get_results() for each job in task list; * arrange atomicresult data into e/d/g/h fields in compute_list and copy them into cbs tables. _assemble_cbs_components(); --------------------------; * fill in results from TROVE/trove into GRAND_NEED/cbsrec. _contract_scheme_orders(); -------------------------; * prepare arguments for xtpl fns based on desired E/D/G/H quantity. * form extrapolated values for all available E/D/G/H quantities; * return structure of extrapolated values and filled-in GRAND_NEED/cbsrec. _summary_table(); ----------------; * build string table of cbs results. * form cbs qcvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import math; import re; import sys; import copy; import pprint; from typing import Any, Callable, Dict, List, Optional, Tuple, Union, TYPE_CHECKING; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; from pydantic import Field, validator; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core; from psi4.driver import driver_util, p4util, pp; from psi4.driver import qcdb; from psi4.driver.driver_cbs_helper import composite_procedures, register_composite_function, register_xtpl_function, xtpl_procedures # lgtm[py/unused-import]; from psi4.driver.driver_util import UpgradeHelper; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list; from psi4.driver.task_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:4587,energy,energy,4587,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"h job in task list. -----------------------------------; CompositeComputer.get_psi_results(); -----------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * get_results() for each job in task list; * arrange atomicresult data into e/d/g/h fields in compute_list and copy them into cbs tables. _assemble_cbs_components(); --------------------------; * fill in results from TROVE/trove into GRAND_NEED/cbsrec. _contract_scheme_orders(); -------------------------; * prepare arguments for xtpl fns based on desired E/D/G/H quantity. * form extrapolated values for all available E/D/G/H quantities; * return structure of extrapolated values and filled-in GRAND_NEED/cbsrec. _summary_table(); ----------------; * build string table of cbs results. * form cbs qcvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import math; import re; import sys; import copy; import pprint; from typing import Any, Callable, Dict, List, Optional, Tuple, Union, TYPE_CHECKING; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core; from psi4.driver import driver_util, p4util, pp; from psi4.driver import qcdb; from psi4.driver.driver_cbs_helper import composite_procedures, register_composite_function, register_xtpl_function, xtpl_procedures # lgtm[py/unused-import]; from psi4.driver.driver_util import UpgradeHelper; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.procrou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:4589,energy,energy,4589,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"h job in task list. -----------------------------------; CompositeComputer.get_psi_results(); -----------------------------------. Computer.get_results(); ----------------------. Computer._prepare_results(); ---------------------------; * get_results() for each job in task list; * arrange atomicresult data into e/d/g/h fields in compute_list and copy them into cbs tables. _assemble_cbs_components(); --------------------------; * fill in results from TROVE/trove into GRAND_NEED/cbsrec. _contract_scheme_orders(); -------------------------; * prepare arguments for xtpl fns based on desired E/D/G/H quantity. * form extrapolated values for all available E/D/G/H quantities; * return structure of extrapolated values and filled-in GRAND_NEED/cbsrec. _summary_table(); ----------------; * build string table of cbs results. * form cbs qcvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import math; import re; import sys; import copy; import pprint; from typing import Any, Callable, Dict, List, Optional, Tuple, Union; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; from pydantic import Field, validator; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core; from psi4.driver import driver_util, p4util, pp; from psi4.driver import qcdb; from psi4.driver.driver_cbs_helper import composite_procedures, register_composite_function, register_xtpl_function, xtpl_procedures # lgtm[py/unused-import]; from psi4.driver.driver_util import UpgradeHelper; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list; from psi4.driver.task_base import Ato",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:4587,energy,energy,4587,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"h one; QC_MODULE value OCC. Without set qc_module occ,; these methods may default to implementations in other modules based on efficiency considerations. Orbital-optimized theoretical methods accessible through OCC/DFOCC¶. name; calls method; OO. omp2; orbital-optimized second-order MP perturbation theory; E/G. omp2.5; orbital-optimized average of MP2 and MP3; E/G. omp3; orbital-optimized third-order MP perturbation theory; E/G. oremp2; orbital-optimized second-order REMP hybrid PT; E/G. olccd; orbital-optimized linear coupled cluster doubles; E/G. Detailed orbital-optimized capabilities of the OCC module. “✓” runs analytically. Single underline “✓̲” is default module when QC_MODULE unspecified. Double underline “✓̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified.¶. ◻; ◻; name ↓ →; ◻; ◻. ◻; REFERENCE →; ◻; type[1] ↓ →; FREEZE_CORE[2]→. QC_MODULE=OCC Capabilities. Restricted (RHF); Unrestricted (UHF); Restricted Open (ROHF). energy(); gradient()[3]; energy(); gradient()[3]; energy(); gradient()[3]. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F. omp2[4]; MP2_TYPE; ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. omp2.5[4]; MP_TYPE; ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. omp3[4]; MP_TYPE; ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. oremp2[4]; CC_TYPE; ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. olccd[4]; CC_TYPE; ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. [1]; Algorithm type selection keyword below. Values to the right: conventional CV, density-fitted DF, and Cholesky-decomposed CD. [2]; Active orbital values to the right: all-electron A and frozen-core F. [",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/occ.html:11059,energy,energy,11059,psi4manual/1.7.x/occ.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/occ.html,12,['energy'],['energy']
Energy Efficiency,"h open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'); }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'); }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'); }. return [scf, corl, delta]. [docs]def allen_focal_point(**kwargs) -> CBSMetadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/aliases.html:3277,energy,energy,3277,psi4manual/1.6.x/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/aliases.html,8,['energy'],['energy']
Energy Efficiency,"h the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. cbs-parser; mtd/basis syntax examples. options1; check all variety of options parsing. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. dfccsdat2; DF-A-CCSD(T) cc-pVDZ energy for the NH molecule. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:15593,energy,energy,15593,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"h the computation is run,; or the excited state method are all likely to scramble root numberings. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DFMP2. D 2. D 2. D. D. FNOCC; Y. OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y. D; D. mp3; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; Y. OCC; D; D; D; D; D; D. D; D. D; D. mp2.5; MP_TYPE. CCENERGY. DETCI. DFMP2. FNOCC. OCC; D; D; D; D; D; D. D; D. D; D. mp4; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; D. OCC. lccd; CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC; Y; D; D; D; D; D. D; D. D; D. lccsd, cepa(0); CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC. ccsd; CC_TYPE. CCENERGY; D. D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. D. ccsd(t); CC_TYPE. CCENERGY; D. D. D. D. D. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/notes_c.html:3186,energy,energy,3186,psi4manual/1.6.x/notes_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html,1,['energy'],['energy']
Energy Efficiency,"h the same algorithms. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. fci-h2o; 6-31G H2O Test FCI Energy Point. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. psimrcc-pt2; Mk-MRPT2 single point. F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. mp2_5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. fd-freq-gradient-large; SCF DZ finite difference frequencies by energies for C4NH4. dft1-alt; DFT Functional Test. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. psimrcc-fd-freq2; Mk-MRCCSD frequencies. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “sec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:3619,energy,energy,3619,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"h)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:78746,ENERGY,ENERGY,78746,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,7,['ENERGY'],['ENERGY']
Energy Efficiency,"h, Justin M. Turney, and Daniel G. A. Smith; Section author: Robert M. Parrish; Module: Keywords, PSI Variables, LIBFUNCTIONAL, LIBFOCK, LIBSCF_SOLVER; Both density functional theory and Hartree–Fock theory are controlled; through the SCF module, and the SCF Introduction; section is also relevant here. Note; After May 2017 (anytime after the v1.1 release), PSI4; switched from hand- (+Matlab) coded functionals to Libxc. Thus; many DFT results will be slightly different. Functionals more than; slightly different are B97-D, wB97X (note, not wB97X-D), SOGGA,; DFDL, and M05. Theory¶; Generalized Kohn–Sham Density Functional Theory (KS-DFT) [Kohn:1965:A1133] [Parr:1989] is one of the primary; workhorses of modern computational chemistry due to its phenomenal accuracy/cost; ratio.; Pure Kohn–Sham DFT is built on the Hohenberg–Kohn theorems [Hohenberg:1964:136] which states: A) the energy is a universal; functional of the one-particle electronic density and B) there exists a set of; noninteracting quasiparticles with the same density as the true set of; electrons, with the quasiparticle states determined as eigenvectors of an; effective one-body potential encapsulating the true \(N\)-body quantum; effects. The former idea allows the electronic density to be dealt with instead; of the much more complicated wavefunction, while the latter allows for the; treatment of the troublesome kinetic energy term via the implicit one-body; Kohn–Sham orbitals. KS-DFT borrows much of the machinery of Hartree–Fock, as is; evident by looking at the energy expression,. \[\begin{split}E_{\mathrm{KS}}; &= \sum_{i} \langle i | \hat h | i \rangle; + \frac 1 2 \sum_{i,j} [ii|jj] + E_{\mathrm{xc}} [\rho_\alpha, \rho_\beta] \\; &= D_{\mu\nu}^{\mathrm{T}}\left(T_{\mu\nu} +; V_{\mu\nu}\right) + \frac{1}{2} D_{\mu\nu}^{\mathrm{T}}; D_{\lambda\sigma}^{\mathrm{T}} (\mu\nu|\lambda\sigma) + E_{\mathrm{xc}} [\rho_\alpha, \rho_\beta]\end{split}\]; Here, \(T\) is the noninteracting quasiparticle kinetic energy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dft-1.html:1087,energy,energy,1087,psi4manual/1.3.2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dft-1.html,2,['energy'],['energy']
Energy Efficiency,"h-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to DF_BASIS_SAPT. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. D_CONVERGENCE¶. Convergence criterion for residual of the CPHF coefficients in the SAPT \(E_{ind,resp}^{(20)}\) term. Type: conv double; Default: 1e-8. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. E_CONVERGENCE¶. Convergence criterion for energy (change) in the SAPT \(E_{ind,resp}^{(20)}\) term during solution of the CPHF equations. Type: conv double; Default: 1e-10. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE; Default: FALSE. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. MAXITER¶. Maximum number of CPHF iterations. Type: integer; Default: 50. MAX_CCD_DIISVECS¶. Maximum number of vectors used in CCD-DIIS. Type: integer; Default: 10. MIN_CCD_DIISVECS¶. Minimum number of vectors used in CCD-DIIS. Type: integer; Default: 4. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the \(v^4\) block of two-electron integrals in the evaluatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__sapt-1.html:2332,energy,energy,2332,psi4manual/1.1.0/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__sapt-1.html,4,['energy'],['energy']
Energy Efficiency,"h-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to DF_BASIS_SAPT. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. D_CONVERGENCE¶. Convergence criterion for residual of the CPHF coefficients in the SAPT \(E_{ind,resp}^{(20)}\) term. Type: conv double; Default: 1e-8. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. E_CONVERGENCE¶. Convergence criterion for energy (change) in the SAPT \(E_{ind,resp}^{(20)}\) term during solution of the CPHF equations. Type: conv double; Default: 1e-10. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE; Default: FALSE. INTS_TOLERANCE¶. Schwarz screening threshold. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. MAXITER¶. Maximum number of CPHF iterations. Type: integer; Default: 50. MAX_CCD_DIISVECS¶. Maximum number of vectors used in CCD-DIIS. Type: integer; Default: 10. MIN_CCD_DIISVECS¶. Minimum number of vectors used in CCD-DIIS. Type: integer; Default: 4. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the \(v^4\) block of two-electr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__sapt-1.html:2335,energy,energy,2335,psi4manual/1.3.2/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__sapt-1.html,10,['energy'],['energy']
Energy Efficiency,"h; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). fci-h2o; 6-31G H2O Test FCI Energy Point. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. numpy-array-interface; Numpy interface testing. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:16908,energy,energy,16908,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"ha Density Matrix. Da_subset(self, arg0); Returns the requested Alpha Density subset. Db(self); Returns the Beta Density Matrix. Db_subset(self, arg0); Returns the requested Beta Density subset. Fa(self); Returns the Alpha Fock Matrix. Fa_subset(self, arg0); Returns the Alpha Fock Matrix in the requested basis (AO,SO). Fb(self); Returns the Beta Fock Matrix. Fb_subset(self, arg0); Returns the Beta Fock Matrix in the requested basis (AO,SO). H(self); Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. PCM_enabled(self); Whether running a PCM calculation. S(self); Returns the One-electron Overlap Matrix. X(self); Returns the Lagrangian Matrix. alpha_orbital_space(self, arg0, arg1, arg2); docstring. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key). density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:1507,charge,charges,1507,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['charge'],['charges']
Energy Efficiency,"ha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.08184); X.set_parameter('B97_a1', -0.518339); X.set_parameter('B97_a2', 3.42562); X.set_parameter('B97_a3', -2.62901); X.set_parameter('B97_a4', 2.28855). C = build_functional('B_C'); C.set_name('HCTH407_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.589076); C.set_parameter('B97_os_a1', 4.42374); C.set_parameter('B97_os_a2', -19.2218); C.set_parameter('B97_os_a3', 42.5721); C.set_parameter('B97_os_a4', -42.0052). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.18777); C.set_parameter('B97_ss_a1', -2.40292); C.set_parameter('B97_ss_a2', 5.61741); C.set_parameter('B97_ss_a3', -9.17923); C.set_parameter('B97_ss_a4', 6.24798). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_blypd2p4_superfunctional(name, npoints, deriv):. sup = build_blyp_superfunctional(name, npoints, deriv); sup.set_name('BLYP-D2P4'). # => -D2 <= #; sup.set_dispersion(PsiMod.Dispersion.build(*dash_server('blyp', 'd2p4'))). return sup. [docs]def build_blypd2gr_superfunctional(name, npoints, deriv):. sup = build_blyp_superfunctional(name, npoints, deriv); sup.set_name('BLYP-D2GR'). # => -D2 <= #; sup.set_dispersion(PsiMod.Dispersion.build(*dash_server('blyp', 'd2gr'))). return sup. [docs]def build_blypd3zero_superfunctional(name, npoints, deriv):. sup = build_blyp_superfunctional(name, npoints, deriv); sup.set_name('BLYP-D3ZERO'). # => -D3 <= #; sup.set_dispersion(PsiMod.Dispersion.build(*dash_server('blyp', 'd3zero'))). return sup. [docs]def build_blypd3bj_superfunctional(name, npoints, deriv):. sup = build_blyp_superfunctional(name, npoints, deriv); sup.set_name('BLYP-D3BJ'). # => -D3 <= #; sup.set_dispersion(PsiMod.Dispersion.build(*dash_server('blyp', 'd3bj",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/functional.html:43533,allocate,allocate,43533,psi4manual/4.0b4/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency,"ha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.08184); X.set_parameter('B97_a1', -0.518339); X.set_parameter('B97_a2', 3.42562); X.set_parameter('B97_a3', -2.62901); X.set_parameter('B97_a4', 2.28855). C = build_functional('B_C'); C.set_name('HCTH407_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.589076); C.set_parameter('B97_os_a1', 4.42374); C.set_parameter('B97_os_a2', -19.2218); C.set_parameter('B97_os_a3', 42.5721); C.set_parameter('B97_os_a4', -42.0052). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.18777); C.set_parameter('B97_ss_a1', -2.40292); C.set_parameter('B97_ss_a2', 5.61741); C.set_parameter('B97_ss_a3', -9.17923); C.set_parameter('B97_ss_a4', 6.24798). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_blypd2p4_superfunctional(name, npoints, deriv):. sup = build_blyp_superfunctional(name, npoints, deriv); sup.set_name('BLYP-D2P4'). # => -D2 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('blyp', 'd2p4'))). return sup. [docs]def build_blypd2gr_superfunctional(name, npoints, deriv):. sup = build_blyp_superfunctional(name, npoints, deriv); sup.set_name('BLYP-D2GR'). # => -D2 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('blyp', 'd2gr'))). return sup. [docs]def build_blypd3zero_superfunctional(name, npoints, deriv):. sup = build_blyp_superfunctional(name, npoints, deriv); sup.set_name('BLYP-D3ZERO'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('blyp', 'd3zero'))). return sup. [docs]def build_blypd3bj_superfunctional(name, npoints, deriv):. sup = build_blyp_superfunctional(name, npoints, deriv); sup.set_name('BLYP-D3BJ'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('blyp', 'd3bj'))). re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:44259,allocate,allocate,44259,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,3,['allocate'],['allocate']
Energy Efficiency,"ha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.08184); X.set_parameter('B97_a1', -0.518339); X.set_parameter('B97_a2', 3.42562); X.set_parameter('B97_a3', -2.62901); X.set_parameter('B97_a4', 2.28855). C = build_functional('B_C'); C.set_name('HCTH407_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.589076); C.set_parameter('B97_os_a1', 4.42374); C.set_parameter('B97_os_a2', -19.2218); C.set_parameter('B97_os_a3', 42.5721); C.set_parameter('B97_os_a4', -42.0052). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.18777); C.set_parameter('B97_ss_a1', -2.40292); C.set_parameter('B97_ss_a2', 5.61741); C.set_parameter('B97_ss_a3', -9.17923); C.set_parameter('B97_ss_a4', 6.24798). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_blypd_superfunctional(name, npoints, deriv):. sup = build_blyp_superfunctional(name, npoints, deriv); sup.set_name('BLYP-D'). # => -D2 <= #; sup.set_dispersion(PsiMod.Dispersion.build('-D2', 1.20)). return sup. [docs]def build_b3lypchg_superfunctional(name, npoints, deriv):. sup = build_b3lyp_superfunctional(name, npoints, deriv); sup.set_name('B3LYP-CHG'). # => -D2 <= #; sup.set_dispersion(PsiMod.Dispersion.build('-CHG', 1.00)). return sup. [docs]def build_b3lypd_superfunctional(name, npoints, deriv):. sup = build_b3lyp_superfunctional(name, npoints, deriv); sup.set_name('B3LYP-D'). # => -D2 <= #; sup.set_dispersion(PsiMod.Dispersion.build('-D2', 1.05)). return sup. [docs]def build_b3lyp5d_superfunctional(name, npoints, deriv):. sup = build_b3lyp5_superfunctional(name, npoints, deriv); sup.set_name('B3LYP5-D'). # => -D2 <= #; sup.set_dispersion(PsiMod.Dispersion.build('-D2', 1.05)). return sup. [docs]def build_bp86d_superfunctional(name, npoints, deriv):. s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/functional.html:42164,allocate,allocate,42164,psi4manual/4.0b3/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency,"ha(1.0). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 1.08184); X.set_parameter('B97_a1', -0.518339); X.set_parameter('B97_a2', 3.42562); X.set_parameter('B97_a3', -2.62901); X.set_parameter('B97_a4', 2.28855). C = build_functional('B_C'); C.set_name('HCTH407_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.589076); C.set_parameter('B97_os_a1', 4.42374); C.set_parameter('B97_os_a2', -19.2218); C.set_parameter('B97_os_a3', 42.5721); C.set_parameter('B97_os_a4', -42.0052). C.set_parameter('B97_ss_gamma', 0.2); C.set_parameter('B97_ss_a0', 1.18777); C.set_parameter('B97_ss_a1', -2.40292); C.set_parameter('B97_ss_a2', 5.61741); C.set_parameter('B97_ss_a3', -9.17923); C.set_parameter('B97_ss_a4', 6.24798). sup.add_x_functional(X); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_blypd_superfunctional(name, npoints, deriv):. sup = build_blyp_superfunctional(name, npoints, deriv); sup.set_name('BLYP-D'). # => -D2 <= #; sup.set_dispersion(PsiMod.Dispersion.build('-D2', 1.20)). return sup. [docs]def build_b3lypd_superfunctional(name, npoints, deriv):. sup = build_b3lyp_superfunctional(name, npoints, deriv); sup.set_name('B3LYP-D'). # => -D2 <= #; sup.set_dispersion(PsiMod.Dispersion.build('-D2', 1.05)). return sup. [docs]def build_b3lyp5d_superfunctional(name, npoints, deriv):. sup = build_b3lyp5_superfunctional(name, npoints, deriv); sup.set_name('B3LYP5-D'). # => -D2 <= #; sup.set_dispersion(PsiMod.Dispersion.build('-D2', 1.05)). return sup. [docs]def build_bp86d_superfunctional(name, npoints, deriv):. sup = build_bp86_superfunctional(name, npoints, deriv); sup.set_name('BP86-D'). # => -D2 <= #; sup.set_dispersion(PsiMod.Dispersion.build('-D2', 1.05)). return sup. [docs]def build_pbed_superfunctional(name, npoints, deriv):. sup = buil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:38915,allocate,allocate,38915,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency,"hane dimer with user-combined reference points. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. cc54; CCSD dipole with user-specified basis set. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. fci-h2o-2; 6-31G H2O Test FCI Energy Point. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cepa-module; routing check on lccd, lccsd, cepa(0). pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cc17; Single point energies of multiple excited states with EOM-CCSD. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:24592,energy,energy,24592,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"hange-scaling F-SAPT data. Type: string; Default: s-fsapt/. FISAPT_LINK_ASSIGNMENT¶. Where do sigma links go (to C or to AB)?. Type: string; Possible Values: C, AB; Default: C. FISAPT_LINK_SELECTION¶. Specification algorithm for link bonds in ISAPT. Type: string; Possible Values: AUTOMATIC, MANUAL; Default: AUTOMATIC. FISAPT_MANUAL_LINKS¶. Manual link bond specification [[Atom1, Atom2], ...]. Type: array; Default: No Default. FISAPT_PLOT_FILEPATH¶. Filepath to drop scalar data. Type: string; Default: plot/. INTS_TOLERANCE¶. Minimum absolute value below which integrals are neglected. For ISAPT, a variational collapse problem seems to occur for even rather modest values of this cutoff, when DF is used and when very close contacts occur. Therefore, we will be safe and turn it off (this does not affect performance overtly). Type: conv double; Default: 0.0. LOCAL_CONVERGENCE¶. Relative convergence in orbital localization. Type: conv double; Default: 1.0e-12. LOCAL_IBO_POWER¶. IBO localization metric power. Type: integer; Default: 4. LOCAL_IBO_STARS¶. IBO Centers for Pi Degeneracy. Type: array; Default: No Default. LOCAL_IBO_STARS_COMPLETENESS¶. IBO Charge metric for classification as Pi. Type: double; Default: 0.90. LOCAL_IBO_USE_STARS¶. IBO Stars procedure. Type: boolean; Default: false. LOCAL_MAXITER¶. Maximum iterations in localization. Type: integer; Default: 1000. MAXITER¶. Maximum number of iterations for CPHF. Type: integer; Default: 50. SSAPT0_SCALE¶. Do sSAPT0 exchange-scaling with F-SAPT. Type: boolean; Default: false. Expert¶. CUBIC_BASIS_TOLERANCE¶. CubicScalarGrid basis cutoff. Type: conv double; Default: 1.0e-12. CUBIC_BLOCK_MAX_POINTS¶. CubicScalarGrid maximum number of grid points per evaluation block. Type: integer; Default: 1000. FISAPT_MEM_SAFETY_FACTOR¶. Memory safety factor for heavy FISAPT operations. Type: double; Default: 0.9. LOCAL_IBO_CONDITION¶. Condition number to use in IBO metric inversions. Type: double; Default: 1.0e-7. LOCAL_USE_GHOSTS¶. U",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__fisapt-1.html:2352,power,power,2352,psi4manual/1.0.0/autodir_options_c/module__fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__fisapt-1.html,2,['power'],['power']
Energy Efficiency,"hange. set_x_omega(self, arg0); Sets the range-seperation exchange parameter. test_functional(self, arg0, arg1, arg2, …); Quick testing capabilities. value(self, arg0); Returns a given internal value. values(self); Return all internal values. vv10_b(self); The VV10 b parameter. vv10_c(self); The VV10 c parameter. x_alpha(self); Amount of exact HF exchange. x_beta(self); Amount of exact HF exchange. x_functional(self, arg0); Returns the desired X Functional. x_functionals(self); Returns all X Functionals. x_omega(self); Range-seperated exchange parameter. Methods Documentation. static XC_build(arg0: str, arg1: bool) → psi4.core.SuperFunctional¶; Builds a SuperFunctional from a XC string. add_c_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional) → None¶; Add a correlation Functional. add_x_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional) → None¶; Add a exchange Functional. allocate(self: psi4.core.SuperFunctional) → None¶; Allocates the vectors, should be called after ansatz or npoint changes. ansatz(self: psi4.core.SuperFunctional) → int¶; SuperFunctional rung. static blank() → psi4.core.SuperFunctional¶; Initialize a blank SuperFunctional. c_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of MP2 correlation. c_functional(self: psi4.core.SuperFunctional, arg0: str) → psi4.core.Functional¶; Returns the desired C Functional. c_functionals(self: psi4.core.SuperFunctional) → List[psi4.core.Functional]¶; Returns all C Functionals. c_omega(self: psi4.core.SuperFunctional) → float¶; Range-seperated correlation parameter. c_os_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of SS MP2 correlation. c_ss_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of OS MP2 correlation. citation(self: psi4.core.SuperFunctional) → str¶; SuperFunctional citation. compute_functional(self: psi4.core.SuperFunctional, arg0: Dict[str, psi4.core.Vector], arg1: int) → Dict[str, psi4.core.Vector]¶; Computes the SuperFunctional. density",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.superfunctional.html:4313,Allocate,Allocates,4313,psi4manual/1.4.0/api/psi4.core.superfunctional.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.superfunctional.html,1,['Allocate'],['Allocates']
Energy Efficiency,"hange_file_namespace(97, 'monomerA', 'monomerB'); PsiMod.IO.set_default_namespace('monomerB'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_B'); PsiMod.print_out('\n'); banner('Monomer B HF'); PsiMod.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); PsiMod.print_out('\n'); banner('Monomer B DFMP2'); PsiMod.print_out('\n'); e_monomerB_mp2 = PsiMod.dfmp2(); PsiMod.set_global_option('DF_INTS_IO', df_ints_io). PsiMod.IO.change_file_namespace(121, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerB', 'dimer'). activate(molecule); PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'MP2C'); PsiMod.print_out('\n'); banner('MP2C'); PsiMod.print_out('\n'). PsiMod.set_variable('MP2C DIMER MP2 ENERGY', e_dimer_mp2); PsiMod.set_variable('MP2C MONOMER A MP2 ENERGY', e_monomerA_mp2); PsiMod.set_variable('MP2C MONOMER B MP2 ENERGY', e_monomerB_mp2). e_sapt = PsiMod.sapt(). optstash.restore(); return e_sapt. [docs]def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """""". molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1); monomerA.set_name('monomerA'); mono",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:32396,ENERGY,ENERGY,32396,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"hange_file_namespace(97, 'monomerA', 'monomerB'); PsiMod.IO.set_default_namespace('monomerB'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_B'); PsiMod.print_out('\n'); banner('Monomer B HF'); PsiMod.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); PsiMod.print_out('\n'); banner('Monomer B DFMP2'); PsiMod.print_out('\n'); e_monomerB_mp2 = PsiMod.dfmp2(); PsiMod.set_global_option('DF_INTS_IO', df_ints_io). PsiMod.IO.change_file_namespace(121, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerB', 'dimer'). activate(molecule); PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'MP2C'); PsiMod.print_out('\n'); banner('MP2C'); PsiMod.print_out('\n'). PsiMod.set_variable('MP2C DIMER MP2 ENERGY', e_dimer_mp2); PsiMod.set_variable('MP2C MONOMER A MP2 ENERGY', e_monomerA_mp2); PsiMod.set_variable('MP2C MONOMER B MP2 ENERGY', e_monomerB_mp2). e_sapt = PsiMod.sapt(); return e_sapt. [docs]def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """""". molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(). # There's three-body code somewhere so exceptions may be needed; nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'):; molecule.update_geometry(); monomerA = molecule.extract_su",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/proc.html:24801,ENERGY,ENERGY,24801,psi4manual/4.0b2/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"hanged by giving a; file name (with path if not in the current working directory) to the; function psi4.core.set_output_file(); API,; as a string:. In [2]:. psi4.core.set_output_file('output.dat', False). Additionally, output may be suppressed by instead setting; psi4.core.be_quiet(); API. II. Running a Basic Hartree-Fock Calculation¶; In our first example, we will consider a Hartree-Fock SCF computation; for the water molecule using a cc-pVDZ basis set. First, we will set the; available memory for Psi4 to use with the psi4.set_memory(); API; function, which takes either a string like '30 GB' (with units!) or; an integer number of bytes of memory as its argument. Next, our; molecular geometry is passed as a string into psi4.geometry(); API.; We may input this geometry in either Z-matrix or Cartesian format; to; allow the string to break over multiple lines, use Python’s triple-quote; """"""string"""""" syntax. Finally, we will compute the Hartree-Fock SCF; energy with the cc-pVDZ basis set by passing the method/basis set as a; string ('scf/cc-pvdz') into the function psi4.energy(); API:. In [3]:. #! Sample HF/cc-pVDZ H2O Computation. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:3211,energy,energy,3211,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['energy'],['energy']
Energy Efficiency,"hared_ptrIN3psi6VectorEEE,N5boost10shared_ptrIN3psi6VectorEEE,N5boost10shared_ptrIN3psi6VectorEEE); | ; | writeNO(...); | writeNO( (MoldenWriter)arg1, (str)arg2, (Matrix)arg3, (Matrix)arg4, (Vector)arg5, (Vector)arg6) -> None :; | docstring; | ; | C++ signature :; | void writeNO(N3psi12MoldenWriterE {lvalue},Ss,N5boost10shared_ptrIN3psi6MatrixEEE,N5boost10shared_ptrIN3psi6MatrixEEE,N5boost10shared_ptrIN3psi6VectorEEE,N5boost10shared_ptrIN3psi6VectorEEE); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | C++ signature :; | d Z(N3psi8MoleculeE {lvalue},i); | ; | __getattr__ = new_get_attr(self, name); | Function to redefine __getattr__ method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine __setattr__ method of molecule cla",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:542607,charge,charge,542607,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['charge'],['charge']
Energy Efficiency,"harge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; 1; 2; 3; 4; 5; 6; 7; 8energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0.; A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; 1; 2; 3; 4; 5 SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (i.e., each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (i.e., each monomer utilizes only its; own basis set). It is also possible to run a closed-shell SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; sapt_basis='monomer' to the energy function, such as; 1energy('sapt2',sapt_basis='monomer'). This procedure leads to f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:25247,charge,charge-transfer,25247,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,6,['charge'],['charge-transfer']
Energy Efficiency,"harges = [self.molecule.charge(iatom) for iatom in range(natom)]; MDI_Send(charges, natom, MDI_DOUBLE, self.comm); return charges. # Respond to the <MASSES command; def send_masses(self):; """""" Send the nuclear masses through MDI. :returns: *masses* Atomic masses; """"""; natom = self.molecule.natom(); molecule_dict = self.molecule.to_dict(); masses = molecule_dict['mass']; MDI_Send(masses, natom, MDI_DOUBLE, self.comm); return masses. # Respond to the <ELEMENTS command; def send_elements(self):; """""" Send the atomic number of each nucleus through MDI. :returns: *elements* Element of each atom; """"""; natom = self.molecule.natom(); elements = [self.molecule.true_atomic_number(iatom) for iatom in range(natom)]; MDI_Send(elements, natom, MDI_INT, self.comm); return elements. # Respond to the <ENERGY command; def send_energy(self):; """""" Send the total energy through MDI. :returns: *energy* Energy of the system; """"""; self.run_scf(); MDI_Send(self.energy, 1, MDI_DOUBLE, self.comm); return self.energy. # Respond to the <FORCES command; def send_forces(self):; """""" Send the nuclear forces through MDI. :returns: *forces* Atomic forces; """"""; force_matrix = psi4.driver.gradient(self.scf_method, **self.kwargs); forces = force_matrix.np.ravel(); MDI_Send(forces, len(forces), MDI_DOUBLE, self.comm); return forces. # Respond to the >CHARGES command; def recv_charges(self, charges=None):; """""" Receive a set of nuclear charges through MDI and assign them to the atoms in the current molecule. Arguments:; charges: New nuclear charges. If None, receive through MDI.; """"""; natom = self.molecule.natom(); if charges is None:; charges = MDI_Recv(natom, MDI_DOUBLE, self.comm). # Assign the charge of all atoms, taking care to avoid ghost atoms; jatom = 0; for iatom in range(natom):; while self.molecule.fZ(jatom) == 0 and jatom < self.molecule.nallatom():; jatom = jatom + 1; if jatom >= self.molecule.nallatom():; raise Exception('Unexpected number of ghost atoms when receiving masses'); self.molecule.s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:6185,energy,energy,6185,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,14,['energy'],['energy']
Energy Efficiency,"hat PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. scf3; File retention, docc, socc, and bond distances specified explicitly. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. dft1; DFT Functional Test. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. omp3-3; OMP3 cc-pVDZ energy with B3LYP initial guess for the NO radical. dcft9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mode. Previous topic; CFOUR; Next topic; DFTD3. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/testsuite-1.html:32509,energy,energy,32509,psi4manual/1.0.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"hat Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the SAPT; procedure.; To speed up the computation a little, we also tell the SAPT procedure to freeze the core electrons by adding 'freeze_core': 'true' to the dictionary passed to psi4.set_options(). The SAPT procedure is invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here, Psi4 knows to automatically run two monomer computations and a dimer computation and then use these results to perform the SAPT analysis. The various energy components are printed at the end of the output, in addition to; the total SAPT0 interaction energy. An explanation of the various energy components can be found in the review by Jeziorski, Moszynski, and Szalewicz (Jeziorski:1994:1887), and this is discussed in more detail in the SAPT section of the Psi4 manual.; For now, we’ll note that most of the SAPT energy components are negative; this means those are attractive contributions (the zero of energy in a SAPT computation is defined as non-interacting monomers). The exchange contributions are positive (repulsive). In this example, the most attractive contribution between ethylene and acetylene is an electrostatic term of \(-2.12\) kcal/mol (Elst10,r where the 1 indicates the first-order perturbation theory result with respect to the; intermolecular interaction, and the 0 indicates zeroth-order with respect to the intramolecular electron correlation). The next most attractive contribution is the Disp20 term (second order intermolecular dispersion, which looks like MP2 in which one excitation is placed on each monomer), contributing an attraction of \(-1.21\) kcal/mol. It is not surprising that the electrostatic contribution is dominant, because the geometry chosen for this example has the acetylene perpendicular to; the ethylene, with the acetylene hydrogen pointing directly at the double bond in ethylene; this will be attractive because the H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:15479,energy,energy,15479,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,22,['energy'],['energy']
Energy Efficiency,"hat fitting basis to employ (when; available for all elements, cc-pVDZ-RI is the default). .. deprecated:: Sept-2012; Use option |scf__df_basis_guess| instead. :type bypass_scf: :ref:`boolean <op_py_boolean>`; :param bypass_scf: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether, for *name* values built atop of scf calculations,; the scf step is skipped. Suitable when special steps are taken to get; the scf to converge in an explicit preceeding scf step. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp4'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> molecule H2 {\\n0 1\\nH\\nH 1 0.74\\n}; >>> energy('scf'); >>> H2.set_multiplicity(3); >>> energy('detci', bypass_scf=True). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['energy'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Energy method %s not available.' % (lowername)). [docs]def gradient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:22329,energy,energy,22329,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"hat involve these integrals in the AO; basis. In order to do that one needs to set the AO_BASIS option to; DISK (currently used by default). For more recommendations on the choice of the algorithm see; Recommendations section. Analytic Gradients¶; Analytic gradients are available for the DC-06, ODC-06, ODC-12, and ODC-13 methods.; For DC-06, the evaluation of the analytic gradients requires the solution of the; coupled response equations. Two algorithms are available for their iterative; solution: two-step (default) and simultaneous. These algorithms are similar to those; described for the orbital and cumulant updates in the Iterative Algorithms; section and usually exhibit similar efficiency. The choice of the algorithm can; be made using the RESPONSE_ALGORITHM option. For the DC-12 method the; analytic gradients are not yet available, one has to use numerical gradients to; perform the geometry optimizations. For the ODC-06, ODC-12 and ODC-13 methods no response equations; need to be solved, which makes the computation of the analytic gradients very; efficient. Analytic gradients are not available for the three-particle energy; correction . Methods Summary¶; The table below summarizes current DCFT code features:. Method; Available algorithms; Energy; Gradient; Reference. ODC-06; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-12; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-13; SIMULTANEOUS, QC; Y; Y; UHF. SIMULTANEOUS, QC; Y; N; UHF. SIMULTANEOUS, QC; Y; N; UHF. DC-06; SIMULTANEOUS, QC, TWOSTEP; Y; Y; UHF. DC-12; SIMULTANEOUS, QC, TWOSTEP; Y; N; UHF. Note that for ODC-06 and ODC-12 REFERENCE = RHF is only available for; ALGORITHM = SIMULTANEOUS. To compute correction,; the THREE_PARTICLE option needs to be set to PERTURBATIVE. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. energy('dcft'). The energy('dcft') call to energy() executes the DCFT; module, which will first call the SCF module and perform t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:11868,efficient,efficient,11868,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['efficient'],['efficient']
Energy Efficiency,"hat logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:84221,energy,energypiece,84221,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,6,['energy'],['energypiece']
Energy Efficiency,"hat logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:99998,energy,energypiece,99998,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['energy'],['energypiece']
Energy Efficiency,"hat the DF-CCSD(T) procedure use a; set of vectors defined by the Cholesky decomposition of the ERI tensor as; the auxiliary basis. This feature is enabled by specifying; DF_BASIS_CC as “CHOLESKY”. CD methods can be enabled in the SCF; procedure as well, by specifying the SCF_TYPE as “CD”. The; accuracy of the decomposition can be controlled through the keyword; CHOLESKY_TOLERANCE.; The following input file sets up a DF-CCSD(T); computation using CD integrals; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; scf_type cd; df_basis_cc cholesky; basis aug-cc-pvdz; freeze_core true; }; energy('df-ccsd(t)'). The resulting CCSD(T) correlation energy will be equivalent to that; obtained from a conventional computation if CHOLESKY_TOLERANCE is; sufficiently small (e.g. ). Gn theory¶; The FNOCC module contains all the components that comprise the Gn family; of composite methods. Currently, only the G2 method is supported; [Curtiss:1991:7221]. The G2 procedure may be called through the; energy() wrapper:; energy('gaussian-2'). Supported methods¶; The various methods supported by the FNOCC module in PSI4 are detailed; in Table FNOCC Methods. Note that these methods; are implemented for closed-shell references only. For open-shell references,; the calls energy('mp2.5'), energy('mp3'), and energy('mp4') will; default to the DETCI implementations of these methods. name; calls method. qcisd; quadratic configuration interaction singles doubles. qcisd(t); qcisd with perturbative triples. mp2.5; average of second- and third-order perturbation theories. mp3; third-order perturbation theory. mp4(sdq); fourth-order perturbation theory, minus triples contribution. mp4; full fourth-order perturbation theory. cepa(0); coupled electron pair approximation, variant 0. cepa(1); coupled electron pair approximation, variant 1. cepa(3); coupled electron pair approximation, variant 3. acpf; averaged coupled-pair functional. aqcc; averaged quadratic coupled-cluster. sdci; configuration in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/fnocc-1.html:9962,energy,energy,9962,psi4manual/4.0b5/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/fnocc-1.html,4,['energy'],['energy']
Energy Efficiency,"hat{H}^{\kappa} | 0 \rangle; \ + \ \langle 0| \big(\hat{W}_{N}^{\kappa}\hat{T}_{2}\big)_{c} | 0 \rangle \\; &+ \langle 0| \{\hat{\Lambda}_{2} \ \big(\hat{W}_{N}^{\kappa} \ + \ \hat{H}_{N}^{\kappa}\hat{T}_{2} \big)_{c}\}_{c} | 0 \rangle\end{split}\]; where subscript c means only connected diagrams are allowed, and; \(\hat{H}^{\kappa}\), \(\hat{f}_{N}^{\kappa}\), and \(\hat{W}_{N}^{\kappa}\) defined as. \[\begin{split}\hat{H}^{\kappa} &= e^{-\hat{K}} \hat{H} e^{\hat{K}} \\; \hat{f}_{N}^{\kappa} &= e^{-\hat{K}} \hat{f}_{N}^{d} e^{\hat{K}} \\; \hat{W}_{N}^{\kappa} &= e^{-\hat{K}} \hat{W}_{N} e^{\hat{K}}\end{split}\]; where \(\hat{f}_{N}\), and \(\hat{W}_{N}\) are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the \({\bf \kappa}\) parameter at \({\bf \kappa} = 0\). \[w_{pq} = \frac{\partial \widetilde{E}}{\partial \kappa_{pq}}\]. \[A_{pq,rs} = \frac{\partial^2 \widetilde{E}}{\partial \kappa_{pq} \partial \kappa_{rs}}\]; Then the energy can be expanded up to second-order as follows. \[\widetilde{E}^{(2)}({\bf \kappa}) = \widetilde{E}^{(0)} + {\bf \kappa^{\dagger} w} + \frac{1}{2}~{\bf \kappa^{\dagger} A \kappa}\]; where \({\bf w}\) is the MO gradient vector, \({\bf \kappa}\) is the MO rotation vector,; and \({\bf A}\) is the MO Hessian matrix. Therefore, minimizing the energy with respect to \({\bf \kappa}\); yields. \[{\bf \kappa} = -{\bf A^{-1}w}\]; This final equation corresponds to the usual Newton-Raphson step. OREMP. The REMP hybrid perturbation theory is a constrained mixture of the Møller–Plesset perturbation theory and the; Retaining the Excitation degree perturbation theory([Fink:2006:RE], [Behnle:2019:REMP]).; The mixing ratio is determined by the parameter :math’:A:. \[\widehat{H}^{(0)}_\text{REMP} = (1-A)\widehat{H}^{(0)}_\text{RE} + A\widehat{H}^{(0)}_\text{MP}\]; Technically, the second order of RE corresponds to LCCD for RHF and UHF references. REMP2 and its orbital-optim",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/occ.html:7804,energy,energy,7804,psi4manual/1.7.x/occ.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/occ.html,4,['energy'],['energy']
Energy Efficiency,"hat{H}^{\kappa} | 0 \rangle; \ + \ \langle 0| \big(\hat{W}_{N}^{\kappa}\hat{T}_{2}\big)_{c} | 0 \rangle \\; &+ \langle 0| \{\hat{\Lambda}_{2} \ \big(\hat{W}_{N}^{\kappa} \ + \ \hat{H}_{N}^{\kappa}\hat{T}_{2} \big)_{c}\}_{c} | 0 \rangle\end{split}\]; where subscript c means only connected diagrams are allowed, and; \(\hat{H}^{\kappa}\), \(\hat{f}_{N}^{\kappa}\), and \(\hat{W}_{N}^{\kappa}\) defined as. \[\begin{split}\hat{H}^{\kappa} &= e^{-\hat{K}} \hat{H} e^{\hat{K}} \\; \hat{f}_{N}^{\kappa} &= e^{-\hat{K}} \hat{f}_{N}^{d} e^{\hat{K}} \\; \hat{W}_{N}^{\kappa} &= e^{-\hat{K}} \hat{W}_{N} e^{\hat{K}}\end{split}\]; where \(\hat{f}_{N}\), and \(\hat{W}_{N}\) are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the \({\bf \kappa}\) parameter at \({\bf \kappa} = 0\). \[w_{pq} = \frac{\partial \widetilde{E}}{\partial \kappa_{pq}}\]. \[A_{pq,rs} = \frac{\partial^2 \widetilde{E}}{\partial \kappa_{pq} \partial \kappa_{rs}}\]; Then the energy can be expanded up to second-order as follows. \[\widetilde{E}^{(2)}({\bf \kappa}) = \widetilde{E}^{(0)} + {\bf \kappa^{\dagger} w} + \frac{1}{2}~{\bf \kappa^{\dagger} A \kappa}\]; where \({\bf w}\) is the MO gradient vector, \({\bf \kappa}\) is the MO rotation vector,; and \({\bf A}\) is the MO Hessian matrix. Therefore, minimizing the energy with respect to \({\bf \kappa}\); yields. \[{\bf \kappa} = -{\bf A^{-1}w}\]; This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the orbital-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Bot",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/occ-1.html:7723,energy,energy,7723,psi4manual/1.1.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/occ-1.html,11,['energy'],['energy']
Energy Efficiency,"hat{\Lambda}_{2}^{(2)} \ \big(\hat{f}_{N}^{\kappa} \hat{T}_{2}^{(1)}; \ + \ \hat{W}_{N}^{\kappa} \big)_{c}\}_{c} | 0 \rangle\end{split}\]. OLCCD. \[\begin{split}\widetilde{E}({\bf \kappa}) &= \langle 0| \hat{H}^{\kappa} | 0 \rangle; \ + \ \langle 0| \big(\hat{W}_{N}^{\kappa}\hat{T}_{2}\big)_{c} | 0 \rangle \\; &+ \langle 0| \{\hat{\Lambda}_{2} \ \big(\hat{W}_{N}^{\kappa} \ + \ \hat{H}_{N}^{\kappa}\hat{T}_{2} \big)_{c}\}_{c} | 0 \rangle\end{split}\]; where subscript c means only connected diagrams are allowed, and; \(\hat{H}^{\kappa}\), \(\hat{f}_{N}^{\kappa}\), and \(\hat{W}_{N}^{\kappa}\) defined as. \[\begin{split}\hat{H}^{\kappa} &= e^{-\hat{K}} \hat{H} e^{\hat{K}} \\; \hat{f}_{N}^{\kappa} &= e^{-\hat{K}} \hat{f}_{N}^{d} e^{\hat{K}} \\; \hat{W}_{N}^{\kappa} &= e^{-\hat{K}} \hat{W}_{N} e^{\hat{K}}\end{split}\]; where \(\hat{f}_{N}\), and \(\hat{W}_{N}\) are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the \({\bf \kappa}\) parameter at \({\bf \kappa} = 0\). \[w_{pq} = \frac{\partial \widetilde{E}}{\partial \kappa_{pq}}\]. \[A_{pq,rs} = \frac{\partial^2 \widetilde{E}}{\partial \kappa_{pq} \partial \kappa_{rs}}\]; Then the energy can be expanded up to second-order as follows. \[\widetilde{E}^{(2)}({\bf \kappa}) = \widetilde{E}^{(0)} + {\bf \kappa^{\dagger} w} + \frac{1}{2}~{\bf \kappa^{\dagger} A \kappa}\]; where \({\bf w}\) is the MO gradient vector, \({\bf \kappa}\) is the MO rotation vector,; and \({\bf A}\) is the MO Hessian matrix. Therefore, minimizing the energy with respect to \({\bf \kappa}\); yields. \[{\bf \kappa} = -{\bf A^{-1}w}\]; This final equation corresponds to the usual Newton-Raphson step. OREMP. The REMP hybrid perturbation theory is a constrained mixture of the Møller–Plesset perturbation theory and the; Retaining the Excitation degree perturbation theory([Fink:2006:RE], [Behnle:2019:REMP]).; The mixing ratio is determined by the parameter :math’:A:. \[\wide",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/occ.html:7558,energy,energy,7558,psi4manual/1.7.x/occ.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/occ.html,4,['energy'],['energy']
Energy Efficiency,"hat{\Lambda}_{2}^{(2)} \ \big(\hat{f}_{N}^{\kappa} \hat{T}_{2}^{(1)}; \ + \ \hat{W}_{N}^{\kappa} \big)_{c}\}_{c} | 0 \rangle\end{split}\]. OLCCD. \[\begin{split}\widetilde{E}({\bf \kappa}) &= \langle 0| \hat{H}^{\kappa} | 0 \rangle; \ + \ \langle 0| \big(\hat{W}_{N}^{\kappa}\hat{T}_{2}\big)_{c} | 0 \rangle \\; &+ \langle 0| \{\hat{\Lambda}_{2} \ \big(\hat{W}_{N}^{\kappa} \ + \ \hat{H}_{N}^{\kappa}\hat{T}_{2} \big)_{c}\}_{c} | 0 \rangle\end{split}\]; where subscript c means only connected diagrams are allowed, and; \(\hat{H}^{\kappa}\), \(\hat{f}_{N}^{\kappa}\), and \(\hat{W}_{N}^{\kappa}\) defined as. \[\begin{split}\hat{H}^{\kappa} &= e^{-\hat{K}} \hat{H} e^{\hat{K}} \\; \hat{f}_{N}^{\kappa} &= e^{-\hat{K}} \hat{f}_{N}^{d} e^{\hat{K}} \\; \hat{W}_{N}^{\kappa} &= e^{-\hat{K}} \hat{W}_{N} e^{\hat{K}}\end{split}\]; where \(\hat{f}_{N}\), and \(\hat{W}_{N}\) are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the \({\bf \kappa}\) parameter at \({\bf \kappa} = 0\). \[w_{pq} = \frac{\partial \widetilde{E}}{\partial \kappa_{pq}}\]. \[A_{pq,rs} = \frac{\partial^2 \widetilde{E}}{\partial \kappa_{pq} \partial \kappa_{rs}}\]; Then the energy can be expanded up to second-order as follows. \[\widetilde{E}^{(2)}({\bf \kappa}) = \widetilde{E}^{(0)} + {\bf \kappa^{\dagger} w} + \frac{1}{2}~{\bf \kappa^{\dagger} A \kappa}\]; where \({\bf w}\) is the MO gradient vector, \({\bf \kappa}\) is the MO rotation vector,; and \({\bf A}\) is the MO Hessian matrix. Therefore, minimizing the energy with respect to \({\bf \kappa}\); yields. \[{\bf \kappa} = -{\bf A^{-1}w}\]; This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the orbital-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [B",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/occ-1.html:7477,energy,energy,7477,psi4manual/1.1.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/occ-1.html,11,['energy'],['energy']
Energy Efficiency,"have chosen the intermediate normalization, . The CISD correlation energy is given by. (4); and the amplitudes can be determined by the solution to the coupled set of; eqations:. (5); The CISD method is not size-extensive, but this problem can be overcome by; making very simple modifications to the amplitude equations. We replace; the correlation energy, , with generalized shifts for the; doubles and singles equations, and :. (6); These shifts approximate the effects of triple and quadruple excitations.; The values for and used in several; coupled-pair methods are given in Table CEPA Shifts. Note that these shifts are defined in a spin-free; formalism for closed-shell references only. method. sdci. dci. NA. cepa(0); 0; 0. cepa(1). cepa(3). acpf. aqcc. The pair correlation energy, , is simply a partial; sum of the correlation energy. In a spin-free formalism, the pair energy; is given by. (7); Methods whose shifts ( and ) do not; explicitly depend on orbitals or (CISD, CEPA(0), ACPF,; and AQCC) have solutions that render the energy stationary with respect; variations in the amplitudes. This convenient property allows density; matrices and 1-electron properties to be evaluated without any additional; effort. Note, however, that 1-electron properties are currently; unavailable when coupling these stationary CEPA-like methods with frozen; natural orbitals. Density-fitted coupled cluster¶; Density fitting (DF) [or the resolution of the identity (RI)] and Cholesky; decomposition (CD) techniques are popular in quantum chemistry to avoid; the computation and storage of the 4-index electron repulsion integral; (ERI) tensor and even to reduce the computational scaling of some terms.; DF/CD-CCSD(T) computations are available in PSI4, with or without the; use of FNOs, through the FNOCC module. The implementation and accuracy of; the DF/CD-CCSD(T) method are described in Ref. [DePrince:2013:inpress].; The DF-CCSD(T) procedure uses two auxiliary basis sets. The first set is; that ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/fnocc-1.html:7327,energy,energy,7327,psi4manual/4.0b5/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/fnocc-1.html,2,['energy'],['energy']
Energy Efficiency,"have chosen the intermediate normalization, . The CISD correlation energy is given by. (4); and the amplitudes can be determined by the solution to the coupled set of; eqations:. (5); The CISD method is not size-extensive, but this problem can be overcome by; making very simple modifications to the amplitude equations. We replace; the correlation energy, , with generalized shifts for the; doubles and singles equations, and :. (6); These shifts approximate the effects of triple and quadruple excitations.; The values for and used in several; coupled-pair methods are given in Table CEPA Shifts. Note that these shifts are defined in a spin-free; formalism for closed-shell references only. method. sdci. dci. NA. cepa(0); 0; 0. cepa(1). cepa(3). acpf. aqcc. The pair correlation energy, , is simply a partial; sum of the correlation energy. In a spin-free formalism, the pair energy; is given by. (7); Methods whose shifts ( and ) do not; explicitly depend on orbitals or (CISD, CEPA(0), ACPF,; and AQCC) have solutions that render the energy stationary with respect; variations in the amplitudes. This convenient property allows density; matrices and 1-electron properties to be evaluated without any additional; effort. Note, however, that 1-electron properties are currently; unavailable when coupling these stationary CEPA-like methods with frozen; natural orbitals. Density-fitted coupled cluster¶; Density fitting (DF) or resolution of the identity (RI) techniques are; popular in quantum chemistry to avoid the computation and storage of the; 4-index electron repulsion integral (ERI) tensor and even to reduce the; computational scaling of some terms. DF-CCSD(T) computations are; available in PSI4, with or without the use of FNOs, through the FNOCC; module. The implementation and accuracy of the DF-CCSD(T) method are; described in Ref. [DePrince:2013:inprep].; The default auxiliary basis set for a DF-CCSD computation is chosen to be; the RI set (optimized for DFMP2) most similar to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/fnocc-1.html:7289,energy,energy,7289,psi4manual/4.0b4/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/fnocc-1.html,2,['energy'],['energy']
Energy Efficiency,"he Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet) → psi4.core.CUHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wav",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.cuhf.html:3294,energy,energy,3294,psi4manual/1.2.1/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.cuhf.html,1,['energy'],['energy']
Energy Efficiency,"he Atomic Orbital to Symmetry Orbital transformer. arrays(self: psi4.core.Wavefunction) → Dict[str, psi4.core.Matrix]¶; Returns the map of all internal arrays. atomic_point_charges(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet) → psi4.core.ROHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wav",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.rohf.html:3544,energy,energy,3544,psi4manual/1.2.1/api/psi4.core.rohf.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.rohf.html,1,['energy'],['energy']
Energy Efficiency,"he DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. Table Of Contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; FROZEN_UOCC; MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; SAPT: Symmetry-Adapted Perturbation Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/detci-1.html:11232,energy,energy,11232,psi4manual/4.0b4/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/detci-1.html,2,['energy'],['energy']
Energy Efficiency,"he DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. Table Of Contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; FROZEN_UOCC; MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; SAPT: Symmetry-Adapted Perturbation Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/detci-1.html:11232,energy,energy,11232,psi4manual/4.0b5/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/detci-1.html,2,['energy'],['energy']
Energy Efficiency,"he Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: int, arg2: psi4.core.Matrix, arg3: psi::detci::CIvect) → None; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶. density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use onl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.ciwavefunction.html:9028,energy,energy,9028,psi4manual/1.3.2/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.ciwavefunction.html,1,['energy'],['energy']
Energy Efficiency,"he KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Advanced Functional Use and Manipulation¶; New DFT functionals can be created from scratch from within the input; file and accessed using the dft_functional keyword argument in the; energy call:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28# DFT Custom Functional. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis sto-3g; dft_spherical_points 302; dft_radial_points 99; reference rks; }. pbe0 = {; ""name"": ""my_PBE0"",; ""x_functionals"": {""GGA_X_PBE"": {""alpha"": 0.75}},; ""x_hf"": {""alpha"": 0.25},; ""c_functionals"": {""GGA_C_PBE"": {}}; }. func_call = energy('SCF', dft_functional=pbe0). # as PBE0 is a pre-defined functional, the call above is equivalent to both below:; func_call = energy('SCF', dft_functional=""PBE0""); func_call = energy('PBE0'). Supported keywords include:. name: string, name of the functional. for custom defined functionals used for printing only.; xc_functionals: dict, definition of a complete (X + C) functional based in LibXC name; x_functionals: dict, definition of exchange functionals using LibXC names; c_functionals: dict, definition of correlation functionals",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dft-1.html:27338,energy,energy,27338,psi4manual/1.3.2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dft-1.html,2,['energy'],['energy']
Energy Efficiency,"he LDA response for FDDS. Type: double; Default: 1.e-6. SAPT_LEVEL (SAPT)¶SAPT — The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. SAPT_MEM_CHECK (SAPT)¶SAPT — Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. SAPT_MEM_FACTOR (SAPT)¶SAPT (Expert) — Proportion of memory available for the DF-MP2 three-index integral buffers used to evaluate dispersion. Type: double; Default: 0.9. SAPT_MEM_SAFETY (SAPT)¶SAPT — Memory safety. Type: double; Default: 0.9. SAPT_QUIET (SAPT)¶SAPT (Expert) — Interior option to clean up printing. Type: boolean; Default: false. SAVE_JK (SCF)¶SCF — Keep JK object for later use?. Type: boolean; Default: false. SAVE_UHF_NOS (SCF)¶SCF — Save the UHF NOs. Type: boolean; Default: false. SCF_MEM_SAFETY_FACTOR (SCF)¶SCF — Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_PROPERTIES (SCF)¶SCF — SCF Properties to calculate after an energy evaluation. Note, this keyword is not used for property evaluations. Type: array; Default: No Default. SCF_TYPE (CPHF)¶CPHF — SCF Type. Type: string; Possible Values: DIRECT, DF, PK, OUT_OF_CORE, PS, INDEPENDENT, GTFOCK; Default: DIRECT. SCF_TYPE (GLOBALS)¶GLOBALS — What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRECT, DF, MEM_DF, DISK_DF, PK, OUT_OF_CORE, CD, GTFOCK; Default: PK. SCHMIDT_ADD_RESIDUAL_TOLERANCE (CCEOM)¶CCEOM — Minimum absolute value above which a guess vector to a root is added to the Davidson algorithm in the EOM-CC iterative procedure. Type: conv double; Default: 1e-3. SCREENING (GLOBALS)¶GLOBALS — The type of screening used when computing two-electron integrals. Type: string; Possible Values: SCHWARZ, CSAM, DENSITY; Default: CSAM. SCS_CCSD (CCENERGY)¶CCENERGY — Do spin-component-scaled CCSD. Type: boolean; Default",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html:214257,energy,energy,214257,psi4manual/1.5.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"he LDA response for FDDS. Type: double; Default: 1.e-6. SAPT_LEVEL (SAPT)¶SAPT — The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. SAPT_MEM_CHECK (SAPT)¶SAPT — Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. SAPT_MEM_FACTOR (SAPT)¶SAPT (Expert) — Proportion of memory available for the DF-MP2 three-index integral buffers used to evaluate dispersion. Type: double; Default: 0.9. SAPT_MEM_SAFETY (SAPT)¶SAPT — Memory safety. Type: double; Default: 0.9. SAPT_QUIET (SAPT)¶SAPT (Expert) — Interior option to clean up printing. Type: boolean; Default: false. SAVE_JK (SCF)¶SCF — Keep JK object for later use?. Type: boolean; Default: false. SAVE_UHF_NOS (SCF)¶SCF — Save the UHF NOs. Type: boolean; Default: false. SCF_MEM_SAFETY_FACTOR (SCF)¶SCF — Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_PROPERTIES (SCF)¶SCF — SCF Properties to calculate after an energy evaluation. Note, this keyword is not used for property evaluations. Type: array; Default: No Default. SCF_TYPE (CPHF)¶CPHF — SCF Type. Type: string; Possible Values: DIRECT, DF, PK, OUT_OF_CORE, PS, INDEPENDENT, GTFOCK; Default: DIRECT. SCF_TYPE (GLOBALS)¶GLOBALS — What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRECT, DF, MEM_DF, DISK_DF, PK, OUT_OF_CORE, CD, GTFOCK; Default: PK. SCHMIDT_ADD_RESIDUAL_TOLERANCE (CCEOM)¶CCEOM — Minimum absolute value above which a guess vector to a root is added to the Davidson algorithm in the EOM-CC iterative procedure. Type: conv double; Default: 1e-3. SCREENING (SAPT)¶SAPT — Do use Combined Schwarz Approximation Maximum (CSAM) screening on two-electron integrals. This is a slightly tighter bound than that of default Schwarz screening. Type: string; Possible Values: SCHWARZ, CSAM; Default: CSAM. SC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:212898,energy,energy,212898,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"he License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. import psi4; import p4const; from math import sqrt, pi; from diatomic_fits import *. [docs]def anharmonicity(rvals, energies, mol = None):; """"""Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using either a 5 or 9 point Legendre fit, locates the minimum; energy point, and then applies second order vibrational perturbation theory to obtain spectroscopic; constants. The r values provided must bracket the minimum energy point, or an error will result. A dictionary with the following keys, which correspond to spectroscopic constants, is returned:. :type rvals: list; :param rvals: The bond lengths (in Angstrom) for which energies are; provided of length either 5 or 9 but must be the same length as; the energies array. :type energies: list; :param energies: The energies (Eh) computed at the bond lengths in the rvals list. :returns: (*dict*) Keys: ""re"", ""r0"", ""we"", ""wexe"", ""nu"", ""ZPVE(harmonic)"", ""ZPVE(anharmonic)"", ""Be"", ""B0"", ""ae"", ""De""; corresponding to the spectroscopic constants in cm-1; """""". angstrom_to_bohr = 1.0 / p4const.psi_bohr2angstroms; angstrom_to_meter = 10e-10;. if len(rvals) != len(energies):; raise Exception(""The number of energies must match the number of distances""). npoints = len(rvals). if npoints != 5 and npoints != 9:; raise Exception(""Only 5- or 9-point fits are implemented right now""). psi4.print_out(""\n\nPerforming a %d-point fit\n"" % npoints). psi4.print_out(""\nOpti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/diatomic.html:1426,energy,energy,1426,psi4manual/4.0b5/_modules/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/diatomic.html,2,['energy'],['energy']
Energy Efficiency,"he MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP3 level of theory. MP4(T) CORRECTION ENERGY¶; The MP4 triples component [Eh]. Quantity is second right-hand term in; Eq. (2). MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP4 singles, doubles, quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY; is left-hand term in Eq. (2). (2)¶\[E_{\text{MP4}} = E_{\text{MP4(SDQ)}} + E_{\text{MP4(T)}}\]. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled Møller–Plesset perturbation theory level.; n is MP perturbation order. MP2 DOUBLES ENERGY¶. MP2.5 DOUBLES ENERGY¶. MP3 DOUBLES ENERGY¶. CEPA(0) DOUBLES ENERGY¶. CEPA(1) DOUBLES ENERGY¶. CEPA(2) DOUBLES ENERGY¶. CEPA(3) DOUBLES ENERGY¶. CISD DOUBLES ENERGY¶. QCISD DOUBLES ENERGY¶. LCCD DOUBLES ENERGY¶. CCD DOUBLES ENERGY¶. LCCSD DOUBLES ENERGY¶. CCSD DOUBLES ENERGY¶. OMP2 DOUBLES ENERGY¶. OMP2.5 DOUBLES ENERGY¶. OMP3 DOUBLES ENERGY¶. OLCCD DOUBLES ENERGY¶; The doubles portion [Eh] of the named correlation energy; including same-spin and opposite-spin correlations. MP2 SINGLES ENERGY¶. MP2.5 SINGLES ENERGY¶. MP3 SINGLES ENERGY¶. CEPA(0) SINGLES ENERGY¶. CEPA(1) SINGLES ENERGY¶. CEPA(2) SINGLES ENERGY¶. CEPA(3) SINGLES ENERGY¶. CISD SINGLES ENERGY¶. QCISD SINGLES ENERGY¶. LCCD SINGLES ENERGY¶. CCD SINGLES ENERGY¶. LCCSD SINGLES ENERGY¶. CCSD SINGLES ENERGY¶. OLCCD SINGLES ENERGY¶; The singles portion [Eh] of the named correlation energy.; Zero except in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:29274,energy,energy,29274,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,10,['energy'],['energy']
Energy Efficiency,"he Ms = 0 component of the triplet. Uses ROHF triplet orbitals. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). fcidump; test FCIDUMP functionality for rhf/uhf. fnocc5; Test FNO-DF-CCSD(T) energy. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc12; Single point energies of multiple excited states with EOM-CCSD. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. fnocc4; Test FNO-DF-CCSD(T) energy. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc54; CCSD dipole with user-specified basis set. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-pt2; Mk-MRPT2 single point. \(^1A_1\) F2 state described using t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:8283,energy,energy,8283,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"he NO radical. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. dft1-alt; DFT Functional Test. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. scf6; Tests RHF/ROHF/UHF SCF gradients. numpy-array-interface; Numpy interface testing. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. casscf-fzc-sp; CASSCF/6-31G** energy point. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keywor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:13557,energy,energy,13557,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"he SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins. Damping [Off by Default]In some cases, a static mixing of Fock Matrices from adjacent; iterations can quench oscillations. This mixing, known as; “damping” can be activated by setting the; DAMPING_PERCENTAGE keyword to a nonzero percent. Damping is; turned off when the DIIS error is smaller than; DAMPING_CONVERGENCE. Level shifting [Off by default]A commonly used alternative to damping is to use level shifting,; which decreases the mixing of occupied and unoccupied orbitals in; the SCF update by moving the unoccupied orbitals up in energy. It; can be shown that the SCF procedure always converges with a; suitably large level shift; however, the larger the shift is, the; slower the convergence becomes, and the calculation may end up; converging onto a higher lying SCF solution. Because of this, in; practice level shifting is most useful in the initial phase of the; calculation to reduce the orbital error enough for DIIS to work; well. The level shift is controlled by the parameter; LEVEL_SHIFT, and it is turned off when the DIIS error is; smaller than LEVEL_SHIFT_CUTOFF. Reasonable values for; the shift and convergence threshold are 5.0 and 1e-2,; respectively. SOSCF [Off by Default]See Second-order Convergence. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals. OUT_OF_COREAn out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Inte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:23825,reduce,reduce,23825,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,6,['reduce'],['reduce']
Energy Efficiency,"he SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins. Damping [Off by Default]In some cases, a static mixing of Fock Matrices from adjacent; iterations can quench oscillations. This mixing, known as; “damping” can be activated by setting the; DAMPING_PERCENTAGE keyword to a nonzero percent. Damping is; turned off when the DIIS error is smaller than; DAMPING_CONVERGENCE. Level shifting [Off by default]A commonly used alternative to damping is to use level shifting,; which decreases the mixing of occupied and unoccupied orbitals in; the SCF update by moving the unoccupied orbitals up in energy. It; can be shown that the SCF procedure always converges with a; suitably large level shift; however, the larger the shift is, the; slower the convergence becomes, and the calculation may end up; converging onto a higher lying SCF solution. Because of this, in; practice level shifting is most useful in the initial phase of the; calculation to reduce the orbital error enough for DIIS to work; well. The level shift is controlled by the parameter; LEVEL_SHIFT, and it is turned off when the DIIS error is; smaller than LEVEL_SHIFT_CUTOFF. Reasonable values for; the shift and convergence threshold are 5.0 and 1e-2,; respectively. SOSCF [Off by Default]See Second-order Convergence. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword. Most consist of a single algorithm applied to; the construction of both the Coulomb and Exchange parts; of the Fock Matrix:. PK [Default]An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals. OUT_OF_COREAn out-of-core, unsorted algo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:24984,reduce,reduce,24984,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,3,['reduce'],['reduce']
Energy Efficiency,"he algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. select_mp3(name, **kwargs)[source]¶; Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. select_mp3_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. select_mp4(name, **kwargs)[source]¶; Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. select_olccd(name, **kwargs)[source]¶; Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. select_olccd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. select_omp2(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. select_omp2_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. select_omp2_property(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. select_omp2p5(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. select_omp2p5_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. select_omp3(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. select_omp3_gradient(name, **kwargs)[source]¶; Function selecting the algorith",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:169672,energy,energy,169672,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency,"he basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta4_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta5_scheme: function; :param delta5_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta5_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:28125,energy,energy,28125,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"he basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; 1energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; 1optimize('pbeh3c'). HF-3c with non-standard basis; 1; 2set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; 1; 2set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.interface_gcp.run_gcp(self, func=None, dertype=None, verbose=False)[source]¶; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. table of contents. Interface to gCP by S. Grimme; Installation; Running gCP. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/gcp-1.html:3175,energy,energy,3175,psi4manual/1.3.2/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/gcp-1.html,4,['energy'],['energy']
Energy Efficiency,"he cfour {...}; block are for the sandwich mode, where the entire ZMAT is enclosed,; or for extra directives like %excite*, which presently have no other; specification route.; Specifying the basis is perhaps the regulated piece of input. Since; basis set names differ between PSI4 and Cfour and it’s not; practical to compare exponent-to-exponent, any input file with both; BASIS and CFOUR_BASIS keywords present will halt. Once; a basis set has been requested through BASIS, overriding the; default spherical/Cartesian setting must be done through; PUREAM (as opposed to CFOUR_SPHERICAL).; Specifying keywords that control geometry optimization is; straightforward. Unless the optimization is invoked in sandwich mode,; all Cfour optimization keywords (e.g., CFOUR_GEO_MAXCYC) are; ineffective, as the Cfour optimizer is never invoked. PSI4; optimization keywords (e.g., GEOM_MAXITER) instead fill; these roles.; Specifying the computational method (through, for instance,; energy('c4-ccsd') instead of energy('cfour')) often; sets additional keywords consistent with best practices (e.g.,; CFOUR_CC_PROGRAM). Since those settings are implicit, any; explicit setting of those those keywords, whether contradicting or; concurring, takes priority (halts never generated). The following are; some concrete examples. For the moment, click the source button at; muster_modelchem for details of what keywords; get set. runs in vcc since that’s Cfour’s default for cc_program; set cfour_calc_level ccsd; energy('cfour'). runs in ecc since Cfour’s default overwritten by keyword; set cfour_calc_level ccsd; set cfour_cc_program ecc; energy('cfour'). runs in ecc since that’s best practice for the requested ccsd; energy('c4-ccsd'). runs in vcc since hidden default overwritten by keyword; set cfour_cc_program vcc; energy('c4-ccsd'). Specifying certain keywords that are nominally applicable for pure-PSI4 modules directs them to fulfil analogous roles; in the Cfour program (e.g., MAXITER is used to set; C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:31635,energy,energy,31635,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,18,['energy'],['energy']
Energy Efficiency,"he common; Cfour keyword abbreviations CALC, REF, etc. must be replaced by their; proper names of CFOUR_CALC_LEVEL, CFOUR_REFERENCE, etc. Whenever the molecule is supplied in PSI4 format, it is possible to; perform geometry optimizations where Cfour supplies the gradient and the; PSI4 module optking drives the structural; changes. Because of the limitations on geometry specification for; optimizations in Cfour, optking-driven optimizations are the only; optimizations allowed in the P4C4 interface. (The exception is sandwich; mode, which, of course, permits optimizations with the Cfour optimizer.); Below is an example of a geometry optimization:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Several sample inputs in; psi4/tests/cfour/ starting with opt- show basic geometry; optimizations. cfour/mints5-grad shows optimizations from a; variety of molecule input formats, and cfour/psi-ghost-grad; shows an optimization with ghosted atoms. To obtain a single gradient; sans optimization, call instead gradient().; Note that it can be convenient to monitor the progress of a geometry; optimization by grepping the tilde ~ character.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19Measures of convergence in internal coordinates in au.; Criteria marked as inactive (o), active & met (*), and active & unmet ( ).; ---------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:7243,energy,energy,7243,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,6,['energy'],['energy']
Energy Efficiency,"he components into a minimum number of calculations. check_iwl_file_from_scf_type(scf_type, wfn); Ensures that a IWL file has been written based on input SCF type. compare_fchkfiles(expected, computed, ...); Comparison function for output data in FCHK (formatted checkpoint) file format. compare_fcidumps(expected, computed, label); Comparison function for FCIDUMP files. compare_moldenfiles(expected, computed[, ...]); Comparison function for output data in Molden file format. copy_file_from_scratch(filename, prefix, ...); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, ...); Function to move file into scratch with correct naming convention. create_plugin(name, template). rtype; None. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energies_from_fcidump(intdump). energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename, *[, debug, strict_label]); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fchkfile_to_string(fname); Load FCHK file into a string. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. find_approximate_string_matches(seq1, ...); Find list of approximate (within max_distance) matches to string seq1 among options. free_atom_volumes(wfn, **kwargs); Computes free-atom volumes using MBIS density partitioning. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geomet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psi4api.html:17882,energy,energy,17882,psi4manual/1.6.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html,2,['energy'],['energy']
Energy Efficiency,"he constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. sapt3; SAPT2+3(CCD) aug-cc-pVDZ computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ CH2 single-point energy (fzc, MO-basis ). dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. fd-gradient; SCF STO-3G finite-difference tests. psimrcc-sp1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. fnocc2; Test G2 method for H2O. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. dfccdl1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:8622,energy,energy,8622,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"he coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4,; "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after |PSIfour|",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:3298,energy,energy,3298,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,4,['energy'],['energy']
Energy Efficiency,"he copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Plan, run, and assemble QC tasks to obtain derivatives by finite difference of lesser derivatives. ===========; FINDIF Flow; ===========; Bullet points are major actions; Lines of dashes denote function calls; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian. -----------------------------------; FiniteDifferenceComputer.__init__(); -----------------------------------; * collect findif_stencil_size, findif_step_size from initializer kwargs; * BaseComputer.__init__(); * negotiate safety and user wishes on translation and rotation projection. gradient_from_energies_geometries(); -----------------------------------; hessian_from_gradients_geometries(); -----------------------------------; hessian_from_energies_geometries(); ----------------------------------. _geom_generator(); -----------------. _initialize_findif(); --------------------; * initialize CdSalcs, partition them per irrep, apply user irreps. * start the governing dict findifrec with parameters, size, mol; * for each irrep, for each relevant salc ... _displace_cart(); ----------------; * form new geometry by linear combination. * ... and collect geometry into a field of findifrec[""d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:1340,energy,energy,1340,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,8,['energy'],['energy']
Energy Efficiency,"he correlation energy. delta4_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy. delta5_scheme (function) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:8867,energy,energy,8867,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"he cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. Aliases :counterpoise_correct(), counterpoise_correction(). Returns:(float) Counterpoise-corrected interaction energy in Hartrees. Psi variables:. CP-CORRECTED 2-BODY INTERACTION ENERGY; UNCP-CORRECTED 2-BODY INTERACTION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No values of func besides energy have been tested.; Table print-out needs improving. Add some PSI variables. Parameters:; name (string) – 'scf' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; energy(); however, SAPT is not appropriate. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; energy('name'), while optimize perfoms a geometry optimization; on each system, and cbs performs a compound single-point energy.; If a nested series of python functions is intended; (see Function Intercalls), use keyword cp_func instead of func. check_bsse (boolean) – 'on' || 'off' ; Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). n_body(name[, func, bsse, max_n_body, do_total, external, external_monomers, molecule])[source]¶. Previous topic; Property; Next topic; Optimize; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cp-1.html:1241,energy,energy,1241,psi4manual/4.0b3/cp-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cp-1.html,4,['energy'],['energy']
Energy Efficiency,"he cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. Aliases :counterpoise_correct(), counterpoise_correction(). Returns:(float) Counterpoise-corrected interaction energy in Hartrees. Psi variables:. CP-CORRECTED 2-BODY INTERACTION ENERGY; UNCP-CORRECTED 2-BODY INTERACTION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No values of func besides energy have been tested.; Table print-out needs improving. Add some PSI variables. Parameters:; name (string) – 'scf' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; energy(); however, SAPT is not appropriate. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; energy('name'), while optimize perfoms a geometry optimization; on each system, and cbs performs a compound single-point energy.; If a nested series of python functions is intended; (see Function Intercalls), use keyword cp_func instead of func. check_bsse (boolean) – 'on' || 'off' ; Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). n_body(name[, func, bsse, max_n_body, do_total, external, external_monomers, molecule])[source]¶. Previous topic; Property; Next topic; Optimize; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/cp-1.html:1241,energy,energy,1241,psi4manual/4.0b4/cp-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/cp-1.html,4,['energy'],['energy']
Energy Efficiency,"he cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. Aliases :counterpoise_correct(), counterpoise_correction(). Returns:(float) Counterpoise-corrected interaction energy in Hartrees. Psi variables:. CP-CORRECTED 2-BODY INTERACTION ENERGY; UNCP-CORRECTED 2-BODY INTERACTION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No values of func besides energy have been tested.; Table print-out needs improving. Add some PSI variables. Parameters:; name (string) – 'scf' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; energy(); however, SAPT is not appropriate. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; energy('name'), while optimize perfoms a geometry optimization; on each system, and cbs performs a compound single-point energy.; If a nested series of python functions is intended; (see Function Intercalls), use keyword cp_func instead of func. check_bsse (boolean) – 'on' || 'off' ; Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). n_body(name[, func, bsse, max_n_body, do_total, external, external_monomers, molecule])[source]¶. Previous topic; Property; Next topic; Optimize; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cp-1.html:1241,energy,energy,1241,psi4manual/4.0b5/cp-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cp-1.html,4,['energy'],['energy']
Energy Efficiency,"he cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. Aliases :counterpoise_correct(), counterpoise_correction(). Returns:(float) Counterpoise-corrected interaction energy in kcal/mol. Psi variables:. CP-CORRECTED 2-BODY INTERACTION ENERGY; UNCP-CORRECTED 2-BODY INTERACTION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No values of func besides energy have been tested.; Table print-out needs improving. Add some PSI variables. Parameters:; name (string) – 'scf' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; energy(); however, SAPT is not appropriate. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; energy('name'), while optimize perfoms a geometry optimization; on each system, and cbs performs a compound single-point energy.; If a nested series of python functions is intended; (see Function Intercalls), use keyword cp_func instead of func. check_bsse (boolean) – 'on' || 'off' ; Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). n_body(name[, func, bsse, max_n_body, do_total, external, external_monomers, molecule])[source]¶. Previous topic; Property; Next topic; Optimize; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cp-1.html:1226,energy,energy,1226,psi4manual/4.0b2/cp-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cp-1.html,4,['energy'],['energy']
Energy Efficiency,"he density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:None. Parameters:; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate cube files; filename (string) – destination file name for MOLDEN file (optional); density_a (Matrix) – density in the MO basis to build alpha NO’s from (optional); density_b (Matrix) – density in the MO basis to build beta NO’s from, assumes restricted if not supplied (optional); dovirtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional). Examples:. 1; 2; 3>>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 1; 2; 3>>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). 1; 2; 3>>> # [3] The following does NOT work, please see below; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). 1; 2; 3; 4; 5>>> # [4] This WILL work, note the transformation of Da (SO->MO); >>> E, wfn = properties('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> Da_mo = Matrix.triplet(wfn.Ca(), Da_so, wfn.Ca(), True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). Options¶. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. U",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/molden-1.html:2480,energy,energy,2480,psi4manual/1.2.1/molden-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/molden-1.html,2,['energy'],['energy']
Energy Efficiency,"he density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:None. Parameters:; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate cube files; filename (string) – destination file name for MOLDEN file (optional); density_a (Matrix) – density in the MO basis to build alpha NO’s from (optional); density_b (Matrix) – density in the MO basis to build beta NO’s from, assumes restricted if not supplied (optional); dovirtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional). Examples:. 1; 2; 3>>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). 1; 2; 3>>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). 1; 2; 3>>> # [3] The following does NOT work, please see below; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). 1; 2; 3; 4; 5>>> # [4] This WILL work, note the transformation of Da (SO->MO); >>> E, wfn = property('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> Da_mo = Matrix.triplet(wfn.Ca(), Da_so, wfn.Ca(), True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). Options¶. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/molden-1.html:2485,energy,energy,2485,psi4manual/1.1.0/molden-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/molden-1.html,2,['energy'],['energy']
Energy Efficiency,"he density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str]) – Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.; do_virtual (Optional[bool]) – Do write all the MOs to the MOLDEN file (True) or discard the unoccupied; MOs (False). Not valid for NO’s. If unspecified (None), value taken from; MOLDEN_WITH_VIRTUAL.; use_natural (bool) – Write natural orbitals determined from density on wavefunction.; self (Wavefunction) – . Examples:. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; “properties” or “gradient” must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.; The first two arguments of get_opdm(); can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(wfn, 'no_root1.molden', use_natural=True). write_nbo(name)¶; Write wavefunction information in wfn to name in NBO format. Parameters:; name (str) – ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html:28259,energy,energy,28259,psi4manual/1.7.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Wavefunction.html,6,['energy'],['energy']
Energy Efficiency,he difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP2.5 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP3 level of theory. OMP3 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP3 level of theory. OREMP2 TOTAL ENERGY¶. OREMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized retaining-the-excitation-degree Møller–Plesset; hybrid perturbation theory level. OREMP2 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized retaining-the-excitation-degree; Møller–Plesset hybrid perturbation theory level. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [E_h] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). PCM POLARIZATION ENERGY¶; The energy contribution [E_h] from the polarizable continuum model for solvation. DD SOLVATION ENERGY¶; The energy contribution [Eh] from continuum solvation models based on a; domain-decomposition ansatz. PE ENERGY¶; The energy contribution [E_h] from the polarizable embedding model for solvation. QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. QCISD(T) CORRECTION ENERGY¶; The quadratic configuration interaction singles and doubles perturbative; triples correction [E_h]. REMP2 TOTAL E,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:44011,energy,energy,44011,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency,"he dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and open-shell monomers.; Higher-order SAPT and SAPT(DFT) are currently available only; for computation of interactions between; closed-shell singlets. The SAPT codes in PSI4 have been written; to utilize density fitting, which is much faster than using conventional; 4-index electron repulsion integrals. This happens automatically and; does not require any additional keywords to be specified (both the; SAPT computations and the underlying Hartree-Fock computations will; utilize density fitting).; For SAPT(DFT), the user will need to manually specify the GRAC shift of; both monomers, defined by the difference of ionization potential (IP) and; Kohn-Sham HOMO energy. The ionization potential data for many common molecules; is available in NIST Chemistry Webbook. Alternatively, one can estimate the; ionization potential of molecule by computing the energy difference between; the molecule as given, and the molecule after one electron has been removed; (e.g., the energy difference between a neutral molecule and its cation).; The values of GRAC shifts should be given in Hartree. For the example above,; the GRAC shift value of both molecules are calculated to be 0.1307 (using experimental; IP from CCCBDB), and the user would specify them using the following keywords:; set globals {; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307; }. A complete, minimal example of a SAPT(DFT) computation is given below.; molecule {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/sapt.html:13089,energy,energy,13089,psi4manual/1.7.x/sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/sapt.html,4,['energy'],['energy']
Energy Efficiency,"he dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and open-shell monomers.; Higher-order SAPT and SAPT(DFT) are currently available only; for computation of interactions between; closed-shell singlets. The SAPT codes in PSI4 have been written; to utilize density fitting, which is much faster than using conventional; 4-index electron repulsion integrals. This happens automatically and; does not require any additional keywords to be specified (both the; SAPT computations and the underlying Hartree-Fock computations will; utilize density fitting).; For SAPT(DFT), the user will need to manually specify the GRAC shift of; both monomers, defined by the difference of ionization potential (IP) and; Kohn-Sham HOMO energy. The ionization potential data for many common molecules; is available in NIST Chemistry Webbook. Alternatively, one can estimate the; ionization potential of molecule by computing the energy difference between; the molecule as given, and the molecule after one electron has been removed; (e.g., the energy difference between a neutral molecule and its cation).; The values of GRAC shifts should be given in Hartree. For the example above,; the GRAC shift value of both molecules are calculated to be 0.1307, and the; user would specify them using the following keywords:; set globals {; sapt_dft_grac_shift_a 0.1307; sapt_dft_grac_shift_b 0.1307; }. A complete, minimal example of a SAPT(DFT) computation is given below.; molecule {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.68039",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:11634,energy,energy,11634,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,5,['energy'],['energy']
Energy Efficiency,"he docstring in energy() below; },; 'gradient' : {; 'scf' : run_scf_gradient,; 'ccsd' : run_cc_gradient,; 'ccsd(t)' : run_cc_gradient,; 'mp2' : run_mp2_gradient,; 'eom-ccsd' : run_eom_cc_gradient,; 'dcft' : run_dcft_gradient; # Upon adding a method to this list, add it to the docstring in optimize() below; },; 'hessian' : {; # Upon adding a method to this list, add it to the docstring in frequency() below; },; 'property' : {; 'scf' : run_scf_property,; 'cc2' : run_cc_property,; 'ccsd' : run_cc_property,; 'eom-cc2' : run_cc_property,; 'eom-ccsd' : run_cc_property,; 'eom_cc2' : run_cc_property,; 'eom_ccsd' : run_cc_property; # Upon adding a method to this list, add it to the docstring in property() below; }}. # Integrate DFT with driver routines; for ssuper in superfunctional_list():; procedures['energy'][ssuper.name().lower()] = run_dft. for ssuper in superfunctional_list():; procedures['gradient'][ssuper.name().lower()] = run_dft_gradient. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: (*float*) Total electronic energy in Hartrees. SAPT returns interaction energy. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. comment In this table immediately below, place methods that should only be called by ; .. comment developers at present. This table won't show up in the manual.; .. comment; .. comment .. _`table:energy_devel`:; .. comment ; .. comment +-------------------------+---------------------------------------------------------------------------------------+; .. comment | name | calls method |; .. comment +=========================+=======================================================================================+; .. comment | df-cc | coupled cluster with density fitting |; .. comment +-------------------------+---------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:3086,energy,energy,3086,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,4,['energy'],['energy']
Energy Efficiency,"he energy contribution [Eh] from the polarizable embedding model for solvation. QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [Eh] for the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶. SAPT ENERGY¶; The total electronic interaction energy [Eh] for the requested SAPT; level of theory. SAPT ELST10,R ENERGY¶; An electrostatics-classified SAPT term energy [Eh] implemented for SAPT0. SAPT ELST EXTERN-EXTERN ENERGY¶; Electrostatic interaction [Eh] between the point charges in fragments; A and B in F/I-SAPT. SAPT EXCH10 ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT0. SAPT EXCH10(S^2) ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT0. SAPT IND20,R ENERGY¶. SAPT EXCH-IND20,R ENERGY¶. SAPT IND20,U ENERGY¶. SAPT EXCH-IND20,U ENERGY¶; An induction-classified SAPT term energy [Eh] implemented for SAPT0. SAPT DISP20 ENERGY¶. SAPT EXCH-DISP20 ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT0. SAPT EXCH-DISP20(S^INF) ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT0. See Higher-Order Exchange Terms without Single-Exchange Approximation. SAPT SAME-SPIN DISP20 ENERGY¶. SAPT SAME-SPIN EXCH-DISP20 ENERGY¶; The portion of SAPT DISP20 ENERGY or; SAPT EXCH-DISP20 ENERGY resulting from; from same-spin or triplet doubles correlat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:42877,energy,energy,42877,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['energy'],['energy']
Energy Efficiency,"he energy contribution [Eh] from the polarizable embedding model for solvation. QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [Eh] for the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶. SAPT ENERGY¶; The total electronic interaction energy [Eh] for the requested SAPT; level of theory. SAPT ELST10,R ENERGY¶; An electrostatics-classified SAPT term energy [Eh] implemented for SAPT0. SAPT ELST EXTERN-EXTERN ENERGY¶; Electrostatic interaction [Eh] between the point charges in fragments; A and B in F/I-SAPT. SAPT EXCH10 ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT0. SAPT EXCH10(S^2) ENERGY¶; An exchange-classified SAPT term energy [Eh] implemented for SAPT0. SAPT IND20,R ENERGY¶. SAPT EXCH-IND20,R ENERGY¶. SAPT IND20,U ENERGY¶. SAPT EXCH-IND20,U ENERGY¶; An induction-classified SAPT term energy [Eh] implemented for SAPT0. SAPT DISP20 ENERGY¶. SAPT EXCH-DISP20 ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT0. SAPT EXCH-DISP20(S^INF) ENERGY¶; A dispersion-classified SAPT term energy [Eh] implemented for SAPT0. See Second-Order Exchange Terms without Single-Exchange Approximation. SAPT SAME-SPIN DISP20 ENERGY¶. SAPT SAME-SPIN EXCH-DISP20 ENERGY¶; The portion of SAPT DISP20 ENERGY or; SAPT EXCH-DISP20 ENERGY resulting from; from same-spin or triplet doubles correlat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:35359,energy,energy,35359,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency,"he field to zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → List[Tuple[float, float, float, float]]¶; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential) → psi4.core.Matrix¶; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential) → None¶; Print ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html:1593,charge,charge,1593,psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,2,['charge'],['charge']
Energy Efficiency,"he field to zero (eliminates all entries). computeExternExternInteraction(self, arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self, arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self, basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self, arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector) → None¶; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float) → None¶; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: list[tuple[float, float, float, float]]) → None¶; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential) → None¶; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential) → float¶; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule) → float¶; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet) → psi4.core.Matrix¶; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential) → list[tuple[float, float, float, float]]¶; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential) → psi4.core.Matrix¶; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential) → None¶; Print ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html:1600,charge,charge,1600,psi4manual/master/api/psi4.core.ExternalPotential.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.ExternalPotential.html,2,['charge'],['charge']
Energy Efficiency,"he following list: ""; 		print allowedSolvents.keys(); 		print ""or specify the solvent data explicitly.""; 		sys.exit(1). correction = section.get('Correction'); 	if (correction.get() < 0.0):; 		print ""Correction for CPCM solver must be greater than 0.0""; 		sys.exit(1). 	convert_length_scalar(section.get('ProbeRadius')); 	radius = section.get('ProbeRadius'); 	if (radius.get() < 0.1 or radius.get() > 100):; 		print ""Probe radius has to be within [0.1,100] Atomic Units""; 		sys.exit(1). 	allowed_types = ('IEFPCM', 'CPCM', 'Wavelet', 'Linear'); key = section.get('SolverType'); val = key.get(); if (val not in allowed_types): ; print ""Allowed types are: "", allowed_types; 	sys.exit(1); 	allowed_equations = ('FirstKind', 'SecondKind', 'Full'); key = section.get('EquationType'); val = key.get(); if (val not in allowed_equations): ; print ""Allowed equations are: "", allowed_equations; 	sys.exit(1). [docs]def verify_green(section):; 	required = ('Type',); 	allowed = ('Vacuum', 'UniformDielectric', 'MetalSphere', 'GreensFunctionSum'); 	allowed_der = ('Numerical', 'Derivative', 'Gradient', 'Hessian'). 	green1 = section.fetch_sect('Green<one>'); 	green2 = section.fetch_sect('Green<two>'); 	eps = section.get('Eps'); 	epsimg = section.get('EpsImg'); 	epsre = section.get('EpsRe'). 	convert_length_array(section.get('SpherePosition')); position = section.get('SpherePosition'); 	convert_length_scalar(section.get('SphereRadius')); radius = section.get('SphereRadius'). 	type=section.get('Type'); 	if (type.get() not in allowed):; 		print ""Allowed Green's functions are:"", allowed; 		sys.exit(1). 	type=section.get('Der'); 	if (type.get() not in allowed_der):; 		print ""Allowed Derivatives are:"", allowed; 		sys.exit(1). 	if (type.get() == 'UniformDielectric'):; 		if not eps.is_set():; 			print ""Eps not defined for UniformDielectric""; 			sys.exit(1). 	if (type.get() == 'MetalSphere'):; 		if not (eps.is_set() and epsre.is_set and epsimg.is_set()):; 			print ""Eps and/or EpsImg not defined for Metal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/pcmpreprocess.html:6335,Green,GreensFunctionSum,6335,psi4manual/4.0b5/_modules/pcmpreprocess.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/pcmpreprocess.html,1,['Green'],['GreensFunctionSum']
Energy Efficiency,"he full point group (e.g., Td for methane) as opposed to the computational point group (e.g., C2v for methane). Default takes into account symmetry reduction through asymmetric isotopic substitution and is unaffected by user-set symmetry on molecule, so this option is the sole way to influence the symmetry-dependent aspects of the thermodynamic analysis. Type: integer; Default: 1. RSRFO_ALPHA_MAX (OPTKING); OPTKING — Absolute maximum value of RS-RFO. Type: double; Default: 1e8. RUN_CCSD (FNOCC); FNOCC (Expert) — do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA (FNOCC); FNOCC (Expert) — Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2 (FNOCC); FNOCC (Expert) — do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3 (FNOCC); FNOCC (Expert) — do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4 (FNOCC); FNOCC (Expert) — do only evaluate mp4 energy?. Type: boolean; Default: false. S (DETCI); DETCI — The value of the spin quantum number is given by this option. The default is determined by the value of the multiplicity. This is used for two things: (1) determining the phase of the redundant half of the CI vector when the component is used (i.e., MS0 = TRUE), and (2) making sure the guess vector has the desired value of (if CALC_S_SQUARED is TRUE and ICORE = 1). Type: double; Default: 0.0. S_ORTHOGONALIZATION (SCF); SCF — SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_TOLERANCE (SCF); SCF — Minimum S matrix eigenvalue to be used before compensating for linear dependencies. Type: conv double; Default: 1e-7. SAD_CHOL_TOLERANCE (SCF); SCF (Expert) — Auxiliary basis for the SAD guess. Type: conv double; Default: 1e-7. SAD_D_CONVERGENCE (SCF); SCF — Convergence criterion for SCF density in SAD Guess. Type: conv double; Default: 1e-5",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:199956,energy,energy,199956,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"he geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [E_h] of the reference stage corresponding to; the CURRENT ENERGY variable. CURRENT DIPOLE¶; The total dipole [e a0] of the most recent stage of a calculation (frequently overwritten), (3,). CURRENT GRADIENT¶; The total electronic gradient [E_h/a0] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer, ({nat}, 3). CURRENT DIPOLE GRADIENT¶; The derivative of the dipole with respect to nuclear perturbations [E_h a0/u] = [(e a0/a0)^2/u]; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). CURRENT HESSIAN¶; The total electronic Hessian [E_h/a0/a0] of the most recent stage of a; calculation, (3 * {nat}, 3 * {nat}). CUSTOM SCS-MP2 TOTAL ENERGY¶. CUSTOM SCS-MP2 CORRELATION ENERGY¶; Changeable quantities based on options.; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by any reweighting of MP2 DOUBLES ENERGY; for opposite-spin and same-spin contributions, with; any singles carried along.; Depending on weights, may equal any of MP2, SCS-MP2, SCS(N)-MP2, etc. quantities.; Contrast with SCS-MP2 TOTAL ENERGY. CUSTOM SCS-MP2.5 TOTAL ENERGY¶. CUSTOM SCS-MP2.5 CORRELATION ENERGY¶. CUSTOM SCS-MP3 TOTAL ENERGY¶. CUSTOM SCS-MP3 CORRELATION ENERGY¶. CUSTOM SCS-REMP2 TOTAL ENERGY¶. CUSTOM SCS-REMP2 CORRELATION ENERGY¶. CUSTOM SCS-LCCD TOTAL ENERGY¶. CUSTOM SCS-LCCD CORRELATION ENERGY¶. CUSTOM SCS-OMP2 TOTAL ENERGY¶. CUSTOM SCS-OMP2 CORRELATION ENERGY¶. CUSTOM SCS-OMP2.5 TOTAL ENERGY¶. CUSTOM SCS-OMP2.5 CORRELATION ENERGY¶. CUSTOM SCS-OMP3 TOTAL ENERGY¶. CUSTOM SCS-OMP3 CORRELATION ENERGY¶. CUSTOM SCS-OREMP2 TOTAL ENERGY¶. CUSTOM SCS-OREMP2 CORRELATION ENERGY¶. CUSTOM SCS-OLCCD TOTAL ENERGY¶. CUSTOM SCS-OLCCD CORRELATION ENERGY¶; Changeable quantities based on options.; The total electronic energy [E_h] and correlation energy component [E_h]; for the method formed by a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:24686,energy,energy,24686,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency,"he induction energy is not going to be used. Type: boolean; Default: false. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Specific open-shell SAPT0 keywords¶. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. COUPLED_INDUCTION¶. Whether or not to compute coupled induction, applies only to the open-shell SAPT0 code. Coupled induction is not available for ROHF, and the option is automatically false in this case. Note that when coupled induction is turned off, the Psi variables SAPT IND20,R ENERGY and SAPT EXCH-IND20,R ENERGY actually contain the uncoupled induction! A corresponding warning is issued in the output file. Type: boolean; Default: true. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:17697,efficient,efficient,17697,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,2,['efficient'],['efficient']
Energy Efficiency,"he internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; 1; 2; 3; 4F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; 1; 2; 3; 4F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4¶. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  ; \(4.5 \times 10^{-3}\); \(3.0 \times 10^{-3}\); \(5.4 \times 10^{-3}\); \(3.6 \times 10^{-3}\). GAU_LOOSE [6];  ; \(2.5 \times 10^{-3}\); \(1.7 \times 10^{-3}\); \(1.0 \times 10^{-2}\); \(6.7 \times 10^{-3}\). TURBOMOLE [4]; \(1.0 \times 10^{-6}\); \(1.0 \times 10^{-3}\); \(5.0 \times 10^{-4}\); \(1.0 \times 10^{-3}\); \(5.0 \times 10^{-4}\). GAU [3] [6];  ; \(4.5 \times 10^{-4}\); \(3.0 \times 10^{-4}\); \(1.8 \times 10^{-3}\); \(1.2 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:11293,energy,energy,11293,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,6,['energy'],['energy']
Energy Efficiency,"he left hand eigenvectors, :math:`X-Y`, computed on the last iteration of the solver.; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Notes; -----; The solution vector is normalized to 1/2. The solver will return even when `maxiter` iterations are performed without convergence.; The caller **must check** ``stats[-1]['done']`` for failure and handle each case accordingly. References; ----------; R. Eric Stratmann, G. E. Scuseria, and M. J. Frisch, ""An efficient; implementation of time-dependent density-functional theory for the; calculation of excitation energies of large molecules."" J. Chem. Phys.,; 109, 8218 (1998); """""". nk = nroot. iter_info = {; ""count"": 0,; ""res_norm"": np.zeros((nk)),; ""val"": np.zeros((nk)),; ""delta_val"": np.zeros((nk)),. # conv defaults to true, and will be flipped when a non-conv root is hit; ""conv"": True,; ""nvec"": 0,; ""product_count"": 0,; }; print_name = ""HamiltonianSolver""; title_lines = [""Generalized Hamiltonian Solver"", ""By Andrew M. James""]. _diag_print_heading(title_lines, print_name, max_ss_size, nroot, r_convergence, maxiter, verbose). vecs = guess; best_L = []; best_R = []; best_vals = []; stats = []; while iter_info['count'] < maxiter:. # increment iteration/ save old vals; iter_info['count'] += 1; old_w = iter_info['val'].copy(). # reset flags; iter_info['collapse'] = False; iter_info['done'] = True. # get subspace dimension; l = len(vecs); iter_info['nvec'] = l. # check if subspace dimension has exceeded limits; if l >= max_ss_size:; iter_info['collapse'] ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:27257,efficient,efficient,27257,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,8,['efficient'],['efficient']
Energy Efficiency,"he lines looking for fragment markers; ifrag = 0; iatom = 0; tempfrag = []; atomSym = """"; atomLabel = """"; zmatrix = False; for line in glines:. # handle fragment markers; if frag.match(line):; ifrag += 1; self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); tempfrag = []. # handle atom markers; elif atom.match(line):; entries = re.split(r'\s+|\s*,\s*', line.strip()); atomLabel = entries[0]. # handle ghost atoms; ghostAtom = False; if ghost.match(atomLabel):; # We don't know whether the @C or Gh(C) notation matched. Do a quick check.; atomLabel = ghost.match(atomLabel).group(2) if not ghost.match(atomLabel).group(1) \; else ghost.match(atomLabel).group(1); ghostAtom = True. # Save the actual atom symbol (H1 => H); atomSym = re.split('(\d+)', atomLabel)[0].upper(). # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:18005,charge,charge,18005,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,4,['charge'],['charge']
Energy Efficiency,"he list, returns true if it is, and returns false if not. label((self: psi4.core.Molecule, ...); Gets the original label of the atom arg1 as given in the input file (C2, H4) (0-indexed). mass((self: psi4.core.Molecule, ...); Gets mass of atom arg1 (0-indexed). molecular_charge(...); Gets the charge on full molecule. move_to_com((self: psi4.core.Molecule) -> None); Moves molecule to center of mass. multiplicity((self: psi4.core.Molecule) -> int); Gets the multiplicity (defined as $2M_s + 1$) of full molecule. nactive_fragments(...); Gets the number of active (non-ghosted) fragments in the molecule. nallatom((self: psi4.core.Molecule) -> int); Number of real and dummy atoms. name((self: psi4.core.Molecule) -> str); Gets molecule name. natom((self: psi4.core.Molecule) -> int); Number of real atoms. nfragments((self: psi4.core.Molecule) -> int); Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_repulsion_energy(...); Computes nuclear repulsion energy. point_group(...); Returns the current point group object. print_bond_angles(...); Print the bond angle geometrical parameters. print_cluster((self: psi4.core.Molecule) -> None); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(...); Print the interatomic distance geometrical parameters. print_in_input_format(...); Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out((self: psi4.core.Molecule) -> None); Prints the molecule in Cartesians in input units. print_out_in_angstrom(...); Prints the molecule in Cartesians in Angstroms. print_out_in_bohr(...); Prints the molecule in Cartesians in Bohr. print_out_of_planes(...); Print the out-of-plane angle geometrical parameters. reinterpret_coordentry(...); Do reinterpret coordinate entries during update_geometry(). reset_point_group((self: psi4.core.Molecule, ...); Overrides symmetry from outside the molecule string. rotational_constants(...); Prints the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:4377,energy,energy,4377,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,1,['energy'],['energy']
Energy Efficiency,"he lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psithoninput.html:13942,energy,energy,13942,psi4manual/1.6.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psithoninput.html,1,['energy'],['energy']
Energy Efficiency,"he number of iterations taken to converge the SCF equations. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF) → None¶; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. diis(self: psi4.core.HF, arg0: float) → bool¶; docstring. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s temporary data. finalize_energy()¶; Performs stability analysis and call",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:6008,energy,energy,6008,psi4manual/1.7.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html,4,['energy'],['energy']
Energy Efficiency,"he other; values. The Libint2 engine instead provides all integrals, so the caller; simply needs to loop over all of the buffers provided in the appropriate order. Changes to External Potential Engines¶; Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted “CartAO”) and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set.; Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns – corresponding to charge, x, y, z; – to the set_charge_field() member of the potential integral class. The; same information is now passed using the more verbose; std::vector<std::pair<double, std::array<double, 3>>> type instead, to be; consistent with Libint2’s convention. New Operators Available¶; Libint2 provides a range of integrals that were previously not available in; PSI4, such as the Erfc attenuated nuclear potential integrals needed for; Ewald methods. If new integrals are added to Libint2 but are not yet; interfaced to PSI4, please open an issue on the PSI4 GitHub page to; alert the developers, who will be able to add the appropriate code.; Available integrals classes and parameters currently documented at; Libint2 C++11 Interface Wiki. Shell Pairs¶; To ensure consistency between one- and two-electron terms when s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/prog_integrals.html:15718,charge,charges,15718,psi4manual/1.6.x/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html,5,['charge'],['charges']
Energy Efficiency,"he physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule Specification¶; P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:2639,joule,joule,2639,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,4,['joule'],['joule']
Energy Efficiency,"he physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; PSI4 input files. Molecule and Geometry Spec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:2654,joule,joule,2654,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['joule'],['joule']
Energy Efficiency,"he presence of a dipole field. fnocc3; Test FNO-QCISD(T) computation. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. dft-custom; DFT custom functional test. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. cc30; CCSD/sto-3g optical rotation calcu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:30856,energy,energy,30856,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"he proper CFOUR options list; plus notes on keyword relevance when run through PSI4. Information; at the CFOUR manual may; also be useful, as may the many samples at psi4/samples/cfour.; Set Cfour keywords just like PSI4 keywords. The names of keywords; are unchanged beyond a prepended “cfour_”. (Though be aware that common; abbreviations like CALC and REF must be fully spelled out as; CFOUR_CALC_LEVEL and CFOUR_REFERENCE when used in; PSI4.); In limited trial cases, keywords nominally directed at non-Cfour modules; are translated into their Cfour counterparts. For example, setting; REFERENCE will appropriately set CFOUR_REFERENCE. For a; list of applicable keywords, see source of; muster_psi4options.; Consult Functionality for information on what Cfour; functionality is accessible through PSI4. PSI4 for Cfour Users¶; In the simplest use of the Psi4/Cfour interface, a PSI4 input file; can simply “wrap” a ZMAT file and execute xcfour. This is; illustrated in the following example:; cfour {; UHF-SCF energy calculation; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0. *ACES2(CALC=HF,BASIS=qz2p; MULT=2,REF=UHF; OCCUPATION=3-1-1-0/3-0-1-0; SCF_CONV=12; MEMORY=20000000); }. energy('cfour'). Here, the contents of the cfour {...} block are written directly to a; ZMAT file. This is joined by a default GENBAS file; (psi4/psi4/share/psi4/basis/GENBAS). To preferentially use your own GENBAS,; place it in PATH or PSIPATH. The line calling; energy() with argument 'cfour' invokes; xcfour.; After execution of the energy('cfour') line completes, Cfour results; are read back into PSI4 format and are thereafter accessible for; further processing in the input file. See Output for; details. This storage of results in variables and arrays in memory for; the duration of the PSI4 instance (as opposed to solely in files); is the only advantage thus far incurred by the P4C4 interface. We’ll call; this mode of basic utility the “sandwich” mode.; Molecule specification in PSI4 allows Cartesians, Z-matri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:3083,energy,energy,3083,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,9,['energy'],['energy']
Energy Efficiency,"he psi4/samples directory. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 600 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). Note; The memory and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; 1>>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; 1; 2; 3Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about \(1.0 \times 10^{-6}\), so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:2760,energy,energy,2760,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,4,['energy'],['energy']
Energy Efficiency,"he split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. dcft9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. fci-coverage; 6-31G H2O Test for coverage. scf-occ; force occupations in scf. scf7; Tests SCF gradient in the presence of a dipole field. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_.. tuple. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. cepa4; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:36460,energy,energy,36460,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,8,['energy'],['energy']
Energy Efficiency,"he supplied \alpha does not impact delta or any further stages. .. hlist::; :columns: 1. * :py:func:`corl_xtpl_helgaker_2`. :type delta_alpha: float. Overrides the default \alpha parameter used in the listed; :py:func:`corl_xtpl_helgaker_2` correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different \alpha might; be more appropriate. .. hlist::; :columns: 1. * :py:func:`corl_xtpl_helgaker_2`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:36289,energy,energy,36289,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"he target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html:1766,energy,energy,1766,psi4manual/1.7.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html,20,['energy'],['energy']
Energy Efficiency,"he total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized linearized coupled cluster doubles level of theory. OLCCD REFERENCE CORRECTION ENERGY¶; The additional correction to the SCF reference energy [Eh]; for the orbital-optimized linearized coupled cluster doubles level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP2 level of theory. OMP2.5 TOTAL ENERGY¶. OMP2.5 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP2.5 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [Eh] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). PCM POLARIZATION ENERGY¶; The energy contribution [Eh] from the polarizable continuum model for solvation. PE ENERGY¶; The energy contribution [Eh] from the polarizable embedding model for solvation. QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [Eh] for the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶. SAPT ENERGY¶; The total electronic interaction energy [Eh] for the requested SAP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:34254,energy,energy,34254,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['energy'],['energy']
Energy Efficiency,"he user UNUSED; self.PYcharge_specified = False; # The multiplicity (defined as 2Ms + 1); self.PYmultiplicity = 1; # Whether the multiplicity was specified by the user UNUSED; self.PYmultiplicity_specified = False; # The units used to define the geometry; self.PYunits = 'Angstrom'; # The conversion factor to take input units to Bohr; self.input_units_to_au = 1.0 / psi_bohr2angstroms; # Whether this molecule has at least one zmatrix entry; self.zmat = False. # <<< Coordinates >>>. # Atom info vector (no knowledge of dummy atoms); self.atoms = []; # Atom info vector (includes dummy atoms); self.full_atoms = []; # A list of all variables known, whether they have been set or not.; self.all_variables = []; # A listing of the variables used to define the geometries; self.geometry_variables = {}. # <<< Fragmentation >>>. # The list of atom ranges defining each fragment from parent molecule; self.fragments = []; # A list describing how to handle each fragment; self.fragment_types = []; # The charge of each fragment; self.fragment_charges = []; # The multiplicity of each fragment; self.fragment_multiplicities = []. # <<< Frame >>>. # Move to center of mass or not?; self.PYmove_to_com = True; # Reorient or not? UNUSED; self.PYfix_orientation = False; # Reinterpret the coord entries or not (Default is true, except for findif); self.PYreinterpret_coordentries = True; # Nilpotence boolean (flagged upon first determination of symmetry frame,; # reset each time a substantiative change is made); self.lock_frame = False. # <<< Symmetry >>>. # Point group to use with this molecule UNUSED; self.pg = None; # Full point group UNUSED; self.full_pg = 'PG_C1'; # n of the highest rotational axis Cn UNUSED; self.full_pg_n = 1; # Symmetry string from geometry specification; self.PYsymmetry_from_input = 'C1'; # Number of unique atoms; self.PYnunique = 0; # Number of equivalent atoms per unique atom (length nunique); self.nequiv = 0; # Equivalent atom mapping array; self.equiv = 0; # Atom to uni",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:3639,charge,charge,3639,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,2,['charge'],['charge']
Energy Efficiency,"he user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); core.set_global_option('BASIS', basis); ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); core.clean(). optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # Drop out for unsupported calls; if ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(""%s: Cannot extrapolate or delta correct %s yet."" % (ptype.title(), ptype)). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype != None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'scf_scheme' in kwargs:; stage['scheme'] = kwargs.pop('scf_scheme'); stage['stage'] = ""scf""; stage['treatment'] = ""scf""; else:; # _validate_cbs_inputs will produce scf stage automatically; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'corl_scheme' in kwargs:; stage['scheme'] =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:64855,energy,energy,64855,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"he; run_cfour() function documented below. Functionality¶; Through clever use of the cfour {...} block, one could run most any; Cfour computation through the P4C4 interface. In contrast, enumerated; below are tested functionalities where results from Cfour are collected; into PSI4 data objects.; Implemented. Single-point energy() commands for ground state; methods. Examples:; cfour/sp-rhf-ccsd_t_-ao-ecc, cfour/scf4,; cfour/mints5.; Analytic gradient() and optimize(); commands for ground state methods. Real and; Ghost atoms permitted (though the latter will naturally collapse after; several cycles). Examples: cfour/opt-rhf-ccsd_t_,; cfour/mp2-1, and cfour/mints5-grad. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Finite difference of energy gradient() and; optimize() for methods.; Force with gradient('name', dertype=0), etc..; nbody_gufunc() for computation of interaction energies with or; without counterpoise correction. Example: cfour/dfmp2-1.; database() for computation of a collection of molecules in a; single input, with summarization of results. Examples:; cfour/pywrap-db1 and cfour/psi-a24-grad.; complete_basis_set() for computation of compound methods involving; basis set extrapolations and/or delta corrections with any combination; of PSI4 and Cfour computational methods and PSI4 basis sets.; Example: cfour/pywrap-cbs1. Not Yet Implemented. Ground state CI energies and optimizations; Excited state energies and optimizations; Properties are not yet regex-ed, transformed into input frame, and; stowed in PSI Variables.; Property calls that required extra computation not yet translated into; property() computation command; Frequencies. Energy methods available through P4C4 interface. name; calls method in Stanton and Gaus",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:25167,energy,energy,25167,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,6,['energy'],['energy']
Energy Efficiency,"heckpoint file is renamed, using the PSIO handler. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. dcft-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. dft-grad-lr3; wB97X-D test for a large UKS molecule. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. pywrap-db2; Database calculation, run in sow/reap mode. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly. ocepa2; OCEPA cc-pVDZ energy with B3LYP initial guess for the NO radical. dcft5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. opt-irc-1; Compute the IRC for HOOH torsional rotation",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:10893,energy,energy,10893,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"heckrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. casscf-sp; CASSCF/6-31G** energy point. dfccsd-grad2; DF-CCSD cc-pVDZ gradient for the NH molecule. opt15; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. pywrap-align; apply linear fragmentation algorithm to a water cluster. cubeprop-frontier; ROHF frontier orbitals of CH2(s) and CH2(t). nbody-multi-level-2; many-body different levels of theory on each body of helium tetramer. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. fci-h2o-2; 6-31G H2O Test FCI Energy Point. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. nbody-he-4b; MP2/aug-cc-pvDZ many body energies of an arbitrary Helium complex, addressing 4-body formulas. sapt10; usapt example with empty beta due to frozen core. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:6499,energy,energy,6499,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"hell; systems with an RHF reference) and for Z-averaged perturbation theory; (ZAPTn, open-shell systems with an ROHF reference). However, please; note that these computations are essentially doing high-order CI (up to; full CI) computations to obtain these results, and hence they will only; be possible for very small systems (generally a dozen electrons or less).; The simplest way to run high-order perturbation theory computations is to; call, e.g., energy('mp10') to invoke a MP10 computation or; energy('zapt25') to invoke a ZAPT25 computation. This will; automatically set several additional user options to their appropriate; values. The program uses the Wigner (2n+1) rule to obtain higher-order; energies from lower-order wavefunctions.; For the interested reader, the additional user options that are; automatically set up by the calls above are as follows. A call like; energy('mp10') sets MPN to TRUE.; The program uses the Wigner (2n+1) rule by default; (MPN_WIGNER = TRUE); and figures out what order of wavefunction is; necessary to reach the desired order in the energy. The program then; sets MAX_NUM_VECS to the required order in the; wavefunction.; By default, the requested n-th order energy is saved as the current; energy to the process environment. ZAPTN works essentially the same; way for an ROHF reference. Arbitrary Order Coupled-Cluster Theory¶; This DETCI-based version of this feature is not yet released. However,; the current version of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/detci-1.html:10077,energy,energy,10077,psi4manual/1.0.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/detci-1.html,10,['energy'],['energy']
Energy Efficiency,"help efficiency, but hazardous when solving for higher roots. Type: boolean; Default: false. COMPLEX_TOLERANCE (CCEOM)¶CCEOM — Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. COMPUT_S2 (DFOCC)¶DFOCC — Do compute \(\langle \hat{S}^2 \rangle\) for DF-OMP2/DF-MP2?. Type: boolean; Default: false. COMPUTE_MP4_TRIPLES (FNOCC)¶FNOCC (Expert) — Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES (FNOCC)¶FNOCC (Expert) — Do compute triples contribution?. Type: boolean; Default: true. CONSECUTIVE_BACKSTEPS (OPTKING)¶OPTKING — Set number of consecutive backward steps allowed in optimization. Type: integer; Default: 0. CORR_ANSATZ (PSIMRCC)¶PSIMRCC — The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T (PSIMRCC)¶PSIMRCC — The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE (PSIMRCC)¶PSIMRCC — The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP (PSIMRCC)¶PSIMRCC — The multiplicity, \(M_S(M_S+1)\), of the target state. Must be specified if different from the reference \(M_s\). Type: integer; Default: 1. CORR_WFN (PSIMRCC)¶PSIMRCC — The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COSX_BASIS_TOLERANCE (SCF)¶SCF (Expert) — Screening criteria for basis function values on COSX grids. Type: conv double; Default: 1.0e-10. COSX_DENSITY_TOLERANCE (SCF)¶SCF (Expert) — Screening criteria for shell-pair densities in COSX. Type: conv double; Default: 1.0e-10. COSX_INCFOCK (SCF)¶SCF (Expert) — Do allow for improved COSX screening performance by constructing the Fock matrix incrementally?. Type: boolean; Default: true. COSX_INTS_TOLERANCE (SCF)¶SCF — Screening criteria for integrals and intermediates in COSX. Type: conv double; Default: 1.0e-11. COSX_OVERLAP_FITTING (SCF)¶SCF (Expert) — Do reduce numeric",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html:88394,charge,charge,88394,psi4manual/1.6.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html,1,['charge'],['charge']
Energy Efficiency,"help efficiency, but hazardous when solving for higher roots. Type: boolean; Default: false. COMPLEX_TOLERANCE (CCEOM)¶CCEOM — Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. COMPUT_S2 (DFOCC)¶DFOCC — Do compute \(\langle \hat{S}^2 \rangle\) for DF-OMP2/DF-MP2?. Type: boolean; Default: false. COMPUTE_MP4_TRIPLES (FNOCC)¶FNOCC (Expert) — Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES (FNOCC)¶FNOCC (Expert) — Do compute triples contribution?. Type: boolean; Default: true. CONSECUTIVE_BACKSTEPS (OPTKING)¶OPTKING — Set number of consecutive backward steps allowed in optimization. Type: integer; Default: 0. CORR_ANSATZ (PSIMRCC)¶PSIMRCC — The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T (PSIMRCC)¶PSIMRCC — The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE (PSIMRCC)¶PSIMRCC — The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP (PSIMRCC)¶PSIMRCC — The multiplicity, \(M_S(M_S+1)\), of the target state. Must be specified if different from the reference \(M_s\). Type: integer; Default: 1. CORR_WFN (PSIMRCC)¶PSIMRCC — The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COSX_BASIS_TOLERANCE (SCF)¶SCF (Expert) — Screening criteria for basis function values on COSX grids. Type: conv double; Default: 1.0e-10. COSX_DENSITY_TOLERANCE (SCF)¶SCF (Expert) — Screening criteria for shell-pair densities in COSX. Type: conv double; Default: 1.0e-10. COSX_INTS_TOLERANCE (SCF)¶SCF — Screening criteria for integrals and intermediates in COSX. Type: conv double; Default: 1.0e-11. COSX_MAXITER_FINAL (SCF)¶SCF — Controls SCF iteration behavior for the larger (i.e., final) COSX grid. -1 fully converges the SCF on the final grid if possible, ending early if MAXITER total SCF iterations are reached (f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_glossary_options_c.html:88223,charge,charge,88223,psi4manual/1.9.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_glossary_options_c.html,2,['charge'],['charge']
Energy Efficiency,"help efficiency, but hazardous when solving for higher roots. Type: boolean; Default: false. COMPLEX_TOLERANCE (CCEOM)¶CCEOM — Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. COMPUT_S2 (DFOCC)¶DFOCC — Do compute \(\langle \hat{S}^2 \rangle\) for DF-OMP2/DF-MP2?. Type: boolean; Default: false. COMPUTE_MP4_TRIPLES (FNOCC)¶FNOCC (Expert) — Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES (FNOCC)¶FNOCC (Expert) — Do compute triples contribution?. Type: boolean; Default: true. CONSECUTIVE_BACKSTEPS (OPTKING)¶OPTKING — Set number of consecutive backward steps allowed in optimization. Type: integer; Default: 0. CORR_ANSATZ (PSIMRCC)¶PSIMRCC — The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T (PSIMRCC)¶PSIMRCC — The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE (PSIMRCC)¶PSIMRCC — The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP (PSIMRCC)¶PSIMRCC — The multiplicity, \(M_S(M_S+1)\), of the target state. Must be specified if different from the reference \(M_s\). Type: integer; Default: 1. CORR_WFN (PSIMRCC)¶PSIMRCC — The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COSX_BASIS_TOLERANCE (SCF)¶SCF (Expert) — Screening criteria for basis function values on COSX grids. Type: conv double; Default: 1.0e-10. COSX_DENSITY_TOLERANCE (SCF)¶SCF (Expert) — Screening criteria for shell-pair densities in COSX. Type: conv double; Default: 1.0e-10. COSX_INTS_TOLERANCE (SCF)¶SCF — Screening criteria for integrals and intermediates in COSX. Type: conv double; Default: 1.0e-11. COSX_OVERLAP_FITTING (SCF)¶SCF (Expert) — Do reduce numerical COSX errors with overlap fitting?. Type: boolean; Default: true. COSX_PRUNING_SCHEME (SCF)¶SCF (Expert) — Pruning scheme for COSX grids. Type: string; Default",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:88221,charge,charge,88221,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,2,['charge'],['charge']
Energy Efficiency,"help efficiency, but hazardous when solving for higher roots. Type: boolean; Default: false. COMPLEX_TOLERANCE (CCEOM)¶CCEOM — Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. COMPUT_S2 (DFOCC)¶DFOCC — Do compute \(\langle \hat{S}^2 \rangle\) for DF-OMP2/DF-MP2?. Type: boolean; Default: false. COMPUTE_MP4_TRIPLES (FNOCC)¶FNOCC (Expert) — Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES (FNOCC)¶FNOCC (Expert) — Do compute triples contribution?. Type: boolean; Default: true. CONSECUTIVE_BACKSTEPS (OPTKING)¶OPTKING — Set number of consecutive backward steps allowed in optimization. Type: integer; Default: 0. CORR_ANSATZ (PSIMRCC)¶PSIMRCC — The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T (PSIMRCC)¶PSIMRCC — The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE (PSIMRCC)¶PSIMRCC — The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP (PSIMRCC)¶PSIMRCC — The multiplicity, \(M_S(M_S+1)\), of the target state. Must be specified if different from the reference \(M_s\). Type: integer; Default: 1. CORR_WFN (PSIMRCC)¶PSIMRCC — The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COUPLED_INDUCTION (SAPT)¶SAPT (Expert) — Solve the CPHF equations to compute coupled induction and exchange-induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. COUPLING (PSIMRCC)¶PSIMRCC — The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS (PSIMRCC)¶PSIMRCC — Do include the terms that couple the reference dete",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:88710,charge,charge,88710,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,4,['charge'],['charge']
Energy Efficiency,"helper(name, **kwargs). return PsiMod.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). PsiMod.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = PsiMod.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf(name, **kwargs); returnvalue = PsiMod.get_variable('CURRENT ENERGY'). for ssuper in superfunctional_list():; if ssuper.name().lower() == name.lower():; dfun = ssuper. if dfun.is_c_hybrid():. # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). if dfun.is_c_scs_hybrid():; PsiMod.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); PsiMod.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); PsiMod.dfmp2(); vdh = dfun.c_alpha() * PsiMod.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; PsiMod.dfmp2(); vdh = dfun.c_alpha() * PsiMod.get_variable('MP2 CORRELATION ENERGY'). PsiMod.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; PsiMod.set_variable('DFT TO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:35964,ENERGY,ENERGY,35964,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"heme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_Karton_2: datatype is not recognized '{type(valueLO)}'.""). [docs]def scf_xtpl_helgaker_3(functionname: str, zLO: int, valueLO: Extrapolatable, zMD: int, valueMD: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 3-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 3-point; extrapolation.; zMD; Zeta number of the medium basis set in 3-point extrapolation.; Must be `zLO + 1`.; valueMD; Energy, gradient, or Hessian value at the medium basis set in 3-point; extrapolation.; zHI; Zeta number of the larger basis set in 3-point extrapolation.; Must be `zLO + 2`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 3-point; extrapolation.; verbose; Controls volume of printing.; alpha; Not used. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [4]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 3.0`. References; ----------. .. [4] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(; f""scf_xtpl_helgaker_3: Inputs must b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:14027,Energy,Energy,14027,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Energy'],['Energy']
Energy Efficiency,"hemistry software package; #; # Copyright (c) 2007-2016 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; from __future__ import print_function; from __future__ import absolute_import; import shutil; import os; import subprocess; import re. # Relative hack for now; import sys, inspect; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],""../""))); sys.path.append(path_dir); import p4util; from p4util.exceptions import *; from molutil import *. from .functional import *; from .roa import *; from . import proc_util. # never import driver, wrappers, or aliases into this file. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. [docs]def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:1243,energy,energy,1243,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['energy'],['energy']
Energy Efficiency,"heory¶; QCI and CC methods are closely related to perturbation theory, and the; MP2, MP3, and MP4(SDQ) correlation energies can be obtained as a free; by-product of a CCSD or QCISD computation. The following is an; example of the results for a computation run with the call; energy('fno-qcisd') to energy():; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30QCISD iterations converged!. OS MP2 FNO correction: -0.000819116338; SS MP2 FNO correction: -0.000092278158; MP2 FNO correction: -0.000911394496. OS MP2 correlation energy: -0.166478414245; SS MP2 correlation energy: -0.056669079827; MP2 correlation energy: -0.223147494072; * MP2 total energy: -76.258836941658. OS MP2.5 correlation energy: -0.171225850256; SS MP2.5 correlation energy: -0.054028401038; MP2.5 correlation energy: -0.225254251294; * MP2.5 total energy: -76.260943698880. OS MP3 correlation energy: -0.175973286267; SS MP3 correlation energy: -0.051387722248; MP3 correlation energy: -0.227361008515; * MP3 total energy: -76.263050456101. OS MP4(SDQ) correlation energy: -0.180324322304; SS MP4(SDQ) correlation energy: -0.048798468084; MP4(SDQ) correlation energy: -0.230995119324; * MP4(SDQ) total energy: -76.266684566910. OS QCISD correlation energy: -0.181578117924; SS QCISD correlation energy: -0.049853548145; QCISD correlation energy: -0.231431666069; * QCISD total energy: -76.267121113654. The first set of energies printed corresponds to the second-order FNO; correction mentioned previously. Results for many-body perturbation; theory through partial fourth order are then provided.; The notation MP4(SDQ) indicates that we have included all contributions to; the correlation energy through fourth order, with the exception of that; from connected triple excitations.; One need not run a full QCISD or CCSD computation to obtain these; perturbation theory results. The keywords for invoking perturbation; theory computations are given below in; Table FNO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:5914,energy,energy,5914,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,6,['energy'],['energy']
Energy Efficiency,"her response theories as CC2-LR, CIS(D) and CIS(D\(_n\)) has; been addressed [Haettig:2002] by Hattig et al. In the ADC theory,; the residue calculus of the propagator is translated into the eigenvalue; problem with respect to the correlated response matrix, also known as the; shifted-Hamiltonian. The σ-vectors (Hamiltonian-vector products); are constructed several times in the simultaneous expansion method (SEM); to solve the eigenvalue problem, and each σ-vector construction; has a computational cost that scales as \({\cal O}(N^5)\). In addition,; the tensorial form of the σ-vector resembles to that of the; doubles correction in the CIS(D) energetic equation. As a consequence,; the pre-factor in the polynomial scaling becomes far larger than that; of the CIS(D) even though the quasi-degeneracy of the excited state is; properly accounted for in the ADC(2) model.; The ADC code makes use of the libtrans library for efficient and flexible; integral-transformation and also the libdpd library to; utilize molecular symmetry in the tensorial manipulations in framework; of the direct-product decomposition algorithm. By this feature, the Ritz; space and intermediate tensors are blocked according to the irreducible; representations of the point group, and the excited states that belong; to different symmetry are sought separately.; In the output of ADC, the ADC(2) results may look as follows:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13-> 1 B1 state : 0.2565095 (a.u.), 6.9799824 (eV); Non-iterative: 0.2565636 (a.u.), 6.9814532 (eV); Occ Vir Coefficient; ---------------------------------------------; 3 0 -0.9017047264; 3 2 0.3038332241; 3 1 0.2907567119; 3 5 -0.0790167706; 3 4 -0.0425829926. Converged in 4 iteration.; Squared norm of the S component: 0.9315336; The S vector is rotated up to 8.102 (deg.). in which the ADC(2) excitation energy is indicated with arrow symbol; and the pseudo-perturbative value, which is calculated in very similar; fashion to the CIS(D) energy, is al",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/adc-1.html:1888,efficient,efficient,1888,psi4manual/1.2.1/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/adc-1.html,6,['efficient'],['efficient']
Energy Efficiency,"her value used for extrapolation.; alpha : float, optional; Overrides the default :math:`\alpha = 6.3`. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [3]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha\sqrt{X}}, \alpha = 6.3`. References; ----------. .. [3] Karton, Martin, Theor. Chem. Acc. 115 (2006) 330-333,; DOI: 10.1007/s00214-005-0028-6. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; ""scf_xtpl_karton_2: Inputs must be of the same datatype! (%s, %s)"" % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 6.30. beta_division = 1 / (math.exp(-1 * alpha) * (math.exp(math.sqrt(zHI)) - math.exp(math.sqrt(zLO)))); beta_mult = math.exp(-1 * alpha * math.sqrt(zHI)). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Karton 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), zeta_val2sym[zLO].upper(), zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; beta = valueHI.clone(); beta.name = 'Karton SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Karton SCF (%s, %s) data' % (zLO, zHI). if verbose >",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:14717,power,power,14717,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['power'],['power']
Energy Efficiency,"here are any electrons in RAS III, then the number of holes in RAS I cannot exceed the given excitation level EX_LEVEL. Type: boolean; Default: true. MIXED4 (DETCI); DETCI (Expert) — Do allow “mixed” excitations involving RAS IV into the CI space. Useful to specify a split-virtual CISD[TQ] computation. If FALSE, then if there are any electrons in RAS IV, then the number of holes in RAS I cannot exceed the given excitation level EX_LEVEL. Type: boolean; Default: true. MO_DIIS_NUM_VECS (OCC); OCC — Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER (OCC); OCC — Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ (MCSCF); MCSCF — Do read in from file the MOs from a previous computation?. Type: boolean; Default: true. MO_READ (OCC); OCC — Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_RELAX (DCFT); DCFT (Expert) — Controls whether to relax the orbitals during the energy computation or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: true. MO_STEP_MAX (OCC); OCC — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE (OCC); OCC — Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MODE (TRANSQT); TRANSQT — The way of transformation, from ao basis to mo basis or vice versa. Type: string; Possible Values: TO_MO, TO_AO; Default: TO_MO. MODULE (CPHF); CPHF — What app to test?. Type: string; Possible Values: RCIS, RCPHF, RTDHF, RCPKS, RTDA, RTDDFT; Default: RCIS. MOGRAD_DAMPING (OCC); OCC — Damping factor for the orbital gradient (Rendell et al., JCP, vol. 87, pp. 5976, 1987). Type: double; Default: 1.0. MOLDEN_WRITE (SCF); SCF — Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or els",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:78066,energy,energy,78066,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"here isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Specific open-shell SAPT0 keywords¶. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. COUPLED_INDUCTION¶. Solve the CPHF equations to compute coupled induction and exchange-induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies for closed-shell systems; only. Publications resulting from the use of the higher-order SAPT code; should cite the following:; [Hohenstein:2010:014101].; For methods SAPT2+ and above, one can replace the many-body treatment of; dispersion by an improved method based on coupled-cluster doubles (CCD).; This approach tends to give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]).; As shown in [Parker:2014:094106], whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/sapt-1.html:18655,energy,energy,18655,psi4manual/1.2.1/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/sapt-1.html,4,['energy'],['energy']
Energy Efficiency,"here isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Specific open-shell SAPT0 keywords¶. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. COUPLED_INDUCTION¶. Solve the CPHF equations to compute coupled induction and exchange-induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. SAPT(DFT)¶; In general, SAPT(DFT) should provide more accurate interaction energy; components, and overall interaction energies, than SAPT0. The drawback; is SAPT(DFT) method is more computationally demanding than SAPT0,; SAPT(DFT) can still be applied to medium-sized or large systems. The; SAPT(DFT) module was employed successfully in computations of systems; with up to 2000 basis functions, and the code should be scalable to; 3000 basis functions. Like higher-order SAPT, SAPT(DFT) requires; sufficient memory to hold \(2ovN_aux\) doubles.; SAPT(DFT) requires a few special treatments to obtain accurate; result. The DFT functionals used in SAPT(DFT) need to be asymptotically; corrected with Gradient Regulated Asymptotic Correction scheme (GRAC),; in order to recover the correct long-range asymptotic behavior; (approaching \(-1/r\) as \(r\) approaches infinity). The program; requires manual input of GRAC shift parameter for ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:20997,energy,energy,20997,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['energy'],['energy']
Energy Efficiency,"herrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/sapt-1.html:2849,energy,energy,2849,psi4manual/4.0b2/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html,30,['energy'],['energy']
Energy Efficiency,"herwise. xtpl_highest_1(); scf_xtpl_helgaker_3(); scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_scheme (Callable) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in corl_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). delta_scheme (Callable) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). delta2_scheme (Callable) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). scf_alpha (float) – \(\Rightarrow\) 1.63 \(\Leftarrow\); Overrides the default alpha parameter used in the listed SCF extrapolation procedures.; Has no effect on others, including xtpl_highest_1() and scf_xtpl_helgaker_3(). scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_alpha (float) – \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the listed corl_xtpl_helgaker_2() correlation; extrapolation to the corl stage. The supplied alpha does not impact delta or any further stages. corl_xtpl_helgaker_2(). delta_alpha (float) – \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the listed; corl_xtpl_helgaker_2() correlation extrapolation for the delta correction. Useful when; delta correcti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html:9249,energy,energy,9249,psi4manual/1.4.0/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html,12,['energy'],['energy']
Energy Efficiency,"hes. For example, FD_IRREP=1/3/4 means compute the frequencies of modes transforming as the first, third, and fourth irreducible representations. If a symmetry is specified for which there are no vibrational modes, the program will terminate. The labels of the irreducible representations for this keyword are not usually the same as those used in the rest of the calculation. Moreover, for some point groups, for example, those of linear molecules, the two sets of labels refer to different subgroups. There is as yet no straightforward way to determine what they will be without starting a calculation. If one runs the xjoda and then the xsymcor executables, the relevant irreducible representations will be listed. If all vibrational frequencies are desired, this keyword need not be included. Default : compute vibrational frequencies for all irreducible representations. Type: array; Default: No Default. CFOUR_FD_PROJECT (CFOUR); CFOUR — Specifies whether or not rotational degrees of freedoms are projected out from the symmetry-adapted coordinates in a finite difference calculations. ON (=0) uses rotationally projected coordinates, while OFF (=1) retains the rotational degrees of freedom. At a stationary point on the potential energy surface, both options will give equivalent harmonic force fields, but OFF should be used at non-stationary points. Type: string; Possible Values: ON, OFF; Default: ON. CFOUR_FD_STEPSIZE (CFOUR); CFOUR — Specifies the step length in mass-weighted coordinates (in ) used in generating the force constant matrix by finite difference of Cartesian gradients. Type: integer; Default: 5. CFOUR_FD_USEGROUP (CFOUR); CFOUR — In finite difference calculations using the FINDIF option, this keyword specifies the point group to be used in generating the symmetry-adapted vibrational coordinates. FULL (= 0) specifies the full molecular point group, COMP (= 1) specifies the Abelian subgroup used in the electronic structure calculation. Type: string; Possible Values",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:42496,adapt,adapted,42496,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['adapt'],['adapted']
Energy Efficiency,"hes. For example, FD_IRREP=1/3/4 means compute the frequencies of modes transforming as the first, third, and fourth irreducible representations. If a symmetry is specified for which there are no vibrational modes, the program will terminate. The labels of the irreducible representations for this keyword are not usually the same as those used in the rest of the calculation. Moreover, for some point groups, for example, those of linear molecules, the two sets of labels refer to different subgroups. There is as yet no straightforward way to determine what they will be without starting a calculation. If one runs the xjoda and then the xsymcor executables, the relevant irreducible representations will be listed. If all vibrational frequencies are desired, this keyword need not be included. Default : compute vibrational frequencies for all irreducible representations. Type: array; Default: No Default. CFOUR_FD_PROJECT (CFOUR); CFOUR — Specifies whether or not rotational degrees of freedoms are projected out from the symmetry-adapted coordinates in a finite difference calculations. ON (=0) uses rotationally projected coordinates, while OFF (=1) retains the rotational degrees of freedom. At a stationary point on the potential energy surface, both options will give equivalent harmonic force fields, but OFF should be used at non-stationary points. Type: string; Possible Values: ON, OFF; Default: ON. CFOUR_FD_STEPSIZE (CFOUR); CFOUR — Specifies the step length in mass-weighted coordinates (in \(10^{-4} amu^{1/2} bohr\) ) used in generating the force constant matrix by finite difference of Cartesian gradients. Type: integer; Default: 5. CFOUR_FD_USEGROUP (CFOUR); CFOUR — In finite difference calculations using the FINDIF option, this keyword specifies the point group to be used in generating the symmetry-adapted vibrational coordinates. FULL (= 0) specifies the full molecular point group, COMP (= 1) specifies the Abelian subgroup used in the electronic structure calculation. Ty",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:42534,adapt,adapted,42534,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['adapt'],['adapted']
Energy Efficiency,"hes. For example, FD_IRREP=1/3/4 means compute the frequencies of modes transforming as the first, third, and fourth irreducible representations. If a symmetry is specified for which there are no vibrational modes, the program will terminate. The labels of the irreducible representations for this keyword are not usually the same as those used in the rest of the calculation. Moreover, for some point groups, for example, those of linear molecules, the two sets of labels refer to different subgroups. There is as yet no straightforward way to determine what they will be without starting a calculation. If one runs the xjoda and then the xsymcor executables, the relevant irreducible representations will be listed. If all vibrational frequencies are desired, this keyword need not be included. Default : compute vibrational frequencies for all irreducible representations. Type: array; Default: No Default. CFOUR_FD_PROJECT (CFOUR)¶CFOUR — Specifies whether or not rotational degrees of freedoms are projected out from the symmetry-adapted coordinates in a finite difference calculations. ON (=0) uses rotationally projected coordinates, while OFF (=1) retains the rotational degrees of freedom. At a stationary point on the potential energy surface, both options will give equivalent harmonic force fields, but OFF should be used at non-stationary points. Type: string; Possible Values: ON, OFF; Default: ON. CFOUR_FD_STEPSIZE (CFOUR)¶CFOUR — Specifies the step length in mass-weighted coordinates (in \(10^{-4} amu^{1/2} bohr\) ) used in generating the force constant matrix by finite difference of Cartesian gradients. Type: integer; Default: 5. CFOUR_FD_USEGROUP (CFOUR)¶CFOUR — In finite difference calculations using the FINDIF option, this keyword specifies the point group to be used in generating the symmetry-adapted vibrational coordinates. FULL (= 0) specifies the full molecular point group, COMP (= 1) specifies the Abelian subgroup used in the electronic structure calculation. Type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:42877,adapt,adapted,42877,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['adapt'],['adapted']
Energy Efficiency,"hese shifts approximate the effects of triple and quadruple excitations.; The values for \(\Delta_{ij}\) and \(\Delta_i\) used in several; coupled-pair methods are given in Table CEPA Shifts. Note that these shifts are defined in a spin-free; formalism for closed-shell references only. method; \(\Delta_{ij}\); \(\Delta_i\). cisd; \(E_c\); \(E_c\). cepa(0); 0; 0. cepa(1); \(\frac{1}{2}\sum_k(\epsilon_{ik}+\epsilon_{jk})\); \(\sum_k \epsilon_{ik}\). cepa(3); \(-\epsilon_{ij}+\sum_k(\epsilon_{ik}+\epsilon_{jk})\); \(-\epsilon_{ii}+2\sum_k \epsilon_{ik}\). acpf; \(\frac{2}{N} E_c\); \(\frac{2}{N} E_c\). aqcc; \([1-\frac{(N-3)(N-2)}{N(N-1)}]E_c\); \([1-\frac{(N-3)(N-2)}{N(N-1)}]E_c\). The pair correlation energy, \(\epsilon_{ij}\), is simply a partial; sum of the correlation energy. In a spin-free formalism, the pair energy; is given by. (7)¶\[\epsilon_{ij} = \sum_{ab} v_{ij}^{ab} (2 t_{ij}^{ab} - t_{ij}^{ba})\]; Methods whose shifts (\(\Delta_{ij}\) and \(\Delta_i\)) do not; explicitly depend on orbitals \(i\) or \(j\) (CISD, CEPA(0), ACPF,; and AQCC) have solutions that render the energy stationary with respect; variations in the amplitudes. This convenient property allows density; matrices and 1-electron properties to be evaluated without any additional; effort. Note, however, that 1-electron properties are currently; unavailable when coupling these stationary CEPA-like methods with frozen; natural orbitals. Density-fitted coupled cluster¶; Density fitting (DF) [or the resolution of the identity (RI)] and Cholesky; decomposition (CD) techniques are popular in quantum chemistry to avoid; the computation and storage of the 4-index electron repulsion integral; (ERI) tensor and even to reduce the computational scaling of some terms.; DF/CD-CCSD(T) computations are available in PSI4, with or without the; use of FNOs, through the FNOCC module. The implementation and accuracy of; the DF/CD-CCSD(T) method are described in [DePrince:2013:2687].; The DF-CCSD(T) procedure uses t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:9977,energy,energy,9977,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,15,['energy'],['energy']
Energy Efficiency,"hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, ref_gradient=G, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if not core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT'):; if not core.get_option('OPTKING', 'KEEP_INTCOS'):; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_speci",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:67225,energy,energy,67225,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"hest_point_group(); new_bits = parent_group.bits() & disp_group.bits(); new_symm_string = qcdb.PointGroup.bits_to_full_name(new_bits); clone.reset_point_group(new_symm_string). # clean possibly necessary for n=1 if its irrep (unsorted in displacement list) different from initial G0 for freq; core.clean(). # Perform the derivative calculation; derivative, wfn = derivfunc(method, return_wfn=True, molecule=clone, **kwargs); displacement[""energy""] = core.variable('CURRENT ENERGY'). # If we computed a first or higher order derivative, set it.; if derivfunc == gradient:; displacement[""gradient""] = wfn.gradient().np.ravel().tolist(). # clean may be necessary when changing irreps of displacements; core.clean(). return wfn. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type restart_file: string; :param restart_file: ``['file.1, file.32]`` || ``./file`` || etc. Binary data files to be renamed for calculation restart. .. _`table:energy_gen`:. +--",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:7125,energy,energy,7125,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"hf-scf; single-point HF/qz2p on water. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/kw-1; testing best practices options, part i. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Test Suite and Sample Inputs; CFOUR. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_cfour-1.html:4354,energy,energy,4354,psi4manual/1.5.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"hf; scf_type df; basis aug-cc-pVDZ; }. energy('sapt0'). REFERENCE needs to be UHF or ROHF for the open-shell computation to proceed. Advanced example¶; Open-shell computations can be difficult to converge in certain cases, thus you may; want to have more control over the SCF procedure. You have the option of; doing the driver job in the input file, by performing the dimer and monomer computations; yourself. In the example below, we do a stability analysis for the open-shell monomer only; molecule {; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; --; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; units bohr; symmetry c1; no_reorient; no_com; }. dimer = psi4.get_active_molecule(). set {; reference uhf; scf_type df; basis cc-pVDZ; df_basis_sapt cc-pVDZ-ri; guess sad; }. dimer = psi4.get_active_molecule(). set df_ints_io save; psi4.IO.set_default_namespace('dimer'); Edim, wfn_dimer = energy('scf',molecule=dimer,return_wfn=True); set df_ints_io load. monomerA = dimer.extract_subsets(1,2); psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); set {; stability_analysis follow; }; EmonA, wfn_monA = energy('scf',molecule=monomerA,return_wfn=True). monomerB = dimer.extract_subsets(2,1); psi4.IO.change_file_namespace(97, 'monomerA', 'monomerB'); psi4.IO.set_default_namespace('monomerB'); set {; stability_analysis none; }; EmonB, wfn_monB = energy('scf',molecule=monomerB,return_wfn=True). psi4.IO.change_file_namespace(97, 'monomerB', 'dimer'); psi4.IO.set_default_namespace('dimer'). aux_basis = psi4.core.BasisSet.build(wfn_dimer.molecule(), ""DF_BASIS_SAPT"",; psi4.core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", psi4.core.get_global_option(""BASIS"")); wfn_dimer.set_basisset(""DF_BASIS_SAPT"", aux_basis); wfn_dimer.set_basisset(""DF_BASIS_ELST"", aux_basis). psi4.sapt(wfn_dimer,wfn_monA,wfn_monB). In this way, any of the SCF options can be t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:14330,energy,energy,14330,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['energy'],['energy']
Energy Efficiency,"hich code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp (bool) – Whether to request atomic pairwise analysis. Methods Summary. compute_energy(molecule[, wfn]); Compute dispersion energy based on engine, dispersion level, and parameters in self. compute_gradient(molecule[, wfn]); Compute dispersion gradient based on engine, dispersion level, and parameters in self. compute_hessian(molecule[, wfn]); Compute dispersion Hessian based on engine, dispersion level, and parameters in self. print_out(); Format dispersion parameters of self for output file. Methods Documentation. compute_energy(molecule, wfn=None)[source]¶; Compute dispersion energy based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule) – System for which to compute empirical dispersion correction.; wfn (Optional[Wavefunction]) – Location to set QCVariables. Returns:; Dispersion energy [Eh]. Return type:; float. Notes. DISPERSION CORRECTION ENERGYDisp always set. Overridden in SCF finalization, but that only changes for “-3C” methods. fctl DISPERSION CORRECTION ENERGYSet if fctldash nonempty. compute_gradient(molecule, wfn=None)[source]¶; Compute dispersion gradient based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule) – System for which to compute empirical dispersion correction.; wfn (Optional[Wavefunction]) – Location to set QCVariables. Returns:; (nat, 3) dispersion gradient [Eh/a0]. Return type:; Matrix. compute_hessian(molecule, wfn=None)[source]¶; Compute dispersion Hessian based on engine, dispersion level, and parameters in self.; Uses finite difference, as no dispersion engine has analytic second derivatives. Parameters:. molecule (Molecule) – System for which to compute empirical dispersion correction.; wfn (Optional[Wavefunction]) – Location to set QCVariables. Returns:; (3*nat, 3*nat) dispersion Hessian [Eh/a0/a0]. Return type:; Matrix. print_out()[source]¶; Format disper",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.EmpiricalDispersion.html:4566,ENERGY,ENERGYDisp,4566,psi4manual/1.7.x/api/psi4.driver.EmpiricalDispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.EmpiricalDispersion.html,3,['ENERGY'],['ENERGYDisp']
Energy Efficiency,"hich is important for the evaluation of the molecular properties. The additive; separability of the density cumulant guarantees that all of the DCFT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent part of \(\boldsymbol{\gamma_1}\) is; N-representable by construction. One only needs to worry about the; N-representability of the density cumulant, which is a relatively small part of; \(\boldsymbol{\gamma_2}\).; In order to obtain the DCFT energy, two conditions must be satisfied:. The energy must be stationary with respect to a set of orbitals. This can be done by; diagonalizing the generalized Fock operator (as in the DC-06 and DC-12 methods, see below),; which introduces partial orbital relaxation, or by fully relaxing the orbitals and minimizing the entire energy expression; (as in the ODC-06 and ODC-12 methods).; The energy must be stationary with respect to the variation of the density; cumulant \(\boldsymbol{\lambda_2}\), constrained to N-representability conditions. Making the energy stationary requires solution of two sets of coupled; equations for orbitals and density cumulant, respectively (also known as; residual equations). At the present moment, three different algorithms for the; solution of the system of coupled equations are available (see; Iterative Algorithms for details).; Publications resulting from the use of the DCFT code should cite contributions; listed here. Methods¶; Currently five DCFT methods (functionals) are available: DC-06, DC-12, ODC-06, ODC-12, and ODC-13. The first four; methods use approximate N-representability conditions derived from; second-order perturbation theory and differ in the description of the; correlated (non-idempotent) part \(\boldsymbol{\tau}\) of the one-particle density; matrix and orbital optimization. While in the DC-06 and ODC-06 methods \(\boldsymbol{\tau}\) is derived from the density cumulant; in an approximate way ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dcft-1.html:4059,energy,energy,4059,psi4manual/1.2.1/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dcft-1.html,6,['energy'],['energy']
Energy Efficiency,"hich to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl : str, optional; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam : dict, optional; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype : int or str, optional; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose : int, optional; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras'][",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/qcdb/molecule.html:43440,energy,energy,43440,psi4manual/1.5.0/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/qcdb/molecule.html,8,['energy'],['energy']
Energy Efficiency,"hift can improve convergence, it does change the DCT energy. Type: double; Default: 0.0. INTS_TOLERANCE¶. Schwarz screening threshold. Mininum absolute value below which TEI are neglected. Type: conv double; Default: 1e-14. ORBITAL_LEVEL_SHIFT¶. The shift applied to the denominator in the orbital update iterations. Type: double; Default: 0.0. RELAX_GUESS_ORBITALS¶. Controls whether to relax the guess orbitals by taking the guess density cumulant and performing orbital update on the first macroiteration (for ALOGRITHM = TWOSTEP only). Type: boolean; Default: false. STABILITY_ADD_VECTORS¶. The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_AUGMENT_SPACE_TOL¶. The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK¶. Performs stability analysis of the DCT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE¶. Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE¶. The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied. Type: integer; Default: 200. STABILITY_N_EIGENVALUES¶. The number of Hessian eigenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS¶. The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. TIKHONOW_OMEGA¶. The shift applied to the denominator in the density cumulant update iterations. Type: double; Default: 0.0. table of contents. DCT; General; ALGORITHM; AO_BASIS; DCT_FUNCTIONAL; DCT_TYPE; DF_BASIS_DCT; DIIS_START_CONVERGENCE; E_CONVERGENCE; GUESS_R_CONVERGENCE; MAXITER; ODC_GUESS; OPDM; QC_COU",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__dct-1.html:6017,energy,energy,6017,psi4manual/1.4.0/autodir_options_c/module__dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__dct-1.html,18,['energy'],['energy']
Energy Efficiency,"hifts for the; doubles and singles equations, \(\Delta_{ij}\) and \(\Delta_i\):. (6)¶\[\begin{split}0 &= \langle \Psi_{ij}^{ab} | \hat{H} - E_0 - \Delta_{ij} | \Psi \rangle, \\; 0 &= \langle \Psi_{i}^{a} | \hat{H} - E_0 - \Delta_i | \Psi \rangle.\end{split}\]; These shifts approximate the effects of triple and quadruple excitations.; The values for \(\Delta_{ij}\) and \(\Delta_i\) used in several; coupled-pair methods are given in Table CEPA Shifts. Note that these shifts are defined in a spin-free; formalism for closed-shell references only. method; \(\Delta_{ij}\); \(\Delta_i\). cisd; \(E_c\); \(E_c\). cepa(0); 0; 0. cepa(1); \(\frac{1}{2}\sum_k(\epsilon_{ik}+\epsilon_{jk})\); \(\sum_k \epsilon_{ik}\). cepa(3); \(-\epsilon_{ij}+\sum_k(\epsilon_{ik}+\epsilon_{jk})\); \(-\epsilon_{ii}+2\sum_k \epsilon_{ik}\). acpf; \(\frac{2}{N} E_c\); \(\frac{2}{N} E_c\). aqcc; \([1-\frac{(N-3)(N-2)}{N(N-1)}]E_c\); \([1-\frac{(N-3)(N-2)}{N(N-1)}]E_c\). The pair correlation energy, \(\epsilon_{ij}\), is simply a partial; sum of the correlation energy. In a spin-free formalism, the pair energy; is given by. (7)¶\[\epsilon_{ij} = \sum_{ab} v_{ij}^{ab} (2 t_{ij}^{ab} - t_{ij}^{ba})\]; Methods whose shifts (\(\Delta_{ij}\) and \(\Delta_i\)) do not; explicitly depend on orbitals \(i\) or \(j\) (CISD, CEPA(0), ACPF,; and AQCC) have solutions that render the energy stationary with respect; variations in the amplitudes. This convenient property allows density; matrices and 1-electron properties to be evaluated without any additional; effort. Note, however, that 1-electron properties are currently; unavailable when coupling these stationary CEPA-like methods with frozen; natural orbitals. Density-fitted coupled cluster¶; Density fitting (DF) [or the resolution of the identity (RI)] and Cholesky; decomposition (CD) techniques are popular in quantum chemistry to avoid; the computation and storage of the 4-index electron repulsion integral; (ERI) tensor and even to reduce the computational scal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fnocc-1.html:9592,energy,energy,9592,psi4manual/1.1.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fnocc-1.html,30,['energy'],['energy']
Energy Efficiency,"highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg1. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int) → float¶; x position of atom arg1 (0-indexed in Bohr). y(self: psi4.core.Molecule, arg0: int) → float¶; y position of atom arg1 (0-indexed in Bohr). z(self: psi4.core.Molecule, arg0: int) → float¶; z position of atom arg1 (0-indexed in Bohr). BFS(); Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int) → float; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule) → None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int) → None; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, arg0: int) → float; Gets charge of atom arg1 (0-indexed). clone(self: psi4.core.Molecule) → psi4.core.Molecule; Returns a new Molecule identical to arg0. create_molecule_from_string(arg0: str) → psi4.core.Molecule;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:20694,charge,charge,20694,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"highest possible \(M_s\) value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fragmented. Advanced Python¶; A named molecule in an input file is a full-fledged instance of the; powerful C++ Molecule class. Thus, all member; functions (that have been exported via pybind11) documented thereat; are accessible through the handle option_molecule_name in; molecule optional_molecule_name {...}. The molecular geometry can be got and set and manipulated as a; Matrix object. Below shows how to access; coordinates in an input file in Python.; molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.geometry() # get coordinates in bohr as a psi4.Matrix. geom1psi.print_out() # print coordinates array to output file; geom1py = mat2arr(geom1psi) # get coordinates as a Python array; print geom1py # print coordinates to screen. geom2py = [[ 0.0, 0.0, 0.0],; [ 0.0, 1.5, 0.0],; [-0.8, -0.3, 0.0],; [ 0.8, -0.3, 0.0]]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html:16210,power,powerful,16210,psi4manual/1.4.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html,6,['power'],['powerful']
Energy Efficiency,"highest_1; corl_xtpl_helgaker_2. delta_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. delta2_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. Combined interface. Others. Parameters:molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html:9597,energy,energy,9597,psi4manual/1.3.2/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html,8,['energy'],['energy']
Energy Efficiency,"hine (i.e., ethylene*acetylene), test case 16 from the S22 database. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. dft1; DFT Functional Test all values update for new BraggSlater radii. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. mints3; Test individual integral objects for correctness. mp2-1; All-electron MP2 6-31G** geometry optimization of water. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:23297,energy,energy,23297,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"his applies to; molecule (including charge/multiplicity through molecule; optional_molecule_name {...}), memory (through memory; value unit), computational method (through . If Cfour keywords; are specified with values that contradict the PSI4 input,; execution is halted.; As an example, the input below is set up to fail in four ways:; contradictory specification of memory, multiplicity, computational; method, and derivative level. Note, though, that the cfour_units; angstrom setting is permissible, since it concurs with the value; implied in the molecule block.; memory 300 mb. molecule {; H; H 1 0.7; }. set basis 6-31g; set cfour_multiplicity 3 # clash with implicit singlet in molecule {} above; set cfour_units angstrom # no problem, consistent with molecule {} above; set cfour_memory_size 100000000 # clash with 300 mb above; set cfour_calc_level ccsd # clash with 'c4-scf' below; set cfour_deriv_level first # clash with energy() below (use gradient('c4-scf') to achieve this). energy('c4-scf'). Specifying anything in PSI4 format (molecule, basis, options,; method call) starts building a *CFOUR(...) directive for the; ZMAT file. Since the contents of the cfour {...} block are; blindly appended to any input interpreted from PSI4 format, mixing; of PSI4 and Cfour input formats likely will give rise to multiple; *CFOUR(...) directives in the prospective ZMAT, execution of; which will be trapped and halted. Proper uses for the cfour {...}; block are for the sandwich mode, where the entire ZMAT is enclosed,; or for extra directives like %excite*, which presently have no other; specification route.; Specifying the basis is perhaps the regulated piece of input. Since; basis set names differ between PSI4 and Cfour and it’s not; practical to compare exponent-to-exponent, any input file with both; BASIS and CFOUR_BASIS keywords present will halt. Once; a basis set has been requested through BASIS, overriding the; default spherical/Cartesian setting must be done through; PUREAM",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:30208,energy,energy,30208,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,9,['energy'],['energy']
Energy Efficiency,"his applies to; molecule (including charge/multiplicity through molecule; optional_molecule_name {...}), memory (through memory; value unit), computational method (through . If Cfour keywords; are specified with values that contradict the Psi4 input,; execution is halted.; As an example, the input below is set up to fail in four ways:; contradictory specification of memory, multiplicity, computational; method, and derivative level. Note, though, that the cfour_units; angstrom setting is permissible, since it concurs with the value; implied in the molecule block.; memory 300 mb. molecule {; H; H 1 0.7; }. set basis 6-31g; set cfour_multiplicity 3 # clash with implicit singlet in molecule {} above; set cfour_units angstrom # no problem, consistent with molecule {} above; set cfour_memory_size 100000000 # clash with 300 mb above; set cfour_calc_level ccsd # clash with 'c4-scf' below; set cfour_deriv_level first # clash with energy() below (use gradient('c4-scf') to achieve this). energy('c4-scf'). Specifying anything in Psi4 format (molecule, basis, options,; method call) starts building a *CFOUR(...) directive for the; ZMAT file. Since the contents of the cfour {...} block are; blindly appended to any input interpreted from Psi4 format, mixing; of Psi4 and Cfour input formats likely will give rise to multiple; *CFOUR(...) directives in the prospective ZMAT, execution of; which will be trapped and halted. Proper uses for the cfour {...}; block are for the sandwich mode, where the entire ZMAT is enclosed,; or for extra directives like %excite*, which presently have no other; specification route. Specifying the basis is perhaps the regulated piece of input. Since; basis set names differ between Psi4 and Cfour and it’s not; practical to compare exponent-to-exponent, any input file with both; BASIS and CFOUR_BASIS keywords present will halt. Once; a basis set has been requested through BASIS, overriding the; default spherical/Cartesian setting must be done through; PUREAM ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:30233,energy,energy,30233,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"his is enough to make sure the SCF converged to a; stationary point, this is not a sufficient condition for a minimal SCF solution. It may be; a saddle point or a maximum.; To ensure that a minimum has been found, the electronic Hessian, i.e. the matrix of second; derivatives of the energy with respect to orbital variation parameters, must be computed.; If one or more eigenvalues of the electronic Hessian are negative, the SCF solution is not a minimum.; In that case, orbital parameters can be varied along the lowest Hessian eigenvector to lower the energy.; Orbital variation parameters are usually constrained. For example, in RHF the; spatial parts of the \(\alpha\) and \(\beta\) orbitals are the same. In; UHF, the orbital coefficients are usually constrained to be real. A stability analysis; can check whether a lower SCF solution exists while respecting the constraints of the original; solution; this is an internal instability. If one or more constraints have to be relaxed to reach; a lower-energy solution, there is an external instability. In PSI4, the only external instability; that can be checked at present is the RHF \(\rightarrow\) UHF one.; Currently, two algorithms exist in PSI4 for stability analysis: the original; Direct Inversion and the newly implemented Davidson algorithms. We will first describe; options common to both algorithms. To request a stability analysis at the end of the SCF,; set the keyword STABILITY_ANALYSIS. Value CHECK only computes the electronic; Hessian eigenvalue and checks if an actual SCF minimum has been found, while value FOLLOW; rotates the converged orbitals along the lowest eigenvector, then invokes the SCF; procedure again to lower the energy. In case the minimization does not succeed; or ends up on the same unstable solution, you can tune the scale factor for the orbital; rotation through the keyword FOLLOW_STEP_SCALE.; The rotation angle is \(\frac{\pi}{2}\mbox{ } \cdot\) (FOLLOW_STEP_SCALE). The default value of; 0.5 usuall",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:26574,energy,energy,26574,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,15,['energy'],['energy']
Energy Efficiency,"his is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. dft1-alt; DFT Functional Test. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. scf6; Tests RHF/ROHF/UHF SCF gradients. numpy-array-interface; Numpy interface testing. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. casscf-fzc-sp; CASSCF/6-31G** energy point. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:13765,energy,energy,13765,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"his is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. filename (string) – destination file name for MOLDEN file (optional); do_virtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional); use_natural (bool) – write natural orbitals determined from density on wavefunction. Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; “properties” or “gradient” must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.`; The first two arguments of get_opdm can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(wfn, 'no_root1.molden', use_natural=True). write_nbo(name)¶. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; Wavefunction. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.wavefunction.html:25906,energy,energy,25906,psi4manual/1.4.0/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.wavefunction.html,2,['energy'],['energy']
Energy Efficiency,"his is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. filename (string) – destination file name for MOLDEN file (optional); do_virtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional); use_natural (bool) – write natural orbitals determined from density on wavefunction. Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; “properties” or “gradient” must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.`; The first two arguments of get_opdm can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(wfn, 'no_root1.molden', use_natural=True). write_nbo(name)¶. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; Wavefunction. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.wavefunction.html:27010,energy,energy,27010,psi4manual/1.5.0/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.wavefunction.html,2,['energy'],['energy']
Energy Efficiency,"his option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56 .. table:: MRCC methods +——-+————–+————————————————————-+ + Value + Method + Description + +=======+==============+=============================================================+ + 1 + CC + + +——-+————–+————————————————————-+ + 2 + CC(n-1)[n] + + +——-+————–+————————————————————-+ + 3 + CC(n-1)(n) + (CC(n-1)[n] energy is also calculated) + +——-+————–+————————————————————-+ + 4 + CC(n-1)(n)_L + (CC(n-1)[n] and CC(n-1)(n) energies are also calculated) + +——-+————–+————————————————————-+ + 5 + CC(n)-1a + + +——-+————–+————————————————————-+ + 6 + CC(n)-1b + + +——-+————–+————————————————————-+ + 7 + CCn + + +——-+————–+————————————————————-+ + 8 + CC(n)-3 + + +——-+————–+————————————————————-+. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling PSI4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each cal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__mrcc-1.html:1929,energy,energy,1929,psi4manual/4.0b4/autodir_options_c/module__mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__mrcc-1.html,8,['energy'],['energy']
Energy Efficiency,"his ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; df-scf; mp2. df-mp2; cc2; ccsd. bccd; cc3; ccsd(t). cisd; cisdt; cisdtq. cin; fci. Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – 'mp2' || 'ccsd' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtain",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cbs-1.html:2897,energy,energy,2897,psi4manual/4.0b3/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"hk file. :param filename: destination file name for FCHK file. :param debug: returns a dictionary to aid with debugging. :param strict_label: If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes; -----; * A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; * The allowed headers for methods are general and limited, i.e., ""Total SCF|MP2|CI|CC Density"",; PSI4 will try to find the right one for the current calculation. If `strict_label=False` the PSI4 method name will be used as label.; * Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; * Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the 'Orbital Energy' field contains ambiguous data. :examples:. >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). """"""; # * Known limitations and notes *; #; # OCC: (occ theory module only, not dfocc) is turned off as densities are not correctly set.; # DFMP2: Contains natural orbitals in wfn.C() and wfn.epsilon() data. This is fixed to contain respective HF data. allowed = ['DFMP2', 'SCF', 'CCENERGY', 'DCT', 'DFOCC']; module_ = wfn.module().upper(); if module_ not in allowed:; core.print_out(f""FCHKWriter: Theory module {module_} is currently not supported by the FCHK writer.""); return None. if (wfn.basisset().has_ECP()):; core.print_out(f""FCHKWriter: Limited ECP support! No ECP data will be written to the FCHK file.""). # fix orbital coefficients and energies for DFM",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:94841,energy,energy,94841,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,14,['energy'],['energy']
Energy Efficiency,hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_karton_2`. :type corl_scheme: string; :param corl_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. :type delta_scheme: string; :param delta_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta_basis`` and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. :type delta2_scheme: string; :param delta2_scheme: |dl| ``'xtpl_highest_1'`` |dr| || ``'corl_xtpl_helgaker_2'`` || etc. Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta2_basis`` and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. :type scf_alpha: float; :param scf_alpha: |dl| ``1.63`` |dr,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:28643,energy,energy,28643,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"hm test for water. mbis-3; MBIS calculation on OH radical. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. dft2; DFT Functional Test. soscf-large; Second-order SCF convergnece: Benzene. cbs-xtpl-alpha; Extrapolated water energies. cc17; Single point energies of multiple excited states with EOM-CCSD. fd-gradient; SCF STO-3G finite-difference tests. mbis-6; MBIS calculation on H2O. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. cbs-delta-energy; Extrapolated energies with delta correction. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. frac-sym; Fractional occupation with symmetry. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. sapt-ecp; sapt0 of charged system in ECP basis set. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. opt5; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:32831,energy,energy,32831,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"hmark_blas2((arg0: int, arg1: float) -> None); docstring. benchmark_blas3((arg0: int, arg1: float, ...); docstring. benchmark_disk((arg0: int, arg1: float) -> None); docstring. benchmark_integrals((arg0: int, ...); docstring. benchmark_math((arg0: float) -> None); docstring. ccdensity((arg0: psi::Wavefunction) -> float); Runs the code to compute coupled cluster density matrices. ccenergy(...); Runs the coupled cluster energy code. cceom((arg0: psi::Wavefunction) -> float); Runs the equation of motion coupled cluster code, for excited states. cchbar((arg0: psi::Wavefunction) -> None); Runs the code to generate the similarity transformed Hamiltonian. cclambda(...); Runs the coupled cluster lambda equations code. ccresponse((arg0: psi::Wavefunction) -> float); Runs the coupled cluster response theory code. cctransort((arg0: psi::Wavefunction) -> None); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples((arg0: psi::Wavefunction) -> float); Runs the coupled cluster (T) energy code. clean(() -> None); Function to remove scratch files. clean_options(() -> None); Function to reset options to clean state. clean_variables(() -> None); Empties all PSI variables that have set internally. close_outfile(() -> None); Closes the output file. dcft(...); Runs the density cumulant functional theory code. detci(...); Runs the determinant-based configuration interaction code. dfmp2(...); Runs the DF-MP2 code. dfocc(...); Runs the density-fitted orbital optimized CC codes. displace_atom((arg0: psi::Matrix, arg1: int, ...); Displaces one coordinate of single atom. dmrg(...); Runs the DMRG code. efp_init(() -> psi4.core.EFP); Initializes the EFP library and returns an EFP object. efp_set_options(() -> None); Set EFP options from environment options object. fd_1_0((arg0: psi::Molecule, ...); Performs a finite difference gradient computation, from energy points. fd_freq_0((arg0: psi::Molecule, arg1: list, ...); Performs a finite difference",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:162928,energy,energy,162928,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency,"hod, [1], [2]. is_meta() psi4.core.Functional method, [1], [2]. psi4.core.SuperFunctional method, [1], [2]. is_poisson() psi4.core.FittingMetric method, [1], [2]. is_pure() psi4.core.GaussianShell method, [1], [2]. is_variable() psi4.core.Molecule method, [1], [2]. is_x_hybrid() psi4.core.SuperFunctional method, [1], [2]. is_x_lrc() psi4.core.SuperFunctional method, [1], [2]. Isotopes. ISTOP (DETCI). iterations() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. J. J() psi4.core.JK method, [1], [2]. JK class in psi4.core, [1]. jk() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. JOBTYPE (CCLAMBDA). join_path() in module psi4.driver. JSCH module, [1]. K. K() psi4.core.JK method, [1], [2]. KEEP_INTCOS (OPTKING). keywords. ; anharmonicity(), setting. cbs(), setting. cp, setting. database(), setting. energy(), setting. frequency(), setting. general, setting. molecule, setting. optimize(), setting. property(), setting. vmfc, setting. KineticInt class in psi4.core, [1]. L. L psi4.core.BoysLocalizer attribute, [1]. psi4.core.Localizer attribute, [1], [2]. psi4.core.PMLocalizer attribute, [1]. label() psi4.core.Molecule method, [1], [2]. LaplaceDenominator class in psi4.core, [1]. LCC2(+LMP2)TOTALENERGY. LCCSD. LCCSD(+LMP2)TOTALENERGY. legacy_wavefunction() in module psi4.core, [1]. LEVEL_SHIFT (DFOCC). (MCSCF). (OCC). levenshtein() in module psi4.driver. LIBEFP. libfock() in module psi4.core, [1]. Libint. license. LINEAR (CCRESPONSE). LINEQ_SOLVER (DFOCC). (OCC). LINESEARCH_STATIC_MAX (OPTKING). LINESEARCH_STATIC_MIN (OPTKING). LINESEARCH_STATIC_N (OPTKING). LITERAL_CFOUR (GLOBALS). load() psi4.core.Matrix method, [1], [2]. load_mpqc() psi4.core.Matrix method, [1], [2]. LOCAL (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_CONVERGENCE (FISAPT). (SCF). LOCAL_CPHF_CUTOFF (CCENERGY). (CCLAMB",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:57686,energy,energy,57686,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['energy'],['energy']
Energy Efficiency,"hod. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOS_TYPE (OCC); OCC — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOSCF (SCF); SCF — Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV (SCF); SCF — Second order convergence threshold. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER (SCF); SCF — Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER (SCF); SCF — Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT (SCF); SCF — Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE (SCF); SCF — When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. SPINADAPT_ENERGIES (CCENERGY); CCENERGY — Do print spin-adapted pair energies?. Type: boolean; Default: false. SS_E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG (CCEOM); CCEOM — Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT (CCEOM); CCEOM — SS vectors stored per root. Type: integer; Default: 5. SSAPT0_SCALE (FISAPT); FISAPT — Do sSAPT0 exchange-scaling with F-SAPT. Type: boolean; Default: false. STABILITY_ADD_VECTORS (DCFT); DCFT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF); SCF — Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:212568,energy,energy,212568,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"hod. psi4.core.SuperFunctional method. is_poisson() psi4.core.FittingMetric method. is_pure() psi4.core.GaussianShell method. is_variable() psi4.core.Molecule method. is_x_hybrid() psi4.core.SuperFunctional method. is_x_lrc() psi4.core.SuperFunctional method. ISA. ; MBIS. Isotopes. ISOTROPIC_POL (PE). ISTOP (DETCI). iteration_ psi4.core.CUHF attribute. psi4.core.HF attribute. psi4.core.RHF attribute. psi4.core.ROHF attribute. psi4.core.UHF attribute. iterations() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. J. J() psi4.core.JK method. psi4.core.MemDFJK method. JK class in psi4.core. jk() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. JOBTYPE (CCLAMBDA). join_path() in module psi4.driver. K. K() psi4.core.JK method. psi4.core.MemDFJK method. KEEP_INTCOS (OPTKING). keywords. ; anharmonicity(), setting. cbs(), setting. cp, setting. database(), setting. energy(), setting. frequency(), setting. general, setting. molecule, setting. optimize(), setting. properties(), setting. vmfc, setting. KIND (ADC). kinetic() psi4.core.FISAPT method. kinetic_grad() psi4.core.MintsHelper method. KineticInt class in psi4.core. L. L psi4.core.BoysLocalizer attribute. psi4.core.Localizer attribute. psi4.core.PMLocalizer attribute. label qcelemental.datum.Datum attribute. label() psi4.core.Molecule method. psi4.core.MOSpace method. lagrangian() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. LaplaceDenominator class in psi4.core. LCC2 (+LMP2) TOTAL ENERGY. LCCD CORRELATION ENERGY. LCCD DOUBLES ENERGY. LCCD OPPOSITE-SPIN CORRELATION ENERGY. LCCD SAME-SPIN CORRELATION ENERGY. LCCD SINGLES ENERGY. LCCD TOTAL ENERGY. LCCSD. (+LMP2). LCCSD CORRELATION ENERGY. LCCSD DOUBLES ENER",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:79972,energy,energy,79972,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,2,['energy'],['energy']
Energy Efficiency,"hod; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:83374,energy,energy,83374,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,6,['energy'],['energy']
Energy Efficiency,"hod; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+-----------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=====",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:84573,energy,energy,84573,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,['energy'],['energy']
Energy Efficiency,"hod; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or string; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+============",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:70485,energy,energy,70485,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"hodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient.rms() < stationary_criterion # 1.e-2 pulled out of a hat. efp = core.get_active_efp(); efp_present = efp.nfragments() > 0. translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and; not core.get_option('SCF', 'PERTURB_H') and; not efp_present); rotations_projection_sound = (translations_projection_sound and; stationary_point). return translations_projection_sound, rotations_projection_sound. [docs]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:3662,energy,energy,3662,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"hodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient.rms() < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:3622,energy,energy,3622,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"hod_string: string; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: string or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP, NoCP, or VMFC. The first in this; list is returned by this function. By default, this function is not called. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the moleucle. :type ptype: string; :param ptype: ``'energy'`` || ``'gradient'`` || ``'hessian'``. Type of the procedure passed in. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/etc) of the system,; otherwise returns interaction data. :type levels: dict; :param levels: ``{1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'}`` || ``{1: 2, 2: 'ccsd(t)', 3: 'mp2'}`` || etc. Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case.; supersystem computes all higher order n-body effects up to nfragments. :type embedding_charges: dict; :param embedding_charges: ``{1: [-0.834, 0.417, 0.417], ..}``. Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment. :type charge_method: string; :param charge_method: ``scf/6-31g`` || ``b3lyp/6-31g*`` || etc. Method to compute point charges for monomers. Overridden by embeddi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html:5137,energy,energy,5137,psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"hod_string: string; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: string or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP, NoCP, or VMFC. The first in this; list is returned by this function. By default, this function is not called. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the moleucle. :type ptype: string; :param ptype: ``'energy'`` || ``'gradient'`` || ``'hessian'``. Type of the procedure passed in. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/etc) of the system,; otherwise returns interaction data.; """""". # Initialize dictionaries for easy data passing; metadata, component_results, nbody_results = {}, {}, {}. # Parse some kwargs; kwargs = p4util.kwargs_lower(kwargs); metadata['ptype'] = kwargs.pop('ptype', None); metadata['return_wfn'] = kwargs.pop('return_wfn', False); metadata['return_total_data'] = kwargs.pop('return_total_data', False); metadata['molecule'] = kwargs.pop('molecule', core.get_active_molecule()); metadata['molecule'].update_geometry(); metadata['kwargs'] = kwargs; core.clean_variables(). if metadata['ptype'] not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % metadata['ptype']). # Parse bsse_type, raise ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html:5129,energy,energy,5129,psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"hod_string: string; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: string or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP, NoCP, or VMFC. The first in this; list is returned by this function. By default, this function is not called. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the moleucle. :type ptype: string; :param ptype: ``'energy'`` || ``'gradient'`` || ``'hessian'``. Type of the procedure passed in. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/etc) of the system,; otherwise returns interaction data.; """""". ### ==> Parse some kwargs <==; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); ptype = kwargs.pop('ptype', None); return_total_data = kwargs.pop('return_total_data', False); molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); core.clean_variables(). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % ptype). # Figure out BSSE types; do_cp = False; do_nocp = False; do_vmfc = False; return_method = False. # Must be passed bsse_type; bsse_type_list = kwargs.pop('bsse_type'); if bsse_type_list is None:; raise ValidationError(""N-Body GUFunc: M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html:5158,energy,energy,5158,psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"hods in Parrish’s thesis.; A video tutorial series for the use of the FISAPT module is available here.; Specific videos in the series include:. F-SAPT#1.; Describes the use of F-SAPT to analyze the; distribution of the intermolecular interaction energy components between the; various hydroxyl and phenyl moieties of the phenol dimer.; F-SAPT#2.; Discusses how to plot the order-1 F-SAPT analysis with PyMol and perform a; “difference F-SAPT” analysis; I-SAPT#1.; Describes the use of I-SAPT to analyze the interaction between the two phenol; groups in a 2,4-pentanediol molecule.; I-SAPT#2.; Discusses how to plot the density fields and ESPs of the various moieties of; the I-SAPT embedding scheme with PyMol; F/I-SAPT Options.; Details all of the more-advanced options in the F/I-SAPT code (rarely needed). The scripts discussed below are located in psi4/psi4/share/psi4/fsapt. F-SAPT: A Representative Example¶; Below, we show an example of using F-SAPT0/jun-cc-pVDZ to analyze the; distribution of the intermolecular interaction energy components between the; various hydroxyl and phenyl moieties of the phenol dimer. This example is; explicitly included in fsapt1. A video; lecture explaining this example is available F-SAPT#1,; while an additional video describing how to plot the order-1 F-SAPT analysis; with PyMol and perform a “difference F-SAPT”; analysis is available F-SAPT#2:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45memory 1 GB. molecule mol {; 0 1; O -1.3885044 1.9298523 -0.4431206; H -0.5238121 1.9646519 -0.0064609; C -2.0071056 0.7638459 -0.1083509; C -1.4630807 -0.1519120 0.7949930; C -2.1475789 -1.3295094 1.0883677; C -3.3743208 -1.6031427 0.4895864; C -3.9143727 -0.6838545 -0.4091028; C -3.2370496 0.4929609 -0.7096126; H -0.5106510 0.0566569 1.2642563; H -1.7151135 -2.0321452 1.7878417; H -3.9024664 -2.5173865 0.7197947; H -4.8670730 -0.8822",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fisapt-1.html:2745,energy,energy,2745,psi4manual/1.1.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fisapt-1.html,6,['energy'],['energy']
Energy Efficiency,"hods in Parrish’s thesis.; A video tutorial series for the use of the FISAPT module is available here.; Specific videos in the series include:. F-SAPT#1.; Describes the use of F-SAPT to analyze the; distribution of the intermolecular interaction energy components between the; various hydroxyl and phenyl moieties of the phenol dimer.; F-SAPT#2.; Discusses how to plot the order-1 F-SAPT analysis with PyMol and perform a; “difference F-SAPT” analysis; I-SAPT#1.; Describes the use of I-SAPT to analyze the interaction between the two phenol; groups in a 2,4-pentanediol molecule.; I-SAPT#2.; Discusses how to plot the density fields and ESPs of the various moieties of; the I-SAPT embedding scheme with PyMol; F/I-SAPT Options.; Details all of the more-advanced options in the F/I-SAPT code (rarely needed). The scripts discussed below are located in psi4/psi4/share/psi4/fsapt. F-SAPT: A Representative Example¶; Below, we show an example of using F-SAPT0/jun-cc-pVDZ to analyze the; distribution of the intermolecular interaction energy components between the; various hydroxyl and phenyl moieties of the phenol dimer. This example is; explicitly included in fsapt1. A video; lecture explaining this example is available F-SAPT#1,; while an additional video describing how to plot the order-1 F-SAPT analysis; with PyMol and perform a “difference F-SAPT”; analysis is available F-SAPT#2:; memory 1 GB. molecule mol {; 0 1; O -1.3885044 1.9298523 -0.4431206; H -0.5238121 1.9646519 -0.0064609; C -2.0071056 0.7638459 -0.1083509; C -1.4630807 -0.1519120 0.7949930; C -2.1475789 -1.3295094 1.0883677; C -3.3743208 -1.6031427 0.4895864; C -3.9143727 -0.6838545 -0.4091028; C -3.2370496 0.4929609 -0.7096126; H -0.5106510 0.0566569 1.2642563; H -1.7151135 -2.0321452 1.7878417; H -3.9024664 -2.5173865 0.7197947; H -4.8670730 -0.8822939 -0.8811319; H -3.6431662 1.2134345 -1.4057590; --; 0 1; O 1.3531168 1.9382724 0.4723133; H 1.7842846 2.3487495 1.2297110; C 2.0369747 0.7865043 0.1495491; C 1.590402",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fisapt-1.html:2800,energy,energy,2800,psi4manual/1.4.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fisapt-1.html,6,['energy'],['energy']
Energy Efficiency,"hods inherited from Wavefunction:; | ; | Ca(...); | Ca( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Cb(...); | Cb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Da(...); | Da( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Db(...); | Db( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fa(...); | Fa( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | Fb(...); | Fb( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | add_postiteration_callback(...); | add_postiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | add_preiteration_callback(...); | add_preiteration_callback( (Wavefunction)arg1, (object)arg2) -> None :; | docstring; | ; | alpha_orbital_space(...); | alpha_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | basisset(...); | basisset( (Wavefunction)arg1) -> BasisSet :; | docstring; | ; | beta_orbital_space(...); | beta_orbital_space( (Wavefunction)arg1, (str)arg2, (str)arg3, (str)arg4) -> OrbitalSpace :; | docstring; | ; | energy(...); | energy( (Wavefunction)arg1) -> float :; | docstring; | ; | epsilon_a(...); | epsilon_a( (Wavefunction)arg1) -> Vector :; | docstring; | ; | epsilon_b(...); | epsilon_b( (Wavefunction)arg1) -> Vector :; | docstring; | ; | frequencies(...); | frequencies( (Wavefunction)arg1) -> Vector :; | docstring; | ; | gradient(...); | gradient( (Wavefunction)arg1) -> Matrix :; | docstring; | ; | molecule(...); | molecule( (Wavefunction)arg1) -> Molecule :; | docstring; | ; | nirrep(...); | nirrep( (Wavefunction)arg1) -> int :; | docstring; | ; | nmo(...); | nmo( (Wavefunction)arg1) -> int :; | docstring; | ; | nso(...); | nso( (Wavefunction)arg1) -> int :; | docstring; | ; | sobasisset(...); | sobasisset( (Wavefunction)arg1) -> SOBasisSet :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ---",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimod-1.html:28678,energy,energy,28678,psi4manual/4.0b2/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimod-1.html,4,['energy'],['energy']
Energy Efficiency,"hods. For further discussion of vibrational and thermochemical analysis,; see Sec. Vibrational and Thermochemical Analysis.; frequency() is the only command most users will ever; need to access directly to perform frequency calculations. Behind; the scenes, frequency() is a light wrapper over; hessian() that computes the Hessian then adds a; thermochemical analysis. frequency(name[, molecule, return_wfn, func, mode, dertype, irrep])[source]¶; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float – Total electronic energy in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || 'off' ; Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'hessian",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/freq-1.html:1369,energy,energy,1369,psi4manual/1.0.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/freq-1.html,2,['energy'],['energy']
Energy Efficiency,"hods; - simple modifications to existing methods. """"""; import PsiMod; import re; import os; import math; import warnings; from driver import *; from wrappers import *; from molutil import *; from text import *; from procutil import *. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end of this file. [docs]def sherrillgroup_gold_standard(name='mp2', **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~wrappers.complete_basis_set` to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~wrappers.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> energy('sherrillgroup_gold_standard'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). if not ('func_cbs' in kwargs):; kwargs['func_cbs'] = energy. if not ('scf_basis' in kwargs):; kwargs['scf_basis'] = 'aug-cc-pVQZ'; if not ('scf_scheme' in kwargs):; kwargs['scf_scheme'] = highest_1. if not ('corl_wfn' in kwargs):; kwargs['corl_wfn'] = 'mp2'; if not ('corl_basis' in kwargs):; kwargs['corl_basis'] = 'aug-cc-pV[TQ]Z'; if not ('corl_scheme' in kwargs):; kwargs['corl_scheme'] = corl_xtpl_helgaker_2. if not ('delta_wfn' in kwargs):; kwargs['delta_wfn'] = 'ccsd(t)'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis' in kwargs):; kwargs['delta_basis'] = 'aug-cc-pVTZ'; if not ('delta_scheme' in kwargs):; kwargs['delta_scheme'] = highest_1. return cbs(name, **kwargs). #def run_mp2_5(name, **kwargs):; # r""""""Function that computes MP2.5 energy from results of a FNOCC; # MP3 calculation.; #; # .. math:: E_{total}^{\text{MP2.5}} = E_{total,\; \text{SCF}}",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html:1319,energy,energy,1319,psi4manual/4.0b4/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html,2,['energy'],['energy']
Energy Efficiency,"hon 3.8, 3.9, 3.10, and 3.11 (no binary packages for 3.11).; PSI4 1.8 supports Python 3.8, 3.9, 3.10, and 3.11.; The future plan is to (1) be compatible with 3.8 and above until there is a good reason to drop; older versions but (2) only build and test for versions conda-forge supports.; The current master supports 3.8, 3.9, 3.10, and 3.11. License¶; PSI4 is distributed under the GNU Lesser General Public License; version 3, LGPL-3.0. Its; required dependencies and add-ons have their own licenses, ranging from; BSD-2-Clause to GPL-2.0+. It is possible to build PSI4 without any; General GPL dependencies. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contracted Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties.; For more tables with capabilities details:. Full Capabilities (first below) lists all methods; Capabilities Breakdown (second below) lists selected methods by reference, etc.; Module Capabilities lists selected methods by implementation; Energy, Energy (DFT), Energy (MRCC), Energy (CFOUR) fully list energy target methods; Gradient, Gradient (CFOUR) fully list gradient target methods; Frequency fully lists Hessian target methods. Summary of theoretical methods available in PSI4¶. Method [1]; Reference[2]; Type[2]; Variants[3]. Canonical; OO; FNO [4]; DLPNO. HF; RHF/UHF/ROHF/CUHF; CONV/DF/CD; E/G/H. DFT; RKS/UKS; CONV/DF/CD; E/G. DFT-D2, DFT-NL; RKS/UKS; CONV/DF/CD; E/G. DCT; RHF/UHF; CONV/DF; E/G. MP2; RHF/UH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/introduction.html:23748,energy,energy,23748,psi4manual/1.8.x/introduction.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/introduction.html,1,['energy'],['energy']
Energy Efficiency,"hon Functions: Invoking a Calculation; Notes on Options. Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; “active” molecule, which is the nearest preceeding molecule declared in a; molecule mymol {...} block or in an activate(mymol) statement. Note; that the value of this keyword (mymol in the example) is a Python object; and so is not wrapped in quotes like a string. Technically, this is a; Molecule object. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Psithon Functions: Invoking a Calculation; Notes on Options. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/notes_py.html:1249,energy,energy,1249,psi4manual/1.8.x/notes_py.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/notes_py.html,1,['energy'],['energy']
Energy Efficiency,"hon Functions: Invoking a Calculation; Notes on Options. Notes on Options¶. Note; The Python options referred to in the Psithon Functions: Invoking a Calculation section below; are placed as arguments to a Python; function (like energy()), not in set blocks or commands. Note; All PSI4 keyword names and values are insensitive to case, both; those that are placed in set blocks and as Python function arguments.; The one exception is documented for the subset option in the database(); function, where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; The derivative level type for optimize() and frequency() functions can be specified by energy, none, or 0 for 0th derivative, gradient, first, or 1 for 1st derivative, and hessian, second, or 2 for 2nd derivative. For finite difference, as opposed to analytic, derivatives, the POINTS option can be increased to 5 for greater accuracy at increased cost. Note; Function option for the Psithon function called by the current function;; the default is usually energy(). See Sec. Function Intercalls; for a fuller description. Note that the value of the keyword is a Python object; and so is not wrapped in quotes like a string. Note; The molecule to be acted upon by the current function; the default is the; “active” molecule, which is the nearest preceeding molecule declared in a; molecule mymol {...} block or in an activate(mymol) statement. Note; that the value of this keyword (mymol in the example) is a Python object; and so is not wrapped in quotes like a string. Technically, this is a; Molecule object. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Psithon Functions: Invoking a Calculation; Notes on Options. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/notes_py.html:1249,energy,energy,1249,psi4manual/1.9.x/notes_py.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/notes_py.html,1,['energy'],['energy']
Energy Efficiency,"hon function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. method_string (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || 'off' ; Indicate to additionally return the Wavefunction; calculation result as the second element of a tuple. bsse_type (string or list) – 'cp' || ['nocp', 'vmfc'] || None || etc.; Type of BSSE correction to compute: CP, NoCP, or VMFC. The first in this; list is returned by this function. By default, this function is not called. max_nbody (int) – 3 || etc.; Maximum n-body to compute, cannot exceed the number of fragments in the moleucle. ptype (string) – 'energy' || 'gradient' || 'hessian'; Type of the procedure passed in. return_total_data (boolean) – 'on' || 'off' ; If True returns the total data (energy/gradient/etc) of the system,; otherwise returns interaction data. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Couterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energy for the Helium dimer; molecule mol {; He; --; He 1 3; }. energy('CCSD(T)', bsse_type='cp'). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). Previous topic; Property; Next topic; Geometry Optimization, optimize() and gradient(). This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Psithon Functions: Invoking a Calculation ». © C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/nbody-1.html:1754,energy,energy,1754,psi4manual/1.0.0/nbody-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/nbody-1.html,2,['energy'],['energy']
Energy Efficiency,"hon interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:8304,energy,energy,8304,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,20,['energy'],['energy']
Energy Efficiency,"hor: Robert M. Parrish and Justin M. Turney; Section author: Robert M. Parrish; Module: Keywords, PSI Variables, LIBFUNCTIONAL, LIBFOCK, LIBSCF_SOLVER; Both density functional theory and Hartree–Fock theory are controlled; through the SCF module, and the SCF Introduction; section is also relevant here. Note; After May 2017 (anytime after the v1.1 release), PSI4; switched from hand- (+Matlab) coded functionals to Libxc. Thus; many DFT results will be slightly different. Functionals more than; slightly different are B97-D, wB97X (note, not wB97X-D), SOGGA,; DFDL, and M05. Theory¶; Generalized Kohn–Sham Density Functional Theory (KS-DFT) [Kohn:1965:A1133] [Parr:1989] is one of the primary; workhorses of modern computational chemistry due to its phenomenal accuracy/cost; ratio.; Pure Kohn–Sham DFT is built on the Hohenberg–Kohn theorems [Hohenberg:1964:136] which states: A) the energy is a universal; functional of the one-particle electronic density and B) there exists a set of; noninteracting quasiparticles with the same density as the true set of; electrons, with the quasiparticle states determined as eigenvectors of an; effective one-body potential encapsulating the true \(N\)-body quantum; effects. The former idea allows the electronic density to be dealt with instead; of the much more complicated wavefunction, while the latter allows for the; treatment of the troublesome kinetic energy term via the implicit one-body; Kohn–Sham orbitals. KS-DFT borrows much of the machinery of Hartree–Fock, as is; evident by looking at the energy expression,. \[\begin{split}E_{\mathrm{KS}}; &= \sum_{i} \langle i | \hat h | i \rangle; + \frac 1 2 \sum_{i,j} [ii|jj] + E_{\mathrm{xc}} [\rho_\alpha, \rho_\beta] \\; &= D_{\mu\nu}^{\mathrm{T}}\left(T_{\mu\nu} +; V_{\mu\nu}\right) + \frac{1}{2} D_{\mu\nu}^{\mathrm{T}}; D_{\lambda\sigma}^{\mathrm{T}} (\mu\nu|\lambda\sigma) + E_{\mathrm{xc}} [\rho_\alpha, \rho_\beta]\end{split}\]; Here, \(T\) is the noninteracting quasiparticle kinetic energy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:1066,energy,energy,1066,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,2,['energy'],['energy']
Energy Efficiency,"hose for SCS-CCSD. Type: boolean; Default: false. SCS_MP2¶. Do SCS-MP2?. Type: boolean; Default: false. TRIPLES_LOW_MEMORY¶. Do use low memory option for triples contribution? Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. Type: boolean; Default: false. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. Table Of Contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. Previous topic; SSAPT0_SCALE; Next topic; ACTIVE_NAT_ORBS. This Page. Show Source. Quick search. Enter search terms or a module, class or function ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__fnocc-1.html:4167,energy,energy,4167,psi4manual/1.0.0/autodir_options_c/module__fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__fnocc-1.html,2,['energy'],['energy']
Energy Efficiency,"hose for SCS-CCSD. Type: boolean; Default: false. SCS_MP2¶. Do SCS-MP2?. Type: boolean; Default: false. TRIPLES_LOW_MEMORY¶. Do use low memory option for triples contribution? Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. Type: boolean; Default: false. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. Table Of Contents. FNOCC; General; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. Previous topic; POINTS; Next topic; BRUECKNER_MAXITER; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules  ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__fnocc-1.html:3419,energy,energy,3419,psi4manual/4.0b5/autodir_options_c/module__fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__fnocc-1.html,4,['energy'],['energy']
Energy Efficiency,"hose for SCS-CCSD. Type: boolean; Default: false. SCS_MP2¶. Do SCS-MP2?. Type: boolean; Default: false. TRIPLES_LOW_MEMORY¶. Do use low memory option for triples contribution? Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. Type: boolean; Default: false. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. table of contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module. © Copyright 2017, The Psi4 Project.; Last updat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__fnocc-1.html:4113,energy,energy,4113,psi4manual/1.1.0/autodir_options_c/module__fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__fnocc-1.html,2,['energy'],['energy']
Energy Efficiency,hose for SCS-CCSD. Type: boolean; Default: false. SCS_MP2¶. Do SCS-MP2?. Type: boolean; Default: false. TRIPLES_LOW_MEMORY¶. Do use low memory option for triples contribution? Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. Type: boolean; Default: false. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. table of contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module. © Copyright,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__fnocc-1.html:4115,energy,energy,4115,psi4manual/1.2.1/autodir_options_c/module__fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__fnocc-1.html,2,['energy'],['energy']
Energy Efficiency,hose for SCS-CCSD. Type: boolean; Default: false. SCS_MP2¶. Do SCS-MP2?. Type: boolean; Default: false. TRIPLES_LOW_MEMORY¶. Do use low memory option for triples contribution? Note that this option is enabled automatically if the memory requirements of the conventional algorithm would exceed the available resources. Type: boolean; Default: false. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. table of contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module. © Copyright,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__fnocc-1.html:4111,energy,energy,4111,psi4manual/1.3.2/autodir_options_c/module__fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__fnocc-1.html,2,['energy'],['energy']
Energy Efficiency,"hould be performed with a; small basis set (3-21G if a basis name is not supplied as keyword; value) followed by projection into the full target basis. .. deprecated:: Sept-2012; Use option |scf__basis_guess| instead. :type cast_up_df: :ref:`boolean <op_py_boolean>` or string; :param cast_up_df: ``'on'`` || |dl| ``'off'`` |dr| || ``'cc-pVDZ-RI'`` || ``'aug-cc-pVDZ-JKFIT'`` || etc. Indicates whether, when *cast_up* is active, to run the preliminary; scf in density-fitted mode or what fitting basis to employ (when; available for all elements, cc-pVDZ-RI is the default). .. deprecated:: Sept-2012; Use option |scf__df_basis_guess| instead. :type bypass_scf: :ref:`boolean <op_py_boolean>`; :param bypass_scf: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether, for *name* values built atop of scf calculations,; the scf step is skipped. Suitable when special steps are taken to get; the scf to converge in an explicit preceeding scf step. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp4'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> molecule H2 {\\n0 1\\nH\\nH 1 0.74\\n}; >>> energy('scf'); >>> H2.set_multiplicity(3); >>> energy('detci', bypass_scf=True). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:21882,energy,energy,21882,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"hparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimme’s DFTD3 program. Parameters:; func (str, optional) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (str, optional) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to one.; dashparam (dict, optional) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (int or str, optional) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int, optional) – Amount of printing. Returns:; energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule) → ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:54101,energy,energy,54101,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,2,['energy'],['energy']
Energy Efficiency,"hreaded (pthreads);  ;  . ACPF/AQCC; RHF; CONV; —; —; threaded [3];  ; E. CISD [10]; RHF/ROHF; CONV; —; —; partially threaded;  ; E. QCISD; RHF; CONV; —; —; threaded [3];  ; E. QCISD(T); RHF; CONV; —; —; threaded [3];  ; E. CI(n); RHF/ROHF; CONV; —; —; partially threaded;  ;  . FCI; RHF/ROHF; CONV; —; —; partially threaded;  ;  . Mk-MRPT2; RHF/ROHF/TCSCF; CONV; —; —; threaded [3];  ;  . Mk-MRCCSD; RHF/ROHF/TCSCF; CONV; —; —; threaded [3];  ;  . Mk-MRCCSD(T); RHF/ROHF/TCSCF; CONV; —; —; threaded [3];  ;  . RAS-CI; RHF/ROHF; CONV; —; —; partially threaded;  ;  . CASSCF, RASSCF; RHF/ROHF; CONV/DF; —; —; partially threaded;  ;  . SAPT; RHF; CONV; —; —; threaded;  ;  . ADC(2); RHF; CONV; —; —; threaded [3];  ;  . EOM-CC2; RHF; CONV; —; —; threaded [3];  ;  . EOM-CCSD; RHF/UHF/ROHF; CONV; RHF/UHF/ROHF; CONV; threaded [3];  ;  . EOM-CC3; RHF/UHF/ROHF; CONV; —; —; threaded [3];  ;  . DMRG-CI; Y; CONV; —; —;  ;  ;  . DMRG-SCF; Y; CONV; —; —;  ;  ;  . Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is distributed for free and without any guarantee of; reliability, accuracy, or suitability for any particular purpose. No; obligation to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries on the forum or GitHub. For bug reports,; specific and detailed information, with example inputs, would be; appreciated.; Where-to-post summary:[6]. How do I? – ask the forum; I got this error, why? – ask the forum; I got this error and I’m sure it’s a bug – file a GitHub issue; Can I open a discussion on this bit of code? – file a GitHub issue; I have an idea/request and a plan – file a GitHub issue; I have an idea/request",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:22257,energy,energy,22257,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,6,['energy'],['energy']
Energy Efficiency,"hrough triples with iterative quadruples (cheapest terms). ccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). ccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). ccsdt-1b; CC through doubles with iterative triples (cheaper terms). ccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). ccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). ccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). cc2; approximate CC through doubles [details]. cc3; approximate CC through triples [details]. cc4; approximate CC through quadruples. cc5; approximate CC through quintuples. cc6; approximate CC through sextuples. ccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). ccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). ccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). ccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('ccsdt'). Interface Details¶. MRCC methods¶. MRCC_METHOD; Method; Description. 1; CC. 2; CC(n-1)[n]. 3; CC(n-1)(n); (CC(n-1)[n] energy is also calculated). 4; CC(n-1)(n)_L; (CC(n-1)[n] and CC(n-1)(n) energies are also calculated). 5; CC(n)-1a. 6; CC(n)-1b. 7; CCn. 8; CC(n)-3. table of contents. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/mrcc.html:4941,energy,energy,4941,psi4manual/1.7.x/mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/mrcc.html,1,['energy'],['energy']
Energy Efficiency,"htola:2020:012516]. The guess and its implementation have; been described in [Lehtola:2019:1593]. The guess is evaluated on a; DFT quadrature grid, so the guess energy depends slightly on the; used DFT quadrature. The current implementation is based on; exchange-only local density calculations that are but nanohartree; away from the complete basis set limit [Lehtola:2020:012516]. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; BASIS_GUESS = SMALL_BASIS to the options list. We recommend the; 3-21G or pcseg-0 basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). Restarting the SCF¶; Reading orbital data from a previous calculations is done via the restart_file option,; where the actual file is a serialized wfn object (see saving the wfn); By default, the orbital data file of the converged SCF(psi.PID.name.180.npy) is deleted; after PSI4 exits or the clean() function is called. The orbital guess is automatically; set to READ when restart_file is given a wfn file.; To write the orbitals after every iteration and keep the orbitals from the last iteration, the write_orbitals options is available:; energy('scf', write_orbitals='my_mos'),. which writes a Wavefunction object converted (serialized) to a numpy file called my_mos.npy.; The restart can then be done as follows:; energy('scf', restart_file='my_mos'). Specifying the .npy suffix when writing and reading restart files is optional.; Alternatively, the restart can also be done from any previously saved wfn object.; energy, scf_wfn = energy('scf',return_wfn=True); scf_wfn.to_file('my_wfn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:19676,energy,energy,19676,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,6,['energy'],['energy']
Energy Efficiency,"http://www.psicode.org/psi4manual/master/scf.html#convergence-and-; algorithm-defaults. SCF will be converged more tightly if a post-SCF; method is select (pscf_Ec, and pscf_Dc) else the looser (scf_Ec, and; scf_Dc convergence criterion will be used). ptype - Procedure type (energy, gradient, etc). Nearly always test on; procedures['energy'] since that's guaranteed to exist for a method.; method_name - Name of the method; scf_Ec - E convergence criterion for scf target method; pscf_Ec - E convergence criterion for scf of post-scf target method; scf_Dc - D convergence criterion for scf target method; pscf_Dc - D convergence criterion for scf of post-scf target method; gen_Ec - E convergence criterion for post-scf target method. """"""; optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Kind of want to move this out of here; _method_exists(ptype, method_name). if verbose >= 2:; print(' Setting convergence', end=' '); # Set method-dependent scf convergence criteria, check against energy routines; if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'E_CONVERGENCE', scf_Ec); if verbose >= 2:; print(scf_Ec, end=' '); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', pscf_Ec); if verbose >= 2:; print(pscf_Ec, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'E_CONVERGENCE'), end=' '). if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][method_name] in [proc.run_scf, proc.run_dft]:; psi4.set_local_option('SCF', 'D_CONVERGENCE', scf_Dc); if verbose >= 2:; print(scf_Dc, end=' '); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', pscf_Dc); if verbose >= 2:; print(pscf_Dc, end=' '); else:; if verbose >= 2:; print('CUSTOM', psi4.get_option('SCF', 'D_CONVERGENCE'), end=' '). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:2950,energy,energy,2950,psi4manual/1.0.0/_modules/driver_util.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html,1,['energy'],['energy']
Energy Efficiency,"hybrid_superfuncs.py. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. mp2-h; check that methods can act on single atom. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. fnocc3; Test FNO-QCISD(T) computation. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. pubchem2; Superficial test of PubChem interface. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cc36; CC2(RHF)/cc-pVDZ energy of H2O. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. dft-smoke; DFT Functional Smoke Test. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. fci-coverage; 6-31G H2O Test for coverage. tdscf-5; td-camb3lyp with DiskDF and method/basis specification. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. mbis-5; MBIS calculation on ZnO. mbis-2; MBIS calculation on OH- (Expanded Arrays). nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:6054,energy,energy,6054,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"hysical constants used within Psi4, which are automatically; made available within all Psi4 input files.; # @END LICENSE; #. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/include/physconst.h; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:2717,joule,joule,2717,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['joule'],['joule']
Energy Efficiency,"i calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(banners). tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables). return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc steps.; [docs]def run_plugin_omega(name, **kwargs):; r""""""Function encoding sequence of PSI module and plugin calls, as well; as typical options, to access Rob Parrish's omega plugin. >>> energy('plugin_omega'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). plugfile = PsiMod.Process.environment[""PSIDATADIR""] + ""/../tests/plugin_omega/plugin_omega.so""; PsiMod.plugin_load(""%s"" % (plugfile)). PsiMod.s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html:3660,energy,energy,3660,psi4manual/4.0b3/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html,2,['energy'],['energy']
Energy Efficiency,"i will also favor neutral, spin-singlet fragments.; For anything complicated, we strongly suggest explicitly providing the charge; and multiplicity of each fragment as well as the total molecular charge and multiplicity. For details and examples, see https://github.com/MolSSI/QCElemental/blob/master/qcelemental/molparse/chgmult.py#L105-L136 .; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fragmented. Advanced Python¶; A named molecule in an input file is a full-fledged instance of the; powerful C++ Molecule class. Thus, all member; functions (that have been exported via pybind11) documented thereat; are accessible through the handle option_molecule_name in; molecule optional_molecule_name {...}. The molecular geometry can be got and set and manipulated as a; Matrix object. Below shows how to access; coordinates in an input file in Python.; molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psithonmol.html:16585,energy,energy,16585,psi4manual/1.8.x/psithonmol.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psithonmol.html,3,['energy'],['energy']
Energy Efficiency,"i-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cfour/kw-2; testing best practices options, part ii. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobas",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_cfour.html:1834,energy,energy,1834,psi4manual/master/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_cfour.html,1,['energy'],['energy']
Energy Efficiency,"i4 options to cfour, part ii. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/sp-rhf-ccsdt; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_cfour.html:2388,energy,energy,2388,psi4manual/1.7.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_cfour.html,1,['energy'],['energy']
Energy Efficiency,"i4 provides a very simple mechanism; for doing so: simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html:14674,charge,charge,14674,psi4manual/1.0.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html,4,['charge'],"['charge', 'charges']"
Energy Efficiency,"i4 then detects these value via the API routines in <omp.h> and; <mkl.h>, and runs all applicable code with 4 threads. These environment; variables are typically defined in a .tcshrc or .bashrc.; (2) The -n Command Line Flag; To change the number of threads at runtime, the psi4 -n flag may be used. An; example is:; psi4 -i input.dat -o output.dat -n 4. which will run on four threads.; (3) Setting Thread Numbers in an Input; For more explicit control, the Process::environment class in Psi4 can; override the number of threads set by environment variables. This functionality; is accessed via the set_num_threads() Psithon function, which controls; both MKL and OpenMP thread numbers. The number of threads may be changed; multiple times in a Psi4 input file. An example input for this feature is:; # A bit small-ish, but you get the idea; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 90.0; }. set scf {; basis cc-pvdz; scf_type df; }. # Run from 1 to 4 threads, for instance, to record timings; for nthread in range(1,5):; set_num_threads(nthread); energy('scf'). (4) Method-Specific Control; Even more control is possible in certain circumstances. For instance, the; threaded generation of AO density-fitted integrals involves a memory requirement; proportional to the number of threads. This requirement may exceed the total; memory of a small-memory node if all threads are involved in the generation of; these integrals. For general DF algorithms, the user may specify:; set MODULE_NAME df_ints_num_threads n. to explicitly control the number of threads used for integral formation. Setting; this variable to 0 (the default) uses the number of threads specified by the; set_num_threads() Psithon method or the default environmental variables. PBS job file¶; To run a Psi4 job on a PBS queueing system, you need to properly set up; all necessary variables in the PBS job file. Below is a minimal example of; a PBS job file for a threaded job, and a short explanation for each section.; #!/bin/tcs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:9009,energy,energy,9009,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['energy'],['energy']
Energy Efficiency,"i4.Matrix method. load_mpqc( (Matrix)arg1, (str)arg2) -> None :. docstring; C++ signature :. void load_mpqc(N3psi6MatrixE {lvalue},Ss). psi4.Matrix.name()¶; Python Library Documentation: method name; name(...) unbound psi4.Matrix method. name( (Matrix)arg1) -> str :. docstring; C++ signature :. Ss name(N3psi6MatrixE {lvalue}). psi4.Matrix.nirrep()¶; Python Library Documentation: method nirrep; nirrep(...) unbound psi4.Matrix method. nirrep( (Matrix)arg1) -> int :. docstring; C++ signature :. i nirrep(N3psi6MatrixE {lvalue}). psi4.Matrix.np()¶; Python Library Documentation: property. psi4.Matrix.partial_cholesky_factorize()¶; Python Library Documentation: method partial_cholesky_factorize; partial_cholesky_factorize(...) unbound psi4.Matrix method. partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE partial_cholesky_factorize(N3psi6MatrixE {lvalue},d,b). psi4.Matrix.power()¶; Python Library Documentation: method power; power(...) unbound psi4.Matrix method. power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :. docstring; C++ signature :. N3psi9DimensionE power(N3psi6MatrixE {lvalue},d,d). psi4.Matrix.print_out()¶; Python Library Documentation: method print_out; print_out(...) unbound psi4.Matrix method. print_out( (Matrix)arg1) -> None :. docstring; C++ signature :. void print_out(N3psi6MatrixE {lvalue}). psi4.Matrix.project_out()¶; Python Library Documentation: method project_out; project_out(...) unbound psi4.Matrix method. project_out( (Matrix)arg1, (Matrix)arg2) -> None :. docstring; C++ signature :. void project_out(N3psi6MatrixE {lvalue},N3psi6MatrixE {lvalue}). psi4.Matrix.remove_symmetry()¶; Python Library Documentation: method remove_symmetry; remove_symmetry(...) unbound psi4.Matrix method. remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :. docstring; C++ signature :. void remove_symmetry(N3psi6MatrixE {lvalue},N5boost10shared_ptrIN3psi6Mat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:210077,power,power,210077,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,6,['power'],['power']
Energy Efficiency,"i4.core.FittingMetric method. is_pure() psi4.core.GaussianShell method. is_variable() psi4.core.Molecule method. is_x_hybrid() psi4.core.SuperFunctional method. is_x_lrc() psi4.core.SuperFunctional method. ISA. ; MBIS. Isotopes. ISOTROPIC_POL (PE). ISTOP (DETCI). iteration_ psi4.core.CUHF attribute. psi4.core.HF attribute. psi4.core.RHF attribute. psi4.core.ROHF attribute. psi4.core.UHF attribute. iterations() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. J. J() psi4.core.DirectJK method. psi4.core.JK method. psi4.core.MemDFJK method. JK class in psi4.core. jk() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. JOBTYPE (CCLAMBDA). join_path() in module psi4.driver. K. K() psi4.core.DirectJK method. psi4.core.JK method. psi4.core.MemDFJK method. KEEP_INTCOS (OPTKING). keywords. ; anharmonicity(), setting. cbs(), setting. cp, setting. database(), setting. energy(), setting. frequency(), setting. general, setting. molecule, setting. optimize(), setting. properties(), setting. vmfc, setting. KIND (ADC). kinetic() psi4.core.FISAPT method. kinetic_grad() psi4.core.MintsHelper method. KineticInt class in psi4.core. L. L psi4.core.BoysLocalizer attribute. psi4.core.Localizer attribute. psi4.core.PMLocalizer attribute. label qcelemental.datum.Datum attribute. label() psi4.core.Molecule method. psi4.core.MOSpace method. lagrangian() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. LaplaceDenominator class in psi4.core. LCC2 (+LMP2) TOTAL ENERGY. LCCD CORRELATION ENERGY. LCCD DOUBLES ENERGY. LCCD OPPOSITE-SPIN CORRELATION ENERGY. LCCD SAME-SPIN CORRELATION ENERGY. LCCD SINGLES ENERGY. LCCD TOTAL ENERGY. LCCSD. (+LMP2). LCCSD CORRELATION ENERGY. LCCSD DOUBLES ENER",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/genindex-1.html:80935,energy,energy,80935,psi4manual/1.5.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/genindex-1.html,2,['energy'],['energy']
Energy Efficiency,"i4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_C(self: psi4.core.HF) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_G(self: psi4.core.HF) → None¶; Forms the G matrix. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. frequencies(self: psi4.core.Wavefunction) → psi4.cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:25365,energy,energy,25365,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,14,['energy'],['energy']
Energy Efficiency,"i4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to a specified origin. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]]=[0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, arg0: List[float[3]]) → psi4.core.Matrix¶; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule) → bool¶; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule) → psi4.core.PointGroup¶; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule) → None¶; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule) → None¶; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule) → None¶; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self: psi4.core.Molecule) → None¶; Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self: psi4.core.Molecule) → None¶; Prints the m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:136490,energy,energy,136490,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,3,['energy'],['energy']
Energy Efficiency,"i4.core.Molecule) → str¶; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str) → float¶; Returns the value of variable arg0 in the structural variables list. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float¶; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → List[str]¶; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str) → bool¶; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int) → str¶; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int) → float¶; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int) → int¶; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule) → int¶; Gets the molecular charge. move_to_com(self: psi4.core.Molecule) → None¶; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule) → int¶; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int¶; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]] = [0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.molecule.html:24102,charge,charge,24102,psi4manual/1.4.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.molecule.html,6,['charge'],['charge']
Energy Efficiency,"i4.core.Molecule) → str¶; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str) → float¶; Returns the value of variable arg0 in the structural variables list. inertia_tensor(self: psi4.core.Molecule) → psi4.core.Matrix¶; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule) → float¶; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule) → List[str]¶; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str) → bool¶; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int) → str¶; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int) → float¶; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int) → int¶; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule) → int¶; Gets the molecular charge. move_to_com(self: psi4.core.Molecule) → None¶; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule) → int¶; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int¶; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str¶; Gets molecule name. natom(self: psi4.core.Molecule) → int¶; Number of real atoms. nfragments(self: psi4.core.Molecule) → int¶; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs)¶; Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]]=[0.0, 0.0, 0.0]) → float¶; Computes nuclear repulsion energy. nuclear_rep",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:24114,charge,charge,24114,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,3,['charge'],['charge']
Energy Efficiency,"i4.core.Molecule¶; Bases: object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Attributes Summary. units; Units (Angstrom or Bohr) used to define the geometry. Methods Summary. BFS(); Perform a breadth-first search (BFS) on the real atoms in molecule, returning an array of atom indices of fragments. Z((self: psi4.core.Molecule, arg0: int) -> float); Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(...); Sets all fragments in the molecule to be active. add_atom((self: psi4.core.Molecule, ...); Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position((self: psi4.core.Molecule, ...); Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(...); Computes center of mass of molecule (does not translate molecule). charge((self: psi4.core.Molecule, ...); Gets charge of atom arg1 (0-indexed). clone(...); Returns a new Molecule identical to arg0. create_molecule_from_string(...); Returns a new Molecule with member data from the geometry string arg0 in Psi4 format. create_psi4_string_from_molecule(...); Gets a string reexpressing in input format the current states of the molecule. deactivate_all_fragments(...); Sets all fragments in the molecule to be inactive. distance_matrix(...); Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. fZ((self: psi4.core.Molecule, ...); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge((self: psi4.core.Molecule, ...); Gets charge of atom arg1 (0-indexed including dummies). find_point_group((self: psi4.core.Molecule, ...); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com((self: psi4.core.Molecule, ...); Whether to fix the Cartesian position, or to translate to the C.O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:1101,charge,charge,1101,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,1,['charge'],['charge']
Energy Efficiency,"i4.core.UHF method, [1]. set_specific_path() psi4.core.IOManager method, [1], [2]. set_specific_retention() psi4.core.IOManager method, [1], [2]. set_title() psi4.core.OEProp method, [1]. psi4.core.Prop method, [1], [2]. set_tpdm_presorted() psi4.core.Deriv method, [1], [2]. set_variable() in module psi4.core, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. psi4.core.Molecule method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. set_x_alpha() psi4.core.SuperFunctional method, [1], [2]. set_x_omega() psi4.core.SuperFunctional method, [1], [2]. setAuxiliary() psi4.core.DFChargeFitter method, [1], [2]. setD() psi4.core.DFChargeFitter method, [1], [2]. setName() psi4.core.ExternalPotential method, [1], [2]. setPrimary() psi4.core.DFChargeFitter method, [1], [2]. setting. ; keywords anharmonicity(). keywords cbs(). keywords cp. keywords database(). keywords energy(). keywords frequency(). keywords general. keywords molecule. keywords optimize(). keywords property(). keywords vmfc. SF_RESTRICT (DETCI). shallow_copy() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. shape psi4.core.Matrix attribute, [1], [2]. psi4.core.Vector attribute, [1], [2]. shared_object() psi4.core.IO method, [1], [2]. psi4.core.IOManager method, [1], [2]. shell() psi4.core.BasisSet method, [1], [2]. shell_to_ao_function() psi4.core.BasisSet method, [1], [2]. shell_to_basis_function() psi4.core.BasisSet method, [1], [2]. shell_to_center() psi4.core.BasisSet method, [1], [2]. ShellInfo class in psi4.core, [1]. shells_iterator() psi4.core.IntegralFactory method, [1], [2]. sherrill_gold_standard() in module psi4.driver.aliases. shift() psi4.core.CIVector method, [1], [2]. sigma() psi4.core.CIWavefunction me",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:93224,energy,energy,93224,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['energy'],['energy']
Energy Efficiency,"i4.core.Wavefunction) – . Examples. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). PSI4 is capable of computing a number of one-electron properties; summarized in the table below. Current one-electron property capabilities of PSI4¶. Feature; Keyword; Notes. Electric dipole moment; DIPOLE. Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE”, “32-POLE”. Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Electrostatic potential, on grid; GRID_ESP; Generates V at each point in grid_esp.dat. See Properties evaluated on a grid. Electric field, on grid; GRID_FIELD; Generates {Ex,Ey,Ez} at each point grid_field.dat. See Properties evaluated on a grid. Molecular orbital extents; MO_EXTENTS. Mulliken atomic charges; MULLIKEN_CHARGES. Löwdin atomic charges; LOWDIN_CHARGES. Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES. Natural orbital occupations; NO_OCCUPATIONS. Stockholder Atomic Multipoles; MBIS_CHARGES; Generates atomic charges, dipoles, etc. See Minimal Basis Iterative Stockholder. There are two ways the computation of one-electron properties can be requested.; Firstly, the properties can be evaluated from the last; computed one-particle density, using the following syntax:; oeprop(""MO_EXTENTS"", ""MULTIPOLE(4)"", title = ""hello!""). Note that it is the user’s responsibility to ensure that the relaxed density; matrix is computed using the method of interest, which may require setting; additional keywords (see the method’s manual section for details). The named; argument, title, is completely optional and is prepended to any; globals variables set during the computation. The unnamed arguments are the; propertie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/oeprop.html:1670,charge,charges,1670,psi4manual/1.6.x/oeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/oeprop.html,1,['charge'],['charges']
Energy Efficiency,"i4.core.Wavefunction) → bool¶; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str) → float¶; Returns the requested (case-insensitive) double QC variable. scalar_variables(self: psi4.core.Wavefunction) → Dict[str, float]¶; Returns the dictionary of all double QC variables. semicanonical_orbs(self: psi4.core.CIWavefunction) → None¶; docstring. set_array(key, val)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix) → None¶; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet) → None¶; Sets the requested auxiliary basis. set_ci_guess(self: psi4.core.CIWavefunction, arg0: str) → None¶; docstring. set_energy(self: psi4.core.Wavefunction, arg0: float) → None¶; Sets the Wavefunction’s energy. Syncs with Wavefunction’s QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential) → None¶; Sets the requested external potential. set_frequencies(val)¶. Deprecated since version 1.4. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s gradient. Syncs with Wavefunction’s QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the Wavefunction’s Hessian. Syncs with Wavefunction’s QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix) → None¶; Sets the orbital Lagrangian matrix. set_legacy_frequencies(self: psi4.core.Wavefunction, arg0: psi4.core.Vector) → None¶; Sets the frequencies of the Hessian. set_module(self: psi4.core.Wavefunction, module: str) → None¶; Sets name of the last/highest level of theory module (internal or external) touching the wavef",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html:25642,energy,energy,25642,psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ciwavefunction.html,5,['energy'],['energy']
Energy Efficiency,"i4.core.Wavefunction.hessian(), and much other computation; info through psi4.core.Wavefunction.frequency_analysis; (note no parentheses). Examples of using this data; structure can be found fd-freq-gradient and; python/vibanalysis. Formatted printing of vibrational; results is available through qcdb.vib.print_vibs(). Results accessible through psi4.core.Wavefunction.frequency_analysis¶. key; description (lbl & comment); units; data (real/imaginary modes). omega; frequency; cm^-1; nd.array(ndof) complex (real/imag). q; normal mode, normalized mass-weighted; a0 u^1/2; ndarray(ndof, ndof) float. w; normal mode, un-mass-weighted; a0; ndarray(ndof, ndof) float. x; normal mode, normalized un-mass-weighted; a0; ndarray(ndof, ndof) float. degeneracy; degree of degeneracy;  ; ndarray(ndof) int. TRV; translation/rotation/vibration;  ; ndarray(ndof) str ‘TR’ or ‘V’ or ‘-‘ for partial. gamma; irreducible representation;  ; ndarray(ndof) str irrep or None if unclassifiable. mu; reduced mass; u; ndarray(ndof) float (+/+). k; force constant; mDyne/A; ndarray(ndof) float (+/-). DQ0; RMS deviation v=0; a0 u^1/2; ndarray(ndof) float (+/0). Qtp0; Turning point v=0; a0 u^1/2; ndarray(ndof) float (+/0). Xtp0; Turning point v=0; a0; ndarray(ndof) float (+/0). theta_vib; char temp; K; ndarray(ndof) float (+/0). Visualization of Normal Modes¶; PSI4 has the ability to export a Molden file that stores information about; the harmonic frequencies and normal modes computed via frequency().; This feature can be enabled by setting the option NORMAL_MODES_WRITE to true.; The filename of the Molden file ends in .molden_normal_modes, and the prefix is; determined by WRITER_FILE_LABEL (if set), or else by the name of the; output file plus the name of the current molecule.; The normal coordinates saved in the Molden file are normalized and are not; mass weighted. Molden Interface Keywords¶. NORMAL_MODES_WRITE¶. Do write a file containing the normal modes in Molden format? If so, the filename will end",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/freq-1.html:5961,reduce,reduced,5961,psi4manual/1.2.1/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/freq-1.html,4,['reduce'],['reduced']
Energy Efficiency,"i4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from gradients, for a given irrep. psi4.core.fd_geoms_1_0(arg0: psi::Molecule) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.fisapt(arg0: psi::Wavefunction) → float¶; Runs the functional-group intramolecular symmetry adapted perturbation theory code. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the currently active molecule object. psi4.core.get_array_variable(arg0: str) → psi::Matrix¶; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). psi4.core.get_array_variables() → Dict[str, psi::Matrix]¶; Returns dictionary of the PSI variables set internally by the modules or python driver. psi4.core.get_atomic_point_charges() → psi::Vector¶; Returns the most recently computed atomic point charges, as a double * object. psi4.core.get_efp_torque() → psi::Matrix¶; Returns the most recently computed gradient for the EFP portion, as ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:148714,adapt,adapted,148714,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['adapt'],['adapted']
Energy Efficiency,"i4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; Customization: Adding Simple Extensions; Next topic; Creating a Database. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Customization: Adding Simple Extensions ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/quickaddalias-1.html:2951,energy,energy,2951,psi4manual/1.0.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/quickaddalias-1.html,2,['energy'],['energy']
Energy Efficiency,"i4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined Basis Sets; Next topic; Creating a Database; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Customization: Adding Simple Extensions ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/quickaddalias-1.html:2889,energy,energy,2889,psi4manual/4.0b5/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/quickaddalias-1.html,12,['energy'],['energy']
Energy Efficiency,"i4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Customization: Adding Simple Extensions; Defining a Method Alias. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/quickaddalias.html:2983,energy,energy,2983,psi4manual/1.7.x/quickaddalias.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/quickaddalias.html,7,['energy'],['energy']
Energy Efficiency,"i4.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, energies_full[n][k],; p4const.psi_hartree2kcalmol * energies_full[n][k])); psi4.print_out('\n'). if bsse == 'off' or bsse == 'both':; psi4.print_out(' => Cluster Basis Set Results <=\n\n'); psi4.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""E [H]"", ""E [kcal mol^-1]"")); for n in Ns:; for k in range(len(energies_mon[n])):; psi4.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, energies_mon[n][k],; p4const.psi_hartree2kcalmol * energies_mon[n][k])); psi4.print_out('\n'). if bsse == 'both':; psi4.print_out(' => BSSE Results <=\n\n'); psi4.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""Delta E [H]"", ""Delta E [kcal mol^-1]"")); for n in Ns:; for k in range(len(energies_mon[n])):; psi4.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, energies_full[n][k] - energies_mon[n][k],; p4const.psi_hartree2kcalmol * (energies_full[n][k] - energies_mon[n][k]))); psi4.print_out('\n'). psi4.print_out(' ==> N-Body Interaction Energy Analysis: N-Body Energies <==\n\n'). if bsse == 'on' or bsse == 'both':; psi4.print_out(' => Full Basis Set Results <=\n\n'); psi4.print_out(' %6s %6s %24s %24s\n' % (""N-Body"", ""Combo"", ""E [H]"", ""E [kcal mol^-1]"")); energies_n_full = {}; for n in Ns:; if n == 1:; continue; En = 0.0; for k in range(len(energies_full[n])):; E = energies_full[n][k]; for l in range(len(combos[n][k])):; E -= energies_full[1][combos[n][k][l] - 1]; psi4.print_out(' %6d %6d %24.16E %24.16E\n' % (n, k + 1, E, p4const.psi_hartree2kcalmol * E)); En += E; energies_n_full[n] = En; for n in Ns:; if n == 1:; continue; nn = molecule.nfragments() - 2; kk = n - 2; energies_n_full[n] /= (math.factorial(nn) / (math.factorial(kk) * math.factorial(nn - kk))); psi4.print_out(' %6d %6s %24.16E %24.16E\n' % (n, 'Total', energies_n_full[n],; p4const.psi_hartree2kcalmol * energies_n_full[n])); psi4.print_out('\n'). if bsse == 'off' or bsse == 'both':; psi4.print_out(' => Cluster Basis Set Results <=\n\n'); psi4.print_out(' %6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:12529,Energy,Energy,12529,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Energy'],['Energy']
Energy Efficiency,"i4.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); psi4.set_local_option('CCSORT', 'WFN', 'CCSD_AT'); psi4.set_local_option('CCENERGY', 'WFN', 'CCSD_AT'); psi4.set_local_option('CCHBAR', 'WFN', 'CCSD_AT'); psi4.set_local_option('CCLAMBDA', 'WFN', 'CCSD_AT'); elif (lowername == 'cc2'):; psi4.set_local_option('TRANSQT2', 'WFN', 'CC2'); psi4.set_local_option('CCSORT', 'WFN', 'CC2'); psi4.set_local_option('CCENERGY', 'WFN', 'CC2'); elif (lowername == 'cc3'):; psi4.set_local_option('TRANSQT2', 'WFN', 'CC3'); psi4.set_local_option('CCSORT', 'WFN', 'CC3'); psi4.set_local_option('CCENERGY', 'WFN', 'CC3'); elif (lowername == 'eom-cc2'):; psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CC2'); elif (lowername == 'eom-ccsd'):; psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); # Call a plain energy('ccenergy') and have full control over options, incl. wfn; elif(lowername == 'ccenergy'):; pass. # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') == 'DF' or psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; mints = psi4.MintsHelper(); mints.integrals(). psi4.transqt2(); psi4.ccsort(); psi4.ccenergy(). if (lowername == 'ccsd(at)' or lowername == 'a-ccsd(t)'):; 	psi4.cchbar(); 	psi4.cclambda(). optstash.restore(). [docs]def run_cc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['CCLAMBDA', 'WFN'],; ['CCDENSITY', 'WFN']). psi4.set_global_option('DERTYPE', 'FIRST'). run_ccenergy(name, **kwargs); if (name.low",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:24866,energy,energy,24866,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,2,['energy'],['energy']
Energy Efficiency,"i4/lib/python/aliases.py; (source location) or psi4/share/psi/python/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. sherrill_gold_standard(name='mp2', **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). allen_focal_point(name='mp2', **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; complete_basis_set() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). Table Of Contents. Complete Basis Set; Output; Extrapolation Schemes; Aliases. Previous topic; BAKERJCC96; Next topic; <no title>; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:15812,energy,energy,15812,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"iMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 6); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 8); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 6); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 8). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 6). procedures['energy'][lowername](lowername, **kwargs). except KeyError:; raise ValidationError('Energy method %s not available.' % (lowername)). optstash.restore(); return PsiMod.get_variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. optstash = OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:30383,ENERGY,ENERGY,30383,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"iMod.sapt(); CTd = PsiMod.get_variable('SAPT CT ENERGY'). PsiMod.print_out('\n'); banner('Monomer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(121, 'monomerAm', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerBm', 'dimer'); e_sapt = PsiMod.sapt(); CTm = PsiMod.get_variable('SAPT CT ENERGY'); CT = CTd - CTm. PsiMod.print_out('\n\n'); PsiMod.print_out(' SAPT Charge Transfer Analysis\n'); PsiMod.print_out(' -----------------------------------------------------------------------------\n'); line1 = ' SAPT Induction (Dimer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTd * 1000.0, CTd * physconst.psi_hartree2kcalmol); line2 = ' SAPT Induction (Monomer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTm * 1000.0, CTm * physconst.psi_hartree2kcalmol); line3 = ' SAPT Charge Transfer %10.4lf mH %10.4lf kcal mol^-1\n\n' % (CT * 1000.0, CT * physconst.psi_hartree2kcalmol); PsiMod.print_out(line1); PsiMod.print_out(line2); PsiMod.print_out(line3); PsiMod.set_variable('SAPT CT ENERGY', CT). molecule.reset_point_group(user_pg); molecule.update_geometry(). return e_sapt. [docs]def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; # TODO: Check to see if we really need to run the SCF code.; run_scf(name, **kwargs). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to PsiMod.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Need to move to the scratch directory, perferrably into a separat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/proc.html:32605,ENERGY,ENERGY,32605,psi4manual/4.0b2/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"ia the keyword CFOUR_EOM_NSTATES (dne?) =MULTIROOT. Type: string; Possible Values: ON, NACV, LVC; Default: OFF. CFOUR_NEGEVAL¶. Specifies what to do if negative eigenvalues are encountered in the totally symmetric Hessian during an NR or MANR geometry-optimization search. If ABORT (=0), the job will terminate with an error message; if SWITCH (=1) the program will just switch the eigenvalue to its absolute value and keep plugging away (this is strongly discouraged!); and if RFA (=2), the keyword CFOUR_GEO_METHOD is switched to RFA internally and the optimization is continued. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead. Type: string; Possible Values: ABORT, SWITCH, RFA; Default: ABORT. CFOUR_NEWNORM¶. All components of spherical AO’s are normalized to 1. This feature can help with numerical convergence issues if AO integrals are involved. Currently only working for single-point energy calculations. Type: boolean; Default: false. CFOUR_NONHF¶. Specifies whether the reference function used in the correlation energy calculation satisfies the (spin-orbital) HF equations or not. Usually there is no need to set this parameter (OFF = 0 and ON =1), since standard non-HF reference functions (QRHF and ROHF) set this flag automatically. Type: boolean; Default: false. CFOUR_NTOP_TAMP¶. Specifies how many t amplitudes will be printed for each spin case and excitation level. For =N, The largest N amplitudes for each spin case and excitation level will be printed. Type: integer; Default: 15. CFOUR_OCCUPATION¶. Specifies the orbital occupanc of the reference function in terms of the occupation numbers of the orbitals and their irreducible representations. The occupancy is specified by either NIRREP or 2*NIRREP integers specifying the number of occupied orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational poi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:39906,energy,energy,39906,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"ia the keyword CFOUR_EOM_NSTATES (dne?) =MULTIROOT. Type: string; Possible Values: ON, NACV, LVC; Default: OFF. CFOUR_NEGEVAL¶. Specifies what to do if negative eigenvalues are encountered in the totally symmetric Hessian during an NR or MANR geometry-optimization search. If ABORT (=0), the job will terminate with an error message; if SWITCH (=1) the program will just switch the eigenvalue to its absolute value and keep plugging away (this is strongly discouraged!); and if RFA (=2), the keyword CFOUR_GEO_METHOD is switched to RFA internally and the optimization is continued. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead. Type: string; Possible Values: ABORT, SWITCH, RFA; Default: ABORT. CFOUR_NEWNORM¶. All components of spherical AO’s are normalized to 1. This feature can help with numerical convergence issues if AO integrals are involved. Currently only working for single-point energy calculations. Type: boolean; Default: false. CFOUR_NONHF¶. Specifies whether the reference function used in the correlation energy calculation satisfies the (spin-orbital) HF equations or not. Usually there is no need to set this parameter (OFF = 0 and ON =1), since standard non-HF reference functions (QRHF and ROHF) set this flag automatically. Type: boolean; Default: false. CFOUR_NTOP_TAMP¶. Specifies how many t amplitudes will be printed for each spin case and excitation level. For =N, The largest N amplitudes for each spin case and excitation level will be printed. Type: integer; Default: 15. CFOUR_OCCUPATION¶. Specifies the orbital occupancy of the reference function in terms of the occupation numbers of the orbitals and their irreducible representations. The occupancy is specified by either NIRREP or 2*NIRREP integers specifying the number of occupied orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational po",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:39842,energy,energy,39842,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,24,['energy'],['energy']
Energy Efficiency,"iable key (case-insensitive); prefer del_variable(). del_scalar_variable(key); Removes the double QCVariable key (case-insensitive); prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from global memory if present. detci(ref_wfn); Runs the determinant-based configuration interaction code. dfmp2(ref_wfn); Runs the DF-MP2 code. dfocc(ref_wfn); Runs the density-fitted orbital optimized CC codes. dlpno(arg0); Runs the DLPNO codes. dmrg(ref_wfn); Runs the CheMPS2 interface DMRG code. doublet(A, B[, transA, transB]); Returns the multiplication of two matrices A and B, with options to transpose each beforehand. dummy_einsums(ref_wfn); Runs the einsums placeholder code. dummy_integratorxx(ref_wfn); Runs the integratorxx placeholder code. fcidump_tei_helper(nirrep, restricted, ...); Write integrals to file in FCIDUMP format. finalize(); Called upon psi4 module exit to closes timers and I/O. flush_outfile(); Flushes the output file. fnocc(ref_wfn); Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. get_active_molecule(); Returns the currently active molecule object. get_array_variable(key). get_array_variables(). get_datadir(); Returns the path to shared text resources, PSIDATADIR. get_global_option(key); Return keyword key value at global (all-module) scope. get_global_option_list(); Returns a list of all global options. get_local_option(module, key); Return keyword key value at module scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel computations. get_option(module, key); Return keyword key value used by module. get_options(); Get options. get_output_file(); Returns output file name (stem + suffix, no directory). get_variable(key). get_variables(). get_writer_file_prefix(molecule_name); Returns the prefix to use for writing files for external programs. git_version(). has_array_variable(key); Is the Matrix QCVariable key (case-insensitive) set? ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psi4api.html:5048,energy,energy,5048,psi4manual/master/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/master/psi4api.html,1,['energy'],['energy']
Energy Efficiency,"iable option is BP, Boughton-Pulay. Type: string; Default: BP. LOCAL_PRECONDITIONER (CCEOM); CCEOM — Preconditioner will be used in local CC computations. Type: string; Possible Values: HBAR, FOCK; Default: HBAR. LOCAL_USE_GHOSTS (FISAPT); FISAPT (Expert) — Use ghost atoms in Pipek-Mezey or IBO metric. Type: boolean; Default: false. LOCAL_WEAKP (CCENERGY); CCENERGY — Desired treatment of “weak pairs” in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, NEGLECT, MP2; Default: NONE. LOCAL_WEAKP (CCEOM); CCEOM — Desired treatment of “weak pairs” in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, MP2, NEGLECT; Default: NONE. LOCAL_WEAKP (CCLAMBDA); CCLAMBDA — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CCRESPONSE); CCRESPONSE — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CCSORT); CCSORT — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCK_SINGLET (PSIMRCC); PSIMRCC — Do lock onto a singlet root?. Type: boolean; Default: false. LSE (DETCI); DETCI — Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:153720,energy,energy,153720,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"iable(""CURRENT CORRELATION ENERGY"",cemp3); elif ( lowername == 'mp4(sdq)'):; emp4sdq = psi4.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4(sdq)'):; emp4sdq = psi4.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4'):; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variable(""MP4 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4); elif (lowername == 'fnocc-mp') and (level == 4):; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variable(""MP4 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4). # restore options; optstash.restore(). return psi4.get_variable(""CURRENT ENERGY""). [docs]def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; lowername = name.lower(); uppername = name.upper(); kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). psi4.set_local_option('FNOCC','RUN_CEPA', True); psi4.set_local_option('FNOCC','USE_DF_INTS', False). # what type of cepa?; cepa_level = uppername; if (lowername == 'cepa(2)'):; raise ValidationError(""Error: %s not implemented\n"" % lowername); if (lowername == 'dci'):; cepa_level = 'CISD'; if (lowername == 'sdci'):; cepa_level = 'CISD'. if (lowername == 'fno-cepa(0)'):; cepa_level = 'CEPA(0)'; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); if (lowername == 'fno-cepa(1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:72045,ENERGY,ENERGY,72045,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"iable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"", emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4(sdq)':; emp4sdq = psi4.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = psi4.get_variable(""MP4(SDQ) CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"", emp4sdq); psi4.set_variable(""CURRENT CORRELATION ENERGY"", cemp4sdq); elif name == 'fno-mp4':; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variable(""MP4 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"", emp4); psi4.set_variable(""CURRENT CORRELATION ENERGY"", cemp4); elif name == 'mp4':; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variable(""MP4 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"", emp4); psi4.set_variable(""CURRENT CORRELATION ENERGY"", cemp4). optstash.restore(); return fnocc_wfn. [docs]def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). psi4.set_local_option('FNOCC', 'RUN_CEPA', True); psi4.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; psi4.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; psi4.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_level = 'acpf'; elif name in ['aqcc', 'fno-aqcc']:; cepa_level = 'aqcc'; elif name in ['cisd', 'fno-cisd']:; cepa_level = 'cisd'; else:; raise ValidationError(""""""Error: %s not implemented\n"""""" % name). p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:105161,energy,energy,105161,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['energy'],['energy']
Energy Efficiency,"iable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_disp_functor('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:85334,ENERGY,ENERGY,85334,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"iable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Customization: Adding Simple Extensions; Defining a Method Alias. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/quickaddalias.html:2992,energy,energy,2992,psi4manual/master/quickaddalias.html,https://psicode.org,https://psicode.org/psi4manual/master/quickaddalias.html,7,['energy'],['energy']
Energy Efficiency,"iable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():. # throw exception for CONV/CD MP2; if (mp2_type := core.get_global_option(""MP2_TYPE"")) != ""DF"":; raise ValidationError(f""Invalid MP2 type {mp2_type} for DF-DFT energy. See capabilities Table.""). core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:81035,energy,energy,81035,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['energy'],['energy']
Energy Efficiency,"iables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. dft-reference; MP2 with a PBE0 reference computation. nbody-nocp-gradient; Computation of NoCP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. linK-1; RHF Linear Exchange Algorithm test for water. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. mp2-h; check that methods can act on single atom. linK-2; RKS Linear Exchange Algorithm test for benzene. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. fsapt-ext-abc2; FSAPT with external charge on dimer. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. fs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:28132,energy,energy,28132,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"iables by Alpha¶. Note; Lowercase letters in PSI variable names represent portions of; the variable name that vary by root number, calculation order, etc.; See text for fuller description. [T] CORRECTION ENERGY¶; The coupled-cluster bracket perturbative triples correction [E_h]. (T) CORRECTION ENERGY¶; The coupled-cluster perturbative triples correction [E_h]. (AT) CORRECTION ENERGY¶. A-(T) CORRECTION ENERGY¶; The coupled-cluster asymmetric perturbative triples correction [E_h]. AAA (T) CORRECTION ENERGY¶. AAB (T) CORRECTION ENERGY¶. ABB (T) CORRECTION ENERGY¶. BBB (T) CORRECTION ENERGY¶; Spin components of the UHF-based coupled-cluster perturbative triples correction [E_h]. ACPF DIPOLE¶; Dipole array [e a0] for the averaged coupled-pair functional level of theory, (3,). ACPF QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the averaged coupled-pair functional level of theory, (3, 3). ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the averaged coupled-pair functional level of theory. ADC ROOT 0 -> ROOT n EXCITATION ENERGY¶. TD-fctl ROOT 0 -> ROOT n EXCITATION ENERGY¶; The excitation energy [E_h] from ground state to root n.; DFT functional labeled if canonical. ADC ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY¶. TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) EXCITATION ENERGY¶; The excitation energy [E_h] from the ground state (which is of irrep h); to root n within irrep i.; DFT functional labeled if canonical. ADC ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY¶. TD-fctl ROOT 0 (h) -> ROOT n (i) EXCITATION ENERGY¶; The excitation energy [E_h] from the ground state (which is of irrep h); to root n (which is of irrep i).; DFT functional labeled if canonical. ADC ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION¶. TD-fctl ROOT 0 -> ROOT n EXCITATION ENERGY - h TRANSITION¶; The excitation energy [E_h] from the ground state to root n, and the; transition is of irrep h.; DFT functional labeled if can",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:1107,energy,energy,1107,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency,"ial options for lower method in a given stage. This is useful to calculate a direct stage in an otherwise density-fitted calculation, or similar.; `treatment`: treat extrapolation stage as `scf` or `corl`, by default only the first stage is `scf` and every later one is `corl`.; `stage`: tag for the stage used in tables. The next items in the `cbs_metadata` array extrapolate correlation. All of the above parameters are available, with only the `wfn` and `basis` keywords required. Other supported parameters are:. `wfn_lo`: the lower method from which the delta correction is to be calculated. By default, it is set to `wfn` from the previous field in the `cbs_metadata` array.; `basis_lo`: basis set to be used for the delta correction. By default, it is the same as the `basis` specified above. Others. Parameters:; molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy('cbs', scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html:12532,energy,energy,12532,psi4manual/1.7.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html,24,['energy'],['energy']
Energy Efficiency,"ial/field integrals for DDX calculations (A Lebedev Points number). Type: integer; Default: 110. DDX_SOLVATION_CONVERGENCE (DDX)¶DDX — Tolerance to which DDX linear systems are solved. Type: conv double; Default: 1e-8. DDX_SOLVENT (DDX)¶DDX — Solvent to use. Not case sensitive. Ignored if SOLVENT_EPSILON is set. Type: string; Default: No Default. DDX_SOLVENT_EPSILON (DDX)¶DDX — Dielectric constant of the solvent to use. Type: double; Default: 0. DEBUG (CCDENSITY)¶CCDENSITY — Reproducing energies from densities ?. Type: integer; Default: 0. DEBUG (CPHF)¶CPHF — The amount of debug information printed to the output file. Type: integer; Default: 0. DEBUG (GLOBALS)¶GLOBALS (Expert) — The amount of information to print to the output file. Type: integer; Default: 0. DELETE_TEI (CCTRANSORT)¶CCTRANSORT — Delete the SO two-electron integrals after the transformation?. Type: boolean; Default: true. DENOMINATOR_ALGORITHM (SAPT)¶SAPT — Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA (SAPT)¶SAPT — Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DERTYPE (EFP)¶EFP (Expert) — Do EFP gradient?. Type: string; Possible Values: NONE, FIRST; Default: NONE. DERTYPE (GLOBALS)¶GLOBALS (Expert) — Derivative level. Type: string; Possible Values: NONE, FIRST, SECOND, RESPONSE; Default: NONE. DETCI_FREEZE_CORE (DETCI)¶DETCI — Do freeze core orbitals?. Type: boolean; Default: true. DF_BASIS_CC (FNOCC)¶FNOCC — Auxilliary basis for df-ccsd(t). Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_CC (GLOBALS)¶GLOBALS — The density fitting basis to use in coupled cluster computations. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_DCT (DCT)¶DCT — Auxiliary basis se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:99968,efficient,efficient,99968,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,1,['efficient'],['efficient']
Energy Efficiency,"ials = []; convs = []; stats = []. # Run one SCF to burn things in; E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs). # Determine HOMO; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); eps_a.print_out(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.get(int(Na - 1)); E_b = eps_b.get(int(Nb - 1)); if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (N, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""); core.set_local_option(""SCF"", ""FRAC_START"", frac_start); core.set_local_option(""SCF"", ""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N, Nmin, -1):. # Nuke the current HOMO; for occ in foccs:. core.set_local_option(""SCF"", ""FRAC_OCC"", [HOMO]); core.set_local_option(""SCF"", ""FRAC_VAL"", [occ]). E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.np[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps.np[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:12131,energy,energy,12131,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,8,['energy'],['energy']
Energy Efficiency,"iary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.3.2;  · . PSI4. Module code. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qmmm.html:4295,charge,charges,4295,psi4manual/1.3.2/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qmmm.html,13,['charge'],"['charge', 'charges']"
Energy Efficiency,"iases.allen_focal_point(**kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). Return type; List[Dict[str, Any]]. Additional composite aliases are easy to define by the; user. Follow models in psi4/psi4/driver/aliases.py; and cbs-xtpl-nbody and use the; psi4.driver.driver_cbs_helper.register_composite_function(); to make user-defined functions known to PSI4. psi4.driver.driver_cbs_helper.register_composite_function(func)[source]¶; Register a user-defined composite method function to use like a built-in one. Parameters; func (Callable) – A Python function that defines a configuration of the psi4.cbs() wrapper.; See psi4/psi4/driver/aliases.py and cbs-xtpl-nbody for examples. table of contents. Complete Basis Set; Output; Extrapolation Schemes; Aliases. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Complete Basis Set. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/cbs.html:32206,energy,energy,32206,psi4manual/1.6.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/cbs.html,2,['energy'],['energy']
Energy Efficiency,"iases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element (after *float* energy) of a tuple. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. For maximum; flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:48878,energy,energy,48878,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"iate order. Changes to External Potential Engines¶; Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted “CartAO”) and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set.; Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns – corresponding to charge, x, y, z; – to the set_charge_field() member of the potential integral class. The; same information is now passed using the more verbose; std::vector<std::pair<double, std::array<double, 3>>> type instead, to be; consistent with Libint2’s convention. New Operators Available¶; Libint2 provides a range of integrals that were previously not available in; PSI4, such as the Erfc attenuated nuclear potential integrals needed for; Ewald methods. If new integrals are added to Libint2 but are not yet; interfaced to PSI4, please open an issue on the PSI4 GitHub page to; alert the developers, who will be able to add the appropriate code.; Available integrals classes and parameters currently documented at; Libint2 C++11 Interface Wiki. Shell Pairs¶; To ensure consistency between one- and two-electron terms when screening, and; for efficiency reasons, shell pair lists should be used to iterate over pairs; of Gaussian shells. These lists contain integer pair numb",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/prog_integrals.html:15792,charge,charges,15792,psi4manual/1.6.x/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html,10,['charge'],"['charge', 'charges']"
Energy Efficiency,"ibes the transition between roots m and n. CCname ROOT m (IN h) -> ROOT n (IN i) EINSTEIN A (LEN)¶; The Einstein A coefficient, the spontaneous emission ‘probability.’; Units are in [1/s].; Describes the transition between root m within irrep h and root n which irrep i. CCname ROOT m (h) -> ROOT n (i) EINSTEIN A (LEN)¶; The Einstein A coefficient, the spontaneous emission ‘probability.’; Units are in [1/s].; Describes the transition between roots m and n, which are in irreps h and i, respectively.. CCname ROOT m -> ROOT n EINSTEIN A (LEN) - h TRANSITION¶; The Einstein A coefficient, the spontaneous emission ‘probability.’; Units are in [1/s].; Describes the irrep h transition between roots m and n. CCname ROOT m -> ROOT n EINSTEIN B (LEN)¶; The Einstein B coefficient, the stimulated emission ‘probability’; in terms of energy density. Units are in [m^3 / J / s^2].; Describes the transition between roots m and n. CCname ROOT m (IN h) -> ROOT n (IN i) EINSTEIN B (LEN)¶; The Einstein B coefficient, the stimulated emission ‘probability’; in terms of energy density. Units are in [m^3 / J / s^2].; Describes the transition between root m within irrep h and root n which irrep i. CCname ROOT m (h) -> ROOT n (i) EINSTEIN B (LEN)¶; The Einstein B coefficient, the stimulated emission ‘probability’; in terms of energy density. Units are in [m^3 / J / s^2].; Describes the transition between roots m and n, which are in irreps h and i, respectively.. CCname ROOT m -> ROOT n EINSTEIN B (LEN) - h TRANSITION¶; The Einstein B coefficient, the stimulated emission ‘probability’; in terms of energy density. Units are in [m^3 / J / s^2].; Describes the irrep h transition between roots m and n. CCname ROOT m -> ROOT n ROTATORY STRENGTH (LEN)¶. TD-fctl ROOT 0 -> ROOT n ROTATORY STRENGTH (LEN)¶; The length-gauge rotatory strength of the transition from root m to root n.; DFT functional labeled if canonical. CCname ROOT m (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (LEN)¶. TD-fctl ROOT 0 (IN h) -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:12508,energy,energy,12508,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,5,['energy'],['energy']
Energy Efficiency,"ibility to restart a CC calculation which stopped for various reasons, e.g. time limit, in the correlation part. However, note that a restart which is specified by ON (= 1) needs the following files of the previous unfinished calculation: JOBARC, JAINDX, MOINTS, and MOABCD. Type: boolean; Default: false. CFOUR_ROT_EVEC (CFOUR); CFOUR — Specifies which eigenvector of the orbital rotation Hessian is to be used to rotate the original SCF orbitals. By default, it will use that associated with the lowest eigenvalue of the totally symmetric part of the block-factored Hessian, as this choice often leads to the lowest energy SCF solution. For RHF stability checks, only those instabilities which correspond to RHF solutions will be considered. It is important to understand that following non-symmetric eigenvectors lowers the symmetry of the wavefunction and that following RHF –> UHF stabilities leads to a UHF solution. To converge the SCF roots associated with such instabilities, one must run the calculation in reduced symmetry and as a closed-shell UHF case, respectively. Value n directs the program to follow the vector associated with the nth lowest eigenvalue having the proper symmetry (totally symmetric) and spin (RHF–>RHF or UHF–>UHF) properties. 0 means use the lowest eigenvalue. Type: integer; Default: 0. CFOUR_SAVE_INTS (CFOUR); CFOUR — Tells CFOUR whether to delete large files (AO integrals and MOINTS file for now) when they are no longer needed. OFF (=0) They will not be saved, ON (=1) they will be saved. Type: boolean; Default: false. CFOUR_SCALE_ON (CFOUR); CFOUR — Controls whether step scaling is based on the absolute step length (1-norm) (=0 or MAG(S)) or the largest individual step in the internal coordinate space (=1 or MAX(S)). Type: string; Possible Values: MAG(S), MAX(S); Default: MAG(S). CFOUR_SCF_CONV (CFOUR); CFOUR — Specifies the convergence criterion for the HF-SCF equations. Equations are considered converged when the maximum change in density matrix e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:73822,reduce,reduced,73822,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['reduce'],['reduced']
Energy Efficiency,"ible Values: RFO, RS_I_RFO, P_RFO, NR, SD, LINESEARCH; Default: RFO. UNFREEZE_DIHEDRALS¶. Unfreeze a subset of dihedrals - meant for use with freeze_all_dihedrals. Type: string; Default: No Default. Convergence Control¶. FLEXIBLE_G_CONVERGENCE¶. Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. MAX_DISP_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum force (internal coordinates, atomic units). Type: conv double; Default: 3.0e-4. RMS_DISP_G_CONVERGENCE¶. Convergence criterion for geometry optmization: rms displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. RMS_FORCE_G_CONVERGENCE¶. Convergence criterion for geometry optmization: rms force (internal coordinates, atomic units). Type: conv double; Default: 3.0e-4. Hessian Update¶. CART_HESS_READ¶. Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__optking.html:6035,energy,energy,6035,psi4manual/master/autodir_options_c/module__optking.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__optking.html,2,['energy'],['energy']
Energy Efficiency,"ible Values: SOS, SOSPI; Default: SOS. SOSCF (SCF)¶SCF — Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV (SCF)¶SCF — Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER (SCF)¶SCF — Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER (SCF)¶SCF — Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT (SCF)¶SCF — Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE (SCF)¶SCF — When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. SPIN_SCALE_TYPE (OCC)¶OCC (Expert) — Controls the spin scaling set to current energy. This is set by Psi internally. Type: string; Possible Values: NONE, CUSTOM, SCS, SCSN, SCSVDW, SOS, SOSPI; Default: NONE. SS_E_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SCALE (OCC)¶OCC — A custom scaling parameter for same-spin terms in OCC. The result goes to a CUSTOM SCS variable, exact name method-dependent. Type: double; Default: 1. SS_SKIP_DIAG (CCEOM)¶CCEOM — Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT (CCEOM)¶CCEOM — SS vectors stored per root. Type: integer; Default: 5. SSAPT0_SCALE (FISAPT)¶FISAPT — Do sSAPT0 exchange-scaling with F-SAPT. Type: boolean; Default: false. STABILITY_ADD_VECTORS (DCT)¶DCT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF)¶SCF — Whether to perform stabilit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html:223505,energy,energy,223505,psi4manual/1.6.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html,5,['energy'],['energy']
Energy Efficiency,"ible excitation manifolds,; use the KIND keyword. For restricted references; by default only singlet excited states are computed,; corresponding to the keyword value 'singlet'.; To compute triplet states, select 'triplet'.; To compute both without making a spin distinction, select 'any'.; The latter is default for unrestricted references.; The special KIND value 'spin_flip' selects; a spin-flip computation where a simultaneous flip of spin; and excitation is performed. This is only available; for unrestricted references and not for CVS-ADC(n) methods,; see table ADC capabilities of Psi4.; Using the core-valence separation.; For tackling core-valence excitations using the CVS-ADC(n); methods, the keyword argument NUM_CORE_ORBITALS; is additionally required. It is used to specify the number of; (spatial) orbitals to put into the core space and thus select; as target orbitals for a core-valence excitation process.; A value of 2 indicates, for example,; that the two lowest-energy \(\alpha\) and the two; lowest-energy \(\beta\) orbitals are placed in the core space.; Since the implemented ADC procedures tackle the; lowest-energy excitations, the value should be specified; such that the targeted core orbital is just inside the core space.; Example: Consider furane, \(C_4H_4O\). In order to tackle; the oxygen 1s edge, i.e simulate a O 1s XAS spectrum, one may; just set NUM_CORE_ORBITALS to 1. This will select the; oxygen 1s orbital for the core space as it is energetically the lowest.; For C 1s core excitations the NUM_CORE_ORBITALS value needs; to be set to 5, such that both the O 1s and all four C 1s orbitals; are part of the core space.; Other keywords and examples.; Apart from the mentioned keywords, the following are common:. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, UHF; Default: RHF. R_CONVERGENCE¶. Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/adc-1.html:6863,energy,energy,6863,psi4manual/1.4.0/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/adc-1.html,18,['energy'],['energy']
Energy Efficiency,"ible to run a SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; sapt_basis='monomer' to the energy function, such as; energy('sapt2',sapt_basis='monomer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat_orbs_t2 true; freeze_core true; }. energy('sapt2+3'). To reiterate some of the options mentioned above: the; NAT_ORBS_T2 option will compute MP2 natural orbitals and use; them in the evaluation of the triples correction to dispersion, and the; FREEZE_CORE option will freeze the core throughout the SAPT; computation. This SAPT2+3/aug-cc-pVDZ computation produces the following; results:; SAPT Results; --------------------------------------------------------------------------------------------------------; Electrostatics -13.06509118 [mEh] -8.19846883 [kcal/mol] -34.30239689 [kJ/mol]; Elst10,r -13.37542977 [mEh] -8.39320925 [kcal/mol] -35.11719087 [kJ/mol]; Elst12,r 0.04490350 [mEh] 0.02817737 [kcal/mol] 0.11789413 [kJ/mol]; Elst13,r 0.26543510 [mEh] 0.16656305 [kcal/mol] 0.69689985 [kJ/mol]. Exchange 13.41768202 [mEh] 8.41972294 [kcal/mol] 35.22812415 [kJ/mol]; Exch10 11.21822294 [mEh] 7.03954147 [kcal/mol] 29.45344432 [kJ/mol]; Exch10(S^2) 11.13802706 [mEh] 6.98921779 [kcal/mol] 29.24289005 [kJ/mol]; Exch11(S^2) 0.04558907 [mEh] ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:19912,energy,energy,19912,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"ible to run a SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; sapt_basis='monomer' to the energy function, such as; energy('sapt2',sapt_basis='monomer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat_orbs_t2 true; freeze_core true; }. energy('sapt2+3'). To reiterate some of the options mentioned above: the; NAT_ORBS_T2 option will compute MP2 natural orbitals and use; them in the evaluation of the triples correction to dispersion, and the; FREEZE_CORE option will freeze the core throughout the SAPT; computation. This SAPT2+3/aug-cc-pVDZ computation produces the following; results:; SAPT Results; --------------------------------------------------------------------------; Electrostatics -13.06429805 mH -8.19797114 kcal mol^-1; Elst10,r -13.37543274 mH -8.39321111 kcal mol^-1; Elst12,r 0.04490253 mH 0.02817676 kcal mol^-1; Elst13,r 0.26623216 mH 0.16706321 kcal mol^-1. Exchange 13.41793548 mH 8.41988199 kcal mol^-1; Exch10 11.21823471 mH 7.03954885 kcal mol^-1; Exch10(S^2) 11.13803867 mH 6.98922508 kcal mol^-1; Exch11(S^2) 0.04558910 mH 0.02860760 kcal mol^-1; Exch12(S^2) 2.15411167 mH 1.35172554 kcal mol^-1. Induction -3.91333155 mH -2.45565272 kcal mol^-1; Ind20,r -4.57531220 mH -2.87105187 kcal mol^-1; Ind30,r -4.91715479 mH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/sapt-1.html:14503,energy,energy,14503,psi4manual/4.0b5/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"ibmkl_rt.so"" -DLAPACK_INCLUDE_DIRS=""${CONDA_PREFIX}/include"". OpenBLAS - see note below. >>> MATH_ROOT=/path/to/openblas/0.2.13_seq/x86_64/gcc_5.2.0/lib cmake. Build with explicit MKL LAPACK. >>> cmake -DLAPACK_LIBRARIES=""/path/to/lib/intel64/libmkl_lapack95_lp64.a;/path/to/lib/intel64/libmkl_rt.so"" -DLAPACK_INCLUDE_DIRS=""/path/to/mkl-h-include/"". Build with explicit non-MKL LAPACK. >>> cmake -DLAPACK_LIBRARIES=""/path/to/lib/liblapack.so;/path/to/lib/libblas.a"". Notes. Much of PSI4’s speed and efficiency depends on the corresponding; speed and efficiency of the linked BLAS and LAPACK libraries; (especially the former). Consider the following recommendations:; It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat, as it is usually just the completely; unoptimized netlib distribution. The choice of LAPACK is less; critical, and so the unoptimized netlib distribution is acceptable.; Perhaps the best choice, if available, is Intel’s MKL library,; which includes efficient threaded BLAS and LAPACK (as of PSI4; v1.1, earliest known working version is MKL 2013). MKL, which is; freely available through conda, is the only threaded BLAS/LAPACK; distribution fully supported by PSI4.; On Mac, the native Accelerate libraries are very nice and would; be recommended but for the potential conflict between PSI4; BLAS and NumPy BLAS. Unless you’ve a special NumPy, avoid!; The open-source LAPACK distributions OpenBLAS (formerly GotoBLAS); mostly works. Use it at your own risk and after testing your; particular distribution, including tests run multithreaded,; if you intend to run PSI4 so. Use at least 0.2.15, and; pay attention to how it was compiled - unthreaded seems safe,; openmp-threaded is mostly safe, default pthreaded is not safe. See; https://github.com/psi4/psi4/issues/1009 for recent analysis.; Another open-source LAPACK distribution, ATLAS had; stability issues with the DFOCC module at last testing,; https://github.com/psi4/psi4/iss",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:37940,efficient,efficient,37940,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['efficient'],['efficient']
Energy Efficiency,"ibution to the reduced; density matrix energy expression, plus the contribution of the; antisymmetrized product of 1RDMs. Not recommended for interpretative; use except by reduced density matrix specialists. DCT THREE-PARTICLE ENERGY¶; The three-particle correlation energy correction [E_h] in density cumulant; theory, akin to (T) CORRECTION ENERGY in coupled-cluster. DCT TOTAL ENERGY¶; Total energy [E_h] in density cumulant theory. Sum of DCT SCF ENERGY,; DCT LAMBDA ENERGY, and DCT THREE-PARTICLE ENERGY when present. DETCI AVG DVEC NORM¶; A measure of configuration interaction convergence. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [E_h] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (4) or (1). Quantity; \(E_{\text{FCTL}}\) in Eqs. (4) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [E_h] for the requested DFT method,; \(E_{\text{DFT}}\) in Eq. (1). \begin{align*}; E_{\text{DFT}} & = E_{NN} + E_{1e^-} + E_{2e^-} + E_{xc} + E_{\text{-D}} + E_{\text{DH}} \\; & = E_{\text{FCTL}} + E_{\text{-D}} + E_{\text{DH}} \\; & = E_{\text{SCF}} + E_{\text{DH}}; \end{align*}Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT TOTAL GRADIENT¶; The total electronic gradient [E_h/a0] of the requested DFT method, ({nat}, 3). DFT DIPOLE GRADIENT¶; The derivative of the requested DFT method dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). DFT TOTAL HESSIAN¶; The total electronic second derivative [E_h/a0/a0] for the requested DFT method, (3 * {nat}, 3 * {nat}). DFT XC ENERGY¶; The functional energy contribution [E_h] to the total SCF energy (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:28392,energy,energy,28392,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"ibution to; ROHF-MBPT(2) using semicanonical orbitals, the spin-free equations are. and. Note that the UHF-MP2 equations use three classes of integrals, while the; RHF-MP2 equations use only one class. Because of this, a UHF-MP2 or; ROHF-MBPT(2) energy should take roughly three times as long as an RHF-MP2; energy. Recommendations¶; All-in-all, DFMP2 should be a simple module to use, with few keywords (fully; documented in the Appendix DFMP2). Some basic recommendations are included below:. DFMP2 should be run with the -type RI or MP2FIT auxiliary; basis sets, not the -JKFIT basis sets. The automatic basis selector; should work fine for all of the Dunning and Pople bases (provided the auxiliary; basis exists for the atom in question). If it does not, use the; DF_BASIS_MP2 keyword to manually specify the basis.; DFMP2 likes memory. At a minimum, doubles are required,; where is the size of the auxiliary basis set. However, there is; one disk transpose of the tensor in the RHF-MP2 algorithm; [two for UHF-MP2 and ROHF-MBPT(2)], so more memory will reduce seek times.; If you notice DFMP2 using more memory than allowed, it is possible that; the threaded three-index ERI computers are using too much overhead memory.; Set the DF_INTS_NUM_THREADS to a smaller number to prevent this; in this section (does not affect threaded efficiency in the rest of the; code).; DFMP2 likes disk. At a minimum, doubles are required for; RHF-MP2, and doubles are required for UHF-MP2.; DFMP2 likes threads. Some of the formation of the tensor; relies on threaded BLAS (such as MKL) for efficiency. The main; step is done via small/medium-sized DGEMMs inside of; OpenMP, so make sure to set the OMP_NESTED environment variable; to FALSE to prevent thread thrash (or just as well, do not define; OMP_NESTED at all).; Freezing core is good for both efficiency and correctness purposes.; Freezing virtuals is not recommended. The DFMP2 module will remind you how; many frozen/active orbitals it is using in a se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dfmp2-1.html:6489,reduce,reduce,6489,psi4manual/1.0.0/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dfmp2-1.html,8,['reduce'],['reduce']
Energy Efficiency,"ic License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]; class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1):",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:1595,charge,charge,1595,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,2,['charge'],['charge']
Energy Efficiency,"ic build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]]) → List[List[Tuple[float, float]]]; Computes the density-fitted EP2 energy for the input orbitals. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.dfep2wavefunction.html:3773,energy,energy,3773,psi4manual/1.2.1/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.dfep2wavefunction.html,1,['energy'],['energy']
Energy Efficiency,"ic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec(banners). try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; optstash.restore(); return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies); ; # The last item in the list is the reference energy, return it; optstash.restore(); return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:40424,energy,energy,40424,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"ic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec(banners). try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies). # The last item in the list is the reference energy, return it; return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+================",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:31981,energy,energy,31981,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,ic unit of charge density [C m^{-3}] uncertainty=0.000 000 0067 e12. atomic_unit_of_current; 0.006623618183; atomic unit of current [A] uncertainty=0.000 000 041 e-3. atomic_unit_of_electric_dipole_mom; 8.478353552E-30; atomic unit of electric dipole mom. [C m] uncertainty=0.000 000 052 e-30. atomic_unit_of_electric_field; 5.142206707E+11; atomic unit of electric field [V m^{-1}] uncertainty=0.000 000 032 e11. atomic_unit_of_electric_field_gradient; 9.717362356E+21; atomic unit of electric field gradient [V m^{-2}] uncertainty=0.000 000 060 e21. atomic_unit_of_electric_polarizability; 1.6487772731E-41; atomic unit of electric polarizability [C^2 m^2 J^{-1}] uncertainty=0.000 000 0011 e-41. atomic_unit_of_electric_potential; 27.21138602; atomic unit of electric potential [V] uncertainty=0.000 000 17. atomic_unit_of_electric_quadrupole_mom; 4.486551484E-40; atomic unit of electric quadrupole mom. [C m^2] uncertainty=0.000 000 028 e-40. atomic_unit_of_energy; 4.359744650E-18; atomic unit of energy [J] uncertainty=0.000 000 054 e-18. atomic_unit_of_force; 8.23872336E-8; atomic unit of force [N] uncertainty=0.000 000 10 e-8. atomic_unit_of_length; 5.2917721067E-11; atomic unit of length [m] uncertainty=0.000 000 000 12 e-10. atomic_unit_of_mag_dipole_mom; 1.854801999E-23; atomic unit of mag. dipole mom. [J T^{-1}] uncertainty=0.000 000 011 e-23. atomic_unit_of_mag_flux_density; 235051.7550; atomic unit of mag. flux density [T] uncertainty=0.000 000 014 e5. atomic_unit_of_magnetizability; 7.8910365886E-29; atomic unit of magnetizability [J T^{-2}] uncertainty=0.000 000 0090 e-29. atomic_unit_of_mass; 9.10938356E-31; atomic unit of mass [kg] uncertainty=0.000 000 11 e-31. atomic_unit_of_momum; 1.992851882E-24; atomic unit of mom.um [kg m s^{-1}] uncertainty=0.000 000 024 e-24. atomic_unit_of_permittivity; 1.112650056E-10; atomic unit of permittivity [F m^{-1}] uncertainty=(exact). atomic_unit_of_time; 2.418884326509E-17; atomic unit of time [s] uncertainty=0.000 000 000 014,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:4022,energy,energy,4022,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['energy'],['energy']
Energy Efficiency,"ical atoms. rotor_type(self: psi4.core.Molecule) → str¶; Returns rotor type, e.g. ‘RT_ATOM’ or ‘RT_SYMMETRIC_TOP’. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]¶; Compute dispersion correction via Grimme’s DFTD3 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[dashlvl][‘default’]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None]) – Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (~numpy.ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]¶; Compute dispersion correction via Grimme’s DFTD4 program. Parameters:. func (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to run.; dashparam (Optional[Dict]) – Values for the same keys as dashcoeff[",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:28662,energy,energy-only,28662,psi4manual/1.7.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html,16,"['efficient', 'energy']","['efficient', 'energy-only']"
Energy Efficiency,"ical rotation calculation; >>> property('cc2', properties=['rotation']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); #PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['property'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Hartree--Fock (HF) or density functional theory (DFT) |; +-------------------------+---------------------------------------------------------------------------------------+; | dcft | density cumulant functional theory |; +-------------------------+---------------------------------------------------------------------------------------+; | mp2 | 2nd-order Moller-Plesset perturbation theory (MP2) |; +-------------------------+---------------------------------------------------------------------------------------+; | cc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:35399,ENERGY,ENERGY,35399,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ical) water Hessian test, against Psi3 reference values. ao-casscf-sp; CASSCF/6-31G** energy point. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. fnocc6; Test method/basis with disk_df. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc36; CC2(RHF)/cc-pVDZ energy of H2O. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. sapt-compare; SAPT0 aug-cc-pVDZ computation of the water-water interaction energy, using the three SAPT codes. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. cepa1; cc-pvdz H2O Test CEPA(1) Energy. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. ao-dfcasscf-sp; CASSCF/6-31G** energy point. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:39723,energy,energy,39723,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ications resulting from the use of MP2 NO-based approximations should; cite the following: [Hohenstein:2010:104107]. Basic Keywords Controlling MP2 NO Approximations¶. NAT_ORBS¶. Do natural orbitals to speed up evaluation of the triples contribution to dispersion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/sapt-1.html:12137,energy,energy,12137,psi4manual/4.0b2/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html,12,"['charge', 'energy']","['charge-transfer', 'energy']"
Energy Efficiency,"icense along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. from __future__ import print_function; import math; import re; import psi4; import qcdb; import p4util; from p4util.exceptions import *; from procedures import *. def _method_exists(ptype, method_name):; r""""""; Quick check to see if this method exists, if it does not exist we raise a convenient flag.; """"""; if method_name not in procedures[ptype].keys():; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(method_name,; procedures[ptype].keys(), 2); if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)); Cptype = ptype[0].upper() + ptype[1:]; raise ValidationError('%s method ""%s"" is not available.%s' % (Cptype, method_name, alternatives)). def _set_convergence_criterion(ptype, method_name, scf_Ec, pscf_Ec, scf_Dc, pscf_Dc, gen_Ec, verbose=1):; r""""""; This function will set local SCF and global energy convergence criterion; to the defaults listed at:; http://www.psicode.org/psi4manual/master/scf.html#convergence-and-; algorithm-defaults. SCF will be converged more tightly if a post-SCF; method is select (pscf_Ec, and pscf_Dc) else the looser (scf_Ec, and; scf_Dc convergence criterion will be used). ptype - Procedure type (energy, gradient, etc). Nearly always test on; procedures['energy'] since that's guaranteed to exist for a method.; method_name - Name of the method; scf_Ec - E convergence criterion for scf target method; pscf_Ec - E convergence criterion for scf of post-scf target method; scf_Dc - D convergence criterion for scf target method; pscf_Dc - D convergence criterion for scf of post-scf target method; gen_Ec - E convergence criterion for post-scf target method. """"""; optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Kind of want to move this out of here; _method_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html:1845,energy,energy,1845,psi4manual/1.0.0/_modules/driver_util.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_util.html,1,['energy'],['energy']
Energy Efficiency,"ich is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step (in; principle, these numbers could inc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:7017,energy,energy,7017,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,9,['energy'],['energy']
Energy Efficiency,"ich is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step; (in principle, these numbers could inc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psiapi.html:6891,energy,energy,6891,psi4manual/1.9.x/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psiapi.html,2,['energy'],['energy']
Energy Efficiency,"ich is typically less complete (and less expensive) than CASSCF.; Inactive orbitals in the MCSCF may be specified by the; RESTRICTED_DOCC and RESTRICTED_UOCC keywords. These; orbitals will remain doubly-occupied or doubly-unoccupied, respectively, in the; MCSCF wavefunction. However, the form of these orbitals will be optimized in; the MCSCF procedure. It is also possible to literally freeze inactive orbitals; in their original (SCF) form using the FROZEN_DOCC and; FROZEN_UOCC keywords. This is not normally what one wishes to do in; an MCSCF computation (e.g., it complicates the computation of gradients), but; it can make the computations faster and is helpful in some circumstances where; unphysical mixing of inactive and active occupied orbitals might occur.; Presently, it is not possible to mix the use of restricted and frozen orbitals; in PSI4.; An illustrative CASSCF example is as follows:; molecule {; O; H 1 1.00; H 1 1.00 2 103.1; }. set {; basis 6-31G**; restricted_docc [1, 0, 0, 0]; active [3, 0, 1, 2]; }; energy('casscf'). This input will compute the CASSCF energy of water where the 1s Oxygen orbital; and several virtual orbitals are not included in the CI expansion, but are; still optimized. The following is a full list of spaces within the various MCSCF; types. Orbital spaces for MCSCF computations¶. RASSCF; CASSCF. FROZEN_UOCC; FROZEN_UOCC. RESTRICTED_UOCC; RESTRICTED_UOCC. RAS4; ACTIVE. RAS3. RAS2. RAS1. RESTRICTED_DOCC; RESTRICTED_DOCC. FROZEN_DOCC; FROZEN_DOCC. Basic MCSCF Keywords¶. MCSCF_E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-7. MCSCF_R_CONVERGENCE¶. Convergence criterion for the RMS of the orbital gradient. Type: conv double; Default: 1e-5. MCSCF_TYPE¶. Method to handle the two-electron integrals. Type: string; Possible Values: DF, CONV, AO; Default: CONV. MCSCF_ALGORITHM¶. Convergence algorithm to utilize. Two-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/mcscf-1.html:2522,energy,energy,2522,psi4manual/1.4.0/mcscf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/mcscf-1.html,9,['energy'],['energy']
Energy Efficiency,"ich to rotate. Type: double; Default: 0.0. ROTATE_MO_IRREP (MCSCF); MCSCF (Expert) — For orbital rotations after convergence, irrep (1-based, Cotton order) of the orbitals to rotate. Type: integer; Default: 1. ROTATE_MO_P (MCSCF); MCSCF (Expert) — For orbital rotations after convergence, number of the first orbital (1-based) to rotate. Type: integer; Default: 1. ROTATE_MO_Q (MCSCF); MCSCF (Expert) — For orbital rotations after convergence, number of the second orbital (1-based) to rotate. Type: integer; Default: 2. ROTATION_SCHEME (STABILITY); STABILITY — Method for following eigenvectors, either 0 by angles or 1 by antisymmetric matrix. Type: integer; Default: 0. RUN_CCSD (FNOCC); FNOCC (Expert) — do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA (FNOCC); FNOCC (Expert) — Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2 (FNOCC); FNOCC (Expert) — do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3 (FNOCC); FNOCC (Expert) — do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4 (FNOCC); FNOCC (Expert) — do only evaluate mp4 energy?. Type: boolean; Default: false. S (DETCI); DETCI — The value of the spin quantum number is given by this option. The default is determined by the value of the multiplicity. This is used for two things: (1) determining the phase of the redundant half of the CI vector when the component is used (i.e., MS0 = TRUE), and (2) making sure the guess vector has the desired value of (if S_SQUARED is TRUE and ICORE = 1). Type: double; Default: 0.0. S_ORTHOGONALIZATION (SCF); SCF — SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_SQUARED (DETCI); DETCI — Do calculate the value of for each root? Only supported for ICORE = 1. Type: boolean; Default: false. S_TOLERANCE (SCF); SCF — Minimum S matrix eigenvalue t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:114117,energy,energy,114117,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"ich will first call the SCF module and perform the SCF computation; with RHF reference to obtain a guess for the DCT orbitals. After SCF is; converged, the program will perform the energy computation using the ODC-12; method. By default, simultaneous algorithm will be used for the solution of; the equations. One can also request to perform geometry; optimization following example below:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. optimize('dct'). The optimize('dct') call will first perform all of the procedures; described above to obtain the ODC-12 energy. After that, the ODC-12 analytic; gradients code will be executed and geometry optimization will be performed. Recommendations¶; Here is a list of recommendations for the DCT module:. Generally, the use of the simultaneous algorithm together with the; AO_BASIS DISK option is recommended (set by default).; In cases when available memory is insufficient, the use of the AO_BASIS DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In cases when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by setting the; DIIS_START_CONVERGENCE option to the value greater than; \(10^{-3}\) by one or two orders of magnitude (e.g. \(10^{-2}\) or; \(10^{-1}\)). This can be particularly useful for computations using the; ODC methods, because it can greatly reduce the number of iterations.; If oscillatory convergence is observed for atoms or molecules with high; symmetry, it is recommended to use the quadratically-convergent algorithm.; When using the quadratically-convergent algorithm for the closed-shell molecules, it; is recommended to set the QC_COUPLING option ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:14269,reduce,reduce,14269,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,9,['reduce'],['reduce']
Energy Efficiency,"icient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not; all the electrons are paired. For example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not correct, so we need to tell the program the true value (3). Like; many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of; the molecule specification below). In this example, we will also specify; the bond length and bond angle as variables (\(R\) and \(A\)),; whose values are first stored and then inserted into the geometry; specification using Python 3 string; formatting. In [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (res",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:5130,charge,charge,5130,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['charge'],['charge']
Energy Efficiency,"icle correlation effects, similarly to the (T) correction in coupled; cluster theory. Computation of the \((\lambda_3)\) correction can be; requested by setting the THREE_PARTICLE option to PERTURBATIVE. A; combination of the ODC-13 functional with the \((\lambda_3)\) correction; [denoted as \(\mbox{ODC-13$(\lambda_3)$}\)] has been shown to provide highly; accurate results for open-shell molecules near equilibrium geometries.; At the present moment, all of the DCFT methods support unrestricted reference; orbitals (REFERENCE UHF), which can be used to perform energy and; gradient computations for both closed- and open-shell molecules. In addition,; the ODC-06 and ODC-12 methods support restricted reference orbitals; (REFERENCE RHF) for the energy and gradient computations of; closed-shell molecules. Note that in this case restricted reference orbitals; are only available for ALGORITHM SIMULTANEOUS. Iterative Algorithms¶; As explained in the Theory section, in order to obtain the DCFT energy one; needs to solve a system of coupled equations for orbitals and density; cumulant. At the present moment three iterative algorithms for the solution of the; equations are available. The choice of the algorithm is controlled using the; ALGORITHM option. SIMULTANEOUS [Default]; In the simultaneous algorithm the DCFT equations are solved in macroiterations.; Each macroiteration consists of a single iteration of the cumulant update; followed by a single iteration of the orbital update and orbital transformation; of the integrals. The macroiterations are repeated until the simultaneous; convergence of the cumulant and orbitals is achieved.; Convergence of the simultaneous algorithm is accelerated using the; DIIS extrapolation technique.; TWOSTEP; In the two-step algorithm each macroiteration consists of two sets of; microiterations. In the first set, the density cumulant equations are solved; iteratively, while the orbitals are kept fixed. After the density cumulant is; converged, t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dcft-1.html:8274,energy,energy,8274,psi4manual/1.2.1/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dcft-1.html,6,['energy'],['energy']
Energy Efficiency,"icle density matrix is separated into its idempotent part; \(\boldsymbol{\kappa}\) and a correction \(\boldsymbol{\tau}\):. \[\gamma_p^q = \kappa_p^q + \tau_p^q\]; The idempotent part of \(\boldsymbol{\gamma_1}\) corresponds to a mean-field Hartree–Fock-like density,; while the non-idempotent correction \(\boldsymbol{\tau}\); depends on the density cumulant and describes the electron correlation effects.; Inserting the above two equations into the energy expression, we obtain:. \[E_{DCFT} = \frac{1}{2} \left( h_p^q + f_p^q \right) \gamma_q^p + \frac{1}{4} \bar{g}_{pq}^{rs} \lambda_{rs}^{pq}\]; where the antisymmetrized two-electron integrals and the generalized Fock operator; matrix elements were defined as follows:. \[\bar{g}_{pq}^{rs} = g_{pq}^{rs} - g_{pq}^{sr}\]. \[f_p^q = h_p^q + \bar{g}_{pr}^{qs} \gamma_{s}^{r}\]; Energy functional \(E_{DCFT}\) has several important properties. First,; the energy is now a function of two sets of independent parameters, the; idempotent part of \(\boldsymbol{\gamma_1}\) (\(\boldsymbol{\kappa}\)) and the density cumulant; (\(\boldsymbol{\lambda_2}\)). As a result, the energy functional is Hermitian,; which is important for the evaluation of the molecular properties. The additive; separability of the density cumulant guarantees that all of the DCFT methods; are size-extensive and size-consistent. Furthermore, the N-representability; problem is now greatly simplified, because the idempotent part of \(\boldsymbol{\gamma_1}\) is; N-representable by construction. One only needs to worry about the; N-representability of the density cumulant, which is a relatively small part of; \(\boldsymbol{\gamma_2}\).; In order to obtain the DCFT energy, two conditions must be satisfied:. The energy must be stationary with respect to a set of orbitals. This can be done by; diagonalizing the generalized Fock operator (as in the DC-06 and DC-12 methods, see below),; which introduces partial orbital relaxation, or by fully relaxing the orbitals and min",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dcft-1.html:2886,energy,energy,2886,psi4manual/1.2.1/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dcft-1.html,6,['energy'],['energy']
Energy Efficiency,"ics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. mcscf1; ROHF 6-31G** energy of the state of CH2, with Z-matrix input. The occupations are specified explicitly. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. fci-h2o-2; 6-31G H2O Test FCI Energy Point. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cc54; CCSD dipole with user-specified basis set. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc33; CC3(UHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). casscf-sp; CASSCF/6-31G** energy point. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-dif",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:25040,energy,energy,25040,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"icted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734857 -76.026632734857 0.01523505 0.01245744 0.02742199 0.02277500 ~; 2 -76.027022668419 -0.000389933562 0.00178749 0.00142923 0.01007985 0.00594840 ~; 3 -76.027032729361 -0.000010060942 0.00014016 0.00008485 0.00077279 0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:5541,energy,energy,5541,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,6,['energy'],['energy']
Energy Efficiency,"icular negative eigenvalue of the orbital rotation Hessian (see the explanation of keyword CFOUR_ROT_EVEC), after which the SCF is rerun. Type: string; Possible Values: OFF, ON, FOLLOW; Default: OFF. CFOUR_INCORE (CFOUR)¶CFOUR — This keyword can be used to significantly reduce disk i/o, and should be implemented very soon. The following options are available: OFF (= 0), no special algorithms are used (the default case); ALL (=1) all quantities except the \(\langle ab\vert\vert cd\rangle\) molecular integral lists are held in core; PARTIAL (= 2), the T2 and T1 vectors are held in core throughout the calculation; (=4) all quantities except the \(\langle ab\vert\vert cd\rangle\) and \(\langle ab\vert\vert ci\rangle\) integrals are held in core; (=5) \(\langle ij\vert\vert kl\rangle\) and \(\langle ij\vert\vert ka\rangle\) and two-index quantities are held in core; (=6) all direct access files (MOINTS, GAMLAM, etc.) are held in core. At present, these options have been implemented only in the energy code xvcc and the excitation energy code xvee. (Default: 0). Type: string; Possible Values: OFF, ALL, PARTIAL; Default: OFF. CFOUR_INPUT_MRCC (CFOUR)¶CFOUR — Specifies whether an input for mrcc is written (ON, =0) or not (OFF, =1) if CFOUR_CC_PROGRAM =EXTERNAL has been specified. Type: boolean; Default: true. CFOUR_INTEGRALS (CFOUR)¶CFOUR — This keyword defines what type of integral input will be written by xjoda. VMOL (=1) has to be used with the programs of CFOUR. Using ARGOS (=0), input for Pitzer’s ARGOS integral program will be written. (Default: VMOL). Type: string; Possible Values: VMOL, ARGOS; Default: VMOL. CFOUR_JODA_PRINT (CFOUR)¶CFOUR — Controls amount of debug printing performed by xjoda. The higher the number, the more information is printed. Values of 25 or higher generally do not produce anything of interest to the general user. Do not set JODA_PRINT to 999 as this will cause the core vector to be dumped to disk. Type: integer; Default: 0. CFOUR_LINEQ_CONV (C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:52782,energy,energy,52782,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,18,['energy'],['energy']
Energy Efficiency,"id basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:9927,energy,energy,9927,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"iderations. Cube File Visualization with PyMol¶; Setting FISAPT_DO_PLOT true above generates a set of .cube files; containing the densities and ESPs of the various subsystems in the I-SAPT; embedding procedure. These can be used to gain a detailed understanding of the; intermolecular partition and the polarization between non-interacting and; Hartree–Fock-interacting moieties. We have developed a set of template; .pymol scripts to help with this process. These can be obtained by running:; >>> copy_pymol2.py. and then in PyMol:; >>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; DA.pymol), which in turn load in the molecule and cube file data; (contained in the .cube file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some specific; details of the .pymol files require some small tweaks to permit; publication-quality renderings. Adding Point Charges to F/I-SAPT Computations¶; Point charges can be added to the interacting subsystems A and B as well; as to the linking fragment C. Briefly, the interaction between the point charges in A(B); and fragment B(A) enters the SAPT0 interaction energy. It explicitly affects the electrostatics; and induction components, and implicitly affects other SAPT0 components by polarizing the orbitals.; If point charges are present in both subsystems A and B, an additional charge-charge interaction; term is also added to the electrostatic energy. When point charges are assigned to subsystem C, the point; charges in C only polarize the orbitals in both fragment A and B. However, the presence of charges in C does not; directly contribute to the SAPT0 interaction energy.; Examples fsapt-ext-abc and fsapt-ext-abc2; illustrate the use of point charges in F/I-SAPT procedure. Link Orbital Partitioning in I-SAPT¶; The assignment of the A-C and B-C linking electron pairs is controlled by the FISAPT_LINK_ASSIGNMENT; keyword. The default setting fisapt_link_assignmen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/fisapt.html:12180,charge,charges,12180,psi4manual/1.8.x/fisapt.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/fisapt.html,3,['charge'],['charges']
Energy Efficiency,"iderations. Cube File Visualization with PyMol¶; Setting FISAPT_DO_PLOT true above generates a set of .cube files; containing the densities and ESPs of the various subsystems in the I-SAPT; embedding procedure. These can be used to gain a detailed understanding of the; intermolecular partition and the polarization between non-interacting and; Hartree–Fock-interacting moieties. We have developed a set of template; .pymol scripts to help with this process. These can be obtained by running:; >>> copy_pymol2.py. and then in PyMol:; >>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; DA.pymol), which in turn load in the molecule and cube file data; (contained in the .cube file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some specific; details of the .pymol files require some small tweaks to permit; publication-quality renderings. Adding Point Charges to F/I-SAPT Computations¶; Point charges can be added to the interacting subsystems A and B as well; as to the linking fragment C. Briefly, the interaction between the point charges in A(B); and fragment B(A) enters the SAPT0 interction energy. It explicitly affects in the electrostatics; and induction components, and implicitly affects other SAPT0 components by polarizing the orbitals.; If point charges are present in both subsystems A and B, an additional charge-charge interaction; term is also added to the electrostatic energy. When point charges are assigned to subsystem C, the point; charges in C only polarize the orbitals in both fragment A and B. However, the presence of charges in C does not; directly contribute to the SAPT0 interaction energy.; Examples fsapt-ext-abc and fsapt-ext-abc2; illustrate the use of point charges in F/I-SAPT procedure. F/I-SAPT Keywords¶; The input files described above cover roughly 90% of all F/I-SAPT analyses. For; more delicate or involved problems, there are a large number of user options; that perm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fisapt-1.html:12012,charge,charges,12012,psi4manual/1.4.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fisapt-1.html,6,['charge'],['charges']
Energy Efficiency,"idues ({residues.shape}) vectors do not match!""). # Validate kind of spectrum; kind = kind.lower(); valid_kinds = [""opa"", ""ecd""]; if kind not in valid_kinds:; raise ValueError(f""Spectrum kind {kind} not among recognized ({valid_kinds})""). # Validate output units; out_units = out_units.lower(); valid_out_units = [""au"", ""eh"", ""ev"", ""nm"", ""thz""]; if out_units not in valid_out_units:; raise ValueError(f""Output units {out_units} not among recognized ({valid_out_units})""). c = constants.get(""speed of light in vacuum""); c_nm = c * constants.conversion_factor(""m"", ""nm""); hbar = constants.get(""Planck constant over 2 pi""); h = constants.get(""Planck constant""); Eh = constants.get(""Hartree energy""); au_to_nm = 2.0 * np.pi * c_nm * hbar / Eh; au_to_THz = (Eh / h) * constants.conversion_factor(""Hz"", ""THz""); au_to_eV = constants.get(""Hartree energy in eV""). converters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). # Broadening functions; gammas = {; ""au"": lambda x_0: gamma, # Angular frequency in atomic units; ""eh"": lambda x_0: gamma, # Energy in atomic units; ""ev"": lambda x_0: gamma * au_to_eV, # Energy in electronvolts; ""nm"": lambda x_0: ((x_0**2 * gamma * (Eh / hbar)) / (2 * np.pi * c_nm)), # Wavelength in nanometers; ""thz"": lambda x_0: gamma * au_to_THz, # Frequency in terahertz; }. # Generate x axis; # Add a fifth of the range on each side; expand_side = (np.max(poles) - np.min(poles)) / 5; x = np.linspace(np.min(poles) - expand_side, np.max(poles) + expand_side, npoints). # Validate lineshape; lineshape = lineshape.lower(); valid_lineshapes = [""gaussian"", ""lorentzian""]; if lineshape not in valid_lineshapes:; raise ValueError(f""Linesh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:11164,Energy,Energy,11164,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,8,['Energy'],['Energy']
Energy Efficiency,"idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 0], idxs[sl, 1], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 2], idxs[sl, 3])] = ints[sl]; eri[(idxs[sl, 1], idxs[sl, 0], idxs[sl, 3], idxs[sl, 2])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 0], idxs[sl, 1])] = ints[sl]; eri[(idxs[sl, 2], idxs[sl, 3], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; eri[(idxs[sl, 3], idxs[sl, 2], idxs[sl, 1], idxs[sl, 0])] = ints[sl]; intdump['eri'] = eri. return intdump. [docs]; def compare_fcidumps(expected: str, computed: str, label: str):; """"""Comparison function for FCIDUMP files.; Compares the first six below, then computes energies from MO integrals and compares the last four. - 'norb' : number of basis functions; - 'nelec' : number of electrons; - 'ms2' : spin polarization of the system; - 'isym' : symmetry of state (if present in FCIDUMP); - 'orbsym' : list of symmetry labels of each orbital; - 'uhf' : whether restricted or unrestricted; - 'ONE-ELECTRON ENERGY' : SCF one-electron energy; - 'TWO-ELECTRON ENERGY' : SCF two-electron energy; - 'SCF TOTAL ENERGY' : SCF total energy; - 'MP2 CORRELATION ENERGY' : MP2 correlation energy. :param expected: Reference FCIDUMP file against which `computed` is compared.; :param computed: Input FCIDUMP file to compare against `expected`.; :param label: string labeling the test; """""". # Grab expected header and integrals; ref_intdump = fcidump_from_file(expected); intdump = fcidump_from_file(computed). # Compare headers; compare_recursive(; ref_intdump,; intdump,; 'FCIDUMP header',; forgive=['enuc', 'hcore', 'eri', 'epsilon']). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:12660,energy,energy,12660,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,36,"['ENERGY', 'energy']","['ENERGY', 'energy']"
Energy Efficiency,"ied block of the unperturbed density matrix in analytic derivative calculations. For testing purposes, it is possible to force the use standard perturbed orbitals even in case of iterative triple excitations via the option FORCE_STANDA (dne?). Note also that in case of unrelaxed derivatives standard orbitals must be used. Default : STANDARD for all methods without triples (except CCSDT), CANONICAL for all methods with triples in case of relaxed derivatives. Type: string; Possible Values: STANDARD, CANONICAL, IJ_CANONICAL; Default: No Default. CFOUR_POINTS (CFOUR)¶CFOUR — Specifies either single (=1, or SINGLE) or double (=2, DOUBLE) sided numerical differentiation in the finite difference evaluation of the Hessian. Two-sided numerical differentiation is considerably more accurate than the single-sided method, and its use is strongly recommended for production work. Type: string; Possible Values: SINGLE, DOUBLE; Default: DOUBLE. CFOUR_PRINT (CFOUR)¶CFOUR — Controls the amount of printing in the energy and energy derivative calculation programs. Using a value of 1 will produce a modest amount of additional output over the default value of 0, which includes some useful information such as SCF eigenvectors, Fock matrix elements, etc. Type: integer; Default: 0. CFOUR_PROP_INTEGRAL (CFOUR)¶CFOUR — Allows storage of property integrals computed in xvdint on internal files (e.g., MOINTS and GAMLAM, default choice INTERNAL, =0) or on external files (EXTERNAL, =1). Type: string; Possible Values: INTERNAL, EXTERNAL; Default: INTERNAL. CFOUR_PROPS (CFOUR)¶CFOUR — Specifies whether and which molecular property is calculated. OFF (=0) means that no property is calculated, FIRST_ORDER (=1) requests computation of various one-electron first-order properties (e.g., dipole moment, quadrupole moment, electric field gradient, spin densities,etc.), SECOND_ORDER (=2, in the next release replaced by STAT_POL) computes static electric polarizabilities, DYNAMICAL (=7, in the next release rep",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:65476,energy,energy,65476,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,18,['energy'],['energy']
Energy Efficiency,"ied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). full_hess_every = PsiMod.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. # are we in sow/reap mode?; isSowReap = False; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'sow'):; isSowReap = True; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; isSowReap = True; optstash = OptionsState(; ['SCF', 'GUESS']). n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. PsiMod.get_active_mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:50044,energy,energy,50044,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"ied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). full_hess_every = psi4.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. # are we in sow/reap mode?; isSowReap = False; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'sow'):; isSowReap = True; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; isSowReap = True; optstash = p4util.OptionsState(; ['SCF', 'GUESS']). n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. psi4.get_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:50287,energy,energy,50287,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"ied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with utility functions for use in input files.""""""; from __future__ import division; import re; import sys; import os; import math; import numpy as np; from .exceptions import *. [docs]def oeprop(wfn, *args, **kwargs):; """"""Evaluate one-electron properties. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. :type title: string; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); oe.compute(). [docs]def cubeprop(wfn, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CU",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html:1688,energy,energy,1688,psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,1,['energy'],['energy']
Energy Efficiency,"ied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for use in input files.""""""; from __future__ import division; import os; import re; import sys; import math. import numpy as np. from .exceptions import *. [docs]def oeprop(wfn, *args, **kwargs):; """"""Evaluate one-electron properties. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. :type title: string; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); oe.compute(). [docs]def cubeprop(wfn, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CU",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html:1690,energy,energy,1690,psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html,1,['energy'],['energy']
Energy Efficiency,"ied. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible \(M_s\) value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; 1; 2; 3; 4; 5; 6; 7mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fragmented. Advanced Python¶; A named molecule in an input file is a full-fledged instance of the; powerful C++ Molecule class. Thus, all member; functions (that have been exported via pybind11) documented thereat; are accessible through the handle option_molecule_name in; molecule optional_molecule_name {...}. The molecular geometry can be got and set and manipulated as a; Matrix object. Below shows how to access; coordinates in an input file in Python.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:16529,energy,energy,16529,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['energy'],['energy']
Energy Efficiency,"ield [au] for dynamic properties. Type: array; Default: No Default. OMEGA (RESPONSE); RESPONSE —. Type: array; Default: No Default. OMP2_ORBS_PRINT (OMP2); OMP2 — Do ?. Type: boolean; Default: false. OMP_N_THREAD (CPHF); CPHF — The maximum number of integral threads (0 for omp_get_max_threads()). Type: integer; Default: 0. ONEPDM (CCDENSITY); CCDENSITY — Do ?. Type: boolean; Default: false. OPDM (DETCI); DETCI — Do compute one-particle density matrix if not otherwise required?. Type: boolean; Default: false. OPDM (MP2); MP2 — Do compute the one particle density matrix, for properties?. Type: boolean; Default: false. OPDM_AVG (DETCI); DETCI — Do average the OPDM over several roots in order to obtain a state-average one-particle density matrix? This density matrix can be diagonalized to obtain the CI natural orbitals. Type: boolean; Default: false. OPDM_IN_FILE (TRANSQT); TRANSQT —. Type: integer; Default: PSIF_MO_OPDM. OPDM_KE (DETCI); DETCI (Expert) — Do compute the kinetic energy contribution from the correlated part of the one-particle density matrix?. Type: boolean; Default: false. OPDM_OUT_FILE (TRANSQT); TRANSQT —. Type: integer; Default: PSIF_AO_OPDM. OPDM_PRINT (DETCI); DETCI — Do print the one-particle density matrix for each root?. Type: boolean; Default: false. OPDM_RELAX (CCDENSITY); CCDENSITY — Do relax the one-particle density matrix?. Type: boolean; Default: false. OPDM_RELAX (MP2); MP2 — Do add relaxation terms to the one particle density matrix, for properties?. Type: boolean; Default: false. OPT_METHOD (OMP2); OMP2 —. Type: string; Possible Values: SD, DIIS; Default: DIIS. OPT_TYPE (OPTKING); OPTKING — Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. ORTH_TYPE (OMP2); OMP2 —. Type: string; Possible Values: GS, MGS; Default: MGS. PAIR_ENERGIES_PRINT (CCENERGY); CCENERGY — Do print MP2 and CCSD pair energies for RHF references?. Type: boolean; Default: false. PARALLEL (SCF);",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:69658,energy,energy,69658,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"ield. Whether to print/log energy summaries. Default True. False used by multilevel to suppress per-mc-level printing.; nfragments : int; See class field. Number of distinct fragments comprising the full molecular supersystem.; Formerly max_frag; return_total_data : bool; See class field. Whether the total data (e/g/H) of the molecular system has been requested, as opposed to interaction data.; max_nbody : int; See class field. Maximum number of bodies to include in the many-body treatment.""; embedding_charges : bool; Whether embedding charges are present. Used to NaN the output printing rather than print bad numbers.; molecule : psi4.core.Molecule; See class field. Used to count atoms in fragments.; nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]]; See class field. Distribution of active n-body levels among model chemistry levels.; Formerly nbody_list; bsse_type : List[BsseEnum]; See class field. Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.; Note that this is the only arg that gets RESET. Happens for supersystem ""nbody"". Returns; -------; results; Dictionary of all N-body results. See contents at ManyBodyComputer.prepare_results docstring. """"""; # which level are we assembling?; mc_level_labels = {int(i.split(""_"")[0]) for i in component_results.keys()}. if len(mc_level_labels) != 1:; raise ValidationError(f""Something's wrong - this fn handles single-level (e.g., 1- & 2-body w/mp2) not multi-level (e.g., 1-body w/hf & 2-body w/mp2) assembly: len({mc_level_labels}) != 1""). # get the range of nbodies for this level; # * modelchem level label (mc_level_lbl) used in qcvars and dict keys is 1-indexed counterpart to 0-indexed modelchem level position (mc_level_idx) used to navigate self.nbodies_per_mc_level; mc_level_lbl = list(mc_level_labels)[0]; nbodies = metadata['nbodies_per_mc_level'][mc_level_lbl - 1]; if nbodies[0] == 'supersystem':; # range for supersystem sub-components; nbodi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:21806,energy,energy,21806,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,10,['energy'],['energy']
Energy Efficiency,"ient""] = G0. if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_energies(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as FiniteDifference-flavored QCSchema."""""". instructions = ""\n"" + p4util.banner(f"" FiniteDifference Results"", strNotOutfile=True) + ""\n""; core.print_out(instructions). self._prepare_results(client=client) # assembled_results. # load QCVariables & properties; qcvars = self.task_list['reference'].get_results().extras['qcvars']; E0 = self.findifrec['reference']['energy']. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. qcvars['FINDIF NUMBER'] = len(self.task_list); qcvars['NUCLEAR REPULSION ENERGY'] = self.molecule.nuclear_repulsion_energy(); qcvars['CURRENT ENERGY'] = E0. DD0 = self.findifrec['reference'].get('dipole derivative'); if DD0 is not None:; qcvars['CURRENT DIPOLE GRADIENT'] = DD0; qcvars[f""{self.method.upper()} DIPOLE GRADIENT""] = DD0. G0 = self.findifrec['reference'].get('gradient'); if G0 is not None:; qcvars['CURRENT GRADIENT'] = G0; qcvars[f""{self.method.upper()} TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = self.findifrec['reference'].get('hessian'); if H0 is not None:; qcvars['CURRENT HESSIAN'] = H0; qcvars[f""{self.method.upper()} TOTAL HESSIAN""] = H0; properties[""return_hessian""] = H0. # if isinstance(lowername, str) and lowername in procedures['energy']:; # # this correctly filters out cbs fn and ""hf/cc-pvtz""; # # it probably incorrectly filters out mp5, but reconsider in DDD. findif_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; ""basis"": self.basis,; 'method': self.method,; },; 'molecule': self.molecule.to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:50828,ENERGY,ENERGY,50828,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"ient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; —; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta2. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8) threading through BLAS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/introduction-1.html:8474,energy,energy,8474,psi4manual/4.0b2/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html,4,['energy'],['energy']
Energy Efficiency,"ies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). 1; 2>>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). 1; 2>>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). 1; 2>>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; 1; 2; 3; 4RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichiometric weights by which the reagent energies are transformed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the database. One of these, the mean absolute deviation, is; returned by the wrapper as an ordinary Python variable. (For databases; without a stored reference energy, e.g., BASIC, large and meaningless numbers are; printed for error.) The other two tables tabulate the PSI variables requested;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/db-1.html:6637,energy,energy,6637,psi4manual/1.2.1/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/db-1.html,4,['energy'],['energy']
Energy Efficiency,"ies of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Implementation inside adcc,; the ADC backend used for most ADC methods available in PSI4. “adcc: A versatile toolkit for rapid development of; algebraic-diagrammatic construction methods,”; M. F. Herbst, M. Scheurer, T. Fransson, D. R. Rehn, and A. Dreuw.; WIREs Comput. Mol. Sci., (2020).; (DOI: 10.1002/wcms.1462, Preprint https://adc-connect.org/q/publications. “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and the implementation for ADC(2) excitation energies within PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Density Matrix Renormalization Group (DMRG)¶. “CheMPS2: a free open-source spin-adapted implementation of the density; matrix renormalization group for ab initio quantum chemistry,”; S. Wouters, W. Poelmans, P. W. Ayers and D. Van Neck,; Comput. Phys. Commun. 185 (6), 1501-1514 (2014).; (doi: 10.1016/j.cpc.2014.01.019).; “The density matrix renormalization group for ab initio quantum chemistry,”; S. Wouters and D. Van Neck, Eur. Phys. J. D 68 (9), 272 (2014).; (doi: 10.1140/epjd/e2014-50500-1). Scalar Relativistic Corrections¶; General theory for the exact two-component approach (X2C). “Analytic energy gradients for the spin-free exact two-component theory; using an exact block diagonalization for the one-electron Dirac; Hamiltonian,”; L. Cheng and J. Gauss, J. Chem. Phys. 135, 084114 (2011).; (doi: 10.1063/1.3624397). Implementation within Psi4. “Predicting Near Edge X-ray Absorption Spectra with the Spin-Free; Exact-Two-Component Hamiltonian and Orthogonality Constrained Density; Functional Theory,”; P. Verma, W. D. Derricotte and F. A. Evangelista,; J. Chem. Theory Comput. (2015).; (doi: 10.1021",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/introduction-1.html:20824,adapt,adapted,20824,psi4manual/1.4.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/introduction-1.html,5,['adapt'],['adapted']
Energy Efficiency,"ies(molecule, irrep). # Record undisplaced symmetry for projection of displaced point groups; core.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.compute_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_parent_symmetry(''); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energy_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:67156,energy,energy,67156,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"ies, with Z-Matrix input. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. tdscf-6; td-camb3lyp with DiskDF and method/basis specification. dfccsd-grad2; DF-CCSD cc-pVDZ gradient for the NH molecule. cubeprop; RHF orbitals and density for water. dft-smoke; DFT Functional Smoke Test. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). scf-ecp; Water-Argon complex with ECP present; check of energies and forces. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN updated ref gradient due to new BraggSlater radii. fci-h2o; 6-31G H2O Test FCI Energy Point. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. scf-level-shift-uhf; SCF level shift on a UHF computation. linK-2; RKS Linear Exchange Algorithm test for benzene. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. sapt11; sapt example",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:6733,energy,energy,6733,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ies=['rotation']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. properties = kwargs.get('properties', ['dipole', 'quadrupole']); kwargs['properties'] = p4util.drop_duplicates(properties). optstash = driver_util._set_convergence_criterion('property', lowername, 6, 10, 6, 10, 8); wfn = procedures['property'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (core.get_variable('CURRENT ENERGY'), wfn); else:; return core.get_variable('CURRENT ENERGY'). [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type func: :ref:`fun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:49236,energy,energy,49236,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"ies=['rotation']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. properties = kwargs.get('properties', ['dipole', 'quadrupole']); kwargs['properties'] = p4util.drop_duplicates(properties). optstash = driver_util._set_convergence_criterion('property', lowername, 6, 10, 6, 10, 8); wfn = procedures['property'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (psi4.get_variable('CURRENT ENERGY'), wfn); else:; return psi4.get_variable('CURRENT ENERGY'). [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element (after *float* energy) of a tuple. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. I",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:47900,energy,energy,47900,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"ies¶. psi4.driver.frequencies(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) or LSDA density functional theory (DFT)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.frequencies.html:1125,energy,energy,1125,psi4manual/1.7.x/api/psi4.driver.frequencies.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.frequencies.html,8,['energy'],['energy']
Energy Efficiency,"iety of input formats, references from psi4. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/kw-2; testing best practices options, part ii. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/sp-rohf-ccsd-ao; sing",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_cfour-1.html:2469,energy,energy,2469,psi4manual/1.0.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"if (key != ""EXTERN""):; raise ValidationError(""Options: set_global_option_python does not recognize keyword %s"" % key). if EXTERN is None:; core.EXTERN = None; core.set_global_option(""EXTERN"", False); elif isinstance(EXTERN, core.ExternalPotential):; # Well this is probably the worst hack I have done, thats saying something; core.EXTERN = EXTERN; core.set_global_option(""EXTERN"", True); else:; raise ValidationError(""Options: set_global_option_python can either be a NULL or External Potential object""). core.set_global_option_python = _core_set_global_option_python. ## QCvar helps. _qcvar_transitions = {; # old: (replacement, release after next); ""SCSN-MP2 CORRELATION ENERGY"": (""SCS(N)-MP2 CORRELATION ENERGY"", 1.5),; ""SCSN-MP2 TOTAL ENERGY"": (""SCS(N)-MP2 TOTAL ENERGY"", 1.5),; ""MAYER_INDICES"": (""MAYER INDICES"", 1.5),; ""WIBERG_LOWDIN_INDICES"": (""WIBERG LOWDIN INDICES"", 1.5),; ""LOWDIN_CHARGES"": (""LOWDIN CHARGES"", 1.5),; ""MULLIKEN_CHARGES"": (""MULLIKEN CHARGES"", 1.5),; ""(AT) CORRECTION ENERGY"": (""A-(T) CORRECTION ENERGY"", 1.5),; ""CCSD(AT) TOTAL ENERGY"": (""A-CCSD(T) TOTAL ENERGY"", 1.5),; ""CCSD(AT) CORRELATION ENERGY"": (""A-CCSD(T) CORRELATION ENERGY"", 1.5),; ""CP-CORRECTED 2-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY"", 1.7),; ""CP-CORRECTED 3-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 3-BODY"", 1.7),; ""CP-CORRECTED 4-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 4-BODY"", 1.7),; ""CP-CORRECTED 5-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 5-BODY"", 1.7),; ""NOCP-CORRECTED 2-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY"", 1.7),; ""NOCP-CORRECTED 3-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 3-BODY"", 1.7),; ""NOCP-CORRECTED 4-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 4-BODY"", 1.7),; ""NOCP-CORRECTED 5-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 5-BODY"", 1.7),; ""VMFC-CORRECTED 2-B",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:18940,ENERGY,ENERGY,18940,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,10,['ENERGY'],['ENERGY']
Energy Efficiency,"if canonical. TD-fctl ROOT 0 -> ROOT n RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state to root n. DFT; functional labeled if canonical. TD-fctl ROOT 0 (IN h) -> ROOT n (IN i) RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state, which is in irrep h, to root n within irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 (h) -> ROOT n (i) RIGHT EIGENVECTOR BETA¶; The right beta spin eigenvectors of the named method; from ground state, which is in irrep h, to root n, which is in irrep i. DFT; functional labeled if canonical. TD-fctl ROOT 0 -> ROOT n RIGHT EIGENVECTOR BETA - h TRANSITION¶; The right alpha and beta spin eigenvectors of the named method; from ground state to root n, and the transition is of irrep h. DFT; functional labeled if canonical. THERMAL ENERGY¶; Total thermal energy E [Eh] at given temperature. THERMAL ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [Eh] to the thermal energy at given temperature. TWO-ELECTRON ENERGY¶; The two-electron energy contribution [Eh] to the total SCF energy.; Quantity \(E_{2e^-}\) in Eq. (4). UNCP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [Eh] considering only two-body interactions,; computed without counterpoise correction.; Related variable CP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{unCP}}}\]. WIBERG LOWDIN INDICES¶; Property of Wiberg bond indices using orthogonal Löwdin orbitals, (nat, nat). ZAPTn TOTAL ENERGY¶. ZAPTn CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled Z-averaged perturbation theory level.; n is ZAPT perturbation order. ZERO K ENTHALPY¶; Total electronic and zero-point energy [Eh] at 0 [K]. ZPVE¶; Vibrational zero-point energy [Eh] at 0 [K]. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .   ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:60161,energy,energy,60161,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['energy'],['energy']
Energy Efficiency,"if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule.; func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. run_gcp(func=None, dertype=None, verbose=False); Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of func or to supply; individual overrides in the presence of func. Returns energy if dertype is 0,; gradient if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The dftd3 executable must be independently compiled and found in; PATH or PSIPATH.; self may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. save_string_xyz(self: psi4.core.Molecule) → str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None; Saves an XYZ file to arg2. schoenflies_symbol(self: psi4.core.Molecule) → str; Returns the Schoenflies symbol. set_active_fragment(self: psi4.core.Molecule, arg0: int) → None; Sets the specified fragment arg2 to be Real. set_active_fragments(self: psi4.core.Molecule, arg0: list) → None; Sets the specified list arg2 of fragments to be Real. set_basis_all_atoms(self: psi4.core.Molecul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:29214,energy,energy,29214,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,2,['energy'],['energy']
Energy Efficiency,"if do_scf and do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and not do_delta4 and not do_delta5:; # pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and not do_delta5:; # pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and do_delta5:; # pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = _expand_bracketed_basis(kwargs['corl_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""CORL basis sets through keyword '%s' are required."""""" % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = _expand_bracketed_basis(kwargs['scf_basis'].lower(), molecule=molstr); elif do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError(""""""SCF basis sets through keyword '%s' are required. Or perhaps you forgot the '%s'."""""" % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = _expand_bracketed_basis(kwargs['delta_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA basis sets through keyword '%s' are required."""""" % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZET",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:35906,energy,energy,35906,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['energy'],['energy']
Energy Efficiency,"if len(metadata) > 1:; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (; GRAND_NEED[1]['d_stage'], GRAND_NEED[1]['d_wfn'], '/', GRAND_NEED[1]['d_basis'], '',; GRAND_NEED[1]['d_energy'] - GRAND_NEED[2]['d_energy'], GRAND_NEED[1]['d_scheme'].__name__); if len(metadata) > 2:; dc = 3; for delta in metadata[2:]:; deltaE_total = GRAND_NEED[dc]['d_energy'] - GRAND_NEED[dc + 1]['d_energy']; tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % (; GRAND_NEED[dc]['d_stage'], GRAND_NEED[dc]['d_wfn'] + ' - ' + GRAND_NEED[dc + 1]['d_wfn'], '/',; GRAND_NEED[dc]['d_basis'], '', deltaE_total,; GRAND_NEED[dc]['d_scheme'].__name__); core.set_variable(f""CBS {GRAND_NEED[dc]['d_stage'].upper()} TOTAL ENERGY"", deltaE_total); dc += 2. tables += """""" %6s %20s %1s %-27s %2s %16.8f %-s\n"""""" % ('total', 'CBS', '', '', '', finalenergy, ''); tables += table_delimit. core.print_out(tables). core.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); core.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); core.set_variable('CBS TOTAL ENERGY', finalenergy); core.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); core.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); core.set_variable('CURRENT ENERGY', finalenergy); core.set_variable('CBS NUMBER', Njobs). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; basis = core.BasisSet.build(molecule, ""ORBITAL"", 'def2-svp'); wfn = core.Wavefunction(molecule, basis). optstash.restore(). if ptype == 'energy':; finalquantity = finalenergy; elif ptype == 'gradient':; finalquantity = finalgradient; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif ptype == 'hessian':; finalquantity = finalhessian; wfn.set_gradient(finalgradient); wfn.set_hessian(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT HESSIAN'); finalquantity.pri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:59569,ENERGY,ENERGY,59569,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (function",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html:1761,energy,energy,1761,psi4manual/1.4.0/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html,25,['energy'],['energy']
Energy Efficiency,"if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Support for using Psi4 as an MDI engine.; For details regarding MDI, see https://molssi.github.io/MDI_Library/html/index.html. """"""; import numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMM() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:1950,energy,energy,1950,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,4,['energy'],['energy']
Energy Efficiency,"if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Support for using Psi4 as an MDI engine.; For details regarding MDI, see https://molssi.github.io/MDI_Library/html/index.html. """"""; import numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html:1950,energy,energy,1950,psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,2,['energy'],['energy']
Energy Efficiency,"if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:59870,energy,energy,59870,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,6,['energy'],['energy']
Energy Efficiency,"if the memory requirements of the conventional algorithm would exceed the available resources. The low memory algorithm is faster in general and has been turned on by default starting September 2020. Type: boolean; Default: true. Expert¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. USE_DF_INTS¶. Use 3-index integrals to generate 4-index ERI’s? This keyword is used for testing purposes only. Changing its value will have no effect on the computation. Type: boolean; Default: false. table of contents. FNOCC; General; ACTIVE_NAT_ORBS; BRUECKNER_MAXITER; CC_SCALE_OS; CC_SCALE_SS; CC_TIMINGS; CEPA_NO_SINGLES; CHOLESKY_TOLERANCE; DFCC; DF_BASIS_CC; DIIS_MAX_VECS; DIPMOM; E_CONVERGENCE; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; NAT_ORBS; OCC_PERCENTAGE; OCC_TOLERANCE; R_CONVERGENCE; SCS_CCSD; SCS_CEPA; SCS_MP2; TRIPLES_LOW_MEMORY. Expert; CEPA_LEVEL; COMPUTE_MP4_TRIPLES; COMPUTE_TRIPLES; RUN_CCSD; RUN_CEPA; RUN_MP2; RUN_MP3; RUN_MP4; USE_DF_INTS. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; FNOCC. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__fnocc.html:4362,energy,energy,4362,psi4manual/1.7.x/autodir_options_c/module__fnocc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__fnocc.html,2,['energy'],['energy']
Energy Efficiency,"if two valid basis sets; present in delta_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. delta2_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. xtpl_highest_1; corl_xtpl_helgaker_2. delta3_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta3_basis and xtpl_highest_1() otherwise. delta4_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function) – \(\Rightarrow\) xtpl_highest_1 \(\Leftarrow\) || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. 1; 2>>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:9970,energy,energy,9970,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"if vmfc not in bsse_type; total Hessians at each n-body level with vmfc treatment.   1vmfc;   (nat*3, nat*3); when driver is h; zeroed if vmfc not in bsse_type; cumulative through 1-body total Hessians with vmfc treatment.   2vmfc;   (nat*3, nat*3); when driver is h & max_nbody>=2; zeroed if vmfc not in bsse_type; cumulative through 2-body total Hessians with vmfc treatment.   {max_nbody}vmfc;   (nat*3, nat*3); when driver is h; zeroed if vmfc not in bsse_type; cumulative through {max_nbody}-body total Hessians with vmfc treatment. intermediates; ntasks; always; all individual energies with nice labels.   N-BODY (1, 2)@(1, 2) TOTAL ENERGY;   1; always; total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   N-BODY (3)@(2, 3) TOTAL ENERGY;   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_energy; ntasks; always; all individual energies.   1_((1, 2), (1, 2));   1; always; total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_gradient; ntasks; when driver is g/h; all individual gradients.   1_((1, 2), (1, 2));   (nat, 3); when driver is g/h; total gradient for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat, 3); when driver is g/h; total gradient for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_hessian; ntasks; when driver is h; all individual Hessians.   1_((1, 2), (1, 2));   (nat*3, nat*3); when driver is h; total Hessian for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat*3, nat*3); when driver is h; total Hessian for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. validator set_bsse_type  »  bsse_type[source]¶. validator set_embedding_charges  »  embedding_charges[s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/nbody.html:31327,energy,energy,31327,psi4manual/1.7.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/nbody.html,4,['energy'],['energy']
Energy Efficiency,"if vmfc not in bsse_type; total Hessians at each n-body level with vmfc treatment.   1vmfc;   (nat*3, nat*3); when driver is h; zeroed if vmfc not in bsse_type; cumulative through 1-body total Hessians with vmfc treatment.   2vmfc;   (nat*3, nat*3); when driver is h & max_nbody>=2; zeroed if vmfc not in bsse_type; cumulative through 2-body total Hessians with vmfc treatment.   {max_nbody}vmfc;   (nat*3, nat*3); when driver is h; zeroed if vmfc not in bsse_type; cumulative through {max_nbody}-body total Hessians with vmfc treatment. intermediates; ntasks; always; all individual energies with nice labels.   N-BODY (1, 2)@(1, 2) TOTAL ENERGY;   1; always; total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   N-BODY (3)@(2, 3) TOTAL ENERGY;   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_energy; ntasks; always; all individual energies.   1_((1, 2), (1, 2));   1; always; total energy for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_gradient; ntasks; when driver is g/h; all individual gradients.   1_((1, 2), (1, 2));   (nat, 3); when driver is g/h; total gradient for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat, 3); when driver is g/h; total gradient for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_hessian; ntasks; when driver is h; all individual Hessians.   1_((1, 2), (1, 2));   (nat*3, nat*3); when driver is h; total Hessian for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat*3, nat*3); when driver is h; total Hessian for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/nbody.html:22477,energy,energy,22477,psi4manual/1.6.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html,1,['energy'],['energy']
Energy Efficiency,"if you require quartic force constants (for frequency calculations), you must use the ABELIAN option. Moreover, the latter work for only asymmetric tops and linear molecules. Type: string; Possible Values: ABELIAN, NONABELIAN; Default: ABELIAN. CFOUR_ANHARMONIC (CFOUR)¶CFOUR — Specifies treatment of anharmonic effects by calculating cubic and/or quartic force fields. VIBROT (=3) requests calculation of only those cubic constants of the form \(\phi_{nij}\), where n is a totally symmetric coordinate. These are sufficient to determine the vibration-rotation interaction constants needed to calculate vibrational corrections to rotational constants, but are not sufficient to generate the corresponding cubic constants of isotopologs that have a lower point-group symmetry (i.e. HOD isotopolog of water). VPT2 (=1, note that the old value CUBIC can be still used and is equivalent to VPT2) generates all cubic constants and all quartic constants apart from those of the form \(\phi_{ijkl}\), which is enough for: 1) generation of cubic constants of isotopologs (see manual entries associated with anharmonic calculations for an example); 2) calculation of vibrational energy levels with VPT2. This keyword also directs the program to analyze resonances and calculate intensities of one- and two-quantum transitions. FULLQUARTIC (=2) (not part of the public release) is largely self-explanatory; it directs the program to calculate all quartic constants. This is sufficient (but this has not been implemented) to generate the full quartic force field of all isotopologs. Type: string; Possible Values: CUBIC, VPT2, FULLQUARTIC, VIBROT, OFF; Default: OFF. CFOUR_AO_LADDERS (CFOUR)¶CFOUR — Can be used to control the algorithm used by CFOUR when terms involving \(\langle ab||cd\rangle\) molecular orbital integrals are calculated in the atomic orbital basis (see CFOUR_ABCDTYPE). MULTIPASS (= 0) uses an approach where the AO integral file is read a number of times in order to ensure maximal vectori",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:22504,energy,energy,22504,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['energy'],['energy']
Energy Efficiency,"if.assemble_gradient_from_energies(findif_meta_dict); grad_psi_matrix = core.Matrix.from_array(G); grad_psi_matrix.print_out(); wfn.set_gradient(grad_psi_matrix); core.set_variable('CURRENT GRADIENT', grad_psi_matrix). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", grad_psi_matrix); core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). optstash.restore(). if core.get_option('FINDIF', 'GRADIENT_WRITE'):; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".grad""; qcdb.gradparse.to_string(np.asarray(wfn.gradient()), filename, dtype='GRD', mol=molecule, energy=wfn.energy()). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | Name | Calls Method | Reference | Supported Properties |; +====================+===============================================+================+===============================================================+; | scf | Self-consistent field method(s) | RHF/ROHF/UHF | Listed :ref:`here <sec:oeprop>` |; +--------------------+-----------------------------------------------+----------------+--------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:44966,energy,energy,44966,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['energy'],['energy']
Energy Efficiency,"ifference of energies; info = 'Performing finite difference calculations by energies'; print(info). # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed.' % ndisp); energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=''); sys.stdout.flush(). # Load in displacement into the active molecule; molecule.set_geometry(displacement). # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). # Obtain the gradient. This function stores the gradient into the reference wavefunction.; PsiMod.fd_freq_0(energies, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to frequency().""""""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); frequencies(name, **kwargs). [docs]def molden(filename):; """"""Functio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:50846,energy,energy,50846,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"ifferent from initial G0 for freq; core.clean(). # Perform the derivative calculation; derivative, wfn = derivfunc(method, return_wfn=True, molecule=clone, **kwargs); displacement[""energy""] = core.variable('CURRENT ENERGY'). # If we computed a first or higher order derivative, set it.; if derivfunc == gradient:; displacement[""gradient""] = wfn.gradient().np.ravel().tolist(). # clean may be necessary when changing irreps of displacements; core.clean(). return wfn. def _filter_renamed_methods(compute, method):; r""""""Raises UpgradeHelper when a method has been renamed.""""""; if method == ""dcft"":; raise UpgradeHelper(compute + ""('dcft')"", compute + ""('dct')"", 1.4, "" All instances of 'dcft' should be replaced with 'dct'.""). [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`; * :psivar:`CURRENT REFERENCE ENERGY`; * :psivar:`CURRENT CORRELATION ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type write_orbitals: str, :ref:`boolean <op_py_boolean>`; :param write_orbitals: ``filename`` || |dl| ``'on'`` |dr| || ``'off'`` . (str) Save wfn containing current orbitals to the given file name after each SCF iteration; and retain after |PSIfour|",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:7773,energy,energy,7773,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['energy'],['energy']
Energy Efficiency,"iffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = psi4.wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:3748,charge,charge,3748,psi4manual/4.0b5/_modules/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html,2,['charge'],['charge']
Energy Efficiency,"ified above. Others. Parameters; molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> energy(cbs, corl_wfn='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> energy(cbs, scf_wfn='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html:13185,energy,energy,13185,psi4manual/1.4.0/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html,36,['energy'],['energy']
Energy Efficiency,"ified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. In",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:53880,energy,energy,53880,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"ified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:52974,energy,energy,52974,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"ified explicitly. - No way to tell function to boost fitting basis size for all calculations. - No way to extrapolate def2 family basis sets. - Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in four; sequential stages (scf, corl, delta, delta2) covering treatment of the; reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:54181,energy,energy,54181,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"ified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:132159,ENERGY,ENERGY,132159,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,6,['ENERGY'],['ENERGY']
Energy Efficiency,"ifies DF_BASIS_SCF manually. For; some atoms, cc-pVDZ-JKFIT is not defined, so this procedure will fail. In these; cases, you will see an error message of the form:; RuntimeError: sanity check failed! Gaussian94BasisSetParser::parser:; Unable to find the basis set for HE. This failure can be fixed by either setting DF_BASIS_SCF to an auxiliary; basis set defined for all atoms in the system, or by setting DF_SCF_GUESS; to false, which disables this acceleration entirely. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type [1]. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 6; DF. optimization; 8; 8. frequency [7]; 8; 8. SCF of post-HF; energy; 8; 8; PK [3]. optimization; 10; 10. frequency [7]; 10; 10. CC property [2]; 10; 10. Post-SCF convergence criteria defaults by calculation type [4]. Ab Initio Method; Calculation Type; E_CONVERGENCE [5]; R_CONVERGENCE [6]. post-HF of post-HF; energy; 6;  . optimization; 8;  . frequency [7]; 8;  . CC property [2]; 8;  . Footnotes. [1]Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. [2](1, 2) This applies to properties computed through the property() function. [3]Post-HF methods that do not rely upon the usual 4-index AO integrals use a density-; fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. [4]Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. [5]The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list beginning at E_CONVERGENCE. [6]The R_CONVERGENCE keyword places a convergence check on an internal; residual error measure and is implemented for several post-SCF; modules (see list beginning at R_CONVERGENCE). It is defin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/scf-1.html:21547,energy,energy,21547,psi4manual/4.0b4/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/scf-1.html,4,['energy'],['energy']
Energy Efficiency,"ifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP¶. Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. CFOUR_GEO_METHOD¶. Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — straightforward Newton-Raphson search for minimum; RFA (=1) — Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) — Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); SINGLE_POINT (=5) for a single-point energy calculation. ENERONLY (=6) requests a geometry optimization based on single-point energy calculations. Default: SINGLE-POINT (NR as soon as variables are marked to be optimized). Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT, ENERONLY; Default: SINGLE_POINT. CFOUR_GIAO¶. Specifies whether gauge-including atomic orbitals are used (ON) or not (OFF). Default: ON for CFOUR_PROPS =NMR and =MAGNETIC, otherwise OFF. Type: string; Possible Values: ON, OFF; Default: No Default. CFOUR_GRID¶. Keyword used to control type of grid calculation (see later section in this manual). Options are OFF (=0), no grid calculation; CARTESIAN (=1), steps are in Cartesian coordinates (which must be r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:30900,efficient,efficient,30900,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,52,"['efficient', 'energy']","['efficient', 'energy']"
Energy Efficiency,"ifies the orbital occupancy of the reference function in terms of the occupation numbers of the orbitals and their irreducible representations. The occupancy is specified by either NIRREP or 2*NIRREP integers specifying the number of occupied orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. If the reference function is for an open-shell system, two strings of NIRREP occupation numbers separated by a slash are input for the \(\alpha\) and \(\beta\) sets of orbitals. An example of the use of the OCCUPATION keyword for the water molecule would be OCCUPATION=3-1-1-0. For the \(^2A_1\) water cation, an open-shell system, the keyword would be specified by OCCUPATION=3-1-1-0/2-1-1-0. It should be noted that the xvmol integral program orders the irreducible representations in a strange way, which most users do not perceive to be a logical order. Hence, it is usually advisable initially to run just a single point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (white space tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_OCCUPATION. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/cfour__cfour_occupation-1.html:1602,energy,energy,1602,psi4manual/1.4.0/autodir_options_c/cfour__cfour_occupation-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/cfour__cfour_occupation-1.html,4,['energy'],['energy']
Energy Efficiency,"ifies the orbital occupancy of the reference function in terms of the occupation numbers of the orbitals and their irreducible representations. The occupancy is specified by either NIRREP or 2*NIRREP integers specifying the number of occupied orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. If the reference function is for an open-shell system, two strings of NIRREP occupation numbers separated by a slash are input for the \(\alpha\) and \(\beta\) sets of orbitals. An example of the use of the OCCUPATION keyword for the water molecule would be OCCUPATION=3-1-1-0. For the \(^2A_1\) water cation, an open-shell system, the keyword would be specified by OCCUPATION=3-1-1-0/2-1-1-0. It should be noted that the xvmol integral program orders the irreducible representations in a strange way, which most users do not perceive to be a logical order. Hence, it is usually advisable initially to run just a single point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (white space tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; CFOUR; CFOUR_OCCUPATION. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/cfour__cfour_occupation-1.html:1602,energy,energy,1602,psi4manual/1.5.0/autodir_options_c/cfour__cfour_occupation-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/cfour__cfour_occupation-1.html,4,['energy'],['energy']
Energy Efficiency,"igation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Customization: Adding Simple Extensions; Creating a Database. Creating a Database¶. Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry filesAssemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re determ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/quickadddatabase-1.html:1101,energy,energy,1101,psi4manual/1.4.0/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/quickadddatabase-1.html,2,['energy'],['energy']
Energy Efficiency,"igation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Customization: Adding Simple Extensions; Creating a Database. Creating a Database¶. Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry filesAssemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re determ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/quickadddatabase-1.html:1101,energy,energy,1101,psi4manual/1.5.0/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/quickadddatabase-1.html,2,['energy'],['energy']
Energy Efficiency,"igation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Customization: Adding Simple Extensions; Creating a Database. Creating a Database¶. Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry filesAssemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re determ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/quickadddatabase.html:1101,energy,energy,1101,psi4manual/1.6.x/quickadddatabase.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/quickadddatabase.html,1,['energy'],['energy']
Energy Efficiency,"igation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Customization: Adding Simple Extensions; Creating a Database. Creating a Database¶. Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry filesAssemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re determ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/quickadddatabase.html:1101,energy,energy,1101,psi4manual/1.7.x/quickadddatabase.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/quickadddatabase.html,1,['energy'],['energy']
Energy Efficiency,"igenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS (DCFT); DCFT (Expert) — The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STEP_TYPE (OPTKING); OPTKING — Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. T (THERMO); THERMO — Temperature in Kelvin for thermodynamic analysis. Type: double; Default: 298.15. T2_COUPLED (CCENERGY); CCENERGY —. Type: boolean; Default: false. T3_WS_INCORE (CCENERGY); CCENERGY — Do build W intermediates required for cc3 in core memory?. Type: boolean; Default: false. T3_WS_INCORE (CCEOM); CCEOM — Do build W intermediates required for eom_cc3 in core memory?. Type: boolean; Default: false. T_AMPS (CCHBAR); CCHBAR — Do compute the Tamplitude equation matrix elements?. Type: boolean; Default: false. TAU_SQUARED (DCFT); DCFT (Expert) — Controls whether to compute the DCFT energy with the Tau^2 correction to Tau. Type: boolean; Default: false. TDHF_MEM_SAFETY_FACTOR (CPHF); CPHF — Memory safety factor for allocating JK. Type: double; Default: 0.75. TDM (DETCI); DETCI — Do compute the transition density? Note: only transition densities between roots of the same symmetry will be evaluated. DETCI does not compute states of different irreps within the same computation; to do this, lower the symmetry of the computation. Type: boolean; Default: false. TDM_PRINT (DETCI); DETCI — Do print the transition density?. Type: boolean; Default: false. TDM_WRITE (DETCI); DETCI — Do write the transition density?. Type: boolean; Default: false. TEST_B (OPTKING); OPTKING — Do test B matrix?. Type: boolean; Default: false. TEST_DERIVATIVE_B (OPTKING); OPTKING — Do test derivative B matrix?. Type: boolean; Default: false. THETA_POINTS (SCF); SCF — Number of colatitude grid points for sphereical potential integration. Type: integer; Default: 360. THICKNESS (SC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:120852,energy,energy,120852,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"ighly correlated CI wavefunctions that can be helpful in more; challenging cases such as highly strained molecules or bond breaking reactions. The CI; code is based on the fast, determinant-based string formalism; of Handy [Handy:1980]. It can solve for restricted active space; configuration interaction (RAS CI) wavefunctions as described by Olsen,; Roos, Jorgensen, and Aa. Jensen [Olsen:1988]. Excitation-class; selected multi-reference CI wavefunctions, such as second-order CI,; can be formulated as RAS CI’s. A RAS CI selects determinants for the; model space as those which have no more than \(n\) holes in the lowest set; of orbitals (called RAS I) and no more than \(m\) electrons in the highest; set of orbitals (called RAS III). An intermediate set of orbitals, if; present (RAS II), has no restrictions placed upon it. All determinants; satisfying these rules are included in the RAS CI.; The DETCI module is also very efficient at computing full configuration; interaction; wavefunctions, and it is used in this capacity in the complete-active-space; self-consistent-field (CASSCF) code. It can also perform approximate; CASSCF computations in which one uses RAS restrictions on the CI excitations,; rather than doing a full CI in the active space. This is called a; RASSCF. CASSCF and RASSCF computations are types of multi-configurational; self-consistent-field procedures, and are described in MCSCF: Multi-Configurational Self-Consistent-Field.; As mentioned above, the DETCI module is designed for challenging; chemical systems for which simple CISD is not suitable. Because; CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,; typically the DETCI code will be used in cases where the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This us",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:3332,efficient,efficient,3332,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,9,['efficient'],['efficient']
Energy Efficiency,"ight-hand coupled coupled cluster eigenvector and the; left-hand eigenvector from the coupled cluster lambda (response) equations. LOWDIN CHARGES¶; Property of partial atomic charges [e] by the method of Löwdin, (nat,). MAYER INDICES¶; Property of Mayer bond indices, (nat, nat). MBIS CHARGES¶. MBIS DIPOLES¶. MBIS OCTUPOLES¶. MBIS QUADRUPOLES¶; Per-atom charges [e], dipoles [e a0], quadrupoles [e a0^2], and octupoles [e a0^3]; resulting from partitioning the total electron density through the Minimal Basis; Iterative Stockholder (MBIS) Charge Partitioning Scheme. MBIS FREE ATOM n VOLUME¶; Free-atom volume [a0^3] for atom n, computed using the MBIS charge; partitioning scheme. Free atom densities are computed at the same; level of theory as the parent MBIS calculation, with UHF turned on; as needed. MBIS RADIAL MOMENTS <R^3>¶; Per-atom expectation value of r^3 [a0^3], equivalent to the volume; of the MBIS-partitioned density. MBIS VALENCE WIDTHS¶; Per-atom density width [a0] of the associated valence charge computed; from an MBIS partitioned density. Equivalent to the inverse of the; linear decay rate of the atomic density. MBIS VOLUME RATIOS¶; Per-atom ratio between the atomic volume (<R^3>) and the free-atomic; volume, unitless. MCSCF TOTAL ENERGY¶; Multiconfigurational self-consistent-field energy [E_h] in the course of; a configuration interaction computation. May be single-root or state-averaged. mtd DIPOLE¶; Dipole array [e a0] for the named method, (3,). mtd QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the named method, (3, 3). mtd OCTUPOLE¶; Redundant octupole array [e a0^3] for the named method, (3, 3, 3). mtd HEXADECAPOLE¶; Redundant hexadecapole array [e a0^4] for the named method, (3, 3, 3, 3). mtd 32-POLE¶; Redundant 32-pole array [e a0^5] for the named method, (3, 3, 3, 3, 3). mtd 64-POLE¶; Redundant 64-pole array [e a0^6] for the named method, (3, 3, 3, 3, 3, 3). mtd 128-POLE¶; Redundant 128-pole array [e a0^7] for the named method, (3, 3, 3, 3, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:34838,charge,charge,34838,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,3,['charge'],['charge']
Energy Efficiency,"ight-hand coupled coupled cluster eigenvector and the; left-hand eigenvector from the coupled cluster lambda (response) equations. LOWDIN CHARGES¶; Property of partial atomic charges [e] by the method of Löwdin, (nat,). MAYER INDICES¶; Property of Mayer bond indices, (nat, nat). MBIS CHARGES¶. MBIS DIPOLES¶. MBIS OCTUPOLES¶. MBIS QUADRUPOLES¶; Per-atom charges [e], dipoles [e a0], quadrupoles [e a0^2], and octupoles [e a0^3]; resulting from partitioning the total electron density through the Minimal Basis; Iterative Stockholder (MBIS) Charge Partitioning Scheme. MBIS FREE ATOM n VOLUME¶; Free-atom volume [a0^3] for atom n, computed using the MBIS charge; partitioning scheme. Free atom densities are computed at the same; level of theory as the parent MBIS calculation, with UHF turned on; as needed. MBIS RADIAL MOMENTS <R^3>¶; Per-atom expectation value of r^3 [a0^3], equivalent to the volume; of the MBIS-partitioned density. MBIS VALENCE WIDTHS¶; Per-atom density width [a0] of the associated valence charge computed; from an MBIS partitioned density. Equivalent to the inverse of the; linear decay rate of the atomic density. MBIS VOLUME RATIOS¶; Per-atom ratio between the atomic volume (<R^3>) and the free-atomic; volume, unitless. MCSCF TOTAL ENERGY¶; Multiconfigurational self-consistent-field energy [Eh] in the course of; a configuration interaction computation. May be single-root or state-averaged. mtd DIPOLE¶; Dipole array [e a0] for the named method, (3,). mtd QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the named method, (3, 3). mtd OCTUPOLE¶; Redundant octupole array [e a0^3] for the named method, (3, 3, 3). mtd HEXADECAPOLE¶; Redundant hexadecapole array [e a0^4] for the named method, (3, 3, 3, 3). mtd 32-POLE¶; Redundant 32-pole array [e a0^5] for the named method, (3, 3, 3, 3, 3). mtd 64-POLE¶; Redundant 64-pole array [e a0^6] for the named method, (3, 3, 3, 3, 3, 3). mtd 128-POLE¶; Redundant 128-pole array [e a0^7] for the named method, (3, 3, 3, 3, 3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:34126,charge,charge,34126,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['charge'],['charge']
Energy Efficiency,"il.format_options_for_input()); p4util.format_kwargs_for_input(fmaster, 2, **kwargs); fmaster.write(""""""%s('%s', **kwargs)\n\n"""""" % (frequency.__name__, lowername)); fmaster.write(instructionsM); fmaster.close(); psi4.print_out(instructionsM). for n, displacement in enumerate(displacements):; rfile = 'FREQ-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Hessian Computation: Energy Displacement %d ')\n"""""" % (n + 1); banners += """"""psi4.print_out('\\n')\n\n"""""". if (freq_mode.lower() == 'continuous'):; # Print information to output.dat; psi4.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=''); sys.stdout.flush(). # Load in displacement into the active molecule; molecule.set_geometry(displacement). # Perform the energy calculation; func(lowername, **kwargs). # Save the energy; energies.append(psi4.get_variable('CURRENT ENERGY')). # clean may be necessary when changing irreps of displacements; psi4.clean(). # S/R: Write each displaced geometry to an input file; elif (freq_mode.lower() == 'sow'):; molecule.set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(p4util.format_molecule_for_input(molecule)); freagent.write(p4util.format_options_for_input()); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""psi4.print_out('\\nHESSIAN RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:69114,energy,energy,69114,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"il.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""energy"", lowername, molecule, **kwargs); logger.debug('ENERGY PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 0th derivative. # Commit to procedures['energy'] call hereafter; core.clean_variables(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). # needed (+restore below) so long as AtomicComputer-s aren't run through json (where convcrit also lives); optstash = driver_util.negotiate_convergence_criterion((0, 0), lowername, return_optstash=True); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:37598,ENERGY,ENERGY,37598,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"ilable after a license agreement from; http://www.cfour.de/. Installation¶; Follow the instructions provided with the Cfour download to install the; executable or to build the source. To by used by PSI4, the program; binary (xcfour) must be found in your PATH or; PSIPATH. The GENBAS file containing basis sets in Cfour; format is not necessary for this interface, but if you prefer to access; basis sets the “Cfour way” using a custom GENBAS file (the distributed; one is included with the interface), it, too, must be in PATH or; PSIPATH. If PSI4 is unable to execute the binary, an error; will be reported. Caution; The p4c4 interface hasn’t been fully adapted for the new March 2014 version. Cfour for PSI4 Users¶. Set memory as usual; Set molecule as usual; Set basis set as usual (Cfour only cares about orbital basis, no fitting; bases); Set the task as usual, indicating Cfour as the intended code by; prepending “c4-” to the method argument. So energy('scf') becomes; energy('c4-scf') and optimize('ccsd(t)') becomes; optimize('c4-ccsd(t)'). Find available methods for; energy() at Energy (CFOUR); and for optimize() at Gradient (CFOUR).; Generally, the p4c4 interface will handle best practices for path of; execution: vcc/ecc, derivative type, etc. The user is still; responsible for setting convergence, frozen core, guess, diis, etc.; For the moment, so-called “best-practices” keywords are summarized at; Best Practices.; For the type of computation intended, find appropriate options at; Keywords. These keyword summaries contain the same; information as the proper CFOUR options list; plus notes on keyword relevance when run through PSI4. Information; at the CFOUR manual may; also be useful, as may the many samples at psi4/samples/cfour.; Set Cfour keywords just like PSI4 keywords. The names of keywords; are unchanged beyond a prepended “cfour_”. (Though be aware that common; abbreviations like CALC and REF must be fully spelled out as; CFOUR_CALC_LEVEL and CFOUR_REFERENCE whe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:1410,energy,energy,1410,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,30,['energy'],['energy']
Energy Efficiency,"ilable after a license agreement from; http://www.cfour.de/. Installation¶; Follow the instructions provided with the Cfour download to install the; executable or to build the source. To by used by Psi4, the program; binary (xcfour) must be found in your PATH or; PSIPATH. The GENBAS file containing basis sets in Cfour; format is not necessary for this interface, but if you prefer to access; basis sets the “Cfour way” using a custom GENBAS file (the distributed; one is included with the interface), it, too, must be in PATH or; PSIPATH. If Psi4 is unable to execute the binary, an error; will be reported. Caution; The p4c4 interface hasn’t been fully adapted for the new March 2014 version. Cfour for Psi4 Users¶. Set memory as usual; Set molecule as usual; Set basis set as usual (Cfour only cares about orbital basis, no fitting; bases); Set the task as usual, indicating Cfour as the intended code by; prepending “c4-” to the method argument. So energy('scf') becomes; energy('c4-scf') and optimize('ccsd(t)') becomes; optimize('c4-ccsd(t)'). Find available methods for; energy() at Energy (CFOUR); and for optimize() at Gradient (CFOUR).; Generally, the p4c4 interface will handle best practices for path of; execution: vcc/ecc, derivative type, etc. The user is still; responsible for setting convergence, frozen core, guess, diis, etc.; For the moment, so-called “best-practices” keywords are summarized at; Best Practices.; For the type of computation intended, find appropriate options at; Keywords. These keyword summaries contain the same; information as the proper CFOUR options list; plus notes on keyword relevance when run through Psi4. Information; at the CFOUR manual may; also be useful, as may the many samples at psi4/samples/cfour.; Set Cfour keywords just like Psi4 keywords. The names of keywords; are unchanged beyond a prepended “cfour_”. (Though be aware that common; abbreviations like CALC and REF must be fully spelled out as; CFOUR_CALC_LEVEL and CFOUR_REFERENCE whe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:1464,energy,energy,1464,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,4,['energy'],['energy']
Energy Efficiency,"ilable; with the installation of Grimme’s DFTD3 program, and we; will shortly be adding many; more combinations of -D2 and -D3 functionals. For now, the pure-GGA B97-D; functional of Grimme is remarkably accurate, and the hybrid B3LYP-D; functional is also quite reliable. Note: we have made a sincere effort to rigorously test all functionals; implemented in PSI4 for both numerical stability and correctness. If you; observe any unexpected results, please email Rob Parrish (robparrish@gmail.com); for immediate assistance. Additionally, if you have a request for a new; functional, please let us know. Grid Selection¶; PSI4 uses the standard Lebedev-Laikov spherical quadratures in concert with a; number of radial quadratures and atomic partitioning schemes. Pruned grids are; not yet available, but will be implemented by RC1 (in final debugging). The; default grid in PSI4 is a Lebedev-Treutler (75,302) grid with a Treutler; partition of the atomic weights.; Spherical grids are all of the extremely efficient Lebedev-Laikov type.; Spherical grid resolution is controlled by the DFT_SPHERICAL_POINTS; option, which may take one of the following values:. DFT_SPHERICAL_POINTS; Order. 6; 3. 14; 5. 26; 7. 38; 9. 50; 11. 74; 13. 86; 15. 110; 17. 146; 19. 170; 21. 194; 23. 230; 25. 266; 27. 302; 29. 350; 31. 434; 35. 590; 41. 770; 47. 974; 53. 1202; 59. 1454; 65. 1730; 71. 2030; 77. 2354; 83. 2702; 89. 3074; 95. 3470; 101. 3890; 107. 4334; 113. 4802; 119. 5294; 125. 5810; 131. The spherical grids are rotated according to a common set of rules developed; during the implementation of SG1. At the moment, the rules for tetrahedral,; octohedral, and icosohedral systems are not complete, so there may be some; ambiguity in the grid orientation for these systems. A complete grid orientation; rule set will be available in RC1.; Radial grid types are controlled by the DFT_RADIAL_SCHEME option, which; at the moment may be either TREUTLER or BECKE, while the number of radial points; are controll",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/dft-1.html:14969,efficient,efficient,14969,psi4manual/4.0b3/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/dft-1.html,6,['efficient'],['efficient']
Energy Efficiency,"ilable; with the installation of Grimme’s DFTD3 program, and we; will shortly be adding many; more combinations of -D2 and -D3 functionals. For now, the pure-GGA B97-D; functional of Grimme is remarkably accurate, and the hybrid B3LYP-D; functional is also quite reliable. Note: we have made a sincere effort to rigorously test all functionals; implemented in Psi4 for both numerical stability and correctness. If you; observe any unexpected results, please email Rob Parrish (robparrish@gmail.com); for immediate assistance. Additionally, if you have a request for a new; functional, please let us know. Grid Selection¶; Psi4 uses the standard Lebedev-Laikov spherical quadratures in concert with a; number of radial quadratures and atomic partitioning schemes. Pruned grids are; not yet available, but will be implemented by RC1 (in final debugging). The; default grid in PSI4 is a Lebedev-Treutler (75,302) grid with a Treutler; partition of the atomic weights.; Spherical grids are all of the extremely efficient Lebedev-Laikov type.; Spherical grid resolution is controlled by the DFT_SPHERICAL_POINTS; option, which may take one of the following values:. DFT_SPHERICAL_POINTS; Order. 6; 3. 14; 5. 26; 7. 38; 9. 50; 11. 74; 13. 86; 15. 110; 17. 146; 19. 170; 21. 194; 23. 230; 25. 266; 27. 302; 29. 350; 31. 434; 35. 590; 41. 770; 47. 974; 53. 1202; 59. 1454; 65. 1730; 71. 2030; 77. 2354; 83. 2702; 89. 3074; 95. 3470; 101. 3890; 107. 4334; 113. 4802; 119. 5294; 125. 5810; 131. The spherical grids are rotated according to a common set of rules developed; during the implementation of SG1. At the moment, the rules for tetrahedral,; octohedral, and icosohedral systems are not complete, so there may be some; ambiguity in the grid orientation for these systems. A complete grid orientation; rule set will be available in RC1.; Radial grid types are controlled by the DFT_RADIAL_SCHEME option, which; at the moment may be either TREUTLER or BECKE, while the number of radial points; are controll",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:15054,efficient,efficient,15054,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,2,['efficient'],['efficient']
Energy Efficiency,"ild_dsd_blyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('DSD-BLYP'); # Tab in, trailing newlines; sup.set_description(' DSD-BLYP Dispersion-corrected SCS Double Hybrid XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' S. Kozuch, Phys. Chem. Chem. Phys., 13, 20104, 2011\n'). # Add member functionals; X = build_functional('B88_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('LYP_C'); C.set_alpha(0.55); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.71); sup.set_c_alpha(1.0); sup.set_c_os_alpha(0.46); sup.set_c_ss_alpha(0.43). # => -D2 <=. sup.set_dispersion(psi4.Dispersion.build('-D2', 0.35, 0.0, 0.0, 0.0)). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_dsd_pbep86_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('DSD-PBEP86'); # Tab in, trailing newlines; sup.set_description(' DSD-PBEP86 Dispersion-corrected SCS Double Hybrid XC Functional (opt. for -D2)\n'); # Tab in, trailing newlines; sup.set_citation(' S. Kozuch, Phys. Chem. Chem. Phys., 13, 20104, 2011\n'). # Add member functionals; X = build_functional('PBE_X'); X.set_alpha(1.0); sup.add_x_functional(X); C = build_functional('P86_C'); C.set_alpha(0.45); sup.add_c_functional(C). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.68); sup.set_c_alpha(1.0); sup.set_c_ss_alpha(0.23); sup.set_c_os_alpha(0.51). # => -D2 <=. sup.set_dispersion(psi4.Dispersion.build(*dash_server('dsd-pbep86', 'd2p4'))). # => End User-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:75799,allocate,allocate,75799,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,3,['allocate'],['allocate']
Energy Efficiency,"ile. [docs] def print_in_input_format(self):; """"""Print the molecule in the same format that the user provided.; Only returns if Zmat or variable input. """"""; text = """"; if self.nallatom():; # It's only worth echoing these if the user either input some variables,; # or they used a Z matrix for input; if self.full_atoms[0].type() == 'ZMatrixCoord' or len(self.geometry_variables):; text += """"""\n\tFinal optimized geometry and variables (in %s):\n\n"""""" % \; (""Angstrom"" if self.units() == 'Angstrom' else ""bohr""); for i in range(self.nallatom()):; text += self.full_atoms[i].print_in_input_format(); text += ""\n""; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""\t%-10s=%16.10f\n"""""" % (vb, val); text += ""\n""; print text; # TODO outfile. [docs] def everything(self):; """"""Quick print of class data""""""; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" Natom %d\t\tNallatom %d\n"""""" % (self.natom(), self.nallatom()); text += """""" charge %d\t\tspecified? %s\n"""""" % (self.molecular_charge(), self.charge_specified()); text += """""" multiplicity %d\t\tspecified? %s\n"""""" % (self.multiplicity(), self.multiplicity_specified()); text += """""" units %s\tconversion %f\n"""""" % (self.units(), self.input_units_to_au); text += """""" DOcom? %s\t\tDONTreorient? %s\n"""""" % (self.PYmove_to_com, self.orientation_fixed()); text += """""" reinterpret? %s\t\tlock_frame? %s\n"""""" % (self.PYreinterpret_coordentries, self.lock_frame); text += """""" input symm %s\n"""""" % (self.symmetry_from_input()); text += """""" Nfragments %d\t\tNactive %d\n"""""" % (self.nfragments(), self.nactive_fragments()); print text. # <<< Involved Methods for Coordinates >>>. [docs] def get_coord_value(self, vstr):; """"""Attempts to interpret a string as a double, if not it assumes it's a variable. """"""; vstr = vstr.upper(); realNumber = re.compile(r""""""[-+]?(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[Ee][+-]?\d+)?"""""", re.VERBOSE). # handle number values; if realNumber.match(vstr):; return NumberValue(flo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:28381,charge,charge,28381,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,4,['charge'],['charge']
Energy Efficiency,"iled executable,; running compiled Python module,; running conda binary. PATH pointing to bin; PYTHONPATH pointing to lib (ordinary) or lib/pythonX.X/site-packages (conda); PSIDATADIR pointing to share/psi4. How to run Psi4 as executable after compilation¶; Substituting the full installation directory prefix and a; suitable scratch directory, issue the following commands directly in your; terminal or place them into your “rc” file and open a new terminal. (To; use a staged installation directory, substitute; objdir/stage for prefix.); # csh, tcsh: add to shell or ~/.tcshrc file; setenv PATH {prefix}/bin:$PATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PATH={prefix}/bin:$PATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. Run PSI4.; 1; 2; 3; 4; 5; 6; 7; 8>>> cat sample.in; molecule {; He; }; energy('hf/cc-pvdz'); compare_values(-2.85518839, get_variable('current energy'), 5, 'SCF E'); >>> psi4 sample.in; SCF E.............................................................PASSED. todo how to check if current py is compatible with compilation. How to solve ModuleNotFoundError: No module named 'psi4'¶; You’re using PSI4 in PsiAPI mode (python input.py where; input.py contains import psi4) but the Python interpreter; can’t find the PSI4 Python module. Follow the directions at; How to configure paths for PsiAPI. How to configure paths for PsiAPI¶; If you know the location of the PSI4 executable (bin/psi4); for Psithon mode and want to know the corresponding location to add to; PYTHONPATH for PsiAPI mode, execute psi4 --psiapi-path. It; will return bash commands to set PATH (for correct python; interpreter) and PYTHONPATH (to find psi4 module) correctly,; after which import psi4 will work.; >>> psi4 --psiapi-path; export PATH=/path/to/dir/of/python/interpreter/against/which/psi4/compiled:$",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:23350,energy,energy,23350,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['energy'],['energy']
Energy Efficiency,"ilename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! Most post-SCF Wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:None. Parameters:; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate cube files; filename (string) – destination file name for MOLDEN file (optional); density_a (Matrix) – density in the MO basis to build alpha NO’s from (optional); density_b (Matrix) – density in the MO basis to build beta NO’s from, assumes restricted if not supplied (optional); dovirtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional). Examples:. >>> # [1] Molden file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). >>> # [2] Molden file for CI/MCSCF computation using NO roots; >>> E, wfn = energy('ci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.opdm(0, 0, ""A"", True)). >>> # [3] The following does NOT work, please see below; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). >>> # [4] This WILL work, note the transformation of Da (SO->MO); >>> E, wfn = properties('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). Options¶. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: fal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/molden-1.html:2322,energy,energy,2322,psi4manual/1.3.2/molden-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/molden-1.html,2,['energy'],['energy']
Energy Efficiency,"ilename: str, Ca: psi4.core.Matrix, Cb: psi4.core.Matrix, Ea: psi4.core.Vector, Eb: psi4.core.Vector, OccA: psi4.core.Vector, OccB: psi4.core.Vector, dovirtual: bool) → None¶; Writes wavefunction information in molden format. class psi4.core.MolecularGrid¶; Bases: pybind11_builtins.pybind11_object; docstring. blocks(self: psi4.core.MolecularGrid) → List[psi4.core.BlockOPoints]¶; Returns a list of blocks. max_functions(self: psi4.core.MolecularGrid) → int¶; Returns the maximum number of functions in a block. max_points(self: psi4.core.MolecularGrid) → int¶; Returns the maximum number of points in a block. npoints(self: psi4.core.MolecularGrid) → int¶; Returns the number of grid points. orientation(self: psi4.core.MolecularGrid) → psi4.core.Matrix¶; Returns the orientation of the grid. print(self: psi4.core.MolecularGrid, arg0: str, arg1: int) → None¶; Prints grid information. class psi4.core.Molecule¶; Bases: pybind11_builtins.pybind11_object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule. B787(ref_mol, do_plot=False, verbose=1, atoms_map=False, run_resorting=False, mols_align=False, run_to_completion=False, uno_cutoff=0.001, run_mirror=False)¶; Finds shift, rotation, and atom reordering of concern_mol that best; aligns with ref_mol.; Wraps qcdb.align.B787() for qcdb.Molecule or; psi4.core.Molecule. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters:; concern_mol (qcdb.Molecule or psi4.core.Molecule) – Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with ref_mol.; ref_mol (qcdb.Molecule or psi4.core.Molecule) – Molecule to match.; atoms_map (bool, optional) – Whether atom1 of ref_mol corresponds to atom1 of concern_mol, etc.; If true, specifying True can save much time.; mols_align (bool, optional) – Whether ref_mol and concern_mol have identical geometries by eye; (ba",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:123862,charge,charge,123862,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['charge'],['charge']
Energy Efficiency,"ility analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. dft1; DFT Functional Test all values update for new BraggSlater radii. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. scf-level-shift-rks; SCF level shift on an RKS computation. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. mints3; Test individual integral objects for correctness. dft-smoke; DFT Functional Smoke Test. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. linK-1; RHF Linear Exchange Algorithm test for water. mbis-3; MBIS calculation on OH radical. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. dft2; DFT Functional Test. soscf-large; Second-order SCF convergnece: Benzene. cbs-xtpl-alpha; Extrapolated water energies. cc17; Single point energies of multiple excited states with EOM-CCSD. fd-gradient; SCF STO-3G finite-difference tests. mbis-6; MBIS calculation on H2O. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:31788,energy,energy,31788,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ility to use the extremely fast DF; code for intermediate convergence of the orbitals, for SCF_TYPE; DIRECT. At the moment, the code defaults to cc-pVDZ-JKFIT as the; auxiliary basis, unless the user specifies DF_BASIS_SCF manually. For; some atoms, cc-pVDZ-JKFIT is not defined, so this procedure will fail. In these; cases, you will see an error message of the form:; RuntimeError: sanity check failed! Gaussian94BasisSetParser::parser:; Unable to find the basis set for HE. This failure can be fixed by either setting DF_BASIS_SCF to an auxiliary; basis set defined for all atoms in the system, or by setting DF_SCF_GUESS; to false, which disables this acceleration entirely. Second-order Convergence¶; Second-order convergence takes into account both the gradient and Hessian to; take a full Newton step with respect to the orbital parameters. This results in; quadratic convergence with respect to density for SCF methods. For cases where; normal acceleration methods either fail or take many iterations to converge,; second-order can reduce the total time to solution.; Solving second-order (SO) methods exactly would require an inversion of the; orbital Hessian (an expensive operation); however, these; equations are normally solved iteratively where each iteration costs the same; as a normal Fock build (). The overall SOSCF operation is; thus broken down into micro- and macroiterations where the microiterations; refer to solving the SOSCF equations and macroiterations are the construction; of a new Fock matrix based on the orbitals from a SOSCF step.; SOSCF requires that all elements of the gradient to be less than one before the; method is valid. To this end, pre-SOSCF SCF iterations use normal; gradient-based extrapolation procedures (e.g., DIIS) until the gradient; conditions are met. Note that while the total number of macroiterations will be; less for SOSCF than gradient-based convergence acceleration the cost of solving; the microiterations typically results in the overal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:21718,reduce,reduce,21718,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['reduce'],['reduce']
Energy Efficiency,"ils.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""AtomicComputer"",; ""BaseComputer"",; ""EnergyGradientHessianWfnReturn"",; ]. import abc; import copy; import logging; import pprint; from typing import Any, Dict, Optional, Tuple, Union, TYPE_CHECKING. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; import qcelemental as qcel; from qcelemental.models import DriverEnum, AtomicInput, AtomicResult; from qcelemental.models.results import AtomicResultProtocols; qcel.models.molecule.GEOMETRY_NOISE = 13 # need more precision in geometries for high-res findif; import qcengine as qcng. from psi4 import core; from psi4.driver import p4util. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). EnergyGradientHessianWfnReturn = Union[float, core.Matrix, Tuple[Union[float, core.Matrix], core.Wavefunction]]. [docs]; class BaseComputer(qcel.models.ProtoModel):; """"""Base class for ""computers"" that plan, run, and process QC tasks."""""". [docs]; @abc.abstractmethod; def compute(self):; pass. [docs]; @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mutation = True. [docs]; class AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Field(..., description=""The molecule to use in the computation.""); basis: str = Field(..., description=""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...).""); method: str = Field(..., description=""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...).""); driver: DriverEnum = Field(..., description=""The resulting type of computation: energy, gradient, hessian, properties.""; ""Note for finite difference that this should be the target driver,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:1832,Energy,EnergyGradientHessianWfnReturn,1832,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html,1,['Energy'],['EnergyGradientHessianWfnReturn']
Energy Efficiency,"iltin module; that can perform CCSDT. For a method like CCSD, no specification of QC_MODULE; will default to the CCENERGY module, and specification with value mrcc is; required to route the computation to the MRCC program.; For a CCSDT(Q) energy, simply use 'ccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you can call it directly; For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be; more robust by Martin. [Martin:2014:785]. QC_MODULE=MRCC. name; calls method in Kallay’s MRCC program [manual]. ccsd; CC through doubles [details]. ccsdt; CC through triples. ccsdtq; CC through quadruples. ccsdtqp; CC through quintuples. ccsdtqph; CC through sextuples. ccsd(t); CC through doubles with perturbative triples [details]. ccsdt(q); CC through triples with perturbative quadruples. ccsdtq(p); CC through quadruples with pertubative quintuples. ccsdtqp(h); CC through quintuples with pertubative sextuples. ccsd(t)_l; CC through doubles with asymmetric perturbative triples [details]. ccsdt(q)_l; CC through triples with asymmetric perturbative quadruples. ccsdtq(p)_l; CC through quadruples with asymmetric perturbative quintuples. ccsdtqp(h)_l; CC through quintuples with asymmetric perturbative sextuples. ccsdt-1a; CC through doubles with iterative triples (cheapest terms). ccsdtq-1a; CC through tri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/mrcc.html:2542,energy,energy,2542,psi4manual/1.7.x/mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/mrcc.html,4,['energy'],['energy']
Energy Efficiency,"imate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon Functions: Invoking a Calculation; Single-Point Energy — energy(). © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/energy.html:37133,energy,energy,37133,psi4manual/1.7.x/energy.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/energy.html,6,['energy'],['energy']
Energy Efficiency,"imer DF-HF/cc-pVDZ. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. scf-coverage; Lithium test for coverage. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. dft1-alt; DFT Functional Test. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. dft-jk; DFT JK on-disk test. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. dft-b2plyp; Double-hybrid density functional B2PYLP. Rep",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:8353,energy,energy,8353,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"imer and water molecule. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. scf-level-shift-rohf; SCF level shift on an ROHF computation. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. cdoremp-energy1; Cholesky decomposed OO-REMP/cc-pVDZ energy for the H2O molecule. dfcasscf-sp; CASSCF/6-31G** energy point. dforemp-grad1; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O molecule. cc56; EOM-CCSD/6-31g excited state transition data for water cation. fsapt-ext-abc2; FSAPT with external charge on dimer. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. sapt9; usapt example with empty beta. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. ao-dfcasscf-sp; CASSCF/6-31G** energy point. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. dct8; DCT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Fou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:17807,charge,charge,17807,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['charge'],['charge']
Energy Efficiency,"imer'). activate(molecule); PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); if (name.lower() == 'sapt0'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT0'); elif (name.lower() == 'sapt2'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2'); elif (name.lower() == 'sapt2+'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); elif (name.lower() == 'sapt2+(3)'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', False); elif (name.lower() == 'sapt2+3'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', True); PsiMod.print_out('\n'); banner(name.upper()); PsiMod.print_out('\n'); e_sapt = PsiMod.sapt(). molecule.reset_point_group(user_pg); molecule.update_geometry(). return e_sapt. [docs]def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(). # There's three-body code somewhere so exceptions may be needed; nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); molecule.update_geometry(); monomerAm = molecule.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = molecule.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = PsiMod.get_option('SCF_TYPE'); df_ints_io = PsiMod.get_option('DF_INTS_IO'). PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/proc.html:28209,charge,charge-transfer,28209,psi4manual/4.0b2/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html,2,['charge'],['charge-transfer']
Energy Efficiency,"imizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF); CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF); MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DYNAMIC_LEVEL (OPTKING); OPTKING — Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. E3_SCALE (DFOCC); DFOCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. E3_SCALE (OCC); OCC — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DCFT); DCFT — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-10. E_CONVERGENCE (DETCI); DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DFOCC); DFOCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:112991,energy,energy,112991,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,8,['energy'],['energy']
Energy Efficiency,"imme corrections, won’t follow this table exactly. [2]; [Grimme:2004:1463]. [3]; [Grimme:2006:1787]. [4]; (1,2); [Grimme:2010:154104]. [5]; (1,2); [Grimme:2011:1456]. [6]; (1,2,3,4); [Smith:2016:2197]. [7]; [Hujo:2011:3866]. [8]; [Chai:2010:6615]. [9]; [Pernal:2009:263201]. [10]; [Podeszwa:2010:550]. [11]; Keyword not used for user-defined functionals where the dft_dict[""dispersion""][""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. [12]; [Caldeweyher:2019:154122]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). DFT-D2 single point with dftd3 instead of PSI4‘s libdisp; energy('pbe-d2', engine='dftd3'). If only dispersion corrections (rather than total energies) are of; interest, the dispersion programs can be run independently of the scf; through the python function run_dftd3() or run_dftd4(). (These functions; call QCEngine, which is the same PSI4 + dftd3/dftd4 interface that is called during an scf job.); This “D-only” route is much faster than running a DFT-D energy.; This route is NOT available for s-dftd3. File an issue if a definite need arises.; Note that in a DFT+D energy or gradient calculation, user-specified; dispersion parameters override any information provided about the; functional. The same holds true for a dftd3 “D-only” calculation. But; in a dftd4 “D-only” calculation, functional information overrides; any user-specified dispersion parameters. Some set-up:; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; >>> print nene.run_dftd3('bp86', 'd'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:12120,energy,energy,12120,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,4,['energy'],['energy']
Energy Efficiency,"immonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC, Samples; Psi4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by Psi4, ensure that the program binary (dmrcc) can be; found in your PATH. If Psi4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in Psi4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs Psi4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, Psi4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Note that perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are not available with REFERENCE ROHF. name; calls method in Kallay’s MRCC program [manual]. mrccsd; CC through doubles. mrccsdt; CC through triples. mrccsdtq; CC through quadruples. mrccsdtqp; CC through quintuples. mrccsdtqph; CC through sextuples. mrccsd(t); CC through doubles with perturbative triples. mrccsdt(q); CC through triples with perturbative quadruples. mrccsdtq(p); CC through quadruples with pertubative quintuples. mrccsdtqp(h); CC through quintuples with",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/mrcc-1.html:1254,energy,energy,1254,psi4manual/1.0.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/mrcc-1.html,4,['energy'],['energy']
Energy Efficiency,"imod_Wavefunction>`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, psi4.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Gradient: Cannot specify bsse_type for gradient yet.""). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. # Figure out lowername, dertype, and func; # If we have analytical gradients we want to pass to our wrappers, otherwise we want to run; # finite-diference energy or cbs energies; # TODO MP5/cc-pv[DT]Z behavior unkown due to ""levels""; user_dertype = kwargs.pop('dertype', None); if gradient_type == 'custom_function':; if user_dertype is None:; dertype = 0; psi4.print_out(""\nGradient: Custom function passed in without a defined dertype, assuming fd-energy based gradient.\n""); else:; psi4.print_out(""\nGradient: Custom function passed in with a dertype of %d\n"" % user_dertype); dertype = user_dertype. if dertype == 1:; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', 'scf', 8, 10, 8, 10, 8); lowername = name. elif gradient_type == 'cbs_wrapper':; cbs_methods = driver_cbs._cbs_wrapper_methods(**kwargs); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); if dertype == 1:; # Bounce to CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:32964,energy,energy,32964,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"imple-dftd3 Python module.; gcp_engine (Optional[str]) – Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp (bool) – Whether to request atomic pairwise analysis. Methods Summary. compute_energy(molecule[, wfn]); Compute dispersion energy based on engine, dispersion level, and parameters in self. compute_gradient(molecule[, wfn]); Compute dispersion gradient based on engine, dispersion level, and parameters in self. compute_hessian(molecule[, wfn]); Compute dispersion Hessian based on engine, dispersion level, and parameters in self. print_out(); Format dispersion parameters of self for output file. Methods Documentation. compute_energy(molecule, wfn=None)[source]¶; Compute dispersion energy based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule) – System for which to compute empirical dispersion correction.; wfn (Optional[Wavefunction]) – Location to set QCVariables. Returns:; Dispersion energy [Eh]. Return type:; float. Notes. DISPERSION CORRECTION ENERGYDisp always set. Overridden in SCF finalization, but that only changes for “-3C” methods. fctl DISPERSION CORRECTION ENERGYSet if fctldash nonempty. compute_gradient(molecule, wfn=None)[source]¶; Compute dispersion gradient based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule) – System for which to compute empirical dispersion correction.; wfn (Optional[Wavefunction]) – Location to set QCVariables. Returns:; (nat, 3) dispersion gradient [Eh/a0]. Return type:; Matrix. compute_hessian(molecule, wfn=None)[source]¶; Compute dispersion Hessian based on engine, dispersion level, and parameters in self.; Uses finite difference, as no dispersion engine has analytic second derivatives. Parameters:. molecule (Molecule) – System for which to compute empirical dispersion correction.; wfn (Optional[Wavefunction]) – Location to set QCVariables. Returns:; (3*nat, 3*nat) dispersion Hessian [",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.EmpiricalDispersion.html:4503,energy,energy,4503,psi4manual/1.7.x/api/psi4.driver.EmpiricalDispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.EmpiricalDispersion.html,6,['energy'],['energy']
Energy Efficiency,"imply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible \(M_s\) value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; 1; 2; 3; 4; 5; 6; 7mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; ac",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:15701,charge,charge,15701,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,12,['charge'],"['charge', 'charges']"
Energy Efficiency,"import os; import math; import warnings; import psi4; import p4const; import p4util; from driver import *; #from extend_Molecule import *; from molutil import *; from p4regex import *; # never import aliases into this file. [docs]def run_gaussian_2(name, **kwargs):. # throw an exception for open-shells; if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""""""g2 computations require ""reference rhf"".""""""). # stash user options:; optstash = p4util.OptionsState(; ['FNOCC','COMPUTE_TRIPLES'],; ['FNOCC','COMPUTE_MP4_TRIPLES'],; ['FREEZE_CORE'],; ['SCF','SCF_TYPE']). # override default scf_type; psi4.set_local_option('SCF','SCF_TYPE','OUT_OF_CORE'). # optimize geometry at scf level; psi4.clean(); psi4.set_global_option('BASIS',""6-31G(D)""); optimize('scf'); psi4.clean(). # scf frequencies for zpe; frequency('scf'). # thermodynamic properties; du = psi4.get_variable('INTERNAL ENERGY CORRECTION'); dh = psi4.get_variable('ENTHALPY CORRECTION'); dg = psi4.get_variable('GIBBS FREE ENERGY CORRECTION'). ref = psi4.wavefunction(); freqs = ref.frequencies(); nfreq = freqs.dim(0); freqsum = 0.0; for i in range (0,nfreq):; freqsum += freqs.get(i); zpe = freqsum / p4const.psi_hartree2wavenumbers * 0.8929 * 0.5; psi4.clean(). # optimize geometry at mp2 (no frozen core) level; # note: freeze_core isn't an option in MP2; psi4.set_global_option('FREEZE_CORE',""FALSE""); optimize('conv-mp2'); psi4.clean(). # qcisd(t); psi4.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES',""TRUE""); psi4.set_global_option('FREEZE_CORE',""TRUE""); psi4.set_global_option('BASIS',""6-311G(D_P)""); run_fnocc('qcisd(t)',**kwargs). # HLC: high-level correction based on number of valence electrons; ref = psi4.wavefunction(); nirrep = ref.nirrep(); frzcpi = ref.frzcpi(); nfzc = 0; for i in range (0,nirrep):; nfzc += frzcpi[i]; nalpha = ref.nalpha() - nfzc; nbeta = ref.nbeta() - nfzc; # hlc of gaussian-2; hlc = -0.00481 * nalpha -0.00019 * nbeta; # hlc of gaussian-1; hlc1 = -0.00614 * nalpha. eqci_6311gdp = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/gaussian_n.html:1992,ENERGY,ENERGY,1992,psi4manual/4.0b5/_modules/gaussian_n.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/gaussian_n.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"import psi4"". How to run Psi4 as Python module after compilation¶; Substituting the full installation directory prefix and a; suitable scratch directory, issue the following commands directly in your; terminal or place them into your “rc” file and open a new terminal. (To; use a staged installation directory, substitute; objdir/stage/prefix for prefix.); # csh, tcsh: add to shell or ~/.tcshrc file; setenv PYTHONPATH {prefix}/lib:$PYTHONPATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PYTHONPATH={prefix}/lib:$PYTHONPATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. How to configure paths for PsiAPI. Run PSI4.; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('current energy'), 5, 'SCF E'); >>> python sample.py; SCF E.............................................................PASSED. How to run Psi4 as executable or Python module from conda installation¶; The configuration commands below are generic versions of the ones printed; to your screen as advice upon installing PSI4 into a Anaconda,; Miniconda, or Psi4conda distribution, condadist =; ana|mini|psi4conda. If which conda python psi4 points to your; condadist and echo $PSI_SCRATCH is set, skip ahead to the; “Run PSI4” commands below. Otherwise, issue the following; commands directly in your terminal or place them into your “rc” file and; open a new terminal.; If you installed the Psi4conda distribution or installed the PSI4; conda package into the main environment of an Anaconda or Miniconda; distribution and added that to your PATH, as prompted, then; which psi4 likely yields condadist/bin/psi4 and the PATH; setting lines below are redundant.; If you installed into a conda environment p4env and performe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:24371,energy,energy,24371,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['energy'],['energy']
Energy Efficiency,"imrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. freq-masses; check nonphysical masses possible. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. cc17; Single point energies of multiple excited states with EOM-CCSD. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. explicit-am-basis; Check that basis sets can be input with explicit angular momentum format. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. casscf-sp; CASSCF/6-31G** energy point. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dfccsdt2; DF-CCSD(T) cc-pVDZ energy for the NH molecule. dft-reference; MP2 with a PBE0 reference computation. o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:31440,energy,energy,31440,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"imum n-body to compute, cannot exceed the number of fragments in the moleucle. :type ptype: string; :param ptype: ``'energy'`` || ``'gradient'`` || ``'hessian'``. Type of the procedure passed in. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/etc) of the system,; otherwise returns interaction data.; """""". # Initialize dictionaries for easy data passing; metadata, component_results, nbody_results = {}, {}, {}. # Parse some kwargs; kwargs = p4util.kwargs_lower(kwargs); metadata['ptype'] = kwargs.pop('ptype', None); metadata['return_wfn'] = kwargs.pop('return_wfn', False); metadata['return_total_data'] = kwargs.pop('return_total_data', False); metadata['molecule'] = kwargs.pop('molecule', core.get_active_molecule()); metadata['molecule'].update_geometry(); metadata['kwargs'] = kwargs; core.clean_variables(). if metadata['ptype'] not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % metadata['ptype']). # Parse bsse_type, raise exception if not provided or unrecognized; metadata['bsse_type_list'] = kwargs.pop('bsse_type'); if metadata['bsse_type_list'] is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(metadata['bsse_type_list'], list):; metadata['bsse_type_list'] = [metadata['bsse_type_list']]. for num, btype in enumerate(metadata['bsse_type_list']):; metadata['bsse_type_list'][num] = btype.lower(); if btype.lower() not in ['cp', 'nocp', 'vmfc']:; raise ValidationError(""N-Body GUFunc: bsse_type '%s' is not recognized"" % btype.lower()). metadata['max_nbody'] = kwargs.get('max_nbody', -1); metadata['max_frag'] = metadata['molecule'].nfragments(); if metadata['max_nbody'] == -1:; metadata['max_nbody'] = metadata['molecule'].nfragments(); else:; metadata['max_nbody'] = min(metadata['max_nbody'], metadata['max_frag']). # Flip this off for now, needs more te",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html:5975,energy,energy,5975,psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,1,['energy'],['energy']
Energy Efficiency,"imum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: str; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:36206,energy,energy,36206,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,30,['energy'],['energy']
Energy Efficiency,"imum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: string; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a seco",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:20199,energy,energy,20199,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,2,['energy'],['energy']
Energy Efficiency,"in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of Psi4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); The and terms take into; account higher-order induction effects and are included in the definition; of SAPT terms. They are computed from the Hartree-Fock supermolecular interaction energy; and are only available in dimer-centered basis SAPT; computations, which is the default (see below for monomer-centered basis; computations). They are defined by:. (6). (7); Additionally, high-order coupling between induction and dispersion can be; extracted from the supermolecular MP2 interaction energy:. where is the correlation part of the supermolecular MP2; interaction energy. and also improve the; description of electrostatically dominated complexes. ; can be applied to SAPT2+ or SAPT2+(3) energies whereas ; should be applied to SAPT2+3 energies.; A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs],; and a systematic study of the accuracy of these truncations (with and; without an improved CCD treatment of dispersion) using different basis sets; is reported in [Parker:2014:094106].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in Psi4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:3171,energy,energy,3171,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"in 1.2), and in 1.3 it will stop working\n"",; category=FutureWarning,; stacklevel=2). import xmltodict as xd; if filename is None:; csx = os.path.splitext(core.outfile_name())[0] + '.csx'; else:; csx = filename; with open(csx, 'r') as handle:; csxdict = xd.parse(handle). return csxdict. [docs]def getFromDict(dataDict, mapList):; warnings.warn(; ""Using `psi4.driver.p4util.getFromDict` is deprecated (silently in 1.2), and in 1.3 it will stop working\n"",; category=FutureWarning,; stacklevel=2). return reduce(lambda d, k: d[k], mapList, dataDict). [docs]def csx2endict():; """"""Grabs the CSX file as a dictionary, encodes translation of PSI variables; to XML blocks, gathers all available energies from CSX file into returned; dictionary. """"""; warnings.warn(; ""Using `psi4.driver.p4util.csx2endict` is deprecated (silently in 1.2), and in 1.3 it will stop working\n"",; category=FutureWarning,; stacklevel=2). blockprefix = [; 'chemicalSemantics', 'molecularCalculation', 'quantumMechanics', 'singleReferenceState', 'singleDeterminant'; ]; blockmidfix = ['energies', 'energy']; prefix = 'cs:'. pv2xml = {; 'MP2 CORRELATION ENERGY': [['mp2'], 'correlation'],; 'MP2 SAME-SPIN CORRELATION ENERGY': [['mp2'], 'sameSpin correlation'],; 'HF TOTAL ENERGY': [['abinitioScf'], 'electronic'],; 'NUCLEAR REPULSION ENERGY': [['abinitioScf'], 'nuclearRepulsion'],; 'DFT FUNCTIONAL TOTAL ENERGY': [['dft'], 'dftFunctional'],; 'DFT TOTAL ENERGY': [['dft'], 'electronic'],; 'DOUBLE-HYBRID CORRECTION ENERGY': [['dft'], 'doubleHybrid correction'],; 'DISPERSION CORRECTION ENERGY': [['dft'], 'dispersion correction'],; }. csxdict = xml2dict(); enedict = {}; for pv, lpv in pv2xml.items():; address = blockprefix + lpv[0] + blockmidfix; indices = [prefix + bit for bit in address]; try:; qwer = getFromDict(csxdict, indices); except KeyError:; continue; for v in qwer:; vv = v.values(); if vv[0] == prefix + lpv[1]:; enedict[pv] = float(vv[1]). return enedict. [docs]def compare_csx():; """"""Function to validate energies ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html:22182,energy,energy,22182,psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,1,['energy'],['energy']
Energy Efficiency,"in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:psi4.OptimizationConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html:1266,energy,energy,1266,psi4manual/1.3.2/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html,4,['energy'],['energy']
Energy Efficiency,"in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:psi4.OptimizationConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html:1266,energy,energy,1266,psi4manual/1.2.1/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html,4,['energy'],['energy']
Energy Efficiency,"in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str) – \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str) – \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. Schemes; Trans",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html:6409,energy,energy,6409,psi4manual/1.3.2/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html,8,['energy'],['energy']
Energy Efficiency,"in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str) – \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str) – \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters. scf_basis (basis string) – \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransforma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html:6410,energy,energy,6410,psi4manual/1.4.0/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html,30,['energy'],['energy']
Energy Efficiency,"in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str) – \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (str) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (str) – \(\Rightarrow\) delta_wfn \(\Leftarrow\) || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis SetsCurrently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:. scf_basis (basis string) – \(\Rightarrow\) corl_basis \(\Leftarrow\) || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. SchemesTransform",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html:6414,energy,energy,6414,psi4manual/1.7.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html,24,['energy'],['energy']
Energy Efficiency,in bsse_type & max_nbody>=2 | 2-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED INTERACTION ENERGY THROUGH {nb}-BODY | |em| 1 | when cp in bsse_type | {max_nbody}-body total data less 1-body total data for cumulative IE; inputs are total energies with cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED INTERACTION ENERGY | |em| 1 | when cp in bsse_type | best available interaction energy with cp treatment: CP-CORRECTED INTERACTION ENERGY THROUGH {max_nbody}-BODY |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED 2-BODY CONTRIBUTION TO ENERGY | |em| 1 | when cp in bsse_type & max_nbody>=2 | 2-body total data less (2-1)-body total data for partial IE; inputs are total energies w/ cp treatment |; +---------------------------------------------------------------+----------------------+--------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+; | |em| CP-CORRECTED {nb}-BODY CONTRIBUTION TO ENERGY | |em| 1 | when cp in bsse_type | {max_nbody}-body total data less ({max_nbody}-1)-body data for partial IE;,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:46456,energy,energy,46456,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,10,['energy'],['energy']
Energy Efficiency,"in data; # after the findif control ones are removed, not this by-name procedure; data['keywords']['PARENT_SYMMETRY'] = self.molecule.point_group().full_name(). self.method = data['method']. self.metameta['mode'] = str(data['findif_mode'][0]) + '_' + str(data['findif_mode'][1]); self.metameta['irrep'] = data.pop('findif_irrep', -1). if self.metameta['mode'] == '1_0':; self.metameta['proxy_driver'] = 'energy'; self.findifrec = gradient_from_energies_geometries(self.molecule,; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_grad). elif self.metameta['mode'] == '2_1':; self.metameta['proxy_driver'] = 'gradient'; self.findifrec = hessian_from_gradients_geometries(self.molecule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). elif self.metameta['mode'] == '2_0':; self.metameta['proxy_driver'] = 'energy'; self.findifrec = hessian_from_energies_geometries(self.molecule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). ndisp = len(self.findifrec[""displacements""]) + 1; info = f"""""" {ndisp} displacements needed ...\n""""""; core.print_out(info); logger.debug(info). # var_dict = core.variables(); packet = {; ""molecule"": self.molecule,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']; passalong = {k: v for k, v in data.items() if k not in packet}; passalong.pop('ptype', None). self.task_list[""reference""] = self.computer(**packet, **passalong). parent_group = self.molecule.point_group(); for label, displacement in self.findifrec[""displacements""].items():; clone = self.molecule.clone(); clone.reinterpret_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:43816,energy,energy,43816,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,8,['energy'],['energy']
Energy Efficiency,"in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH [Default]; Generalized Wolfsberg-Helmholtz, a simple Hückel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. This becomes the; default for the second and later iterations of geometry optimizations. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; BASIS_GUESS = SMALL_BASIS to the options list. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). Convergence Stabilization¶; With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:17678,efficient,efficient,17678,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['efficient'],['efficient']
Energy Efficiency,"in function efp_init in module psi4; efp_init(...). efp_init() -> EFP :. Initializes the EFP library and returns an EFP object.; C++ signature :. N5boost10shared_ptrIN3psi3efp3EFPEEE efp_init(). psi4.efp_set_options()¶; Python Library Documentation: built-in function efp_set_options in module psi4; efp_set_options(...). efp_set_options() -> None :. Set EFP options from environment options object.; C++ signature :. void efp_set_options(). psi4.fd_1_0()¶; Python Library Documentation: built-in function fd_1_0 in module psi4; fd_1_0(...). fd_1_0( (Molecule)arg1, (list)arg2) -> Matrix :. Performs a finite difference gradient computation, from energy points.; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE fd_1_0(N5boost10shared_ptrIN3psi8MoleculeEEE,N5boost6python4listE). psi4.fd_freq_0()¶; Python Library Documentation: built-in function fd_freq_0 in module psi4; fd_freq_0(...). fd_freq_0( (Molecule)arg1, (list)arg2, (int)arg3) -> Matrix :. Performs a finite difference frequency computation, from energy points, for a given irrep.; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE fd_freq_0(N5boost10shared_ptrIN3psi8MoleculeEEE,N5boost6python4listE,i). psi4.fd_freq_1()¶; Python Library Documentation: built-in function fd_freq_1 in module psi4; fd_freq_1(...). fd_freq_1( (Molecule)arg1, (list)arg2, (int)arg3) -> Matrix :. Performs a finite difference frequency computation, from gradients, for a given irrep.; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE fd_freq_1(N5boost10shared_ptrIN3psi8MoleculeEEE,N5boost6python4listE,i). psi4.fd_geoms_1_0()¶; Python Library Documentation: built-in function fd_geoms_1_0 in module psi4; fd_geoms_1_0(...). fd_geoms_1_0( (Molecule)arg1) -> matrix_vector :. Gets list of displacements needed for a finite difference gradient computation, from energy points.; C++ signature :. St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE fd_geoms_1_0(N5boost10shared_ptrIN3psi8MoleculeEEE). psi4.fd_geoms_freq_0()¶; Python Library Document",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:21679,energy,energy,21679,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"in kwargs):; kwargs['scf_scheme'] = highest_1. if not ('corl_wfn' in kwargs):; kwargs['corl_wfn'] = 'mp2'; if not ('corl_basis' in kwargs):; kwargs['corl_basis'] = 'aug-cc-pV[TQ]Z'; if not ('corl_scheme' in kwargs):; kwargs['corl_scheme'] = corl_xtpl_helgaker_2. if not ('delta_wfn' in kwargs):; kwargs['delta_wfn'] = 'ccsd(t)'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis' in kwargs):; kwargs['delta_basis'] = 'aug-cc-pVTZ'; if not ('delta_scheme' in kwargs):; kwargs['delta_scheme'] = highest_1. return cbs(name, **kwargs). #def run_mp2_5(name, **kwargs):; # r""""""Function that computes MP2.5 energy from results of a FNOCC; # MP3 calculation.; #; # .. math:: E_{total}^{\text{MP2.5}} = E_{total,\; \text{SCF}} \; + E_{corl,\; \text{MP2}} + E_{corl, \; \text{MP3}}; #; # :PSI variables: ; #; # .. hlist:: ; # :columns: 1 ; # ; # * :psivar:`MP2.5 TOTAL ENERGY <MP2.5TOTALENERGY>` ; # * :psivar:`MP2.5 CORRELATION ENERGY <MP2.5CORRELATIONENERGY>` ; #; # >>> energy('mp2.5'); #; # """"""; # lowername = name.lower(); # kwargs = kwargs_lower(kwargs); #; # # Run detci calculation and collect conventional quantities; # energy('mp3', **kwargs); # e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); # ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); # ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); # e_mp2 = e_scf + ce_mp2; # e_mp3 = e_scf + ce_mp3; #; # # Compute quantities particular to MP2.5; # ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); # e_mp25 = e_scf + ce_mp25; # PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); # PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); # PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); # PsiMod.set_variable('CURRENT ENERGY', e_mp25); #; # # build string of title banner and print results; # banners = ''; # banners += """"""PsiMod.print_out('\\n')\n""""""; # banners += """"""banner(' MP2.5 ')\n""""""; # banners += """"""PsiMod.print_out('\\n')\n\n""""""; # exec(banners); #; # tables = ''; # tables += """"",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html:2582,energy,energy,2582,psi4manual/4.0b4/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html,2,['energy'],['energy']
Energy Efficiency,"in line -decontract option for basis sets. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. scf-ecp3; Water-Argon complex with ECP present; check of UHF Hessian. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cbs-xtpl-freq; Various gradients for a strained helium dimer an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:11784,energy,energy,11784,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"in module qcdb.Molecule. psi4.core.Molecule method. run_gcp() in module qcdb.Molecule. psi4.core.Molecule method. run_gdma() in module psi4.core. RUN_MP2 (FNOCC). RUN_MP3 (FNOCC). RUN_MP4 (FNOCC). S. S (DETCI). s psi4.core.AOShellCombinationsIterator attribute. S() psi4.core.Wavefunction method. s6() psi4.core.Dispersion method. s8() psi4.core.Dispersion method. S_CHOLESKY_TOLERANCE (SCF). S_CUT (DLPNO). S_ORTHOGONALIZATION (SCF). S_TOLERANCE (SCF). sad_ psi4.core.HF attribute. SAD_CHOL_TOLERANCE (SCF). SAD_D_CONVERGENCE (SCF). SAD_E_CONVERGENCE (SCF). SAD_FRAC_OCC (SCF). SAD_MAXITER (SCF). SAD_PRINT (SCF). SAD_SCF_TYPE (SCF). SAD_SPIN_AVERAGE (SCF). SADGuess class in psi4.core. salc_name() psi4.core.CdSalcList method. SalcComponent class in psi4.core. same_a_b_dens() psi4.core.Wavefunction method. same_a_b_orbs() psi4.core.Wavefunction method. sanitize_method() in module psi4.driver. in module psi4.driver.p4util. sanitize_name() in module psi4.driver. SAPGAU_BASIS (SCF). SAPT. charge-transfer. higher-order. output. SAPT(DFT). SAPT0. theory. SAPT (SCF). SAPT ALPHA. SAPT CT ENERGY. SAPT DISP ENERGY. SAPT DISP2(CCD) ENERGY. SAPT DISP20 ENERGY. SAPT DISP21 ENERGY. SAPT DISP22(S)(CCD) ENERGY. SAPT DISP22(SDQ) ENERGY. SAPT DISP22(T) ENERGY. SAPT DISP22(T)(CCD) ENERGY. SAPT DISP30 ENERGY. SAPT ELST ENERGY. SAPT ELST EXTERN-EXTERN ENERGY. SAPT ELST10,R ENERGY. SAPT ELST12,R ENERGY. SAPT ELST13,R ENERGY. SAPT ENERGY. SAPT EST.DISP22(T) ENERGY. SAPT EST.DISP22(T)(CCD) ENERGY. SAPT EXCH ENERGY. SAPT EXCH-DISP20 ENERGY. SAPT EXCH-DISP20(S^INF) ENERGY. SAPT EXCH-DISP30 ENERGY. SAPT EXCH-IND-DISP30 ENERGY. SAPT EXCH-IND20,R ENERGY. SAPT EXCH-IND20,U ENERGY. SAPT EXCH-IND22 ENERGY. SAPT EXCH-IND30(S^INF) ENERGY. SAPT EXCH-IND30,R ENERGY. SAPT EXCH-IND30,R(S^INF) ENERGY. SAPT EXCH10 ENERGY. SAPT EXCH10(S^2) ENERGY. SAPT EXCH11(S^2) ENERGY. SAPT EXCH12(S^2) ENERGY. SAPT HF TOTAL ENERGY. SAPT HF(2) ENERGY A(0). SAPT HF(2) ENERGY A(HF). SAPT HF(2) ENERGY AB(HF). SAPT HF(2) ENERGY ABC(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/genindex.html:98956,charge,charge-transfer,98956,psi4manual/1.8.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/genindex.html,1,['charge'],['charge-transfer']
Energy Efficiency,in psi4.core. PNO_CONVERGENCE (DLPNO). point_group() psi4.core.Molecule method. point_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. PointFunctions class in psi4.core. PointGroup class in psi4.core. POINTS (FINDIF). POLE_MAXITER (ADC). pop() psi4.core.BSVec method. populateExtern() psi4.driver.QMMMbohr method. potential_grad() psi4.core.MintsHelper method. potential_variable() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. potential_variables() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. PotentialInt class in psi4.core. POTFILE (PE). power() psi4.core.Matrix method. PPL_TYPE (DFOCC). PR (ADC). PRECONDITIONER (DETCI). prepare_options_for_module() in module psi4.core. prepare_results() psi4.driver.driver_nbody.ManyBodyComputer method. prerequisites. presort_so_tei() psi4.core.IntegralTransform method. PrimitiveType class in psi4.core. PRINT (CPHF). (EFP). (GLOBALS). (SAPT). print() psi4.core.DFTGrid method. psi4.core.MolecularGrid method. psi4.core.PetiteList method. print_atom_vector() psi4.core.Matrix method. PRINT_BASIS (SCF). print_bond_angles() psi4.core.Molecule method. print_cluster() psi4.core.Molecule method. print_density_threshold() psi4.core.SuperFunctional method. print_detail() psi4.core.Functional method. psi4.core.LibXCFunctional method. psi4.core.SuperFunctional method. print_detail_out() psi4.core.BasisSet method. print_distances() psi4.core.Molecule method. print_dpd_lookup() psi4.core.IntegralTransform method. print_energies() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.R,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/genindex.html:109367,power,power,109367,psi4manual/1.6.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/genindex.html,1,['power'],['power']
Energy Efficiency,"in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments.""). nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]] = Field([], description=""Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., `[[1, 2]]` has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; `[[1], [2]]` has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry 'supersystem' means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any 'supersystem' element is at the end."") # formerly nbody_list. embedding_charges: Dict[int, List[float]] = Field({}, description=""Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:33444,charge,charges,33444,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,10,['charge'],['charges']
Energy Efficiency,"in the psi4/samples directory. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). Note; The memory and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once Psi4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about , so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s conside",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:2190,energy,energy,2190,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency,"in the psi4/samples directory. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 600 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). Note; The memory and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; >>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about \(1.0 \times 10^{-6}\), so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling and Installing from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional ke",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/tutorial-1.html:2805,energy,energy,2805,psi4manual/1.4.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/tutorial-1.html,9,['energy'],['energy']
Energy Efficiency,"in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. CCD_E_CONVERGENCE¶. E converge value for CCD. Type: conv double; Default: 1e-8. CCD_MAXITER¶. Max CCD iterations. Type: integer; Default: 50. CCD_T_CONVERGENCE¶. Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to DF_BASIS_SAPT. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. D_CONVERGENCE¶. Convergence criterion for residual of the CPHF coefficients in the SAPT term. Type: conv double; Default: 1e-8. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with . If set to a value , performs scaling with . Type: string; Default: FALSE. E_CONVERGENCE¶. Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv doubl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__sapt-1.html:1342,energy,energy,1342,psi4manual/1.0.0/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. CCD_E_CONVERGENCE¶. E converge value for CCD. Type: conv double; Default: 1e-8. CCD_MAXITER¶. Max CCD iterations. Type: integer; Default: 50. CCD_T_CONVERGENCE¶. Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to DF_BASIS_SAPT. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. D_CONVERGENCE¶. Convergence criterion for residual of the CPHF coefficients in the SAPT term. Type: conv double; Default: 1e-8. E_CONVERGENCE¶. Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT and terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE; Default: FALSE. INTS_TOLERANCE¶. Minimum absolute ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__sapt-1.html:1335,energy,energy,1335,psi4manual/4.0b4/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__sapt-1.html,8,['energy'],['energy']
Energy Efficiency,"in; Appendix ADC. Some sample inputs are provided in; psi4/samples, in directories starting with the name adc. The most; important keyword is ROOTS_PER_IRREP, which is an array; giving the number of excited states desired for each irreducible; representation. Implementation¶; Some very essential points are emphasized for understanding of the; nature and the limitations of the theory. The ADC(2) response matrix,; denoted as , is expanded in the single (S) and double (D); excitation manifolds as. where the superscript on each matrix block indicates the order of; the fluctuation. Instead of solving the above equation explicitly,; the large D manifold is treated effectively as. This form of the ADC(2) equation requires 7 – 10 iterations for; convergence on only one root. But thanks to Newton-Raphson; acceleration,. the computational time reduces to shorter than half of the simple iterative; procedure. Construction of the denominator of the second term in the above; equation is less computationally expensive than contruction of one $sigma$-vector with respect to the effective response matrix. The non-iterative excitation energy stated above is calculated as a diagonal element of the Davidson mini-Hamiltonian matrix in the SEM as,. where and denote the CIS; excitation energy and wave function, respectively. The explicit form of the; σ-vector is provided in a note accompanying the source code,; in the file psi4/src/bin/adc/sigma.pdf. Table Of Contents. Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Previous topic; Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Next topic; Symmetry-Adapted Perturbation Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/adc-1.html:6139,energy,energy,6139,psi4manual/4.0b2/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/adc-1.html,4,['energy'],['energy']
Energy Efficiency,"in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DFT FUNCTIONAL TOTAL ENERGY¶; The total electronic energy [H] for the underlying functional of the; requested DFT method, without any dispersion correction; the first four; terms in Eq. (4) or (1). Quantity; in Eqs. (4) and (1).; Unless the method includes a dispersion correction, this quantity is; equal to SCF TOTAL ENERGY. DFT TOTAL ENERGY¶; The total electronic energy [H] for the requested DFT method,; in Eq. (1). (1); Unless the method is a DFT double-hybrid, this quantity is equal to; SCF TOTAL ENERGY. If the method is neither a; double-hybrid, nor dispersion corrected, this quantity is equal to; DFT FUNCTIONAL TOTAL ENERGY. DFT XC ENERGY¶; The functional energy contribution [H] to the total SCF energy (DFT only).; Quantity in Eqs. (4) and (1). DISPERSION CORRECTION ENERGY¶; The dispersion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity ; in Eqs. (4) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any disper",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:10701,energy,energy,10701,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,6,['energy'],['energy']
Energy Efficiency,"in; the equations that define each of the coupled-pair methods implemented in; Psi4. We begin with the CISD wave function. (3); where we have chosen the intermediate normalization, . The CISD correlation energy is given by. (4); and the amplitudes can be determined by the solution to the coupled set of; eqations:. (5); The CISD method is not size-extensive, but this problem can be overcome by; making very simple modifications to the amplitude equations. We replace; the correlation energy, , with generalized shifts for the; doubles and singles equations, and :. (6); These shifts approximate the effects of triple and quadruple excitations.; The values for and used in several; coupled-pair methods are given in Table CEPA Shifts. Note that these shifts are defined in a spin-free; formalism for closed-shell references only. method. cisd. cepa(0); 0; 0. cepa(1). cepa(3). acpf. aqcc. The pair correlation energy, , is simply a partial; sum of the correlation energy. In a spin-free formalism, the pair energy; is given by. (7); Methods whose shifts ( and ) do not; explicitly depend on orbitals or (CISD, CEPA(0), ACPF,; and AQCC) have solutions that render the energy stationary with respect; variations in the amplitudes. This convenient property allows density; matrices and 1-electron properties to be evaluated without any additional; effort. Note, however, that 1-electron properties are currently; unavailable when coupling these stationary CEPA-like methods with frozen; natural orbitals. Density-fitted coupled cluster¶; Density fitting (DF) [or the resolution of the identity (RI)] and Cholesky; decomposition (CD) techniques are popular in quantum chemistry to avoid; the computation and storage of the 4-index electron repulsion integral; (ERI) tensor and even to reduce the computational scaling of some terms.; DF/CD-CCSD(T) computations are available in Psi4, with or without the; use of FNOs, through the FNOCC module. The implementation and accuracy of; the DF/CD-CCSD(T) metho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/fnocc-1.html:7784,energy,energy,7784,psi4manual/1.0.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/fnocc-1.html,2,['energy'],['energy']
Energy Efficiency,"inate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. scf7; Tests SCF gradient in the presence of a dipole field. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. lccd-grad2; LCCD cc-pVDZ gradient for the NO radical. nbody-nocp-gradient; Computation of NoCP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. frac-sym; Fractional occupation with symmetry. sapt-compare; SAPT0 aug-cc-pVDZ computation of the water-water interaction energy, using the three SAPT codes. fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. dft-jk; DFT JK on-disk test. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. cbs-delta-energy; Extrapolated energies with delta correction. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. dct8; DCT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:23233,energy,energy,23233,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody_gufunc() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; # all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; database('mp2', 'S22', cp=1, benchmark='S22B'). w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:13674,energy,energy,13674,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,4,['energy'],['energy']
Energy Efficiency,"induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. INTS_TOLERANCE¶. Schwarz screening threshold. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Specific open-shell SAPT0 keywords¶. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. COUPLED_INDUCTION¶. Solve the CPHF equations to compute coupled induction and exchange-induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/sapt-1.html:17895,energy,energy,17895,psi4manual/1.3.2/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. INTS_TOLERANCE¶. Schwarz screening threshold. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Specific open-shell SAPT0 keywords¶. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. COUPLED_INDUCTION¶. Solve the CPHF equations to compute coupled induction and exchange-induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. SAPT(DFT)¶; In general, SAPT(DFT) should provide more accurate interaction energy; components, and overall interaction energies, than SAPT0. The drawback; is SAPT(D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:20208,energy,energy,20208,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['energy'],['energy']
Energy Efficiency,"induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. cisd-sp; 6-31G** H2O Test CISD Energy Point. opt-multi-frozen-dimer-c2h; Frozen-fragment opt of C2h methane dimer with user-combined reference points. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. cc54; CCSD dipole with user-specified basis set. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN. fci-h2o-2; 6-31G H2O Test FCI Energy Point. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cepa-module; routing check on lccd, lccsd, cepa(0). pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cc17; Single point energies of multiple excited states with EOM-CCSD. castup3; SCF with various combinations of pk/dens",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:26954,energy,energy,26954,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ine set_attr method of molecule class. proc¶. run_adc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. Caution; Get rid of active molecule lines- should be handled in energy. run_bccd(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. run_bccd_t(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a Brueckner CCD(T) calculation. run_cc_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. run_cc_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; all CC property calculations. run_ccenergy(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. run_cepa(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a cepa-like calculation.; >>> energy('cepa(1)'). run_cepa0(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CEPA (LCCD) computation. run_cepa0_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CEPA(0) gradient calculation. run_dcft(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density cumulant functional theory calculation. run_dcft_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; DCFT gradient calculation. run_detci(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. run_dfmp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. run_dfmp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. run_dfmp2_property(name, **kwargs)[source]¶; Function encoding sequence",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:8477,energy,energy,8477,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency,"ine set_attr method of molecule class. proc¶. run_adc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. Caution; Get rid of active molecule lines- should be handled in energy. run_bccd(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. run_bccd_t(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a Brueckner CCD(T) calculation. run_cc_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. run_cc_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; all CC property calculations. run_ccenergy(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. run_cepa(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a cepa-like calculation.; >>> energy('cepa(1)'). run_dcft(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density cumulant functional theory calculation. run_dcft_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; DCFT gradient calculation. run_detci(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. run_dfmp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. run_dfmp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. run_dft(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-functional-theory calculation. run_dft_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. run_eom_cc(name, **kwargs)[source]¶; Functi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:8469,energy,energy,8469,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency,"ine the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int) → float¶; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int) → psi4.core.Vector3¶; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int) → float¶; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int) → float¶; z position [Bohr] of atom arg0 (0-indexed without dummies). table of contents. Molecule; Molecule; Molecule.B787(); Molecule.BFS(); Molecule.Z(); Molecule.activate_all_fragments(); Molecule.add_atom(); Molecule.atom_at_position(); Molecule.basis_on_atom(); Molecule.center_of_mass(); Molecule.charge(); Molecule.clone(); Molecule.com_fixed(); Molecule.comment(); Molecule.connectivity(); Molecule.create_psi4_string_from_molecule(); Molecule.deactivate_all_fragments(); Molecule.distance_matrix(); Molecule.extract_subsets(); Molecule.fZ(); Molecule.fcharge(); Molecule.find_highest_point_group(); Molecule.find_point_group(); Molecule.fix_com(); Molecule.fix_orientation(); Molecule.flabel(); Molecule.fmass(); Molecule.form_symmetry_information(); Molecule.format_molecule_for_mol(); Molecule.from_arrays(); Molecule.from_dict(); Molecule.from_schema(); Molecule.from_string(); Molecule.fsymbol(); Molecule.ftrue_atomic_number(); Molecule.full_geometry(); Molecule.full_pg_n(); Molecule.fx(); Molecule.fy(); Molecule.fz(); Molecule.geometry(); Molecule.get_fragment_charges(); Molecule.get_fragment_multiplicities(); Molecule.get_fragment_types(); Molecule.get_fragments(); Molecule.get_full_point_group(); Molecule.get_full_point_group_with_n(); Molecule.get_variable(); Molecule.has_zmatrix(); Molec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html:39880,charge,charge,39880,psi4manual/1.8.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Molecule.html,6,['charge'],['charge']
Energy Efficiency,"ine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. freq-masses; check nonphysical masses possible. cc17; Single point energies of multiple excited states with EOM-CCSD. fci-coverage; 6-31G H2O Test for coverage. cdoremp-energy1; Cholesky decomposed OO-REMP/cc-pVDZ energy for the H2O molecule. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. dft1-alt; DFT Functional Test. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. mbis-6; MBIS calculation on H2O. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc13c; Tests RHF CCSD(T)gradients. cubeprop-frontier; ROHF frontier orbitals of CH2(s) and CH2(t). mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. sad-scf-type; Test SAD SCF guesses on noble gas atom. x2c1; Test of SFX2C-1e on water uncon",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:2094,energy,energy,2094,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ined. delta3_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string) – delta2_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string) – delta3_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string) – delta4_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – corl_basis || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (basis string) – 'cc-pV[TQ]Z' || ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:5241,energy,energy,5241,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"ined. delta_wfn_lesser (string) – 'mp2' || 'ccsd' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – corl_basis || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:; scf_scheme (function) – highest_1 || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy. corl_scheme (function) – highest_1 || corl_xtpl_helgaker_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cbs-1.html:4261,energy,energy,4261,psi4manual/4.0b2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cbs-1.html,6,['energy'],['energy']
Energy Efficiency,"ines = lines2. # 1. Look for units [ang|bohr|au|a.u.] defaults to ang; re_units = re.compile(r'^\s*units?[\s=]+((ang)|(angstrom)|(bohr)|(au)|(a\.u\.))$\s*', re.IGNORECASE); units = 'ang'; lines2 = []; for line in lines:; mobj = re_units.match(line); if (mobj):; unit = mobj.group(1); if (unit == 'bohr' or unit == 'au' or unit == 'a.u.'):; units = 'bohr'; else:; units = 'ang'; else:; lines2.append(line); lines = lines2. # 2. Look for basis basisname, defaults to cc-pvdz; # 3. Look for df_basis_scf basisname, defaults to cc-pvdz-jkfit; re_basis = re.compile(r'\s*basis[\s=]+(\S+)\s*$', re.IGNORECASE); re_df_basis = re.compile(r'\s*df_basis_scf[\s=]+(\S+)\s*$', re.IGNORECASE); basis = 'cc-pvdz'; df_basis_scf = 'cc-pvdz-jkfit'; lines2 = []; for line in lines:; mobj = re_basis.match(line); if (mobj):; basis = mobj.group(1); else:; mobj = re_df_basis.match(line); if (mobj):; df_basis_scf = mobj.group(1); else:; lines2.append(line); lines = lines2. # 4. Look for charge lines Z x y z, convert according to unit convention; charge_re = re.compile(r'^\s*' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*$'); lines2 = []; for line in lines:; mobj = charge_re.match(line); if (mobj):; if (units == 'ang'):; extern += '%sqmmm.addChargeAngstrom(%s,%s,%s,%s)\n' % (spacing, mobj.group(1), mobj.group(2), mobj.group(3), mobj.group(4)); if (units == 'bohr'):; extern += '%sqmmm.addChargeBohr(%s,%s,%s,%s)\n' % (spacing, mobj.group(1), mobj.group(2), mobj.group(3), mobj.group(4)); else:; lines2.append(line); lines = lines2. # 5. Look for diffuse regions, which are XYZ molecules seperated by the usual -- lines; spacer_re = re.compile(r'^\s*--\s*$'); frags = []; frags.append([]); for line in lines:; mobj = spacer_re.match(line); if (mobj):; if (len(frags[len(frags) - 1])):; frags.append([]); else:; frags[len(frags) - 1].append(line). extern += '%sextern_mol_temp = PsiMod.get_active_molecule()\n' % (spacing). mol_re = re.compile(r'\s*\S+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/input.html:11953,charge,charge,11953,psi4manual/4.0b3/_modules/input.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/input.html,4,['charge'],['charge']
Energy Efficiency,"ines = lines2. # 1. Look for units [ang|bohr|au|a.u.] defaults to ang; re_units = re.compile(r'^\s*units?[\s=]+((ang)|(angstrom)|(bohr)|(au)|(a\.u\.))$\s*', re.IGNORECASE); units = 'ang'; lines2 = []; for line in lines:; mobj = re_units.match(line); if (mobj):; unit = mobj.group(1); if (unit == 'bohr' or unit == 'au' or unit == 'a.u.'):; units = 'bohr'; else:; units = 'ang'; else:; lines2.append(line); lines = lines2. # 2. Look for basis basisname, defaults to cc-pvdz; # 3. Look for df_basis_scf basisname, defaults to cc-pvdz-jkfit; re_basis = re.compile(r'\s*basis[\s=]+(\S+)\s*$', re.IGNORECASE); re_df_basis = re.compile(r'\s*df_basis_scf[\s=]+(\S+)\s*$', re.IGNORECASE); basis = 'cc-pvdz'; df_basis_scf = 'cc-pvdz-jkfit'; lines2 = []; for line in lines:; mobj = re_basis.match(line); if (mobj):; basis = mobj.group(1); else:; mobj = re_df_basis.match(line); if (mobj):; df_basis_scf = mobj.group(1); else:; lines2.append(line); lines = lines2. # 4. Look for charge lines Z x y z, convert according to unit convention; charge_re = re.compile(r'^\s*' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*$'); lines2 = []; for line in lines:; mobj = charge_re.match(line); if (mobj):; if (units == 'ang'):; extern += '%sqmmm.addChargeAngstrom(%s,%s,%s,%s)\n' % (spacing, mobj.group(1), mobj.group(2), mobj.group(3), mobj.group(4)); if (units == 'bohr'):; extern += '%sqmmm.addChargeBohr(%s,%s,%s,%s)\n' % (spacing, mobj.group(1), mobj.group(2), mobj.group(3), mobj.group(4)); else:; lines2.append(line); lines = lines2. # 5. Look for diffuse regions, which are XYZ molecules seperated by the usual -- lines; spacer_re = re.compile(r'^\s*--\s*$'); frags = []; frags.append([]); for line in lines:; mobj = spacer_re.match(line); if (mobj):; if (len(frags[len(frags) - 1])):; frags.append([]); else:; frags[len(frags) - 1].append(line). extern += '%sextern_mol_temp = psi4.get_active_molecule()\n' % (spacing). mol_re = re.compile(r'\s*\S+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/inputparser.html:13140,charge,charge,13140,psi4manual/4.0b5/_modules/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/inputparser.html,2,['charge'],['charge']
Energy Efficiency,"ines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:10379,energy,energy,10379,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,12,['energy'],['energy']
Energy Efficiency,"ing CFOUR_SYMMETRY =OFF in the input. The DEFAULT option (which is the default) uses the highest order Abelian subgroup. Type: string; Possible Values: DEFAULT, C1, C2, CS, CI, C2V, C2H, D2, D2H, OFF; Default: DEFAULT. CFOUR_SYM_CHECK (CFOUR)¶CFOUR — In principle can be used to force the SCF to converge a solution for which the density matrix transforms as the totally symmetric representation of the point group (i.e. no broken symmetry solutions). The code seems to work in most cases, but has currently been implemented for point groups with E type representation and not for those with triply-, quadruply- or pentuply-degenerate representations. Extending the code to those cases is probably straightforward, and the reader is encouraged to do so if (s)he is so inclined. SYM_CHECK=0 “forces” the high-symmetry solution. SYM_CHECK=OVERRIDE (=1) doesn’t. The latter is the default. Type: boolean; Default: true. CFOUR_SYMMETRY (CFOUR)¶CFOUR — Specifies what subgroup of the full point group is to be used in the energy and/or gradient calculation (the computational point group). OFF (=1) forces a no symmetry run (in \(C_1\) ) and ON (=0) runs the calculation in the largest self-adjoint subgroup ( \(D_{2h}\) and its subgroups). Type: boolean; Default: true. CFOUR_T3_EXTRAPOL (CFOUR)¶CFOUR — Specifies whether the T3 amplitudes are included ON (=1) or not included OFF (=0) in the DIIS convergence acceleration during CCSDT calculations. Inclusion of T3 speeds up convergence and allows tight convergence, but on the other hand it increases disk space requirements. Note that this keyword is only available with module xecc. Type: boolean; Default: false. CFOUR_TAMP_SUM (CFOUR)¶CFOUR — Specifies how often the largest \(t\) amplitudes are to be printed. For =0, amplitudes are printed at the beginning and end of the run. For =1, amplitudes are printed every iteration. For =2, amplitudes are printed every other iteration, etc. Type: integer; Default: 5. CFOUR_THERMOCHEMISTRY (CFOUR)¶CFOUR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:79893,energy,energy,79893,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['energy'],['energy']
Energy Efficiency,"ing a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/opt-1.html:1108,energy,energy,1108,psi4manual/4.0b2/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html,2,['energy'],['energy']
Energy Efficiency,"ing a Database. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Customization: Adding Simple Extensions. Creating a Database¶. Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re dete",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/quickadddatabase-1.html:1082,energy,energy,1082,psi4manual/1.2.1/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/quickadddatabase-1.html,2,['energy'],['energy']
Energy Efficiency,"ing a Database. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Customization: Adding Simple Extensions. Creating a Database¶. Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. A necessary consideration in constructing a database is the distinction; between reagents and reactions. A reagent is a single molecular system; (may be a dimer) whose geometry you are possession of and whose electronic; energy may be of interest. A reaction is a combination of one or more; reagent energies whose value you are interested in and a reference value; for which you may or may not be in possession of. A few examples follow.; In a database of interaction energies, the reagents are dimers and their; component monomers (usually derived from the dimer geometry), and the; reactions are the dimer less monomers energies. In a database of barrier; heights, the reagents are reactants, products, and transition-state; structures, and the reactions are the transition-states less; minimum-energy structures. Possibly you may have a collection of; structures to simply be acted upon in parallel, in which case the; structures are both the reagents and the reactions. The role of the; database.py file is to collect arrays and dictionaries that define the; geometries of reagents (GEOS), their combination into reactions (RXNM &; ACTV), available reference values for reactions (BIND), and brief comments; for reagents and reactions (TAGL). The journey from reagent geometries to; functional database.py file is largely automated, in a process described; below. Prepare geometry files; Assemble xyz files for all intended reagent systems in a directory.; Follow the rules below for best results. The filename for each xyz; file should be the name of the system. lowercase or MixedCase is; preferable (according to Sherrill lab convention). Avoid dashes and; dots in the name as python won’t allow them. If you’re dete",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/quickadddatabase-1.html:1082,energy,energy,1082,psi4manual/1.3.2/quickadddatabase-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/quickadddatabase-1.html,2,['energy'],['energy']
Energy Efficiency,"ing a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. scf6; Tests RHF/ROHF/UHF SCF gradients. numpy-array-interface; Numpy interface testing. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. casscf-fzc-sp; CASSCF/6-31G** energy point. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. cbs-xtpl-energy; Extrapolated water energies. mp2p5-grad2; MP2.5 cc-pVDZ gr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:14360,energy,energy,14360,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ing and Installing from Source).; This very simple input is sufficient to run the requested information.; Notice that we didn’t tell the program some otherwise useful information; like the charge on the molecule (0, it’s neutral), the spin multiplicity; (1 for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree–Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where; not all electrons are paired. For example, let’s run a computation; on methylene (CH2), whose ground electronic state has two unpaired; electrons (triplet electronic state, or a spin multiplicity ).; In this case, the default spin multiplicity (1) is not correct, so we; need to tell the program the true value (3). Like many programs, Psi4; can get the charge and multiplicity as the first two integers in the; Z-matrix. Note the line with 0 3 at the beginning of the molecule; specification below. In this example we will also specify the bond length; and bond angle as variables ( and ), whose values are given; at the end of the Z-matrix specification.; #! Sample UHF/6-31G** CH2 computation. memory 250 mb. molecule ch2 {; 0 3; C ; H 1 R; H 1 R 2 A. R = 1.075; A = 133.93; }. set basis 6-31G**; set reference uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestric",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:3568,charge,charge,3568,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['charge'],['charge']
Energy Efficiency,"ing available quantum; chemical methods and functions driving the main quantum chemical; functionality, namely single-point energies, geometry optimizations,; properties, and vibrational frequency calculations. wrapper_autofrag¶. auto_fragments(**kwargs)[source]¶; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. Returns:Molecule) – fragmented molecule. Parameters:molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> molecule mol {\nH 0.0 0.0 0.0\nH 2.0 0.0 0.0\nF 0.0 1.0 0.0\nF 2.0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefunction density. fitScf()[source]¶; Function to run scf and fit a system of diffuse charges to; resulting density. populateExtern(extern)[source]¶. class QMMM[source]¶. addChargeAngstrom(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]¶; Function to add a diffuse charge field diffuse. populateExtern()[source]¶; Function to define a charge field external to the; molecule through point and diffuse charges. qcdb¶; Module to facilitate quantum chemical computations on chemical; databases. Contains Molecule class and physical constants from psi4 suite.; Module with commands building BasisFamily objects; for Pople and other non-Dunning orbital basis sets. Some; plausible fitting basis sets are supplied as defaults. load_basfam_other()[source]¶. class CharacterTable(*ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:8986,charge,charges,8986,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['charge'],['charges']
Energy Efficiency,"ing could be placed in the PSI4 input file.; 1; 2energy('c4-ccsd'); print 'miracle?', 'miracle' in P4C4_INFO['output']. Scratch Files; By default, a separate subdirectory for each Cfour call is created within; the job’s scratch directory. To explicitly specify the location of the; Cfour scratch, execute with, for example, energy('cfour',; path='/full/path/to/cfour/scratch'). Regardless of whether the location; is specified or default, whether to preserve the scratch directory after; the computation can be specified with energy('cfour', keep=True) or; (the default) energy('cfour', keep=False). path and keep are; keyword arguments that get interpreted by the; run_cfour() function documented below. Functionality¶; Through clever use of the cfour {...} block, one could run most any; Cfour computation through the P4C4 interface. In contrast, enumerated; below are tested functionalities where results from Cfour are collected; into PSI4 data objects.; Implemented. Single-point energy() commands for ground state; methods. Examples:; cfour/sp-rhf-ccsd_t_-ao-ecc, cfour/scf4,; cfour/mints5.; Analytic gradient() and optimize(); commands for ground state methods. Real and; Ghost atoms permitted (though the latter will naturally collapse after; several cycles). Examples: cfour/opt-rhf-ccsd_t_,; cfour/mp2-1, and cfour/mints5-grad. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Finite difference of energy gradient() and; optimize() for methods.; Force with gradient('name', dertype=0), etc..; nbody_gufunc() for computation of interaction energies with or; without counterpoise correction. Example: cfour/dfmp2-1.; database() for computation of a collection of molecules in a; single input, with summarization of results. Examples:; cfour/pywrap-db",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:24502,energy,energy,24502,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,6,['energy'],['energy']
Energy Efficiency,"ing form of; Becke and Johnson was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now \(s_6\), \(s_8\),; \(a_1\), and \(a_2\). \[E_{disp}^{\text{D3BJ}}=-\sum_{n=6,8} s_n \sum_{i,j>i}^{N_{at}}; \frac{C_n^{ij}}{(R_{ij})^n + (f_{damp})^n}\]. \[f_{damp} = a_1 \sqrt{\frac{C_8^{ij}}{C_6^{ij}}} + a_2\]; All parameters characterizing the dispersion correction are taken from; http://toc.uni-muenster.de/DFTD3/; or else from the literature. Running DFTD3¶; A number of a posteriori dispersion corrections are available in; PSI4. While most are computed within PSI4‘s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/PSI4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of S. Grimme’s -D correction¶. Extension [1]; Variant and Computing Program; DFT_DISPERSION_PARAMETERS. -D; alias to -D2P4;  . -D1; -D1 [2] within PSI4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within PSI4; [\(s_6\)]. -D2GR; -D2 [3] through dftd3; [\(s_6\), \(\alpha_6\)]. -D3; alias to -D3ZERO;  . -D3ZERO; -D3 [4] w/ o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dftd3-1.html:4707,energy,energy,4707,psi4manual/1.1.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dftd3-1.html,2,['energy'],['energy']
Energy Efficiency,"ing form of; Becke and Johnson was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now \(s_6\), \(s_8\),; \(a_1\), and \(a_2\). \[E_{disp}^{\text{D3BJ}}=-\sum_{n=6,8} s_n \sum_{i,j>i}^{N_{at}}; \frac{C_n^{ij}}{(R_{ij})^n + (f_{damp})^n}\]. \[f_{damp} = a_1 \sqrt{\frac{C_8^{ij}}{C_6^{ij}}} + a_2\]; All parameters characterizing the dispersion correction are taken from; http://toc.uni-muenster.de/DFTD3/; or else from the literature. Running DFTD3¶; A number of a posteriori dispersion corrections are available in; PSI4. While most are computed within PSI4’s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/PSI4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of S. Grimme’s -D correction¶. Extension [1]; Variant and Computing Program; DFT_DISPERSION_PARAMETERS. -D; alias to -D2P4;  . -D1; -D1 [2] within PSI4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within PSI4; [\(s_6\)]. -D2GR; -D2 [3] through dftd3; [\(s_6\), \(\alpha_6\)]. -D3; alias to -D3ZERO;  . -D3ZERO; -D3 [4] w/ o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dftd3-1.html:4870,energy,energy,4870,psi4manual/1.2.1/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dftd3-1.html,2,['energy'],['energy']
Energy Efficiency,"ing frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; ranged_distance = (""; 1 3 0.949 0.95; 2 4 0.949 0.95; ""); }. Note; The effect of the frozen and ranged keywords is generally independent of; how the geometry of the molecule was input (whether Z-matrix or Cartesian, etc.)..; At this time; however, enforcing Cartesian constraints when using a zmatrix for; molecular input is not supported. Freezing or constraining Cartesian coordinates; requires Cartesian molecule input. If numerical errors results in symmetry; breaking, while Cartesian constraints are active, symmetrization cannot occur and; an error will be raised, prompting you to restart the job. As a shortcut, the entire set of dihedral angles can be frozen. A subset can then be unfrozen if desired. set {; freeze_all_dihedrals true; unfreeze_dihedrals ""1 2 3 4""; }. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. lower_bound = [99.99, 109.99, 119.99, 129.99, 149.99]; upper_bound = [100, 110, 120, 130, 140, 150]; PES = []. for lower, upper in zip(lower_bound, upper_bound):; my_string = f""1 2 3 4 {lower} {upper}""; set optking ranged_dihedral = $my_string; E = optimize('scf'); PES.append((upper, E)). print(""\n\tcc-pVDZ SCF energy as a function of phi\n""); for point in PES:; print(""\t%5.1f%20.10f"" % (point[0], point[1])). To scan the potential energy surface without the RANGED_DIHEDRAL keyword, a zmatrix; can be used. Warning; Rotating dihedrals in large increments without allowing the molecule to relax; in between increments can lead to unphysical geometries with overlapping functional groups in larger molecules,; which may prevent successful con",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:7376,energy,energy,7376,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,1,['energy'],['energy']
Energy Efficiency,"ing into paired method and basis stages. * transform user string into cbs kwargs inc'l basic cbs_metadata; cbs kwargs may signal simple method/basis single point -or- a modelchem requiring CompositeComputer. ----------------------------; CompositeComputer.__init__(); ----------------------------. _process_cbs_kwargs(); ---------------------; * if input is cbs_metadata dict, skip to _validate_cbs_inputs(); * otherwise, transform user kwargs into trial cbs_metadata format (aka dict spec). _validate_cbs_inputs(); ----------------------. _get_default_xtpl(); -------------------; * supply default xtpl fn for stage and basis conditions. _expand_bracketed_basis(); -------------------------; * parse and validate user bases. * check and supply defaults for cbs_metadata format (various calls to above two fns). * BaseComputer.__init__(). _build_cbs_compute(); --------------------. _expand_scheme_orders(); -----------------------; * form f_fields dict of entries for each zeta in a scheme (single NEED; entries related by nonlinear fn; (that is, constructing the CBS energy from the component energies is nonlinear)). _contract_bracketed_basis(); ---------------------------; * form basis abbr. string from basis seq. * form d_fields list of stages or stage halves from NEEDs (GRAND_NEED; items related linearly to form final val); * form list of entries (entry:= mtd-bas-opt specification) mentioned in GRAND_NEED (MODELCHEM; redundant, naive); * form subset of MODELCHEM with minimal list of jobs (job:= entry on which to call QC) to satisfy CBS (JOBS; minimal, enlightened); * form superset of JOBS with maximal list of entries resulting from JOBS (TROVE); * return GRAND_NEED/cbsrec, JOBS/compute_list, TROVE/trove. * form task_list of AtomicComputers 1:1 from JOBS/compute_list. -------------------------------; CompositeComputer.build_tasks(); -------------------------------; * pass. ---------------------------; CompositeComputer.compute(); ---------------------------; * compute() for each ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:2655,energy,energy,2655,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,10,['energy'],['energy']
Energy Efficiency,"ing pre-c1-constructed BasisSet basis. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. finalize_E(self: psi4.core.HF) → float¶; Computes the final SCF energy. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavef",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:24653,energy,energy,24653,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,12,['energy'],['energy']
Energy Efficiency,"ing scs-mp2. cisd-sp; 6-31G** H2O Test CISD Energy Point. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. props4; Electrostatic potential and electric field evaluated on a grid around water. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. mp2-1; All-electron MP2 6-31G** geometry optimization of water. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. dft2; DFT Functional Test. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. aediis-1; ADIIS test case, from 10.1063/1.3304922. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. fsapt-ext-abc; FSAPT with external charge on trimer. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. dft-reference; MP2 with a PBE0 reference computation. dft1; DFT Functional Test all values update for new BraggSlater radii. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. ddd-deriv; Sample HF/cc-pVDZ H2O computation all derivatives. nbody-multi-level-2; many-body different levels of theory on each body of helium tetramer. mom; Maximum Overlap Method (MOM) Tes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:25878,energy,energy,25878,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ing something; core.EXTERN = EXTERN; core.set_global_option(""EXTERN"", True); else:; raise ValidationError(""Options: set_global_option_python can either be a NULL or External Potential object""). core.set_global_option_python = _core_set_global_option_python. ## QCvar helps. _qcvar_transitions = {; # old: (replacement, release after next); ""SCSN-MP2 CORRELATION ENERGY"": (""SCS(N)-MP2 CORRELATION ENERGY"", 1.5),; ""SCSN-MP2 TOTAL ENERGY"": (""SCS(N)-MP2 TOTAL ENERGY"", 1.5),; ""MAYER_INDICES"": (""MAYER INDICES"", 1.5),; ""WIBERG_LOWDIN_INDICES"": (""WIBERG LOWDIN INDICES"", 1.5),; ""LOWDIN_CHARGES"": (""LOWDIN CHARGES"", 1.5),; ""MULLIKEN_CHARGES"": (""MULLIKEN CHARGES"", 1.5),; ""(AT) CORRECTION ENERGY"": (""A-(T) CORRECTION ENERGY"", 1.5),; ""CCSD(AT) TOTAL ENERGY"": (""A-CCSD(T) TOTAL ENERGY"", 1.5),; ""CCSD(AT) CORRELATION ENERGY"": (""A-CCSD(T) CORRELATION ENERGY"", 1.5),; ""CP-CORRECTED 2-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY"", 1.7),; ""CP-CORRECTED 3-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 3-BODY"", 1.7),; ""CP-CORRECTED 4-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 4-BODY"", 1.7),; ""CP-CORRECTED 5-BODY INTERACTION ENERGY"": (""CP-CORRECTED INTERACTION ENERGY THROUGH 5-BODY"", 1.7),; ""NOCP-CORRECTED 2-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 2-BODY"", 1.7),; ""NOCP-CORRECTED 3-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 3-BODY"", 1.7),; ""NOCP-CORRECTED 4-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 4-BODY"", 1.7),; ""NOCP-CORRECTED 5-BODY INTERACTION ENERGY"": (""NOCP-CORRECTED INTERACTION ENERGY THROUGH 5-BODY"", 1.7),; ""VMFC-CORRECTED 2-BODY INTERACTION ENERGY"": (""VMFC-CORRECTED INTERACTION ENERGY THROUGH 2-BODY"", 1.7),; ""VMFC-CORRECTED 3-BODY INTERACTION ENERGY"": (""VMFC-CORRECTED INTERACTION ENERGY THROUGH 3-BODY"", 1.7),; ""VMFC-CORRECTED 4-BODY INTERACTION ENERGY"": (""VMFC-CORRECTED INTERACTION ENERGY THROUGH 4-BODY"", 1.7),; ""VMFC-CORRECTED 5",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:19247,ENERGY,ENERGY,19247,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,10,['ENERGY'],['ENERGY']
Energy Efficiency,"ing the root numbers of the states to average in a state-averaged procedure such as SA-CASSCF. Root numbering starts from 1. Type: array; Default: No Default. AVG_WEIGHTS¶. Array giving the weights for each state in a state-averaged procedure. Type: array; Default: No Default. A_RAS3_MAX¶. maximum number of alpha electrons in RAS III. Type: integer; Default: -1. B_RAS3_MAX¶. maximum number of beta electrons in RAS III. Type: integer; Default: -1. CALC_S_SQUARED¶. Do calculate the value of for each root? Only supported for ICORE = 1. Type: boolean; Default: false. CIBLKS_PRINT¶. Do print a summary of the CI blocks?. Type: boolean; Default: false. CI_MAXITER¶. Maximum number of iterations to diagonalize the Hamiltonian. Type: integer; Default: 24. CI_NUM_THREADS¶. Number of threads for DETCI. Type: integer; Default: 1. DETCI_FREEZE_CORE¶. Do freeze core orbitals?. Type: boolean; Default: true. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. ICORE¶. Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. ISTOP¶. Do stop DETCI after string information is formed and before integrals are read?. Type: boolean; Default: false. MS0¶. Do use the component of the state? Defaults to TRUE if closed-shell and FALSE otherwise. Related to the S option. Type: boolean; Default: false. NUM_DETS_PRINT¶. Number of important determinants to print.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__detci-1.html:1597,energy,energy,1597,psi4manual/1.0.0/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__detci-1.html,2,['energy'],['energy']
Energy Efficiency,"ing them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_.. tuple. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. cepa4; cc-pvdz H2O Test coupled-pair LCCD against DCFT CEPA0. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. cc51; EOM-CC3/cc-pVTZ on H2O. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the sing",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:37506,energy,energy,37506,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ing them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_.. tuple. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. cepa4; cc-pvdz H2O Test coupled-pair LCCD against DCFT CEPA0. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. cc51; EOM-CC3/cc-pVTZ on H2O. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:39122,energy,energy,39122,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ing those described below. Defining a Method Alias¶; Since quantum chemical methods in Psi4 are accessed through Python functions, and; most important quantities are available as PSI variables, it is straightforward; to create aliases to commonly run calculations or to define hybrid methods. The; psi4/share/python/aliases.py file is intended for editing by the user for; this purpose.; As an example, the MP2.5 method; (which admittedly is already built in to Psi4); is the average of MP2 and MP3. The latter is; available through the arbitrary order MPn code and returns all lower energies; along with it in PSI variables. The following is basic code that will compute; and return the MP2.5 energy.; def run_mp2_5(name, **kwargs):. energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'). ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25. print """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); print """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25). return e_mp25. Compare the above to the method that resides in psi4/share/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL EN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/quickaddalias-1.html:1302,energy,energy,1302,psi4manual/1.0.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/quickaddalias-1.html,2,['energy'],['energy']
Energy Efficiency,"ing upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies). # The last item in the list is the reference energy, return it; return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: (*float*) Total electronic energy in Hartrees. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities. - Check that energy is actually being returned. - Check if some PSI variables ought to be set. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Self-consistent field method(s) |; +-------------------------+---------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:29779,ENERGY,ENERGY,29779,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ing upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies). # The last item in the list is the reference energy, return it; return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Self-consistent field method(s) |; +-------------------------+---------------------------------------------------------------------------------------+; | cc2 | 2nd-order approximate CCSD |; +-------------------------+--------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:32274,ENERGY,ENERGY,32274,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ing(10); ystr = self.y.variable_to_string(10); zstr = self.z.variable_to_string(10); return ""\t%16s %16s %16s\n"" % (xstr, ystr, zstr); # should go to outfile. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated.""""""; self.computed = False; self.x.invalidate(); self.y.invalidate(); self.z.invalidate(). [docs] def clone(self):; """"""Returns new, independent CartesianEntry object""""""; return copy.deepcopy(self). [docs] def everything(self):; CoordEntry.everything(self); print '\nCartesianEntry\n Type = %s\n x = %s\n y = %s\n z = %s\n\n' % (self.type(), self.x.variable_to_string(8), self.y.variable_to_string(8), self.z.variable_to_string(8)). [docs]class ZMatrixEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as any position of ZMatrix. """"""; def __init__(self, entry_number, Z, charge, mass, symbol, label, \; rto=None, rval=0, ato=None, aval=0, dto=None, dval=0):; CoordEntry.__init__(self, entry_number, Z, charge, mass, symbol, label); self.rto = rto; self.rval = rval; self.ato = ato; self.aval = aval; self.dto = dto; self.dval = dval. [docs] def invalidate(self):; """"""Flags the current coordinates as being outdated""""""; self.computed = False; if self.rval != 0:; self.rval.invalidate(); if self.aval != 0:; self.aval.invalidate(); if self.dval != 0:; self.dval.invalidate(). [docs] def print_in_input_format(self):; """"""Prints the updated geometry, in the format provided by the user""""""; text = """"; if self.rto == None and self.ato == None and self.dto == None:; # The first atom; text += ""\t%s\n"" % (self.symbol()); elif self.ato == None and self.dto == None:; # The second atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); text += ""\t%s %5d %s\n"" % (self.symbol(), now_rto, now_rval); elif self.dto == None:; # The third atom; now_rto = self.rto.entry_number() + 1; now_rval = self.rval.variable_to_string(6); now_ato = self.ato.entry_number() + 1; now_aval = self.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html:9998,charge,charge,9998,psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,4,['charge'],['charge']
Energy Efficiency,"ing,; stacklevel=2). if mat.rowdim().n() != 1:; raise ValidationError('Cannot convert Matrix with symmetry.'); arr = []; for row in range(mat.rowdim()[0]):; temp = []; for col in range(mat.coldim()[0]):; temp.append(mat.get(row, col)); arr.append(temp); return arr. [docs]; def expand_psivars(; pvdefs: Dict[str, Dict[str, Union[List[str], Callable]]],; verbose: Optional[int] = None):; """"""From rules on building QCVariables from others, set new variables to; P::e if all the contributors are available. Parameters; ----------; pvdefs; Dictionary with keys with names of QCVariables to be created and values; with dictionary of two keys: 'args', the QCVariables that contribute to; the key and 'func', a function (or lambda) to combine them.; verbose; Control print level. If unspecified (None), value taken from; :term:`PRINT <PRINT (GLOBALS)>`. Status printing when verbose > 2. Examples; --------; >>> pv1 = dict(); >>> pv1['SAPT CCD DISP'] = {'func': lambda x: x[0] * x[1] + x[2] + x[3] + x[4],; 'args': ['SAPT EXCHSCAL', 'SAPT EXCH-DISP20 ENERGY', 'SAPT DISP2(CCD) ENERGY',; 'SAPT DISP22(S)(CCD) ENERGY', 'SAPT EST.DISP22(T)(CCD) ENERGY']}; >>> pv1['SAPT0 ELST ENERGY'] = {'func': sum, 'args': ['SAPT ELST10,R ENERGY']}; >>> expand_psivars(pv1). """"""; if verbose is None:; verbose = core.get_global_option('PRINT'). for pvar, action in pvdefs.items():; if verbose >= 2:; print(""""""building %s %s"""""" % (pvar, '.' * (50 - len(pvar))), end=''). psivars = core.scalar_variables(); data_rich_args = []. for pv in action['args']:; if isinstance(pv, str):; if pv in psivars:; data_rich_args.append(psivars[pv]); else:; if verbose >= 2:; print(""""""EMPTY, missing {}"""""".format(pv)); break; else:; data_rich_args.append(pv); else:; result = action['func'](data_rich_args); core.set_variable(pvar, result); if verbose >= 2:; print(""""""SUCCESS""""""). [docs]; def provenance_stamp(routine: str, module: str = None) -> Dict[str, str]:; """"""Prepare QCSchema Provenance with |PSIfour| credentials. Parameters; --------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:18793,ENERGY,ENERGY,18793,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,9,['ENERGY'],['ENERGY']
Energy Efficiency,"ing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Fitted 2-point parameter. Overrides the default :math:`\alpha = 1.63`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [1]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63`. References; ----------. .. [1] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DT]Z', scf_scheme='scf_xtpl_helgaker_2'). """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_helgaker_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 1.63. beta_division = 1 / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); beta_mult = math.exp(-1 * alpha * zHI). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 2-point exponential SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.uppe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:4555,energy,energy,4555,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,8,['energy'],['energy']
Energy Efficiency,"ing; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to DF_BASIS_SAPT. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT and terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE, SMALL, LARGE; Default: FALSE. D_CONVERGENCE¶. Convergence criterion for residual of the CPHF coefficients in the SAPT term. Type: conv double; Default: 1e-8. E_CONVERGENCE¶. Convergence criterion for energy (change) in the SAPT term during solution of the CPHF equations. Type: conv double; Default: 1e-10. MAXITER¶. Maxmum number of CPHF iterations. Type: integer; Default: 50. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced SAPT0 Keywords¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/sapt-1.html:5708,energy,energy,5708,psi4manual/4.0b3/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"ing; the input file name and output file name on the the command line.; The syntax is:; 1>>> psi4 input-name output-name. If you give an input name but no output name, then the output name will; be the same as the input name (replacing any “.in” or “.dat” extension by “.out”). Sample Input Files¶; Below, we will provide a few simple input files as examples. A large; number of sample input files, covering everything from single-point energies; using density-functional theory to response properties from coupled-cluster; theory, can be found in the psi4/samples directory. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 600 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). Note; The memory and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; 1>>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; 1; 2; 3Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about \(1.0 \times 10^{-6}\), so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/tutorial-1.html:2189,energy,energy,2189,psi4manual/1.2.1/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency,"ing; the input file name and output file name on the the command line.; The syntax is:; 1>>> psi4 input-name output-name. If you give an input name but no output name, then the output name will; be the same as the input name (replacing any ”.in” or ”.dat” extension by ”.out”). Sample Input Files¶; Below, we will provide a few simple input files as examples. A large; number of sample input files, covering everything from single-point energies; using density-functional theory to response properties from coupled-cluster; theory, can be found in the psi4/samples directory. Running a Basic Hartree–Fock Calculation¶; In our first example, we will consider a Hartree–Fock SCF computation; for the water molecule using a cc-pVDZ basis set. We will specify the; geometry of our water molecule using a standard Z-matrix.; # Any line starting with the # character is a comment line; #! Sample HF/cc-pVDZ H2O computation. memory 600 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; energy('scf'). Note; The memory and basis set specifications are placed before the; energy function is called. Any user options need to; be set before the procedure they are meant to affect. For your convenience, the above example can be found in; tu1-h2o-energy.; You can run it if you wish.; Once PSI4 is in your path (see the; User Configuration; section of the installation instructions), you can run this computation by typing; 1>>> psi4 input.dat output.dat. If everything goes well, the computation should complete and should report; a final restricted Hartree–Fock energy in a section like this:; 1; 2; 3Energy converged. @RHF Final Energy: -76.02663273410671. By default, the energy should be converged to about \(1.0 \times 10^{-6}\), so agreement; is only expected for about the first 6 digits after the decimal. If the; computation does not complete, there is probably a problem with the; compilation or installation of the program (see the installation; instructions in Sec. Compiling",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:2187,energy,energy,2187,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,2,['energy'],['energy']
Energy Efficiency,"ingle point integral and HF-SCF calculation in order to determine the number and ordering of the irreducible representations. The occupation keyword may be omitted, in which case an initial orbital occupancy is determined by diagonalization of the core Hamiltonian. In many cases, HF-SCF calculations run with the core Hamiltonian guess will usually converge to the lowest energy HF-SCF solution, but this should not be blindly assumed. (Default: The occupation is given by the core Hamiltonian initial guess). Psi4 Interface: The arrays above are specified in PSI as (whitespace-tolerant) [3,1,1,0] and [[3,1,1,0],[3,0,1,0]]. Type: array; Default: No Default. CFOUR_OPEN-SHELL¶. Specifies which kind of open-shell CC treatment is employed. The default is a spin-orbital CC treatment (SPIN-ORBITAL =1) which is the only possible choice for UHF-CC schemes anyways. For ROHF-CC treatments, the possible options are beside the standard spin-orbital scheme a spin-restricted CC approach (SR-CC=3), as well as a corresponding linear approximation (which in the literature usually is referred to as partially-spin-adapted CC scheme) (PSA-CC=1). SR-CC and PSA-CC are within the CCSD approximation restricted to excitations defined by the first-order interacting space arguments. With the keywords PSA-CC_FULL (=2) or SR-CC_FULL (=6) inclusion of the so called “pseudo-triples” beyond the first-order interacting space is also possible. The two-determinant CC method for open-shell singlet states can be activated by TD-CC (=8). Type: string; Possible Values: SPIN-ORBITAL, SR-CC, PSA-CC_FULL, SR-CC_FULL, TD-CC; Default: SPIN-ORBITAL. CFOUR_OPT_MAXCYC¶. Identical to CFOUR_GEO_MAXCYC. Type: integer; Default: 50. CFOUR_ORBITALS¶. Specifies the type of molecular orbitals used in post-HF calculations. STANDARD (=0) requests usage of the orbitals (from a corresponding HF-SCF calculation) without any modification. These are in the case of RHF/UHF the usual canonical HF orbitals and in the case of ROHF calcu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:42676,adapt,adapted,42676,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['adapt'],['adapted']
Energy Efficiency,"ingles and doubles (CCSD) :ref:`[manual] <sec:cc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------+. .. include:: autodoc_dft_opt.rst. .. warning:: Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analyt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:49075,energy,energy,49075,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"ingles doubles (QCISD) [manual]. cc2; approximate coupled cluster singles and doubles (CC2) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. bccd; Brueckner coupled cluster doubles (BCCD) [manual]. qcisd(t); QCISD with perturbative triples [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. fno-df-ccsd(t); CCSD(T) with density fitting and frozen natural orbitals [manual]. bccd(t); BCCD with perturbative triples [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual]. ccenergy; expert full control over ccenergy module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual]. cisdt; CI singles, doubles, and triples (CISDT) [manual]. cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ) [manual]. cin; nth-order CI [manual]. fci; full configuration interaction (FCI) [manual]. detci; expert full control over detci module. gaussian-2 (g2); gaussian-2 composite method [manual]. sapt0; 0th-order symmetry adapted perturbation theory (SAPT) [manual]. sapt2; 2nd-order SAPT, traditional definition [manual]. sapt2+; SAPT including all 2nd-order terms [manual]. sapt2+(3); SAPT including perturbative triples [manual]. sapt2+3; SAPT including all 3rd-order terms [manual]. sapt2+(ccd); SAPT2+ with CC-based dispersion [manual]. sapt2+(3)(ccd); SAPT2+(3) with CC-based dispersion [manual]. sapt2+3(ccd); SAPT2+3 with CC-based dispersion [manual]. sapt0-ct; 0th-order SAPT plus charge transfer (CT) calculation [manual]. sapt2-ct; SAPT2 plus CT [manual]. sapt2+-ct; SAPT2+ plus CT [manual]. sapt2+(3)-ct; SAPT2+(3) plus CT [manual]. sapt2+3-ct; SAPT2+3 plus CT [manual]. sapt2+(ccd)-ct; SAPT2+(CCD) plus CT [manual]. sapt2+(3)(ccd)-ct; SAPT2+(3)(CCD) plus CT [manual]. sapt2+3(ccd)-ct; SAPT2+3(CCD) plus CT [manual]. adc; 2nd-order algebraic diagrammatic construction (ADC) [manual]. eom-cc2; EOM-CC2 [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. eom-cc3; EOM-CC3 [manual]. name; calls method (aliases to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/energy-1.html:2780,adapt,adapted,2780,psi4manual/4.0b4/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/energy-1.html,4,['adapt'],['adapted']
Energy Efficiency,"ingles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Psithon Functions: Invoking a Calculation; Single-Point Energy — energy(). © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/energy.html:38691,energy,energy,38691,psi4manual/master/energy.html,https://psicode.org,https://psicode.org/psi4manual/master/energy.html,6,['energy'],['energy']
Energy Efficiency,"ings read identically for psi4/cfour. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/kw-2; testing best practices options, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_cfour-1.html:1316,energy,energy,1316,psi4manual/1.0.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_cfour-1.html,2,['energy'],['energy']
Energy Efficiency,"inimal deviations in absolute energies (1E-06 au) and; relative energies (below 0.002 kcal/mol for S22), depending also on the applied grid, compared; to older versions. We advise not to mix absolute energies absolute energies from before and after this change for the; calculation of relative energies. Note; After May 2017 (anytime after the v1.1 release), PSI4; switched from hand- (+Matlab) coded functionals to Libxc. Thus; many DFT results will be slightly different. Functionals more than; slightly different are B97-D, wB97X (note, not wB97X-D), SOGGA,; DFDL, and M05. Theory¶; Generalized Kohn–Sham Density Functional Theory (KS-DFT) [Kohn:1965:A1133] [Parr:1989] is one of the primary; workhorses of modern computational chemistry due to its phenomenal accuracy/cost; ratio.; Pure Kohn–Sham DFT is built on the Hohenberg–Kohn theorems [Hohenberg:1964:136] which states: A) the energy is a universal; functional of the one-particle electronic density and B) there exists a set of; noninteracting quasiparticles with the same density as the true set of; electrons, with the quasiparticle states determined as eigenvectors of an; effective one-body potential encapsulating the true \(N\)-body quantum; effects. The former idea allows the electronic density to be dealt with instead; of the much more complicated wavefunction, while the latter allows for the; treatment of the troublesome kinetic energy term via the implicit one-body; Kohn–Sham orbitals. KS-DFT borrows much of the machinery of Hartree–Fock, as is; evident by looking at the energy expression,. \[\begin{split}E_{\mathrm{KS}}; &= \sum_{i} \langle i | \hat h | i \rangle; + \frac 1 2 \sum_{i,j} [ii|jj] + E_{\mathrm{xc}} [\rho_\alpha, \rho_\beta] \\; &= D_{\mu\nu}^{\mathrm{T}}\left(T_{\mu\nu} +; V_{\mu\nu}\right) + \frac{1}{2} D_{\mu\nu}^{\mathrm{T}}; D_{\lambda\sigma}^{\mathrm{T}} (\mu\nu|\lambda\sigma) + E_{\mathrm{xc}} [\rho_\alpha, \rho_\beta]\end{split}\]; Here, \(T\) is the noninteracting quasiparticle kinetic energy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:1587,energy,energy,1587,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,9,['energy'],['energy']
Energy Efficiency,"initeDifferenceComputer]. [docs]def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, many-body treatments are inactive. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the molecule. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:9132,energy,energy,9132,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,2,['energy'],['energy']
Energy Efficiency,"initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. dfremp-1; density fitted REMP/cc-pVDZ energies for the CO2 molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. cdremp-2; Cholesky decomposed REMP/cc-pVDZ energies for the CH3 radical. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. dlpnomp2-3; comparison of DF-MP2 and DLPNO-MP2 with a cartesian basis set. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. This test s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:9910,energy,energy,9910,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"inning of a finite difference computation. set_psi_file_prefix(arg0). set_scalar_variable(arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val). timer_off(arg0); Stop timer of label argument. timer_on(arg0); Start timer with argument as label. triplet(A, B, C, transA, transB, transC); Returns the multiplication of three matrics A, B, and C, with options to transpose each beforehand. tstart(); docstring. tstop(); docstring. variable(key). variables(). version(); Returns the version ID of this copy of Psi. Classes¶. AOShellCombinationsIterator. AngularMomentumInt; Computes angular momentum integrals. BSVec. BasisExtents; docstring. BasisFunctions; docstring. BasisSet; Contains basis set information. BlockOPoints; docstring. BoysLocalizer; Performs Boys orbital localization. CCWavefunction; docstring. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. DIISManager; docstring. Deriv; Computes gradients of wavefunctions. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron reuplsion integrals. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. ErfComplementERI; Computes ERF complement electron repulsion integr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:301378,adapt,adapted,301378,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['adapt'],['adapted']
Energy Efficiency,"int ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:8698,energy,energy,8698,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,10,['energy'],['energy']
Energy Efficiency,"int group.\n'). # throw an exception for open-shells; if (PsiMod.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""Error: %s requires \""reference rhf\""."" % lowername). # scf; scf_helper(name,**kwargs). # if the scf type is df, then the ao integrals were never generated.; if PsiMod.get_option('SCF','SCF_TYPE') == 'DF' :; mints = PsiMod.MintsHelper(); mints.integrals(). # if this is not cim or FNO-CC, run transqt2. otherwise, libtrans will be used; if PsiMod.get_option('FNOCC','NAT_ORBS') == False and PsiMod.get_option('FNOCC','RUN_MP2') == False:; PsiMod.set_local_option('TRANSQT2', 'WFN', 'CCSD'); PsiMod.transqt2(). # run ccsd; PsiMod.fnocc(). # set current correlation energy and total energy. only need to treat mpn here.; if (lowername == 'fnocc-mp') and (level == 3):; emp3 = PsiMod.get_variable(""MP3 TOTAL ENERGY""); cemp3 = PsiMod.get_variable(""MP3 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp3); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp3); elif ( lowername == 'fno-mp3' ):; emp3 = PsiMod.get_variable(""MP3 TOTAL ENERGY""); cemp3 = PsiMod.get_variable(""MP3 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp3); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp3); elif ( lowername == 'mp4(sdq)'):; emp4sdq = PsiMod.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = PsiMod.get_variable(""MP4(SDQ) CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4sdq); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4(sdq)'):; emp4sdq = PsiMod.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = PsiMod.get_variable(""MP4(SDQ) CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4sdq); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4'):; emp4 = PsiMod.get_variable(""MP4 TOTAL ENERGY""); cemp4 = PsiMod.get_variable(""MP4 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:74609,ENERGY,ENERGY,74609,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"int(f""CLS-prepared results >>> {k2} {v2.size}""); else:; print(f""CLS-prepared results >>> {k2} {v2}""); else:; print(f""CLS-prepared results >>> {k} {v}""). return nbody_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as ManyBody-flavored QCSchema."""""". info = ""\n"" + p4util.banner(f"" ManyBody Results "", strNotOutfile=True) + ""\n""; core.print_out(info); logger.info(info). results = self.prepare_results(client=client); ret_energy = results.pop(""ret_energy""); ret_ptype = results.pop(""ret_ptype""); ret_gradient = results.pop(""ret_gradient"", None). # load QCVariables; qcvars = {; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; 'NBODY NUMBER': len(self.task_list),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": ret_energy,; }. for k, val in results.items():; qcvars[k] = val. qcvars['CURRENT ENERGY'] = ret_energy; if self.driver == 'gradient':; qcvars['CURRENT GRADIENT'] = ret_ptype; properties[""return_gradient""] = ret_ptype; elif self.driver == 'hessian':; qcvars['CURRENT GRADIENT'] = ret_gradient; qcvars['CURRENT HESSIAN'] = ret_ptype; properties[""return_gradient""] = ret_gradient; properties[""return_hessian""] = ret_ptype. component_results = self.dict()['task_list']; for k, val in component_results.items():; val['molecule'] = val['molecule'].to_schema(dtype=2). nbody_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties': properties,; 'provenance': p4util.provenance_stamp(__name__),; 'extras': {; 'qcvars': qcvars,; 'component_results': component_results,; },; 'return_result': ret_ptype,; 'success': True,; }). logger.debug('\nNBODY QCSchema:\n' + pp.pformat(nbody_model.dict())). return nbody_model. [docs]; def get_psi_results(; self,; client: Optional[""qcportal.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:90258,ENERGY,ENERGY,90258,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"int(optstash). >>> optstash.restore(). restore()[source]¶. gaussian_n¶. run_gaussian_2(name, **kwargs)[source]¶. physconst¶; # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/include/physconst.h; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) conversion factor ; psi_cal2J = 4.184 # Calorie to joule conversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 #",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:20542,joule,joule,20542,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,2,['joule'],['joule']
Energy Efficiency,"int) – Zeta number of the medium basis set in 3-point extrapolation.; Must be zLO + 1.; valueMD (Union[float, Matrix, Vector]) – Energy, gradient, or Hessian value at the medium basis set in 3-point; extrapolation.; zHI (int) – Zeta number of the larger basis set in 3-point extrapolation.; Must be zLO + 2.; valueHI (Union[float, Matrix, Vector]) – Energy, gradient, or Hessian value at the larger basis set in 3-point; extrapolation.; verbose (int) – Controls volume of printing.; alpha (Optional[float]) – Not used. Returns; Eponymous function applied to input zetas and values; type from valueLO. Return type; float or ndarray. Notes; The extrapolation is calculated according to 4:; \(E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 3.0\); References. 4; Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; >>> # [1] Hartree-Fock extrapolation; >>> psi4.energy('cbs', scf_wfn='hf', scf_basis='cc-pV[DTQ]Z', scf_scheme='scf_xtpl_helgaker_3'). psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2(functionname, zLO, valueLO, zHI, valueHI, verbose=1, alpha=None)[source]¶; Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by cbs(). Parameters. functionname (str) – Name of the CBS component (e.g., ‘MP2’) used in summary printing.; zLO (int) – Zeta number of the smaller basis set in 2-point extrapolation.; valueLO (Union[float, Matrix, Vector]) – Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI (int) – Zeta number of the larger basis set in 2-point extrapolation.; Must be zLO + 1.; valueHI (Union[float, Matrix, Vector]) – Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose (int) – Controls volume of printing.; alpha (Optional[float]) – Overrides the default \(\alpha = 3.0\). Returns; Eponymous function applied to input zetas and values; type from valueLO. Return type;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/cbs.html:27489,energy,energy,27489,psi4manual/1.6.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/cbs.html,1,['energy'],['energy']
Energy Efficiency,"int, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; jobrec = qcng.compute(resinp, 'gcp', raise_error=True); jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['extras']['qcvars'].items():; if not isinstance(qcv, (list, np.ndarray)):; core.set_variable(variable_name, float(qcv)). if derint == -1:; return (float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']),; jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']. @staticmethod; def from_schema(molschema, return_dict=False, verbose=1):; """"""Construct Molecule from non-Psi4 schema. Light wrapper around :py:func:`~qcdb.Molecule.from_arrays`. Parameters; ----------; molschema : dict; Dictionary form of Molecule following known schema.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate.; verbose : int, optional; Amount of printing. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """""". molrec = qcel.molparse.from_schema(molschema, verbose=verbose). if return_dict:; return Molecule.from_dict(molrec), molrec; else:; return Molecule.from_dict(molrec). [docs] def to_schema(self, dtype, units='Bohr'):; """"""Serializes instance into dictionary according to schema `dty",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html:44793,ENERGY,ENERGY,44793,psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,6,['ENERGY'],['ENERGY']
Energy Efficiency,"int, with n=2-25. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. frac-traverse; Scan fractional occupation of electrons. ao-casscf-sp; CASSCF/6-31G** energy point. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure. dft-bench-ionization; functionals ionization energies vs. other programs. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. cbs-xtpl-energy; Extrapolated water energies. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. pywrap-align; apply linear fragmentation algorithm to a water cluster. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. cc13b; Tests RHF CCSD(T)gradients. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:14089,energy,energy,14089,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"int. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. rasci-h2o; RASCI/6-31G** H2O Energy Point. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. numpy-array-interface; Numpy interface testing. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. pywrap-align; apply linear fragmentation algorithm to a water cluster. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the differen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:20045,energy,energy,20045,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"int. nbody-nocp-gradient; Computation of NoCP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mints3; Test individual integral objects for correctness. phi-ao; Test computing values of basis functions (puream and non-puream) at points. dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. scf-upcast-custom-basis; test scf castup with custom basis sets. matrix1; An example of using BLAS and LAPACK calls directly",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:37970,energy,energy,37970,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"int_e_kcal = (; energy_body_dict[n] - energy_body_dict[1]) * constants.hartree2kcalmol if not embedding else np.nan; if tot_e:; core.print_out("""""" %4s %20.12f %20.12f %20.12f\n"""""" % (n, energy_body_dict[n], int_e_kcal,; delta_e_kcal)); else:; core.print_out("""""" %4s %20s %20.12f %20.12f\n"""""" % (n, ""N/A"", int_e_kcal,; delta_e_kcal)); previous_e = energy_body_dict[n]; core.print_out(""\n""). [docs]def nbody_gufunc(func: Union[str, Callable], method_string: str, **kwargs):; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type func: Callable; :param func: ``energy`` || etc. Python function that accepts method_string and a molecule. Returns a; energy, gradient, or Hessian as requested. :type method_string: str; :param method_string: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, lowercase and usually unlabeled. Indicates the computational; method to be passed to func. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:4343,energy,energy,4343,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,4,['energy'],['energy']
Energy Efficiency,"int_out("" Found user provided orbital data. Setting orbital guess to READ""); fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); file_num = item.split('.')[-2] if ""180"" in item else ""180""; targetfile = os.path.join(psi_scratch, fname + ""."" + file_num + "".npy""); if not item.endswith("".npy""):; item = item + "".npy""; else:; filenum = name_split[-1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.' + str(filenum); core.print_out(f"" \n Copying restart file <{item}> to <{targetfile}> for internal processing\n""); shutil.copy(item, targetfile). logger.info(f""Compute energy(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:33530,energy,energy,33530,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,10,['energy'],['energy']
Energy Efficiency,"int_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(f""Invalid type {type_val} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := core.get_global_option(""SCF_TYPE"")) not in [""CD"", ""DISK_DF""]:; raise ValidationError(f""Invalid {scf_type=} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:168282,energy,energy,168282,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['energy'],['energy']
Energy Efficiency,"int_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, whi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:61423,ENERGY,ENERGY,61423,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"int_out('\n'); e_monomerA_mp2 = psi4.dfmp2(). activate(monomerB); if (ri == 'DF'):; psi4.IO.change_file_namespace(97, 'monomerA', 'monomerB'); psi4.IO.set_default_namespace('monomerB'); psi4.set_local_option('SCF', 'SAPT', '2-monomer_B'); psi4.print_out('\n'); p4util.banner('Monomer B HF'); psi4.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); psi4.print_out('\n'); p4util.banner('Monomer B DFMP2'); psi4.print_out('\n'); e_monomerB_mp2 = psi4.dfmp2(); psi4.set_global_option('DF_INTS_IO', df_ints_io). psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). activate(molecule); psi4.IO.set_default_namespace('dimer'); psi4.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); psi4.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); psi4.set_local_option('SAPT', 'SAPT_LEVEL', 'MP2C'); psi4.print_out('\n'); p4util.banner('MP2C'); psi4.print_out('\n'). psi4.set_variable('MP2C DIMER MP2 ENERGY', e_dimer_mp2); psi4.set_variable('MP2C MONOMER A MP2 ENERGY', e_monomerA_mp2); psi4.set_variable('MP2C MONOMER B MP2 ENERGY', e_monomerB_mp2). e_sapt = psi4.sapt(). optstash.restore(); return e_sapt. [docs]def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = psi4.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.fix_com(True) # This should always have been set, very dangerous bug here; molecule.update_geometry(); if user_pg != 'c1':; psi4.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:48046,ENERGY,ENERGY,48046,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"int_out('\n'); psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = psi4.sapt(); CTd = psi4.get_variable('SAPT CT ENERGY'). psi4.print_out('\n'); p4util.banner('Monomer Basis SAPT'); psi4.print_out('\n'); psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = psi4.sapt(); CTm = psi4.get_variable('SAPT CT ENERGY'); CT = CTd - CTm. psi4.print_out('\n\n'); psi4.print_out(' SAPT Charge Transfer Analysis\n'); psi4.print_out(' -----------------------------------------------------------------------------\n'); line1 = ' SAPT Induction (Dimer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTd * 1000.0, CTd * p4const.psi_hartree2kcalmol); line2 = ' SAPT Induction (Monomer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTm * 1000.0, CTm * p4const.psi_hartree2kcalmol); line3 = ' SAPT Charge Transfer %10.4lf mH %10.4lf kcal mol^-1\n\n' % (CT * 1000.0, CT * p4const.psi_hartree2kcalmol); psi4.print_out(line1); psi4.print_out(line2); psi4.print_out(line3); psi4.set_variable('SAPT CT ENERGY', CT). molecule.reset_point_group(user_pg); molecule.update_geometry(). optstash.restore(); return e_sapt. [docs]def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; # TODO: Check to see if we really need to run the SCF code.; scf_helper(name, **kwargs); vscf = psi4.get_variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to psi4.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:58874,Charge,Charge,58874,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Charge'],['Charge']
Energy Efficiency,"internal coordinates such; as torsions become poorly defined when they contain near-linear bends.; An internal error AlgError may be raised in such cases. Optking will avoid such; coordinates when choosing an initial coordinate system; however, they may arise in the course; of an optimization. In such cases, try restarting from the most recent geometry.; Alternatively, setting OPT_COORDINATES to cartesian will avoid any internal; coordinate difficulties altogether. These coordinate changes can be automatically; performed by turning DYNAMIC_LEVEL to 1. Warning; In some cases, such as the coordinate issues described above, optking will reset to maintain; a consistent history. If an error occurs in Psi4 due to GEOM_MAXITER being exceeded but; the final step report indicates that optking has not taken GEOM_MAXITER steps, such a; reset has occured. Inspection will show that the step counter was reset to 1 somewhere in the; optimization. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4¶. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4]. \(4.5 \times 10^{-3}\); \(3.0 \times 10^{-3}\); \(5.4 \times 10^{-3}\); \(3.6 \times 10^{-3}\). GAU_LOOSE [6]. \(2.5 \times 10^{-3}\); \(1.7 \times 10^{-3}\); \(1.0 \times 10^{-2}\); \(6.7 \ti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optking.html:18222,monitor,monitors,18222,psi4manual/1.7.x/optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optking.html,4,['monitor'],['monitors']
Energy Efficiency,"internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶; Removes scalar or array QCVariable key from cls if present. Return type; None. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. diis(self: psi4.core.HF, arg0: float) → bool¶; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbital energies should be returned?. Returns; A Pitzer-ordered vector of the orbitals. Return type; Vector. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:20336,energy,energy,20336,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,10,['energy'],['energy']
Energy Efficiency,"into the nature of intermolecular interactions, and Psi4 makes these computations easier than ever.; For a SAPT computation, the input needs to provide information on two distinct molecules. This is very easy, we just give a Z-matrix or set of Cartesian coordinates for each molecule, and separate the two with two dashes, like this:. [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input, where we specify the computation options:. [8]:. psi4.set_options({'scf_type': 'df',; 'freeze_core': 'true'}). psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). [8]:. -0.0022355825227244703. All of the options we have currently set using psi4.set_options() API are “global” options (meaning that they are visible to all parts of the program). Most common Psi4 options can be set like this. If an option needs to be visible only to one part of the program (e.g., we only want to increase the energy convergence in the SCF code, but not the rest of the code), it can be set by with the; psi4.set_module_options() API function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like psi4.set_options() API, psi4.set_module_options() API, psi4.energy() API, psi4.optimize(); API, psi4.frequency() API, etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT computations (i.e., SAPT0), a good error cancellation is found (Hohenstein:2012:WIREs) with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but without diffuse functio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:12595,energy,energy,12595,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,9,['energy'],['energy']
Energy Efficiency,inty=0.000 000 0010 e23. atomic_mass_unit_inverse_meter_relationship; 7.5130066166E+14; atomic mass unit-inverse meter relationship [m^{-1}] uncertainty=0.000 000 0034 e14. atomic_mass_unit_joule_relationship; 1.492418062E-10; atomic mass unit-joule relationship [J] uncertainty=0.000 000 018 e-10. atomic_mass_unit_kelvin_relationship; 1.08095438E+13; atomic mass unit-kelvin relationship [K] uncertainty=0.000 000 62 e13. atomic_mass_unit_kilogram_relationship; 1.660539040E-27; atomic mass unit-kilogram relationship [kg] uncertainty=0.000 000 020 e-27. atomic_unit_of_1st_hyperpolarizability; 3.206361329E-53; atomic unit of 1st hyperpolarizability [C^3 m^3 J^{-2}] uncertainty=0.000 000 020 e-53. atomic_unit_of_2nd_hyperpolarizability; 6.235380085E-65; atomic unit of 2nd hyperpolarizability [C^4 m^4 J^{-3}] uncertainty=0.000 000 077 e-65. atomic_unit_of_action; 1.054571800E-34; atomic unit of action [J s] uncertainty=0.000 000 013 e-34. atomic_unit_of_charge; 1.6021766208E-19; atomic unit of charge [C] uncertainty=0.000 000 0098 e-19. atomic_unit_of_charge_density; 1.0812023770E+12; atomic unit of charge density [C m^{-3}] uncertainty=0.000 000 0067 e12. atomic_unit_of_current; 0.006623618183; atomic unit of current [A] uncertainty=0.000 000 041 e-3. atomic_unit_of_electric_dipole_mom; 8.478353552E-30; atomic unit of electric dipole mom. [C m] uncertainty=0.000 000 052 e-30. atomic_unit_of_electric_field; 5.142206707E+11; atomic unit of electric field [V m^{-1}] uncertainty=0.000 000 032 e11. atomic_unit_of_electric_field_gradient; 9.717362356E+21; atomic unit of electric field gradient [V m^{-2}] uncertainty=0.000 000 060 e21. atomic_unit_of_electric_polarizability; 1.6487772731E-41; atomic unit of electric polarizability [C^2 m^2 J^{-1}] uncertainty=0.000 000 0011 e-41. atomic_unit_of_electric_potential; 27.21138602; atomic unit of electric potential [V] uncertainty=0.000 000 17. atomic_unit_of_electric_quadrupole_mom; 4.486551484E-40; atomic unit of electric quadrupo,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:2922,charge,charge,2922,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['charge'],['charge']
Energy Efficiency,inty=0.000 000 90 e-10. atomic_mass_constant; 1.660539040E-27; atomic mass constant [kg] uncertainty=0.000 000 020 e-27. atomic_mass_constant_energy_equivalent; 1.492418062E-10; atomic mass constant energy equivalent [J] uncertainty=0.000 000 018 e-10. atomic_mass_constant_energy_equivalent_in_MeV; 931.4940954; atomic mass constant energy equivalent in MeV [MeV] uncertainty=0.000 0057. atomic_mass_unit_electron_volt_relationship; 931494095.4; atomic mass unit-electron volt relationship [eV] uncertainty=0.000 0057 e6. atomic_mass_unit_hartree_relationship; 34231776.902; atomic mass unit-hartree relationship [E_h] uncertainty=0.000 000 0016 e7. atomic_mass_unit_hertz_relationship; 2.2523427206E+23; atomic mass unit-hertz relationship [Hz] uncertainty=0.000 000 0010 e23. atomic_mass_unit_inverse_meter_relationship; 7.5130066166E+14; atomic mass unit-inverse meter relationship [m^{-1}] uncertainty=0.000 000 0034 e14. atomic_mass_unit_joule_relationship; 1.492418062E-10; atomic mass unit-joule relationship [J] uncertainty=0.000 000 018 e-10. atomic_mass_unit_kelvin_relationship; 1.08095438E+13; atomic mass unit-kelvin relationship [K] uncertainty=0.000 000 62 e13. atomic_mass_unit_kilogram_relationship; 1.660539040E-27; atomic mass unit-kilogram relationship [kg] uncertainty=0.000 000 020 e-27. atomic_unit_of_1st_hyperpolarizability; 3.206361329E-53; atomic unit of 1st hyperpolarizability [C^3 m^3 J^{-2}] uncertainty=0.000 000 020 e-53. atomic_unit_of_2nd_hyperpolarizability; 6.235380085E-65; atomic unit of 2nd hyperpolarizability [C^4 m^4 J^{-3}] uncertainty=0.000 000 077 e-65. atomic_unit_of_action; 1.054571800E-34; atomic unit of action [J s] uncertainty=0.000 000 013 e-34. atomic_unit_of_charge; 1.6021766208E-19; atomic unit of charge [C] uncertainty=0.000 000 0098 e-19. atomic_unit_of_charge_density; 1.0812023770E+12; atomic unit of charge density [C m^{-3}] uncertainty=0.000 000 0067 e12. atomic_unit_of_current; 0.006623618183; atomic unit of current [A] uncertainty,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:2163,joule,joule,2163,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['joule'],['joule']
Energy Efficiency,"io = psi4.get_global_option(""DF_INTS_IO""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = psi4.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf'); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. molecule.set_molecular_charge(chargem); molecule.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if hf_guess:; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf', molecule=molecule, **kwargs); psi4.set_global_option(""REFERENCE"",""UKS""); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True); psi4.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:. psi4.set_global_option(""FRAC_OCC"", [LUMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[int(LUMO) - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-int(LUMO) - 1]). occs.append(occ); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if not continuous_guess:; psi4.set_global_option(""GUESS"", old_guess); if hf_guess:; psi4.set_global_option(""FRAC_START"", 0); psi4.set_global_option(""REFERENCE"", ""UHF""); energy('scf', molecule=molecule, **kwargs); psi4.set_global_option(""REFERENCE"", ""UKS""); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/frac.html:4168,energy,energy,4168,psi4manual/1.0.0/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html,1,['energy'],['energy']
Energy Efficiency,io; 864.058257; electron to shielded helion mag. mom. ratio [] uncertainty=0.000 010. electron_to_shielded_proton_mag_mom_ratio; -658.2275971; electron to shielded proton mag. mom. ratio [] uncertainty=0.000 0072. electron_triton_mass_ratio; 0.0001819200062203; electron-triton mass ratio [] uncertainty=0.000 000 000 084 e-4. electron_volt; 1.6021766208E-19; electron volt [J] uncertainty=0.000 000 0098 e-19. electron_volt_atomic_mass_unit_relationship; 1.0735441105E-9; electron volt-atomic mass unit relationship [u] uncertainty=0.000 000 0066 e-9. electron_volt_hartree_relationship; 0.03674932248; electron volt-hartree relationship [E_h] uncertainty=0.000 000 023 e-2. electron_volt_hertz_relationship; 2.417989262E+14; electron volt-hertz relationship [Hz] uncertainty=0.000 000 015 e14. electron_volt_inverse_meter_relationship; 806554.4005; electron volt-inverse meter relationship [m^{-1}] uncertainty=0.000 000 050 e5. electron_volt_joule_relationship; 1.6021766208E-19; electron volt-joule relationship [J] uncertainty=0.000 000 0098 e-19. electron_volt_kelvin_relationship; 11604.5221; electron volt-kelvin relationship [K] uncertainty=0.000 000 67 e4. electron_volt_kilogram_relationship; 1.782661907E-36; electron volt-kilogram relationship [kg] uncertainty=0.000 000 011 e-36. elementary_charge; 1.6021766208E-19; elementary charge [C] uncertainty=0.000 000 0098 e-19. elementary_charge_over_h; 2.417989262E+14; elementary charge over h [A J^{-1}] uncertainty=0.000 000 015 e14. Faraday_constant; 96485.33289; Faraday constant [C mol^{-1}] uncertainty=0.000 59. Faraday_constant_for_conventional_electric_current; 96485.3251; Faraday constant for conventional electric current [C_{90} mol^{-1}] uncertainty=0.0012. Fermi_coupling_constant; 0.000011663787; Fermi coupling constant [GeV^{-2}] uncertainty=0.000 0006 e-5. fine_structure_constant; 0.0072973525664; fine-structure constant [] uncertainty=0.000 000 0017 e-3. first_radiation_constant; 3.741771790E-16; first radiation const,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:12523,joule,joule,12523,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['joule'],['joule']
Energy Efficiency,"ion algorithm to a water cluster. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. sapt0-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. sad-scf-type; Test SAD SCF guesses on noble gas atom. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. cubeprop-frontier; ROHF frontier orbitals of CH2(s) and CH2(t). cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:13749,energy,energy,13749,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ion as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; PSI4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. PSI4 provides a very simple mechanism; for doing so; simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf fir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:15781,energy,energy,15781,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['energy'],['energy']
Energy Efficiency,"ion as the state. In this case, the; state is lower in energy, and is not problematic. The distorted; geometries for the state are excited states that are subject to; variational collapse. One way to obtain reliable energies for these states is; to use a multi-state method; in this case it’s easier to run the entire; computation in the lowest symmetry needed during the finite difference; procedure. Non-Covalently Bonded Molecule Fragments¶; Psi4 has an extensive range of tools for treating non-covalent; intermolecular forces, including counterpoise corrections and symmetry adapted; perturbation theory methods. These require the definition of which fragments; are interacting within the complex. Psi4 provides a very simple mechanism; for doing so: simply define the complex’s geometry using the standard; Cartesian, Z-matrix, or mixture thereof, specifications and then place two; dashes between nonbonded fragements. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf fir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html:13977,energy,energy,13977,psi4manual/1.0.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html,2,['energy'],['energy']
Energy Efficiency,"ion at the RHF/DZP level of theory. opt11; Transition-state optimizations of HOOH to both torsional transition states. dft-dsd; DSD S22 Ammonia test. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. dft2; DFT Functional Test. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. aediis-1; ADIIS test case, from 10.1063/1.3304922. mints-benchmark; run some BLAS benchmarks. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. sapt-exch-ind30-inf; SAPT2+3 with S^inf exch-ind30 Geometries taken from the S66x10 database, the shortest-range point (R = 0.7 R_e). frac-sym; Fractional occupation with symmetry. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. options1; check all variety of options parsing. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. mbis-2; MBIS calculation on OH- (Expanded Arrays). scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. fnocc3; Test FNO-QCISD(T) computation. dft-omeg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:21219,energy,energy,21219,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ion author: Andrew C. Simmonett; Many post-processing tools can read information from Gaussian’s formatted; checkpoint (FCHK) files.; To allow interoperability with such tools, PSI4 includes a utility to; generate FCHK files. Wavefunction information, such as orbitals, densities,; orbital energies and basis set information is currently supported, but geometry; optimization and vibrational frequency information are not supported at this; time. To generate a FCHK file, simply store the wavefunction from the energy; calculation, and use it to create an FCHK writer:; 1; 2; 3energy, wfn = energy('scf', return_wfn=True); fchk_writer = psi4.core.FCHKWriter(wfn); fchk_writer.write('output.fchk'). The file will be written to the name passed to the FCHK writer’s write(); method. Note that for MP2 and CCSD methods, the energy can be computed without; the expensive steps required to compute the density, so energy calls for these; methods will return a wavefunction that has the Hartree–Fock density. If a; density is required for these methods, the user should instead request a; gradient computation, to ensure that the density is updated appropriately:; 1; 2; 3grad, wfn = gradient('mp2', return_wfn=True); fchk_writer = psi4.core.FCHKWriter(wfn); fchk_writer.write('output.fchk'). psi4.fchk(wfn, filename)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:None. Parameters:; filename (string) – destination file name for FCHK file; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file. Examples:. 1; 2; 3>>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/fchk-1.html:1928,energy,energy,1928,psi4manual/1.2.1/fchk-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/fchk-1.html,2,['energy'],['energy']
Energy Efficiency,"ion by truncating the virtual orbital space? Recommended true for all SAPT computations. Type: boolean; Default: true. NAT_ORBS_V4¶. Do use MP2 natural orbital approximations for the \(v^4\) block of two-electron integrals in the evaluation of CCD T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: true. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; 1; 2; 3; 4; 5; 6; 7; 8energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0.; A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; 1; 2; 3; 4; 5 SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:24633,energy,energy,24633,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,42,['energy'],['energy']
Energy Efficiency,"ion can be accessed through the first item below more; conveniently than the equivalent second item. optimize('mp2/cc-pv[tq]z + D:ccsd(t)/cc-pvdz'); optimize(cbs, corl_wfn='mp2', corl_basis='cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='cc-pvdz'). Many examples can be found at cbs-xtpl-energy,; cbs-xtpl-gradient, cbs-xtpl-opt,; cbs-xtpl-freq, cbs-xtpl-func,; cbs-xtpl-wrapper. psi4.cbs(name[, scf_basis, scf_scheme, corl_wfn, corl_basis, corl_scheme, delta_wfn, delta_wfn_lesser, delta_basis, delta_scheme, delta2_wfn, delta2_wfn_lesser, delta2_basis, delta2_scheme, delta3_wfn, delta3_wfn_lesser, delta3_basis, delta3_scheme, delta4_wfn, delta4_wfn_lesser, delta4_basis, delta4_scheme, delta5_wfn, delta5_wfn_lesser, delta5_basis, delta5_scheme])[source]¶; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:complete_basis_set(). Returns:(float) – Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No way to tell function to boost fitting basis size for all calculations.; No way to extrapolate def2 family basis sets; Need to add more extrapolation schemes. As represented in the equation below, a CBS energy method is defined in several; sequential stages (scf, corl, delta, delta2, delta3, delta4, delta5) covering treatment; of the reference total energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction, etc.. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:1769,energy,energy,1769,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"ion code. dfmp2(...); Runs the DF-MP2 code. dfocc(...); Runs the density-fitted orbital optimized CC codes. displace_atom((arg0: psi::Matrix, arg1: int, ...); Displaces one coordinate of single atom. dmrg(...); Runs the DMRG code. efp_init(() -> psi4.core.EFP); Initializes the EFP library and returns an EFP object. efp_set_options(() -> None); Set EFP options from environment options object. fd_1_0((arg0: psi::Molecule, ...); Performs a finite difference gradient computation, from energy points. fd_freq_0((arg0: psi::Molecule, arg1: list, ...); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1((arg0: psi::Molecule, arg1: list, ...); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(...); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0((arg0: psi::Molecule, ...); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1((arg0: psi::Molecule, ...); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(() -> None). fisapt((arg0: psi::Wavefunction) -> float); Runs the functional-group intramolecular symmetry adapted perturbation theory code. flush_outfile(() -> None); Flushes the output file. fnocc(...); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(() -> psi4.core.EFP); Returns the currently active EFP object. get_active_molecule(() -> psi::Molecule); Returns the currently active molecule object. get_array_variable((arg0: str) -> psi::Matrix); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(() -> Dict[str, psi::Matrix]); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomic_point_charges(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:164345,energy,energy,164345,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['energy'],['energy']
Energy Efficiency,"ion computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. Aliases :counterpoise_correct(), counterpoise_correction(). Returns:(float) Counterpoise-corrected interaction energy in kcal/mol. Psi variables:. CP-CORRECTED 2-BODY INTERACTION ENERGY; UNCP-CORRECTED 2-BODY INTERACTION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No values of func besides energy have been tested.; Table print-out needs improving. Add some PSI variables. Parameters:; name (string) – 'scf' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; energy(); however, SAPT is not appropriate. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; energy('name'), while optimize perfoms a geometry optimization; on each system, and cbs performs a compound single-point energy.; If a nested series of python functions is intended; (see Function Intercalls), use keyword cp_func instead of func. check_bsse (boolean) – 'on' || 'off' ; Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). n_body(name[, func, bsse, max_n_body, do_total, external, external_monomers, molecule])[source]¶. Previous topic; Property; Next topic; Optimize; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cp-1.html:1807,energy,energy,1807,psi4manual/4.0b2/cp-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cp-1.html,2,['energy'],['energy']
Energy Efficiency,"ion correction [H] appended to an underlying functional; when a DFT-D method is requested. Quantity \(E_{\text{-D}}\); in Eqs. (4) and (1). DOUBLE-HYBRID CORRECTION ENERGY¶; The scaled MP2 correlation energy correction [H] appended to an; underlying functional when a DH-DFT method is requested.; Quantity \(E_{\text{DH}}\) in Eq. (1). FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full configuration interaction level of theory. HF TOTAL ENERGY¶; The total electronic energy [H] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; \(E_{xc} = 0\)) terms in Eq. (4). Quantity \(E_{\text{HF}}\); in Eq. (4). LCC2 (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CC2 level of theory. LCCSD (+LMP2) TOTAL ENERGY¶; The total electronic energy [H] for the local CCSD level of theory. MP2 TOTAL ENERGY¶. MP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2 level of theory. MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP3 level of theory. MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP4 singles, doubles, quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY is left-hand term in Eq. (2). (2)¶\[E_{\text{MP4}} = E_{\text{MP4(SDQ)}} + E_{\text{MP4(T)}}\]. MPn TOTAL ENERGY¶. MPn ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:13214,energy,energy,13214,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,12,['energy'],['energy']
Energy Efficiency,"ion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:40899,energy,energy,40899,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,8,['energy'],['energy']
Energy Efficiency,"ion density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / constants.bohr2angstroms, y / constants.bohr2angstroms, z / constants.bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qmmm.html:3769,charge,charge,3769,psi4manual/1.3.2/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qmmm.html,7,['charge'],['charge']
Energy Efficiency,"ion energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('df-mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichoimetric weights by which the reagent energies are transfromed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the database. One of these, the mean absolute deviation, is; returned by the wrapper as an ordinary Python variable. (For databases; without a stored reference energy, e.g., BASIC, large and meaningless numbers are; printed for error.) The other two tables tabulate the PSI variables requested; throu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/db-1.html:6354,energy,energy,6354,psi4manual/4.0b4/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/db-1.html,4,['energy'],['energy']
Energy Efficiency,"ion energy component [E_h]; for the MP2 level of theory. MP2 TOTAL GRADIENT¶. The total electronic gradient [E_h/a0] of the MP2 level of theory, ({nat}, 3).¶. MP2 DIPOLE GRADIENT¶; The derivative of the MP2 level of theory dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). MP2 TOTAL HESSIAN¶; The total electronic second derivative [E_h/a0/a0] for the MP2 level of theory, (3 * {nat}, 3 * {nat}). MP2.5 TOTAL ENERGY¶. MP2.5 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2.5 level of theory. MP3 TOTAL ENERGY¶. MP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP3 level of theory. MP4(T) CORRECTION ENERGY¶; The MP4 triples component [E_h]. Quantity is second right-hand term in; Eq. (2). MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP4 singles, doubles, quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY; is left-hand term in Eq. (2). (2)¶\[E_{\text{MP4}} = E_{\text{MP4(SDQ)}} + E_{\text{MP4(T)}}\]. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the labeled Møller–Plesset perturbation theory level.; n is MP perturbation order. MP2 DOUBLES ENERGY¶. MP2.5 DOUBLES ENERGY¶. MP3 DOUBLES ENERGY¶. CEPA(0) DOUBLES ENERGY¶. CEPA(1) DOUBLES ENERGY¶. CEPA(2) DOUBLES ENERGY¶. CEPA(3) DOUBLES ENERGY¶. ACPF DOUBLES ENERGY¶. AQCC DOUBLES ENERGY¶. CISD DOUBLES ENERGY¶. QCISD DOUBLES ENERGY¶. REMP2 DOUBLES ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:36896,energy,energy,36896,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,8,['energy'],['energy']
Energy Efficiency,"ion energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CCSD DIPOLE POLARIZABILITY @ xNM¶; The dipole polarizability [au] calculated at the CCSD level; for a given (x) wavelength, (x) rounded to nearest integer. CCSD SPECIFIC ROTATION (LEN) @ xNM¶; The specific rotation [deg/(dm (g/cm^3))] calculated at the CCSD level in the; length gauge for a given (x) wavelength, (x) rounded to nearest integer. CCSD SPECIFIC ROTATION (VEL) @ xNM¶; The specific rotation [deg/(dm (g/cm^3))] calculated at the CCSD level in the; velocity gauge for a given (x) wavelength, (x) rounded to nearest integer. CCSD SPECIFIC ROTATION (MVG) @ xNM¶; The specific rotation [deg/(dm (g/cm^3))] calculated at the CCSD level in the; modified velocity gauge for a given (x) wavelength, (x) rounded to nearest integer. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html:6447,energy,energy,6447,psi4manual/1.2.1/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency,"ion energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CFOUR ERROR CODE¶; The non-zero return value from a Cfour execution. CI DIPOLE X¶. CI DIPOLE Y¶. CI DI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:5597,energy,energy,5597,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency,"ion energy component [H]; for the approximate coupled-cluster (CCSD(T)-1a, CCSDT(Q)-1a,; up to CCn-1a) level of theory. CCSDT-1b TOTAL ENERGY¶. CCSDT-1b CORRELATION ENERGY¶. CCSDTQ-1b TOTAL ENERGY¶. CCSDTQ-1b CORRELATION ENERGY¶. CCn-1b TOTAL ENERGY¶. CCn-1b CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-1b, CCSDT(Q)-1b,; up to CCn-1b) level of theory. CCSDT-3 TOTAL ENERGY¶. CCSDT-3 CORRELATION ENERGY¶. CCSDTQ-3 TOTAL ENERGY¶. CCSDTQ-3 CORRELATION ENERGY¶. CCn-3 TOTAL ENERGY¶. CCn-3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)-3, CCSDT(Q)-3,; up to CCn-3) level of theory. CCSD(T)_L TOTAL ENERGY¶. CCSD(T)_L CORRELATION ENERGY¶. CCSDT(Q)_L TOTAL ENERGY¶. CCSDT(Q)_L CORRELATION ENERGY¶. CC(n-1)(n)_L TOTAL ENERGY¶. CC(n-1)(n)_L CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the approximate coupled-cluster (CCSD(T)_L, CCSDT(Q)_L,; up to CC(n-1)(n)L level of theory. CEPA(0) DIPOLE X¶. CEPA(0) DIPOLE Y¶. CEPA(0) DIPOLE Z¶; The three components of the dipole [Debye] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) QUADRUPOLE XX¶. CEPA(0) QUADRUPOLE XY¶. CEPA(0) QUADRUPOLE XZ¶. CEPA(0) QUADRUPOLE YY¶. CEPA(0) QUADRUPOLE YZ¶. CEPA(0) QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; coupled electron pair approximation variant 0 level of theory. CEPA(0) TOTAL ENERGY¶. CEPA(0) CORRELATION ENERGY¶. CEPA(1) TOTAL ENERGY¶. CEPA(1) CORRELATION ENERGY¶. CEPA(2) TOTAL ENERGY¶. CEPA(2) CORRELATION ENERGY¶. CEPA(3) TOTAL ENERGY¶. CEPA(3) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested variant of coupled electron pair approximation level of theory. CI DIPOLE X¶. CI DIPOLE Y¶. CI DIPOLE Z¶; The three components of the dipole [Debye] for the requested",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:4800,energy,energy,4800,psi4manual/4.0b3/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html,12,['energy'],['energy']
Energy Efficiency,"ion energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``delta3_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``delta4_wfn`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. :type delta3_basis: :ref:`basis string <apdx:basisElement>`; :param delta3_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:23146,energy,energy,23146,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['energy'],['energy']
Energy Efficiency,"ion energy term in EFP computation?. Type: boolean; Default: true. EFP_DISP_DAMPING¶. Fragment-fragment dispersion damping type. TT is a damping formula by Tang and Toennies. OVERLAP is overlap-based dispersion damping. Type: string; Possible Values: TT, OVERLAP, OFF; Default: OVERLAP. EFP_ELST¶. Do include electrostatics energy term in EFP computation?. Type: boolean; Default: true. EFP_ELST_DAMPING¶. Fragment-fragment electrostatic damping type. SCREEN is a damping formula based on screen group in the EFP potential. OVERLAP is damping that computes charge penetration energy. Type: string; Possible Values: SCREEN, OVERLAP, OFF; Default: SCREEN. EFP_EXCH¶. Do include exchange repulsion energy term in EFP computation?. Type: boolean; Default: true. EFP_IND¶. Do include polarization energy term in EFP computation? (EFP_POL c. v1.1). Type: boolean; Default: true. EFP_IND_DAMPING¶. Fragment-fragment polarization damping type. TT is a damping formula like Tang and Toennies. (EFP_POL_DAMPING c. v1.1). Type: string; Possible Values: TT, OFF; Default: TT. EFP_QM_ELST¶. Do include electrostatics energy term in QM/EFP computation? (QMEFP_ELST c. v1.1). Type: boolean; Default: true. EFP_QM_IND¶. Do include polarization energy term in QM/EFP computation? (QMEFP_POL c. v1.1). Type: boolean; Default: true. PRINT¶. The amount of information printed to the output file. Type: integer; Default: 1. Expert¶. DERTYPE¶. Do EFP gradient?. Type: string; Possible Values: NONE, FIRST; Default: NONE. QMEFP¶. Do turn on QM/EFP terms?. Type: boolean; Default: false. table of contents. EFP; General; EFP_DISP; EFP_DISP_DAMPING; EFP_ELST; EFP_ELST_DAMPING; EFP_EXCH; EFP_IND; EFP_IND_DAMPING; EFP_QM_ELST; EFP_QM_IND; PRINT. Expert; DERTYPE; QMEFP. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; EFP. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__efp.html:1356,energy,energy,1356,psi4manual/1.6.x/autodir_options_c/module__efp.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__efp.html,4,['energy'],['energy']
Energy Efficiency,"ion energy, , with generalized shifts for; the doubles and singles equations, and :. (4); These shifts approximate the effects of triple and quadruple excitations.; The values for and used in several coupled-pair methods are given in Table; CEPA Shifts. Note that these shifts are defined in a spin-free formalism; for closed-shell references only. method. sdci. dci. NA. cepa(0); 0; 0. cepa(1). cepa(3). acpf. aqcc. The pair correlation energy, , is simply a partial sum of the correlation energy. In a spin-free formalism,; the pair energy is given by. (5); Methods whose shifts ( and ) do not explicitly depend on orbitals or ; (CISD, CEPA(0), ACPF, and AQCC); have solutions that render the energy stationary with respect variations in the amplitudes. This convenient property allows; density matrices and 1-electron properties to be evaluated without any additional effort.; The coupled-pair methods currently supported in PSI4 are outlined in Table CEPA Methods. name; calls method; energy; derivatives; 1-electron properties. cepa(0); coupled electron pair approximation, variant 0; Y; N; Y. cepa(1); coupled electron pair approximation, variant 1; Y; N; N. cepa(3); coupled electron pair approximation, variant 3; Y; N; N. acpf; averaged coupled-pair functional; Y; N; Y. aqcc; averaged quadratic coupled-cluster; Y; N; Y. sdci; configuration interaction with single and double excitations; Y; N; Y. dci; configuration interaction with double excitations; Y; N; Y. Basic Coupled Pair Keywords¶. BASIS¶. Primary basis set. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For heavier elements, there can be some ambiguity in how many core orbitals to freeze; in such cases, SMALL picks the most conservative standard setting (freezes fewer orbitals), and LARGE picks the least conservative standard setting (freezes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cepa-1.html:2512,energy,energy,2512,psi4manual/4.0b3/cepa-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cepa-1.html,2,['energy'],['energy']
Energy Efficiency,"ion energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. cisd-sp; 6-31G** H2O Test CISD Energy Point. opt-multi-frozen-dimer-c2h; Frozen-fragment opt of C2h methane dimer with user-combined reference points. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. cc54; CCSD dipole with user-specified basis set. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. fci-h2o-2; 6-31G H2O Test FCI Energy Point. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cepa-module; routing check on lccd, lccsd, cepa(0). pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cc17; Single point energies of multiple excited states with EOM-CCSD. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:24039,energy,energy,24039,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"ion explicitly. nbo; Generation of NBO file. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. dft-smoke; DFT Functional Smoke Test. omp2p5-2; OMP2 cc-pVDZ energy for the H2O molecule. dcft1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. scf-guess-read2; Test if the the guess read in the same basis converges. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. opt3; SCF cc-pVDZ ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:35283,energy,energy,35283,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ion follows a syntax; that is slightly different from that of PSI4 and is fully documented; here; A typical input for a Hartree–Fock calculation with PCM would look like the following:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; pcmsolver/pcm-scf,; pcmsolver/pcm-dft, and; pcmsolver/pcm-dipole. Keywords for PCMSolver¶. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PCM_SCF_TYPE¶. Use total or separate potentials and charges in the PCM-SCF step. Type: string; Possible Values: TOTAL, SEPARATE; Default: TOTAL. PCM_CC_TYPE¶. PCM-CCSD algorithm type. Type: string; Possible Values: PTE; Default: PTE. How to configure PCMSolver for building Psi4¶; Role and Dependencies. Role — In PSI4, PCMSolver is a library that provides additional; quantum chemical capabilities (solvation modeling).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) PCMSolver; Upstream Dependencies — PCMSolver \(\Leftarrow\) Fortran, ???. table of contents. Interface to PCMSolver by R. Di Remigio; Installation; Using the polarizable continuum model; Keywords for PCMSolver; PCM; PCM_SCF_TYPE; PCM_CC_TYPE. How to configure PCMSolver for building Psi4. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/pcmsolver-1.html:3341,charge,charges,3341,psi4manual/1.1.0/pcmsolver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/pcmsolver-1.html,2,['charge'],['charges']
Energy Efficiency,"ion of TS for HCN to HNC Performs finite difference hessian calculation. Then optimizes using previous orbitals for scf guess, in subsequent calculations. The last two displacements of the hessian break the plane of symemtry, This test confirms that only the reference geometry, with the correct symmetry, writes orbitals to disk. SCF will fail (ValidationError) otherwise. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. nbody-vmfc-hessian; Computation of VMFC-corrected water trimer Hessian (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. extern4; External potential calculation involving a TIP3P water and a QM water. Gradient on the external charges is compared to gradient on the QM atoms to validate the gradient on the charges. tdscf-7; TD-HF test variable access. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). mom-h2o-3; MOM excitation from LUMO HOMO+3. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. fsapt-ext-abc; FSAPT with external charge on trimer. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). mcscf1; ROHF 6-31G*",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:17195,charge,charges,17195,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,4,['charge'],['charges']
Energy Efficiency,"ion of \(-1.21\); kcal/mol. It is not surprising that the electrostatic contribution is; dominant, because the geometry chosen for this example has the acetylene; perpendicular to the ethylene, with the acetylene hydrogen pointing; directly at the double bond in ethylene; this will be attractive because; the H atoms in acetylene bear a partial positive charge, while the; electron rich double bond in ethylene bears a partial negative charge.; At the same time, the dispersion interaction should be smaller because; the perpendicular geometry does not allow much overlap between the; monomers. Hence, the SAPT analysis helps clarify (and quantify) our; physical understanding about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops and string formatting to make our lives; simpler. Additionally, let’s suppose you want to do counterpoise (CP); correction to compute interaction energies. Counterpoise correction; involves computing the dimer energy and then subtracting out the; energies of the two monomers, each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of sp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:17306,energy,energy,17306,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,8,['energy'],['energy']
Energy Efficiency,"ion of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. table of contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; RESTRICTED_DOCC; RESTRICTED_UOCC; FROZEN_UOCC; CI_MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Spin Multiplicities of Higher Roots; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Theoretical Methods: SCF to FCI; CI: Configuration Interaction. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:15398,energy,energy,15398,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,2,['energy'],['energy']
Energy Efficiency,"ion of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. table of contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; RESTRICTED_DOCC; RESTRICTED_UOCC; FROZEN_UOCC; CI_MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Spin Multiplicities of Higher Roots; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Theoretical Methods: SCF to FCI; CI: Configuration Interaction. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/detci-1.html:15398,energy,energy,15398,psi4manual/1.5.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/detci-1.html,2,['energy'],['energy']
Energy Efficiency,"ion of this feature is not yet released. However,; the current version of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. table of contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; RESTRICTED_DOCC; RESTRICTED_UOCC; FROZEN_UOCC; CI_MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/detci-1.html:12852,energy,energy,12852,psi4manual/1.2.1/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/detci-1.html,2,['energy'],['energy']
Energy Efficiency,"ion received through MDI; """"""; self.lattice_field = psi4.QMMM(); unit_conv = self.length_conversion(); for ilat in range(self.nlattice):; latx = self.clattice[3 * ilat + 0] * unit_conv; laty = self.clattice[3 * ilat + 1] * unit_conv; latz = self.clattice[3 * ilat + 2] * unit_conv; self.lattice_field.extern.addCharge(self.lattice[ilat], latx, laty, latz); psi4.core.set_global_option_python('EXTERN', self.lattice_field.extern); self.set_lattice = True. # Respond to the >NLATTICE command; def recv_nlattice(self, nlattice=None):; """""" Receive the number of lattice point charges through MDI. Arguments:; nlattice: New number of point charges. If None, receive through MDI.; """"""; if nlattice is None:; self.nlattice = MDI_Recv(1, MDI_INT, self.comm); else:; self.nlattice = nlattice; self.clattice = [0.0 for ilat in range(3 * self.nlattice)]; self.lattice = [0.0 for ilat in range(self.nlattice)]; self.set_lattice_field(). # Respond to the >CLATTICE command; def recv_clattice(self, clattice=None):; """""" Receive the coordinates of a set of lattice point charges through MDI. Arguments:; clattice: New coordinates of the lattice of point charges. If None, receive through MDI.; """"""; if clattice is None:; self.clattice = MDI_Recv(3 * self.nlattice, MDI_DOUBLE, self.comm); else:; self.clattice = clattice; self.set_lattice_field(). # Respond to the >LATTICE command; def recv_lattice(self, lattice=None):; """""" Receive the charges of a set of lattice point charges through MDI. Arguments:; lattice: New charges of the lattice of point charges. If None, receive through MDI.; """"""; if lattice is None:; self.lattice = MDI_Recv(self.nlattice, MDI_DOUBLE, self.comm); else:; self.lattice = lattice; self.set_lattice_field(). # Respond to the SCF command; def run_scf(self):; """""" Run an energy calculation; """"""; self.energy = psi4.energy(self.scf_method, **self.kwargs). # Respond to the <DIMENSIONS command; def send_dimensions(self):; """""" Send the dimensionality of the system through MDI. :returns: *di",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:9621,charge,charges,9621,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,4,['charge'],['charges']
Energy Efficiency,"ion tests the FROZEN_DOCC option explicitly. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. dft-smoke; DFT Functional Smoke Test. omp2p5-2; OMP2 cc-pVDZ energy for the H2O molecule. dcft1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. scf-guess-read2; Test if the the guess read in the same basis converges. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. opt3; SCF cc-pVDZ ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:33667,energy,energy,33667,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/opt-1.html:1852,energy,energy,1852,psi4manual/4.0b2/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html,2,['energy'],['energy']
Energy Efficiency,"ion to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str]) – Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None]) – Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int) – Amount of printing. Unused at present. Returns:. energy (float) – When dertype=0, energy [Eh].; gradient (ndarray) – When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray) – When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule) → str¶; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule) → str¶; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool) → None¶; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule) → str¶; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]¶; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:. ref_mol (Molecule) – Molecule to perturb.; do_shift (Union[bool, ndarray, List]) – Whether to generate a random atom s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:31830,energy,energy,31830,psi4manual/1.7.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html,16,['energy'],['energy']
Energy Efficiency,"ion type. Type: string; Possible Values: SUBSPACE, JACOBI, NONE; Default: JACOBI. SOLVER_PRECONDITION_MAXITER (CPHF); CPHF — Solver precondtion max steps. Type: integer; Default: 1. SOLVER_PRECONDITION_STEPS (CPHF); CPHF — Solver precondition step type. Type: string; Possible Values: CONSTANT, TRIANGULAR; Default: TRIANGULAR. SOLVER_QUANTITY (CPHF); CPHF — Solver residue or eigenvector delta. Type: string; Possible Values: EIGENVECTOR, RESIDUAL; Default: RESIDUAL. SOLVER_TYPE (CPHF); CPHF — Solver type (for interchangeable solvers). Type: string; Possible Values: DL, RAYLEIGH; Default: DL. SORTED_TEI_FILE (TRANSQT); TRANSQT — MO-basis sorted two-electron integrals file. Type: integer; Default: PSIF_MO_TEI. SOS_TYPE (OCC); OCC — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SPINADAPT_ENERGIES (CCENERGY); CCENERGY — Do print spin-adapted pair energies?. Type: boolean; Default: false. SS_E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG (CCEOM); CCEOM — Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT (CCEOM); CCEOM — SS vectors stored per root. Type: integer; Default: 5. STABILITY_ADD_VECTORS (DCFT); DCFT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF); SCF — Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to foll",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:123210,energy,energy,123210,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,['energy'],['energy']
Energy Efficiency,"ion will be performed. Recommendations¶; Here is a list of recommendations for the DCT module:. Generally, the use of the simultaneous algorithm together with the; AO_BASIS DISK option is recommended (set by default).; In cases when available memory is insufficient, the use of the AO_BASIS DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In cases when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by setting the; DIIS_START_CONVERGENCE option to the value greater than; \(10^{-3}\) by one or two orders of magnitude (e.g. \(10^{-2}\) or; \(10^{-1}\)). This can be particularly useful for computations using the; ODC methods, because it can greatly reduce the number of iterations.; If oscillatory convergence is observed for atoms or molecules with high; symmetry, it is recommended to use the quadratically-convergent algorithm.; When using the quadratically-convergent algorithm for the closed-shell molecules, it; is recommended to set the QC_COUPLING option to FALSE for efficiency; reasons (set by default).; For the ODC computations, the user has a choice of performing the computation of the guess orbitals and cumulants; using the corresponding DC method (set ODC_GUESS to TRUE). This can often lead to; significant computational savings, since the orbital update step in the DC methods is cheap.; Convergence of the guess orbitals and cumulants can be controlled using the; GUESS_R_CONVERGENCE option. table of contents. DCT: Density Cumulant Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Methods Summary; Minimal Input; Recommendations. «; hide menu. menu; sidebar; »; . Navigation. In",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:14958,reduce,reduce,14958,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,9,['reduce'],['reduce']
Energy Efficiency,"ion('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if name in [""mp3"", ""fno-mp3""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP3 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")); elif name in [""mp4(sdq)"", ""fno-mp4(sdq)""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4(SDQ) TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4(SDQ) CORRELATION ENERGY"")); elif name in [""mp4"", ""fno-mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(""MP4 TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:160114,ENERGY,ENERGY,160114,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"ion(); freqs = ref.frequencies(); nfreq = freqs.dim(0); freqsum = 0.0; for i in range (0,nfreq):; freqsum += freqs.get(i); zpe = freqsum / psi_hartree2wavenumbers * 0.8929 * 0.5; PsiMod.clean(). # optimize geometry at mp2 (no frozen core) level; # note: freeze_core isn't an option in MP2; PsiMod.set_global_option('FREEZE_CORE',""FALSE""); optimize('conv-mp2'); PsiMod.clean(). # qcisd(t); PsiMod.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES',""TRUE""); PsiMod.set_global_option('FREEZE_CORE',""TRUE""); PsiMod.set_global_option('BASIS',""6-311G(D_P)""); run_fnocc('qcisd(t)',**kwargs). # HLC: high-level correction based on number of valence electrons; ref = PsiMod.wavefunction(); nirrep = ref.nirrep(); frzcpi = ref.frzcpi(); nfzc = 0; for i in range (0,nirrep):; nfzc += frzcpi[i]; nalpha = ref.nalpha() - nfzc; nbeta = ref.nbeta() - nfzc; # hlc of gaussian-2; hlc = -0.00481 * nalpha -0.00019 * nbeta; # hlc of gaussian-1; hlc1 = -0.00614 * nalpha. eqci_6311gdp = PsiMod.get_variable(""QCISD(T) TOTAL ENERGY""); emp4_6311gd = PsiMod.get_variable(""MP4 TOTAL ENERGY""); emp2_6311gd = PsiMod.get_variable(""MP2 TOTAL ENERGY""); PsiMod.clean(). # correction for diffuse functions; PsiMod.set_global_option('BASIS',""6-311+G(D_P)""); energy('mp4'); emp4_6311pg_dp = PsiMod.get_variable(""MP4 TOTAL ENERGY""); emp2_6311pg_dp = PsiMod.get_variable(""MP2 TOTAL ENERGY""); PsiMod.clean(). # correction for polarization functions; PsiMod.set_global_option('BASIS',""6-311G(2DF_P)""); energy('mp4'); emp4_6311g2dfp = PsiMod.get_variable(""MP4 TOTAL ENERGY""); emp2_6311g2dfp = PsiMod.get_variable(""MP2 TOTAL ENERGY""); PsiMod.clean(). # big basis mp2; PsiMod.set_global_option('BASIS',""6-311+G(3DF_2P)""); run_fnocc('_mp2',**kwargs); emp2_big = PsiMod.get_variable(""MP2 TOTAL ENERGY""); PsiMod.clean(). eqci = eqci_6311gdp; e_delta_g2 = emp2_big + emp2_6311gd - emp2_6311g2dfp - emp2_6311pg_dp; e_plus = emp4_6311pg_dp - emp4_6311gd; e_2df = emp4_6311g2dfp - emp4_6311gd. eg2 = eqci + e_delta_g2 + e_plus + e_2df; eg2_mp2_0k = eqc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/gaussian_n.html:2210,ENERGY,ENERGY,2210,psi4manual/4.0b4/_modules/gaussian_n.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/gaussian_n.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ion(psi4.Dispersion.build('-DAS2010', 1.0, 0.0, 0.0, 0.0)) # Does not have an s6, so set to 1.0. sup.allocate(); return sup. [docs]def build_b2plyp_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B2PLYP'); # Tab in, trailing newlines; sup.set_description(' B2PLYP Double Hybrid Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' S. Grimme, J. Chem. Phys., 124, 034108, 2006\n'). # Add member functionals; becke = build_functional('B88_X'); becke.set_alpha(1.0); sup.add_x_functional(becke); lyp = build_functional('LYP_C'); lyp.set_alpha(0.73); sup.add_c_functional(lyp). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.53); sup.set_c_alpha(0.27). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wb97x_2tqz_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wB97X-2(TQZ)'); # Tab in, trailing newlines; sup.set_description(' Double Hybrid LRC B97 GGA XC Functional (TQZ parametrization)\n'); # Tab in, trailing newlines; sup.set_citation(' J.-D. Chai and M. Head-Gordon, J. Chem. Phys., 131, 174105, 2009\n'). # Add member functionals; X = build_functional('wB97_X'); X.set_name('wB97X_X'); X.set_alpha(1.0 / (1.0 - 0.636158)). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 3.15503E-1); X.set_parameter('B97_a1', 1.04772E0); X.set_parameter('B97_a2', -2.33506E0); X.set_parameter('B97_a3', 3.19909E0). C = build_functional('B_C'); C.set_name('wB97X_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 5.18198E-1); C.set_parameter('B97",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/functional.html:70654,allocate,allocate,70654,psi4manual/4.0b5/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/functional.html,2,['allocate'],['allocate']
Energy Efficiency,"ion) – highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the second delta correction; to the correlation energy. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs('scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs('mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs('scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('conv-mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('conv-mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('conv-mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). Output¶; At the beginning of a cbs() job is printed a listing of the individual; energy calculations which will be performed. The output snippet below is; from the example job [2] above. It shows first each model che",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cbs-1.html:6645,energy,energy,6645,psi4manual/4.0b3/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"ion) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key)¶; Removes scalar or array QCVariable key from self if present. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Alpha orbital energies subset. Parameters:. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbital energies should be returned?. Returns:; A Pitzer-ordered vector of the orbitals. Return type:; Vector. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html:14156,energy,energy,14156,psi4manual/master/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Wavefunction.html,2,['energy'],['energy']
Energy Efficiency,"ion) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(self: psi4.core.Wavefunction, arg0: str) → int¶; Removes the requested (case-insensitive) double QC variable. del_variable(key)¶. density_fitted(self: psi4.core.Wavefunction) → bool¶; Returns whether this wavefunction was obtained using density fitting or not. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction) → float¶; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunction’s energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Alpha Eigenvalues subset. epsilon_b(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use onl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html:4716,energy,energy,4716,psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.dfep2wavefunction.html,9,['energy'],['energy']
Energy Efficiency,"ion) → psi4.core.Vector¶; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet) → psi4.core.Wavefunction¶; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet *basis. ci_nat_orbs(self: psi4.core.CIWavefunction) → None; docstring. cleanup_ci(self: psi4.core.CIWavefunction) → None; docstring. cleanup_dpd(self: psi4.core.CIWavefunction) → None; docstring. compute_energy(self: psi4.core.Wavefunction) → float¶; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_state_transfer(self: psi4.core.CIWavefunction, arg0: psi::detci::CIvect, arg1: int, arg2: psi4.core.Matrix, arg3: psi::detci::CIvect) → None; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Deep copies the internal data. diag_h(self: psi4.core.CIWavefunction, arg0: float, arg1: float) → int; docstring. doccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of doubly occupied orbitals per irrep. energy(self: psi4.core.Wavefunction) → float¶; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction) → psi4.core.Vector¶; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Vector¶; Returns the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.ciwavefunction.html:7291,energy,energy,7291,psi4manual/1.2.1/api/psi4.core.ciwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.ciwavefunction.html,1,['energy'],['energy']
Energy Efficiency,ion). psi4.Matrix.back_transform() (built-in function). psi4.Matrix.canonical_orthogonalization() (built-in function). psi4.Matrix.cholesky_factorize() (built-in function). psi4.Matrix.clone() (built-in function). psi4.Matrix.coldim() (built-in function). psi4.Matrix.cols() (built-in function). psi4.Matrix.copy_lower_to_upper() (built-in function). psi4.Matrix.copy_upper_to_lower() (built-in function). psi4.Matrix.diagonalize() (built-in function). psi4.Matrix.doublet() (built-in function). psi4.Matrix.from_array() (built-in function). psi4.Matrix.gemm() (built-in function). psi4.Matrix.get() (built-in function). psi4.Matrix.identity() (built-in function). psi4.Matrix.invert() (built-in function). psi4.Matrix.load() (built-in function). psi4.Matrix.load_mpqc() (built-in function). psi4.Matrix.name() (built-in function). psi4.Matrix.nirrep() (built-in function). psi4.Matrix.np() (built-in function). psi4.Matrix.partial_cholesky_factorize() (built-in function). psi4.Matrix.power() (built-in function). psi4.Matrix.print_out() (built-in function). psi4.Matrix.project_out() (built-in function). psi4.Matrix.remove_symmetry() (built-in function). psi4.Matrix.rms() (built-in function). psi4.Matrix.rowdim() (built-in function). psi4.Matrix.rows() (built-in function). psi4.Matrix.save() (built-in function). psi4.Matrix.scale() (built-in function). psi4.Matrix.scale_column() (built-in function). psi4.Matrix.scale_row() (built-in function). psi4.Matrix.schmidt() (built-in function). psi4.Matrix.set() (built-in function). psi4.Matrix.set_name() (built-in function). psi4.Matrix.shape() (built-in function). psi4.Matrix.subtract() (built-in function). psi4.Matrix.sum_of_squares() (built-in function). psi4.Matrix.symmetrize_gradient() (built-in function). psi4.Matrix.symmetry() (built-in function). psi4.Matrix.to_array() (built-in function). psi4.Matrix.trace() (built-in function). psi4.Matrix.transform() (built-in function). psi4.Matrix.vector_dot() (built-in function). psi4.Matrix,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:91265,power,power,91265,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['power'],['power']
Energy Efficiency,"ion, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet) → psi4.core.RHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wav",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.rhf.html:4291,energy,energy,4291,psi4manual/1.3.2/api/psi4.core.rhf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.rhf.html,1,['energy'],['energy']
Energy Efficiency,"ion, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet) → psi4.core.Matrix¶; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction) → psi4.core.BasisSet¶; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. static build(mol, basis=None)¶. c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet) → psi4.core.UHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_gradient(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Computes the Hessian of the Wavefunction. compute_initial_E(self: psi4.core.HF) → float¶; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int) → float¶; docstring. compute_spin_contamination(self: psi4.core.HF) → None¶; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix]) → List[psi4.core.Matrix]¶; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF) → bool¶; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int=2) → List[psi4.core.Matrix]¶; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float) → None¶; docstring. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wav",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.uhf.html:4291,energy,energy,4291,psi4manual/1.3.2/api/psi4.core.uhf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.uhf.html,1,['energy'],['energy']
Energy Efficiency,"ion, arg0: str) → None¶; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential) → None¶; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int) → None¶; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float) → None¶; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val)¶; Sets scalar or array QCVariable key to val on self.; :rtype: None. Parameters:. self (Wavefunction) – Wavefunction instance.; key (str) – Case-insensitive key to instance’s double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float]) – Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError – If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction) → None¶; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. to_file(filename=None)¶; Serialize a Wavefunction object. Opposite of; from_file(). Par",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:24428,ENERGY,ENERGY,24428,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ion. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. explicit-am-basis; Check that basis sets can be input with explicit angular momentum format. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. casscf-sp; CASSCF/6-31G** energy point. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dfccsdt2; DF-CCSD(T) cc-pVDZ energy for the NH molecule. dft-reference; MP2 with a PBE0 reference computation. options1; check all variety of options parsing. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). fnocc5; Test FNO-DF-CCSD(T) energy. omp2p5-2; OMP2.5 cc-pVDZ energy for the H2O molecule. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. nbody-multi-level-2; many-body different levels of theory on each body of helium tetramer. oremp-grad1; integral conventional OO-REMP/cc-pVDZ engrad single points for the H2O molecule. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. cc45; RHF-EOM-CC2/cc-pVD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:32559,energy,energy,32559,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ion. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. dfremp-2; density fitted REMP/cc-pVDZ energies for the CH3 radical. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. sapt-ecp; sapt0 of charged system in ECP basis set. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). cbs-xtpl-energy; Extrapolated water energies - density-fitted version. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. dfccsdat2; DF-A-CCSD(T) cc-pVDZ energy for the NH molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. omp3-5; SOS-OMP3 cc-pVDZ geometry optimizati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:25693,energy,energy,25693,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ion. Navigation. index. modules    . toc    ; PSI4 [beta3] » ; Module code ». Source code for aliases; """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; import PsiMod; import re; import os; import math; import warnings; from driver import *; from wrappers import *; from molutil import *; from text import *; from procutil import *. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end of this file. [docs]def sherrillgroup_gold_standard(name='mp2', **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~wrappers.complete_basis_set` to evaluateo; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~wrappers.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> energy('sherrillgroup_gold_standard'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). if not ('func_cbs' in kwargs):; kwargs['func_cbs'] = energy. if not ('scf_basis' in kwargs):; kwargs['scf_basis'] = 'aug-cc-pVQZ'; if not ('scf_scheme' in kwargs):; kwargs['scf_scheme'] = highest_1. if not ('corl_wfn' in kwargs):; kwargs['corl_wfn'] = 'mp2'; if not ('corl_basis' in kwargs):; kwargs['corl_basis'] = 'aug-cc-pV[TQ]Z'; if not ('corl_scheme' in kwargs):; kwargs['corl_scheme'] = corl_xtpl_helgaker_2. if not ('delta_wfn' in kwargs):; kwargs['delta_wfn'] = 'ccsd(t)'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis' in kwargs):; kwargs['delta_basis'] = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html:1033,energy,energy,1033,psi4manual/4.0b3/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html,2,['energy'],['energy']
Energy Efficiency,"ion. The -D3; dispersion has the following form, where and ; are the customary nonunity parameters fitted for individual functionals. (2). A modified damping scheme for DFT-D3 using the rational damping form of; Becke and Johnson was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now , ,; , and . All parameters characterizing the dispersion correction are taken from; http://toc.uni-muenster.de/DFTD3/; or else from the literature. Running DFTD3¶; A number of a posteriori dispersion corrections are available in; PSI4. While most are computed within PSI4’s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/PSI4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of S. Grimme’s -D correction. Extension [1]; Variant and Computing Program; DFT_DISPERSION_PARAMETERS. -D; alias to -D2P4;  . -D1; -D1 [2] within PSI4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within PSI4; []. -D2GR; -D2 [3] through dftd3; [, ]. -D3; alias to -D3ZERO;  . -D3ZERO; -D3 [4] w/ original zero-damping through dftd3; [, , , ]. -D3BJ; -D3 [5]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/dftd3.html:3823,energy,energy,3823,psi4manual/4.0b3/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/dftd3.html,5,['energy'],['energy']
Energy Efficiency,"ion. The -D3; dispersion has the following form, where and ; are the customary nonunity parameters fitted for individual functionals. (2). A modified damping scheme for DFT-D3 using the rational damping form of; Becke and Johnson was introduced in [Grimme:2011:1456]. The parameters; fit for individual functionals are now , ,; , and . All parameters characterizing the dispersion correction are taken from; http://toc.uni-muenster.de/DFTD3/; or else from the literature. Running DFTD3¶; A number of a posteriori dispersion corrections are available in; Psi4. While most are computed within Psi4‘s codebase (-D1, -D2,; -CHG, -DAS2009, -DAS2010), the -D3 correction and its variants are; available only through the DFTD3 program. Once installed, the; dftd3/Psi4 interface is transparent, and all corrections are; interfaced exactly alike.; Dispersion corrections are built into DFT functionals, so appending an a; posteriori correction to a computation is as simple as; energy('b2plyp-d') vs. energy('b2plyp'). For example, the; following input file computes (with much redundant work) for water a; B3LYP, a B3LYP-D2, and a B3LYP-D3 (zero-damping) energy.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('b3lyp'); energy('b3lyp-d'); energy('b3lyp-d3'). Consult the table -D Functionals to see for each; functional what corrections are available and what default parameters; define them. The dispersion correction is available after a calculation in; the PSI variable DISPERSION CORRECTION ENERGY.; By default, the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of S. Grimme’s -D correction¶. Extension [1]; Variant and Computing Program; DFT_DISPERSION_PARAMETERS. -D; alias to -D2P4;  . -D1; -D1 [2] within Psi4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within Psi4; []. -D2GR; -D2 [3] through dftd3; [, ]. -D3; alias to -D3ZERO;  . -D3ZERO; -D3 [4] w/ original zero-damping through dftd3; [, , , ]. -D3BJ; -D3 [5",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dftd3-1.html:4537,energy,energy,4537,psi4manual/1.0.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dftd3-1.html,2,['energy'],['energy']
Energy Efficiency,"ion. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:10786,energy,energy,10786,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['energy'],['energy']
Energy Efficiency,"ion. ao_overlap_half_deriv1(self, side, atom); Half-derivative of AO basis overlap integrals: returns (3 * natoms) matrices. ao_potential(*args, **kwargs); Overloaded function. ao_pvp(self); AO pvp integrals. ao_quadrupole(self); Vector AO quadrupole integrals. ao_tei_deriv1(self, atom[, omega, factory]); Gradient of AO basis TEI integrals: returns (3 * natoms) matrices. ao_tei_deriv2(self, atom1, atom2); Hessian of AO basis TEI integrals: returns (3 * natoms)^2 matrices. ao_traceless_quadrupole(self); Vector AO traceless quadrupole integrals. basisset(self); Returns the basis set being used. cdsalcs(self, arg0, arg1, arg2); Returns a CdSalcList object. core_hamiltonian_grad(self, arg0); First nuclear derivative T + V + Perturb integrals. dipole_grad(self, arg0); First nuclear derivative dipole integrals. electric_field(self, origin[, deriv]); Vector electric field integrals. electric_field_value(self, arg0, arg1); Electric field expectation value at given sites. electrostatic_potential_value(self, charges, ...); Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self[, exponent]); F12 Fitted Slater Correlation Factor. factory(self); Returns the Matrix factory being used. induction_operator(self, arg0, arg1); Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self); Integral factory being used. integrals(self); Molecular integrals. integrals_erf(self[, w]); ERF integrals. integrals_erfc(self[, w]); ERFC integrals. kinetic_grad(self, arg0); First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self, atom, C1, C2); Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self, omega, C1, C2, C3, C4); MO ERFC Omega Integrals. mo_eri(self, C1, C2, C3, C4); MO ERI Integrals. mo_f12(self, corr, C1, C2, C3, C4); MO F12 Integrals. mo_f12_double_commutator(self, corr, C1, C2, ...);",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.MintsHelper.html:2782,charge,charges,2782,psi4manual/1.7.x/api/psi4.core.MintsHelper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.MintsHelper.html,6,['charge'],['charges']
Energy Efficiency,"ion. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. mp2-module; OMP2 cc-pVDZ energy for the H2O molecule. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. dft-bench-interaction; functionals + DFTD3 interaction energies vs. other programs. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dcft6; DCFT calculation for the triplet O2 using DC-06, DC-12 and CEPA0 functionals. Only two-step algorithm is tested. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mode. dfmp2-ecp; He-Ne dimer MP2 energies with ECP, Ne electrons correlated then frozen. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:6920,energy,energy,6920,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ion. opt-multi-frozen-dimer-c2h; Frozen-fragment opt of C2h methane dimer with user-combined reference points. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. mp2-h; check that methods can act on single atom. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. fci-dipole; 6-31G H2O Test FCI Energy Point. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. rasci-h2o; RASCI/6-31G** H2O Energy Point. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. dft-grad-lr1; wB97X-D cc-pVDZ grad",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:19225,energy,energy,19225,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ion. psi4.set_memory('500 MB'). h2o = psi4.geometry(""""""; O; H 1 0.96; H 1 0.96 2 104.5; """"""). psi4.energy('scf/cc-pvdz'). Out[3]:. -76.02663273488399. If everything goes well, the computation should complete and should; report a final restricted Hartree-Fock energy in the output file; output.dat in a section like this:; Energy converged. @DF-RHF Final Energy: -76.02663273486682. By default, the energy should be converged to about; \(1.0\times 10^{-6}\), so agreement is only expected for about the; first 6 digits after the decimal. If the computation does not complete,; there is probably a problem with the compilation or installation of the; program (see the installation instructions in the main Psi4 manual; section Compiling and Installing from; Source).; This very simple input is sufficient to run the requested information.; Notice we didn’t tell the program some otherwise useful information like; the charge of the molecule (0, it’s neutral), the spin multiplicity (1; for a closed-shell molecule with all electrons paired), or the reference; wavefunction to use (restricted Hartree-Fock, or RHF, is usually; appropriate for a closed-shell molecule). The program correctly guessed; all of these options for us. We can change the default behavior through; additional keywords.; Let’s consider what we would do for an open-shell molecule, where not; all the electrons are paired. For example, let’s run a computation on; methylene (\(\text{CH}_2\)), whose ground electronic state has two; unpaired electrons (triplet electronic state, or a spin multiplicity; \(2S + 1 = 3\)). In this case, the default spin multiplicity (1) is; not correct, so we need to tell the program the true value (3). Like; many programs, Psi4 can get the charge and multiplicity as the first two; integers in the Z-matrix (note the line with 0 3 at the beginning of; the molecule specification below). In this example, we will also specify; the bond length and bond angle as variables (\(R\) and \(A\)),; whose va",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:4303,charge,charge,4303,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['charge'],['charge']
Energy Efficiency,"ion. unit()[source]¶; Set equal to a unit matrix. zero()[source]¶; zero out the symop. similar(bits)[source]¶; From bits of a directionalized point group, returns array of; bits of all directions. class Molecule(psi4molstr=None)[source]¶; Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. BFS()[source]¶; Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. auto_fragments()[source]¶; Detects fragments in an unfragmented molecule using BFS; algorithm. Returns a new Molecule in Cartesian, fixed-geom; (no variable values), no dummy-atom format. Any non-default; charge and multiplicity assigned to first fragment. bond_profile()¶; Obtain bonding topology of molecule. center_of_charge()[source]¶; Computes center of charge of molecule (does not translate molecule).; >>> H2OH2O.center_of_charge(); [-0.073339893272065401, 0.002959783555632145, 0.0]. format_basis_for_cfour(puream)[source]¶; Function to print the BASIS=SPECIAL block for Cfour according; to the active atoms in Molecule. Special short basis names; are used by Psi4 libmints GENBAS-writer in accordance with; Cfour constraints. format_molecule_for_cfour()[source]¶; Function to print Molecule in a form readable by Cfour. format_molecule_for_cfour_old()[source]¶; Function to print Molecule in a form readable by Cfour. This; version works as long as zmat is composed entirely of variables,; not internal values, while cartesian is all internal values,; no variables. Cutting off this line of development because,; with getting molecules after passing through libmints Molecule,; all zmats with dummies (Cfour’s favorite kind) have already been; converted into cartesian. Next step, if this line was pursued; would be to shift any zmat internal values",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:18595,charge,charge,18595,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency,"ion.build(self.dashlevel, **resolved['dashparams']). if gcp_engine is None:; self.gcp_engine = capable_engines_for_disp[""3c""][0]; else:; if ""3c"" in _engine_can_do[gcp_engine]:; self.gcp_engine = gcp_engine; else:; raise ValidationError(f""This little engine ({engine}) can't (3c)""). [docs] def print_out(self):; """"""Format dispersion parameters of `self` for output file."""""". text = []; text.append("" => {}: Empirical Dispersion <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in [""s-dftd3"", 'dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'apply_qcengine_aliases': True, # for s-dftd3; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:8644,energy,energy,8644,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,2,['energy'],['energy']
Energy Efficiency,"ion; Complete Basis Set. Complete Basis Set¶. Code author: Lori A. Burns, Daniel G. A. Smith and Peter Kraus; Section author: Lori A. Burns and Peter Kraus; The psi4.driver.cbs() function described below is; powerful but complicated, requiring many options. For most common; calculations, a shorthand can be accessed directly though; psi4.driver.energy(), psi4.driver.gradient(), etc. For example,; a MP2 single-point DT extrapolation can be accessed through the first item; below more conveniently than the equivalent second or third items. energy('mp2/cc-pv[dt]z'); energy(""cbs"", corl_wfn='mp2', corl_basis='cc-pv[dt]z'); energy(""cbs"", cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvtz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[dt]z"", ""scheme"": ""corl_xtpl_helgaker_2""}]). Caution; In PSI4 previous to Spring 2022 and v1.6, calling certain; cbs-related functions like the above looked like; energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z'). energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvtz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[dt]z"", ""scheme"": corl_xtpl_helgaker_2}]). The difference is that the main function; psi4.driver.cbs() and extrapolation schemes like; psi4.driver.driver_cbs_helper.xtpl_highest_1() and; psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2() and composite; aliases like psi4.driver.aliases.sherrill_gold_standard(); and psi4.driver.aliases.allen_focal_point() in the old way; passed the Python function directly, whereas the new way uses the; string of the function name. A CCSD(T) DT coupled-cluster correction atop a TQ MP2 extrapolation; geometry optimization can also be accessed through the first item below more; conveniently than the equivalent second and third items. optimize('mp2/cc-pv[tq]z + D:ccsd(t)/cc-pvdz'); optimize(""cbs"", corl_wfn='mp2', corl_basis='cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='cc-pvdz'); optimize(""cbs"", cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvqz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvdz""}]). Many e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cbs.html:1063,energy,energy,1063,psi4manual/1.7.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cbs.html,4,['energy'],['energy']
Energy Efficiency,"ion; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. * Basis Sets; Currently, the basis set set through ``set`` commands have no influence; on a cbs calculation. :type scf_basis: :ref:`basis string <apdx:basisElement>`; :param scf_basis: |dl| ``corl_basis`` |dr| || ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, ``scf_basis`` can default; to ``corl_basis``. :type corl_basis: :ref:`basis string <apdx:basisElement>`; :param corl_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the correlation energy. :type delta_basis: :ref:`basis string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:54828,energy,energy,54828,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,6,['energy'],['energy']
Energy Efficiency,"ion; to the correlation energy is to be obtained. delta4_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string) – delta3_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string) – delta4_wfn || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – corl_basis || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:5612,energy,energy,5612,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"ionError(""Error: %s requires \""reference rhf\""."" % lowername). # scf; scf_helper(name,**kwargs). # if the scf type is df, then the ao integrals were never generated.; if PsiMod.get_option('SCF','SCF_TYPE') == 'DF' :; mints = PsiMod.MintsHelper(); mints.integrals(). # if this is not cim or FNO-CC, run transqt2. otherwise, libtrans will be used; if PsiMod.get_option('FNOCC','NAT_ORBS') == False and PsiMod.get_option('FNOCC','RUN_MP2') == False:; PsiMod.set_local_option('TRANSQT2', 'WFN', 'CCSD'); PsiMod.transqt2(). # run ccsd; PsiMod.fnocc(). # set current correlation energy and total energy. only need to treat mpn here.; if (lowername == 'fnocc-mp') and (level == 3):; emp3 = PsiMod.get_variable(""MP3 TOTAL ENERGY""); cemp3 = PsiMod.get_variable(""MP3 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp3); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp3); elif ( lowername == 'fno-mp3' ):; emp3 = PsiMod.get_variable(""MP3 TOTAL ENERGY""); cemp3 = PsiMod.get_variable(""MP3 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp3); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp3); elif ( lowername == 'mp4(sdq)'):; emp4sdq = PsiMod.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = PsiMod.get_variable(""MP4(SDQ) CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4sdq); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4(sdq)'):; emp4sdq = PsiMod.get_variable(""MP4(SDQ) TOTAL ENERGY""); cemp4sdq = PsiMod.get_variable(""MP4(SDQ) CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4sdq); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4sdq); elif ( lowername == 'fno-mp4'):; emp4 = PsiMod.get_variable(""MP4 TOTAL ENERGY""); cemp4 = PsiMod.get_variable(""MP4 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4); elif (lowername == 'fnocc-mp') and (level == 4):; emp4 = PsiMod.get_variable(""MP4 TOTAL ENERGY""); cemp4 = PsiMod.get_varia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:74752,ENERGY,ENERGY,74752,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"ionError(""Requested Orca dertype {} is not available.""; .format(dertype)). if lowername == 'orca':; pass; elif lowername == 'orca-b3lyp':; options['ORCA']['ORCA_FUNCTIONAL']['value'] = 'B3LYP_G'; elif lowername == 'orca-mp2':; options['ORCA']['ORCA_CALC_LEVEL']['value'] = 'MP2'; elif lowername == 'orca-ccsd':; options['ORCA']['ORCA_CALC_LEVEL']['value'] = 'CCSD'; elif lowername == 'orca-ccsd(t)':; options['ORCA']['ORCA_CALC_LEVEL']['value'] = 'CCSD(T)'; else:; raise ValidationError(""Requested Orca computational methods {} is not ""; ""available."" .format(lowername)). # Set clobbering; if 'ORCA_RUNTYP' in options['ORCA']:; options['ORCA']['ORCA_RUNTYP']['clobber'] = True; options['ORCA']['ORCA_RUNTYP']['superclobber'] = True; if 'ORCA_FUNCTIONAL' in options['ORCA']:; options['ORCA']['ORCA_FUNCTIONAL']['clobber'] = True; options['ORCA']['ORCA_FUNCTIONAL']['superclobber'] = True. return text, options. [docs]def orca_list():; """"""Return an array of Orca methods with energies. Appended; to procedures['energy']. """"""; val = []; val.append('orca'); val.append('orca-b3lyp'); return val. [docs]def orca_gradient_list():; """"""Return an array of Orca methods with analytical gradients.; Appended to procedures['gradient']. """"""; val = []; val.append('oc-b3lyp'); return val. [docs]def harvest_molecule_from_outfile(lines):; """"""Return a molecule of the last geometry""""""; """"""Sample molecule block""""""; #----------------------------; #CARTESIAN COORDINATES (A.U.); #----------------------------; # NO LB ZA FRAG MASS X Y Z; # 0 O 8.0000 0 15.999 -0.043407801307192 -0.055556028344352 0.000000000000000; # 1 H 1.0000 0 1.008 1.780497256508764 -0.017018089151928 0.000000000000000; # 2 H 1.0000 0 1.008 -0.462170608038134 1.719154625261312 0.000000000000000; #. geom_start = find_start(lines, 'CARTESIAN COORDINATES (A.U.)'); if geom_start == -1:; return Molecule(). # Geometry starts 3 lines after header and ends with a blank line; geom_start += 3; end = ''; mol_str = ''; for i, line in enumerate(lines[g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html:3160,energy,energy,3160,psi4manual/1.0.0/_modules/qcdb/orca.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orca.html,1,['energy'],['energy']
Energy Efficiency,"ionError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element (after *float* energy) of a tuple. :type restart_file: string; :param restart_file: ``['file.1, file.32]`` || ``./file`` || etc. Binary data files to be renamed for calculation re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:3815,energy,energy,3815,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"ion`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; kwargs = p4util.kwargs_lower(kwargs); ; core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif kwargs.get('bsse_type', None) is not None:; gradient_type = 'nbody_gufunc'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. # Figure out lowername, dertype, and func; # If we have analytical gradients we want to pass to our wrappers, otherwise we want to run; # finite-diference energy or cbs energies; # TODO MP5/cc-pv[DT]Z behavior unknown due to ""levels""; user_dertype = kwargs.pop('dertype', None); if gradient_type == 'custom_function':; if user_dertype is None:; dertype = 0; core.print_out(; ""\nGradient: Custom function passed in without a defined dertype, assuming fd-energy based gradient.\n""; ); else:; core.print_out(""\nGradient: Custom function passed in with a dertype of %d\n"" % user_dertype); dertype = user_dertype. if dertype == 1:; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', 'scf', 8, 10, 8, 10, 8); lowername = name. elif gradient_type == 'nbody_gufunc':; return driver_nbody.nbody_gufunc(gradient, name, ptype='gradient', **kwargs). elif gradient_type == 'cbs_wrapper':; cbs_methods = driver_cbs._cbs_wrapper_methods(**kwargs); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html:39623,energy,energy,39623,psi4manual/1.5.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"ional and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). mp2-1; All-electron MP2 6-31G** geometry optimization of water. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. pubchem2; Superficial test of PubChem interface. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. lccd-grad2; LCCD cc-pVDZ gradient for the NO radical. aediis-1; ADIIS test case, from 10.1063/1.3304922. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. This test should match RHF values exactly. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. sapt11; sapt example with orbital freezing with alkali metal and dMP2. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. opt2; SCF DZ allene geometry optim",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:1175,energy,energy,1175,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ional(name, npoints, deriv):. sup = build_pbe0_superfunctional(name, npoints, deriv); sup.set_name('PBE0-D3MBJ'). # => -D3 <= #; sup.set_dispersion(psi4.Dispersion.build(*dash_server('pbe0', 'd3mbj'))). return sup. [docs]def build_wsvwn_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wSVWN'); # Tab in, trailing newlines; sup.set_description(' LSDA SR-XC Functional\n'); # Tab in, trailing newlines; sup.set_citation(' Adamson et. al., J. Comput. Chem., 20(9), 921-927, 1999\n'). # Add member functionals; sup.add_x_functional(build_functional('wS_X')); sup.add_c_functional(build_functional('VWN3RPA_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.3); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbe_superfunctional(name, npoints, deriv):. # Call this first; sup = psi4.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('wPBE'); # Tab in, trailing newlines; sup.set_description(' PBE SR-XC Functional (HJS Model)\n'); # Tab in, trailing newlines; sup.set_citation(' Henderson et. al., J. Chem. Phys., 128, 194105, 2008\n Weintraub, Henderson, and Scuseria, J. Chem. Theory. Comput., 5, 754 (2009)\n'). # Add member functionals; sup.add_x_functional(build_functional('wPBE_X')); sup.add_c_functional(build_functional('PBE_C')). # Set GKS up after adding functionals; sup.set_x_omega(0.4); sup.set_c_omega(0.0); sup.set_x_alpha(0.0); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_wpbed3zero_superfunctional(name, npoints, deriv):. sup = build_wpbe_superfunctional(name, np",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html:60157,allocate,allocate,60157,psi4manual/1.0.0/_modules/procedures/functional.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/functional.html,1,['allocate'],['allocate']
Energy Efficiency,"ional) theory code. del_array_variable(key); Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). del_scalar_variable(key); Removes the double QCVariable key (case-insensitive); prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from global memory if present. detci(ref_wfn); Runs the determinant-based configuration interaction code. dfmp2(ref_wfn); Runs the DF-MP2 code. dfocc(ref_wfn); Runs the density-fitted orbital optimized CC codes. dlpno(arg0); Runs the DLPNO codes. dmrg(ref_wfn); Runs the CheMPS2 interface DMRG code. doublet(A, B[, transA, transB]); Returns the multiplication of two matrices A and B, with options to transpose each beforehand. dummy_einsums(ref_wfn); Runs the einsums placeholder code. fcidump_tei_helper(nirrep, restricted, ...); Write integrals to file in FCIDUMP format. finalize(); Called upon psi4 module exit to closes timers and I/O. flush_outfile(); Flushes the output file. fnocc(ref_wfn); Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. get_active_molecule(); Returns the currently active molecule object. get_array_variable(key). Deprecated since version 1.4. get_array_variables(). Deprecated since version 1.4. get_datadir(); Returns the path to shared text resources, PSIDATADIR. get_global_option(key); Return keyword key value at global (all-module) scope. get_global_option_list(); Returns a list of all global options. get_local_option(module, key); Return keyword key value at module scope. get_memory(); Returns the amount of memory available to Psi (in bytes). get_num_threads(); Returns the number of threads to use in SMP parallel computations. get_option(module, key); Return keyword key value used by module. get_options(); Get options. get_output_file(); Returns output file name (stem + suffix, no directory). get_variable(key). Deprecated since version 1.4. get_variables(). Deprecated since version 1.4. get_writer_file_prefix(molecule_name); Returns the prefix to use for writing fi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psi4api.html:4972,energy,energy,4972,psi4manual/1.9.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psi4api.html,1,['energy'],['energy']
Energy Efficiency,"ional) → Dict[str, psi4.core.Vector]¶; Return all internal values. vv10_b(self: psi4.core.SuperFunctional) → float¶; The VV10 b parameter. vv10_c(self: psi4.core.SuperFunctional) → float¶; The VV10 c parameter. x_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of exact HF exchange. x_beta(self: psi4.core.SuperFunctional) → float¶; Amount of exact HF exchange. x_functional(self: psi4.core.SuperFunctional, arg0: str) → psi::Functional¶; Returns the desired X Functional. x_functionals(self: psi4.core.SuperFunctional) → List[psi::Functional]¶; Returns all X Functionals. x_omega(self: psi4.core.SuperFunctional) → float¶; Range-seperated exchange parameter. XC_build(arg0: str, arg1: bool) → psi4.core.SuperFunctional; Builds a SuperFunctional from a XC string. add_c_functional(self: psi4.core.SuperFunctional, arg0: psi::Functional) → None; Add a correlation Functional. add_x_functional(self: psi4.core.SuperFunctional, arg0: psi::Functional) → None; Add a exchange Functional. allocate(self: psi4.core.SuperFunctional) → None; Allocates the vectors, should be called after ansatz or npoint changes. ansatz(self: psi4.core.SuperFunctional) → int; SuperFunctional rung. blank() → psi4.core.SuperFunctional; Initialize a blank SuperFunctional. c_alpha(self: psi4.core.SuperFunctional) → float; Amount of MP2 correlation. c_functional(self: psi4.core.SuperFunctional, arg0: str) → psi::Functional; Returns the desired C Functional. c_functionals(self: psi4.core.SuperFunctional) → List[psi::Functional]; Returns all C Functionals. c_omega(self: psi4.core.SuperFunctional) → float; Range-seperated correlation parameter. c_os_alpha(self: psi4.core.SuperFunctional) → float; Amount of SS MP2 correlation. c_ss_alpha(self: psi4.core.SuperFunctional) → float; Amount of OS MP2 correlation. citation(self: psi4.core.SuperFunctional) → str; SuperFunctional citation. compute_functional(self: psi4.core.SuperFunctional, arg0: Dict[str, psi4.core.Vector], arg1: int) → Dict[str, psi4.core.Vector]; C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.superfunctional.html:10099,allocate,allocate,10099,psi4manual/1.3.2/api/psi4.core.superfunctional.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.superfunctional.html,2,['allocate'],['allocate']
Energy Efficiency,"ional-with-dashlevel]; can be overwritten via param_tweaks.; level_hint (str) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to one.; param_tweaks (Union[Dict, List]) – Values for the same keys as dashcoeff[dashlevel][‘default’]; (and same order if list) used to override any or all values; initialized by name_hint. Extra parameters will error.; engine (str) – Override which code computes dispersion. See above for allowed; values. Formerly (pre Nov 2022) only relevant for -D2, which can be computed by; libdisp or dftd3. Now (post Nov 2022) also relevant for -D3 variants,; which can be computed by dftd3 executable or simple-dftd3 Python module.; gcp_engine (str) – Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp (bool) – Whether to request atomic pairwise analysis. Methods Summary. compute_energy(molecule[, wfn]); Compute dispersion energy based on engine, dispersion level, and parameters in self. compute_gradient(molecule[, wfn]); Compute dispersion gradient based on engine, dispersion level, and parameters in self. compute_hessian(molecule[, wfn]); Compute dispersion Hessian based on engine, dispersion level, and parameters in self. print_out(); Format dispersion parameters of self for output file. Methods Documentation. compute_energy(molecule, wfn=None)[source]¶; Compute dispersion energy based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule) – System for which to compute empirical dispersion correction.; wfn (Wavefunction) – Location to set QCVariables. Returns:; Dispersion energy [Eh]. Return type:; float. Notes. DISPERSION CORRECTION ENERGYDisp always set. Overridden in SCF finalization, but that only changes for “-3C” methods. fctl DISPERSION CORRECTION ENERGYSet if fctldash nonempty. compute_gradient(molecule, wfn=None)[source]¶; Compute dispersion gradient based on engine, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html:3753,energy,energy,3753,psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html,2,['energy'],['energy']
Energy Efficiency,"ional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; opt. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.opt.html:13428,energy,energy,13428,psi4manual/1.6.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.opt.html,4,['energy'],['energy']
Energy Efficiency,"ional; If True, also return fragments as list of Molecules.; return_molecule : bool, optional; If True, also return one big Molecule with fragmentation encoded. Returns; -------; bfs_map : list of lists; Array of atom indices (0-indexed) of detected fragments.; bfs_arrays : tuple of lists of ndarray, optional; geom, mass, elem info per-fragment.; Only provided if `return_arrays` is True.; bfs_molecules : list of qcdb.Molecule or psi4.core.Molecule, optional; List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See `seed_atoms`.; Any existing fragmentation info/chgmult encoded in `self` is lost. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_arr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:51720,charge,charge,51720,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,1,['charge'],['charge']
Energy Efficiency,"ional; If True, also return fragments as list of Molecules.; return_molecule : bool, optional; If True, also return one big Molecule with fragmentation encoded. Returns; -------; bfs_map : list of lists; Array of atom indices (0-indexed) of detected fragments.; bfs_arrays : tuple of lists of ndarray, optional; geom, mass, elem info per-fragment.; Only provided if `return_arrays` is True.; bfs_molecules : list of qcdb.Molecule or psi4.core.Molecule, optional; List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See `seed_atoms`.; Any existing fragmentation info/chgmult encoded in `self` is lost. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [molparse.from_arrays(geo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:54861,charge,charge,54861,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['charge'],['charge']
Energy Efficiency,"ional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:40777,energy,energy,40777,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,16,['energy'],['energy']
Energy Efficiency,"ionary associating SCF energies with occupations. """"""; optstash = p4util.OptionsState(; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'REFERENCE'],; [""SCF"", ""FRAC_START""],; [""SCF"", ""FRAC_RENORMALIZE""],; #[""SCF"", ""FRAC_LOAD""],; [""SCF"", ""FRAC_OCC""],; [""SCF"", ""FRAC_VAL""],; [""SCF"", ""FRAC_DIIS""]); kwargs = p4util.kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one, and neutral; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). if molecule.molecular_charge() != 0:; raise ValidationError(""""""frac_traverse requires neutral molecule to start.""""""); if molecule.schoenflies_symbol() != 'c1':; core.print_out("""""" Requested procedure `frac_traverse` does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); molecule = molecule.clone(); molecule.reset_point_group('c1'); molecule.update_geometry(). charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). chargep = charge0 + 1; chargem = charge0 - 1. multp = kwargs.get('cation_mult', mult0 + 1); multm = kwargs.get('anion_mult', mult0 + 1). # By default, we start the frac procedure on the 25th iteration; # when not reading a previous guess; frac_start = kwargs.get('frac_start', 25). # By default, we occupy by tenths of electrons; HOMO_occs = kwargs.get('HOMO_occs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]); LUMO_occs = kwargs.get('LUMO_occs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]). # By default, HOMO and LUMO are both in alpha; Z = 0; for A in range(molecule.natom()):; Z += molecule.Z(A); Z -= charge0; HOMO = kwargs.get('HOMO', (Z / 2 + 1 if (Z % 2) else Z / 2)); LUMO = kwargs.get('LUMO', HOMO + 1). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = kwargs.get('frac_diis', True). # By default, use the neutral orbitals as a guess for the anion; neutral_guess = kwargs.get('neutral_guess', True). # By default, burn-in with UHF first, if UKS; hf_guess = Fals",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:3719,charge,chargep,3719,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,16,['charge'],"['chargem', 'chargep']"
Energy Efficiency,"ionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:78622,energy,energypiece,78622,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,6,['energy'],['energypiece']
Energy Efficiency,"ionname; Name of the CBS component (e.g., 'MP2') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation.; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.0`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [5]_:; :math:`E_{corl}^X = E_{corl}^{\infty} + \beta X^{-alpha}`. References; ----------. .. [5] Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson,; Chem. Phys. Lett. 286 (1998) 243-252,; DOI: 10.1016/S0009-2614(99)00179-7. Examples; --------; >>> # [1] CISD extrapolation; >>> energy('cbs', corl_wfn='cisd', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2'). """"""; if type(valueLO) != type(valueHI):; raise ValidationError(; f""corl_xtpl_helgaker_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 3.0. if isinstance(valueLO, float):; value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = f""""""\n\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n\n""""""; cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % alpha; cbsscheme += f"""""" Beta (coefficient) Value: {beta: 16.12f}\n\n""""""; cbsscheme += """""" Extrapolated Energy: % 16.12f\n\n"""""" % value; # Note that in energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:18884,energy,energy,18884,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,8,['energy'],['energy']
Energy Efficiency,"ions at Quick Installation),; PCMSolver can be obtained through conda install pcmsolver -c psi4.; Then enable it as a feature with ENABLE_PCMSolver,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect PCMSolver and activate dependent code. Previous bullet had details. To build PSI4 from source and use; pcmsolver from conda without thinking, consult sec:condapsi4dev. To remove a conda installation, conda remove pcmsolver. Source. If using PSI4 built from source and you want PCMSolver built from; from source also,; enable it as a feature with ENABLE_PCMSolver,; and let the build system fetch and build it and activate dependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option |globals__pcm_scf_type| with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging. Note; At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104].; All ERI algorithms (PK, OUT_OF_CORE, DIRECT, DF, CD) are supported. Warning; The PCMSolver library cannot exploit molecular point group symmetry. Warning; ROHF with PCM is known not to work. See issue #999 on GitHub.; For the adventurous, a fix is available in pull request #953 on GitHub. Warning; Analytic gradients and Hessians are not available with PCM. Finite differences will be used; regardless of the dertype passed to the optimize function.; See pcmsolver/opt-fd for a sample input. The PCM model and molecular cavity are specified in a pcm section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of PSI4 and is fully documented; here; A typical input for a Har",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/pcmsolver-1.html:2027,charge,charges,2027,psi4manual/1.3.2/pcmsolver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/pcmsolver-1.html,2,['charge'],['charges']
Energy Efficiency,"ions import ValidationError, TestComparisonError. [docs]def fcidump(wfn, fname='INTDUMP', oe_ints=None):; """"""Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989); Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. :returns: None. :raises: ValidationError when SCF wavefunction is not RHF. :type wfn: :py:class:`~psi4.core.Wavefunction`. :param wfn: set of molecule, basis, orbitals from which to generate cube files; :param fname: name of the integrals file, defaults to INTDUMP; :param oe_ints: list of additional one-electron integrals to save to file. So far only EIGENVALUES is a valid option. :examples:. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.doccpi(); frzcpi = wfn.frzcpi(); frzvpi = wfn.frzvpi(); active_docc = docc - frzcpi; active_socc = wfn.soccpi(); active_mopi = wfn.nmopi() - frzcpi - frzvpi. nbf = active_mopi.sum() if wfn.same_a_b_orbs() else 2 * active_mopi.sum(); nirrep = wfn.nirrep(); nelectron = 2 * active_docc.sum() + active_socc.sum(); irrep_map = _irrep_map(wfn). wfn_irrep = 0; for h, n_socc in enumerate(active_socc):; if n_socc % 2 == 1:; wfn_irrep ^= h. core.print_out('Writing integrals in FCIDUMP format to ' + fname + '\n'); # Generate FCIDUMP header; header = '&FCI\n'; header += 'NORB={:d},\n'.format(nbf); header += ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html:2440,energy,energy,2440,psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fcidump.html,6,['energy'],['energy']
Energy Efficiency,"ions of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. scf-ecp3; Water-Argon complex with ECP present; check of UHF Hessian. cdoremp-energy2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. fnocc5; Test FNO-DF-CCSD(T) energy. mints-benchmark; run some BLAS benchmarks. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. mbis-1; MBIS calculation on H2O. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. dft-reference; MP2 with a PBE0 reference computation. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. cubeprop-esp; RHF orbitals and density for water. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. linK-2; RKS Linear Exchange Algorithm test for benzene. opt15; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:30148,energy,energy,30148,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ions of the two; monomers and for the dimer). The next keyword tells PSI4 to run; in C1 point-group symmetry (i.e., without using symmetry), even if a; higher symmetry is detected. SAPT computations know to turn off; symmetry and fix orientation even without the user specifying these; molecule keywords.; Here’s the second half of the input:; set globals {; basis jun-cc-pVDZ; scf_type DF; freeze_core True; }. energy('sapt0'). Before, we have been setting keywords individually with commands like; set basis cc-pVDZ. Because we have a few more options now, it’s; convenient to place them together into the set globals or set; block, bounded by {...}. This; will set all of these options as “global” options (meaning that they are; visible to all parts of the program). Most common PSI4 options can be; set in a globals section like this. If an option needs to be visible; only to one part of the program (e.g., we only want to increase the; energy convergence in the SCF code, but not the rest of the; code), it can be placed in a section of input visible to that part of the; program (e.g., set scf e_convergence 1.0E-8).; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; [Hohenstein:2012:WIREs] with the jun-cc-pVDZ basis (this is the; usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and; without diffuse functions on heavy atoms) [Papajak:2011:10]. So,; we’ll use that as our standard basis set. The SAPT code is designed to; use density fitting techniques, because they introduce minimal errors; whil providing much faster computations [Hohenstein:2010:184111]; [Hohenstein:2010:014101]. Since we’re using density fitting for the SAPT,; we might as well also use it for the Hartree–Fock computations that are; performed as part of the SAPT. We can specify that with; scf_type DF.; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortuna",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:10112,energy,energy,10112,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,4,['energy'],['energy']
Energy Efficiency,"ions, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set globals basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn = True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""MP2/cc-pV[DT]Z""). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody._nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). for precallback in hooks['energy']['pre']:; precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if restartfile != list(restartfile):; restartfile = [restartfile]; # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; name_split = re.s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:29196,energy,energy,29196,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"ions,; the dftd3/PSI4 interface enables computations of three-body dispersion; corrections. In DFT-D3, three-body dispersion is approximated with the; Axilrod-Teller-Muto model:. \[E_{disp}^{(3)}=-\frac{1}{6}\sum_{A\neqB\neqC}\frac{C_{9}^{ABC}(3\cos{\theta_a}\cos{\theta_b}\cos{\theta_c}+1)}{(r_{AB}r_{BC}r_{AC})^{3}}f_{damp}(\bar{r}_{ABC})\]; where \(\theta_a\) is the angle at atom A corresponding to the triangle formed by atoms A, B, and C,; and \(\bar{r}_{ABC}\) is the geometric mean of the corresponding atomic-pair distances.; The dispersion coefficients are defined as. \[C_{9}^{ABC} = \sqrt{C_{6}^{AB}C_{6}^{BC}C_{6}^{AC}}\]; See the DFT-D3 documentation; for more details.; For now, the three-body correction can be called by using the run_dftd3(); function with d3-atmgr as the passed functional string.; For example, the three-body ATM dispersion correction for a neon trimer could; be computed with:; molecule ne3 {; Ne 0.0 0.0 0.0; Ne 0.0 0.0 1.0; Ne 0.0 1.0 1.0; }; ne.update_geometry(); energy = m.run_dftd3('d3-atmgr', dertype=0); print(energy). Footnotes. 1; Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, won’t follow this table exactly. 2; [Grimme:2004:1463]. 3; [Grimme:2006:1787]. 4; [Grimme:2010:154104]. 5; [Grimme:2011:1456]. 6(1,2); [Smith:2016:2197]. 7; [Hujo:2011:3866]. 8; [Chai:2010:6615]. 9; [Pernal:2009:263201]. 10; [Podeszwa:2010:550]. 11; Keyword not used for user-defined functionals where the dft_dict[""dispersion""][""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. 12; [Caldeweyher:2019:154122]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four valu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/dftd3-1.html:8074,energy,energy,8074,psi4manual/1.5.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/dftd3-1.html,3,['energy'],['energy']
Energy Efficiency,"ions,; the dftd3/PSI4 interface enables computations of three-body dispersion; corrections. In DFT-D3, three-body dispersion is approximated with the; Axilrod-Teller-Muto model:. \[E_{disp}^{(3)}=-\frac{1}{6}\sum_{A\neqB\neqC}\frac{C_{9}^{ABC}(3\cos{\theta_a}\cos{\theta_b}\cos{\theta_c}+1)}{(r_{AB}r_{BC}r_{AC})^{3}}f_{damp}(\bar{r}_{ABC})\]; where \(\theta_a\) is the angle at atom A corresponding to the triangle formed by atoms A, B, and C,; and \(\bar{r}_{ABC}\) is the geometric mean of the corresponding atomic-pair distances.; The dispersion coefficients are defined as. \[C_{9}^{ABC} = \sqrt{C_{6}^{AB}C_{6}^{BC}C_{6}^{AC}}\]; See the DFT-D3 documentation; for more details.; For now, the three-body correction can be called by using the run_dftd3(); function with d3-atmgr as the passed functional string.; For example, the three-body ATM dispersion correction for a neon trimer could; be computed with:; molecule ne3 {; Ne 0.0 0.0 0.0; Ne 0.0 0.0 1.0; Ne 0.0 1.0 1.0; }; ne.update_geometry(); energy = m.run_dftd3('d3-atmgr', dertype=0); print(energy). Footnotes. 1; Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, won’t follow this table exactly. 2; [Grimme:2004:1463]. 3; [Grimme:2006:1787]. 4; [Grimme:2010:154104]. 5; [Grimme:2011:1456]. 6(1,2); [Smith:2016:2197]. 7; [Hujo:2011:3866]. 8; [Chai:2010:6615]. 9; [Pernal:2009:263201]. 10; [Podeszwa:2010:550]. 11; Keyword not used for user-defined functionals where the dft_dict[""dispersion""][""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_paramet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dftd3-1.html:7779,energy,energy,7779,psi4manual/1.4.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dftd3-1.html,2,['energy'],['energy']
Energy Efficiency,"ions,; the dftd3/PSI4 interface enables computations of three-body dispersion; corrections. In DFT-D3, three-body dispersion is approximated with the; Axilrod-Teller-Muto model:. \[E_{disp}^{(3)}=-\frac{1}{6}\sum_{A\neqB\neqC}\frac{C_{9}^{ABC}(3\cos{\theta_a}\cos{\theta_b}\cos{\theta_c}+1)}{(r_{AB}r_{BC}r_{AC})^{3}}f_{damp}(\bar{r}_{ABC})\]; where \(\theta_a\) is the angle at atom A corresponding to the triangle formed by atoms A, B, and C,; and \(\bar{r}_{ABC}\) is the geometric mean of the corresponding atomic-pair distances.; The dispersion coefficients are defined as. \[C_{9}^{ABC} = \sqrt{C_{6}^{AB}C_{6}^{BC}C_{6}^{AC}}\]; See the DFT-D3 documentation; for more details.; For now, the three-body correction can be called by using the run_dftd3(); function with d3-atmgr as the passed functional string.; For example, the three-body ATM dispersion correction for a neon trimer could; be computed with:; molecule ne3 {; Ne 0.0 0.0 0.0; Ne 0.0 0.0 1.0; Ne 0.0 1.0 1.0; }; ne.update_geometry(); energy = m.run_dftd3('d3-atmgr', dertype=0); print(energy). Since v1.7, it is preferred to use s-dftd3 for ATM since the 3-body can be run concurrent; with the 2-body contribution.; Footnotes. [1]; Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, won’t follow this table exactly. [2]; [Grimme:2004:1463]. [3]; [Grimme:2006:1787]. [4]; (1,2); [Grimme:2010:154104]. [5]; (1,2); [Grimme:2011:1456]. [6]; (1,2,3,4); [Smith:2016:2197]. [7]; [Hujo:2011:3866]. [8]; [Chai:2010:6615]. [9]; [Pernal:2009:263201]. [10]; [Podeszwa:2010:550]. [11]; Keyword not used for user-defined functionals where the dft_dict[""dispersion""][""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. [12]; [Caldeweyher:2019:154122]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimizati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dftd3.html:10820,energy,energy,10820,psi4manual/1.7.x/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dftd3.html,2,['energy'],['energy']
Energy Efficiency,"ions. Basis Set Superposition Corrections¶; Code author: Daniel G. A. Smith. psi4.driver.driver_nbody.nbody(func, method_string[, molecule, bsse_type, max_nbody, ptype, return_total_data])[source]¶; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. Returns; return type of func – The data. Returns; (float, Wavefunction) – data and wavefunction with energy/gradient/hessian set appropriately when return_wfn specified. Parameters. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element of a tuple. bsse_type (str or list) – 'cp' || ['nocp', 'vmfc'] || \(\Rightarrow\) None \(\Leftarrow\) || etc.; Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, many-body treatments are inactive. max_nbody (int) – 3 || etc.; Maximum n-body to compute, cannot exceed the number of fragments in the molecule. return_total_data (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is 'off' for energies,; 'on' for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying return_total_data = True; may carry out more computations than return_total_data = False.; For gradients and Hessians, return_total_data = False is rarely useful. levels (dict) – {1: 'ccsd(t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/nbody.html:1205,energy,energy,1205,psi4manual/1.6.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html,1,['energy'],['energy']
Energy Efficiency,"ions. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]¶; Function to perform a geometry optimization. Aliases:opt(). Returns:float – Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimization",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/opt-1.html:1612,energy,energy,1612,psi4manual/1.3.2/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/opt-1.html,2,['energy'],['energy']
Energy Efficiency,"ions. Behind; the scenes, optimize() is a wrapper that repeatedly; calls gradient() that computes the gradient then adds a; call to the geometry optimization module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]¶; Function to perform a geometry optimization. Aliases:opt(). Returns:float – Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/opt-1.html:1612,energy,energy,1612,psi4manual/1.2.1/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/opt-1.html,2,['energy'],['energy']
Energy Efficiency,"ions. EFP TORQUE¶; The torque, not gradient for EFP/EFP computations. ENTHALPY¶; Total enthalpy H [E_h] at given temperature. ENTHALPY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the enthalpy at given temperature. ESP AT CENTER n¶; Property of electrostatic potential [E_h / e] at location, usually atom center, n. FCI TOTAL ENERGY¶. FCI CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the full configuration interaction level of theory. GIBBS FREE ENERGY¶; Total Gibbs free energy [E_h], free enthalpy at given temperature. GIBBS FREE ENERGY CORRECTION¶; Sum of electronic, translational, rotational, and vibrational corrections [E_h] to the free enthalpy at given temperature. GRID ELECTRONS TOTAL¶. GRID ELECTRONS ALPHA¶. GRID ELECTRONS BETA¶; The number of electrons integrated by the xc quadrature grid. HF TOTAL ENERGY¶; The total electronic energy [E_h] for the Hartree–Fock method, without; any dispersion correction; the first three (or four, since; \(E_{xc} = 0\)) terms in Eq. (4). Quantity \(E_{\text{HF}}\); in Eq. (4). HF KINETIC ENERGY¶; The total kinetic energy [E_h] of the Hartree–Fock method. HF POTENTIAL ENERGY¶; The total potential energy [E_h] of the Hartree–Fock method. HF VIRIAL RATIO¶; The virial ratio of the Hartree–Fock method. Only defined for a fully quantum mechanical computation, i.e., not QM/MM. HF TOTAL GRADIENT¶; The total electronic gradient [E_h/a0] of the Hartree–Fock method, ({nat}, 3). HF DIPOLE GRADIENT¶; The derivative of the Hartree–Fock method dipole [E_h a0/u] = [(e a0/a0)^2/u] with respect to nuclear perturbations; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). HF TOTAL HESSIAN¶; The total electronic second derivative [E_h/a0/a0] for the Hartree-Fock method, (3 * {nat}, 3 * {nat}). LCCD TOTAL ENERGY¶. LCCD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the linearized c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html:32166,energy,energy,32166,psi4manual/1.7.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/glossary_psivariables.html,4,['energy'],['energy']
Energy Efficiency,"ions. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/sapt-1.html:12431,energy,energy,12431,psi4manual/4.0b2/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html,30,['energy'],['energy']
Energy Efficiency,"ions; need to be solved, which makes the computation of the analytic gradients very; efficient. Analytic gradients are not available for the three-particle energy; correction . Methods Summary¶; The table below summarizes current DCFT code features:. Method; Available algorithms; Energy; Gradient; Reference. ODC-06; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-12; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-13; SIMULTANEOUS, QC; Y; Y; UHF. SIMULTANEOUS, QC; Y; N; UHF. SIMULTANEOUS, QC; Y; N; UHF. DC-06; SIMULTANEOUS, QC, TWOSTEP; Y; Y; UHF. DC-12; SIMULTANEOUS, QC, TWOSTEP; Y; N; UHF. Note that for ODC-06 and ODC-12 REFERENCE = RHF is only available for; ALGORITHM = SIMULTANEOUS. To compute correction,; the THREE_PARTICLE option needs to be set to PERTURBATIVE. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. energy('dcft'). The energy('dcft') call to energy() executes the DCFT; module, which will first call the SCF module and perform the SCF computation; with RHF reference to obtain a guess for the DCFT orbitals. After SCF is; converged, the program will perform the energy computation using the ODC-12; method. By default, simultaneous algorithm will be used for the solution of; the equations. One can also request to perform geometry; optimization following example below:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the ODC-12 energy. After that, the ODC-12 analytic; gradients code will be executed and geometry optimization will be performed. Recommendations¶; Here is a list of recommendations for the DCFT module:. Generally, the use of the simultaneous algorithm together with the; AO_BASIS = DISK option is recommended (set by default).; In cases when available memory is insufficient, the use of the AO_BASIS = DISK option; is recommended. This will significantly reduce the memory requirem",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:12692,energy,energy,12692,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,4,['energy'],['energy']
Energy Efficiency,"ions_projection_sound_grad = translations_projection_sound; rotations_projection_sound_hess = translations_projection_sound and stationary_point; if core.has_option_changed('FINDIF', 'FD_PROJECT'):; r_project_grad = core.get_option('FINDIF', 'FD_PROJECT'); r_project_hess = core.get_option('FINDIF', 'FD_PROJECT'); else:; r_project_grad = rotations_projection_sound_grad; r_project_hess = rotations_projection_sound_hess. for kwg in ['dft_functional']:; if kwg in data:; data['keywords']['function_kwargs'][kwg] = data.pop(kwg); # I have the feeling the keywords.function_kwargs should be all left over in data; # after the findif control ones are removed, not this by-name procedure; data['keywords']['PARENT_SYMMETRY'] = self.molecule.point_group().full_name(). self.method = data['method']. self.metameta['mode'] = str(data['findif_mode'][0]) + '_' + str(data['findif_mode'][1]); self.metameta['irrep'] = data.pop('findif_irrep', -1). if self.metameta['mode'] == '1_0':; self.metameta['proxy_driver'] = 'energy'; self.findifrec = gradient_from_energies_geometries(self.molecule,; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_grad). elif self.metameta['mode'] == '2_1':; self.metameta['proxy_driver'] = 'gradient'; self.findifrec = hessian_from_gradients_geometries(self.molecule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). elif self.metameta['mode'] == '2_0':; self.metameta['proxy_driver'] = 'energy'; self.findifrec = hessian_from_energies_geometries(self.molecule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). ndisp = len(self.findifrec[""displacements""]) + 1; info = f"""""" {ndisp} displacements needed ...\n""""""; core.print_out(info); logger.debug(info)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:43213,energy,energy,43213,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,8,['energy'],['energy']
Energy Efficiency,ionship; 1.5198298460088E-16; hertz-hartree relationship [E_h] uncertainty=0.000 000 000 0090 e-16. hertz_inverse_meter_relationship; 3.335640951E-9; hertz-inverse meter relationship [m^{-1}] uncertainty=(exact). hertz_joule_relationship; 6.626070040E-34; hertz-joule relationship [J] uncertainty=0.000 000 081 e-34. hertz_kelvin_relationship; 4.7992447E-11; hertz-kelvin relationship [K] uncertainty=0.000 0028 e-11. hertz_kilogram_relationship; 7.372497201E-51; hertz-kilogram relationship [kg] uncertainty=0.000 000 091 e-51. inverse_fine_structure_constant; 137.035999139; inverse fine-structure constant [] uncertainty=0.000 000 031. inverse_meter_atomic_mass_unit_relationship; 1.33102504900E-15; inverse meter-atomic mass unit relationship [u] uncertainty=0.000 000 000 61 e-15. inverse_meter_electron_volt_relationship; 0.0000012398419739; inverse meter-electron volt relationship [eV] uncertainty=0.000 000 0076 e-6. inverse_meter_hartree_relationship; 4.556335252767E-8; inverse meter-hartree relationship [E_h] uncertainty=0.000 000 000 027 e-8. inverse_meter_hertz_relationship; 299792458; inverse meter-hertz relationship [Hz] uncertainty=(exact). inverse_meter_joule_relationship; 1.986445824E-25; inverse meter-joule relationship [J] uncertainty=0.000 000 024 e-25. inverse_meter_kelvin_relationship; 0.0143877736; inverse meter-kelvin relationship [K] uncertainty=0.000 000 83 e-2. inverse_meter_kilogram_relationship; 2.210219057E-42; inverse meter-kilogram relationship [kg] uncertainty=0.000 000 027 e-42. inverse_of_conductance_quantum; 12906.4037278; inverse of conductance quantum [ohm] uncertainty=0.000 0029. Josephson_constant; 4.835978525E+14; Josephson constant [Hz V^{-1}] uncertainty=0.0030 e9. joule_atomic_mass_unit_relationship; 6700535363; joule-atomic mass unit relationship [u] uncertainty=0.000 000 082 e9. joule_electron_volt_relationship; 6.241509126E+18; joule-electron volt relationship [eV] uncertainty=0.000 000 038 e18. joule_hartree_relationship; 2.2937123,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:17096,meter,meter-hartree,17096,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['meter'],['meter-hartree']
Energy Efficiency,ionship; 6.626070040E-34; hertz-joule relationship [J] uncertainty=0.000 000 081 e-34. hertz_kelvin_relationship; 4.7992447E-11; hertz-kelvin relationship [K] uncertainty=0.000 0028 e-11. hertz_kilogram_relationship; 7.372497201E-51; hertz-kilogram relationship [kg] uncertainty=0.000 000 091 e-51. inverse_fine_structure_constant; 137.035999139; inverse fine-structure constant [] uncertainty=0.000 000 031. inverse_meter_atomic_mass_unit_relationship; 1.33102504900E-15; inverse meter-atomic mass unit relationship [u] uncertainty=0.000 000 000 61 e-15. inverse_meter_electron_volt_relationship; 0.0000012398419739; inverse meter-electron volt relationship [eV] uncertainty=0.000 000 0076 e-6. inverse_meter_hartree_relationship; 4.556335252767E-8; inverse meter-hartree relationship [E_h] uncertainty=0.000 000 000 027 e-8. inverse_meter_hertz_relationship; 299792458; inverse meter-hertz relationship [Hz] uncertainty=(exact). inverse_meter_joule_relationship; 1.986445824E-25; inverse meter-joule relationship [J] uncertainty=0.000 000 024 e-25. inverse_meter_kelvin_relationship; 0.0143877736; inverse meter-kelvin relationship [K] uncertainty=0.000 000 83 e-2. inverse_meter_kilogram_relationship; 2.210219057E-42; inverse meter-kilogram relationship [kg] uncertainty=0.000 000 027 e-42. inverse_of_conductance_quantum; 12906.4037278; inverse of conductance quantum [ohm] uncertainty=0.000 0029. Josephson_constant; 4.835978525E+14; Josephson constant [Hz V^{-1}] uncertainty=0.0030 e9. joule_atomic_mass_unit_relationship; 6700535363; joule-atomic mass unit relationship [u] uncertainty=0.000 000 082 e9. joule_electron_volt_relationship; 6.241509126E+18; joule-electron volt relationship [eV] uncertainty=0.000 000 038 e18. joule_hartree_relationship; 2.293712317E+17; joule-hartree relationship [E_h] uncertainty=0.000 000 028 e17. joule_hertz_relationship; 1.509190205E+33; joule-hertz relationship [Hz] uncertainty=0.000 000 019 e33. joule_inverse_meter_relationship; 5.034116651E+24; jou,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html:17327,meter,meter-joule,17327,psi4manual/1.3.2/autodoc_physconst-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_physconst-1.html,11,['meter'],['meter-joule']
Energy Efficiency,"ious constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. ddd-deriv; Sample HF/cc-pVDZ H2O computation all derivatives. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. dft-smoke; DFT Functional Smoke Test. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. mbis-4; MBIS calculation on NaCl. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dct10; The multiple guesses for DCT amplitudes for ODC-12. nbody-vmfc-hessian; Computation of VMFC-corrected water trimer Hessian (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. mom-h2o-4; MOM excitation from LUMO HOMO+4. fci-h2o; 6-31G H2O Test FCI Energy Point. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:39568,energy,energy,39568,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ious_e = energy_body_dict[nb]; else:; info += f"""""" {lbl:>8} {nb:3} {""N/A"":20} {""N/A"":20} {""N/A"":20} {""N/A"":20} {""N/A"":20}\n"""""". info += ""\n""; core.print_out(info); logger.info(info). def build_nbody_compute_list(; bsse_type: List[BsseEnum],; nbodies: List[Union[int, Literal[""supersystem""]]],; nfragments: int,; return_total_data: bool,; verbose: int = 1,; ) -> Dict[str, Dict[int, Set[FragBasIndex]]]:; """"""Generates lists of N-Body computations needed for requested BSSE treatments. Parameters; ----------; bsse_type; Requested BSSE treatments.; nbodies; List of n-body levels (e.g., `[2]` or `[1, 2]` or `[""supersystem""]`) for which to generate tasks.; Often this value is an element of self.nbodies_per_mc_level.; Note the natural 1-indexing, so `[1]` covers one-body contributions.; Formerly nbody; nfragments; Number of distinct fragments comprising the full molecular supersystem. Usually self.nfragments.; Formerly max_frag; return_total_data; Whether the total data (True; energy/gradient/Hessian) of the molecular system has been requested, as opposed to interaction data (False).; verbose; Control volume of printing. Returns; -------; compute_dict; Dictionary containing subdicts enumerating compute lists for each possible BSSE treatment.; Subdict keys are n-body levels and values are sets of all the `mc_(frag, bas)` indices; needed to compute that n-body level. A given index can appear multiple times within a; subdict and among subdicts.; Formerly, the subdict values were sets of indices needed for given BSSE treatment _of_ given; n-body level. See current (left) and former (right) definitions below for CP dimer. compute_dict[""cp""] = { compute_dict[""cp""] = {; 1: set(), 1: {((1,), (1, 2)),; 2: {((1,), (1, 2)), ((2,), (1, 2))},; ((2,), (1, 2)), 2: {((1, 2), (1, 2))}; ((1, 2), (1, 2))} }; }. Subdicts below are always returned. Any may be empty if not requested through *bsse_type*. * ``'all'`` |w---w| full list of computations required; * ``'cp'`` |w---w| list of computations ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:16086,energy,energy,16086,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,10,['energy'],['energy']
Energy Efficiency,"iplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF); MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DOMAIN_PRINT (CCENERGY); CCENERGY — Do print the domains?. Type: boolean; Default: false. DOMAIN_PRINT_EXIT (CCENERGY); CCENERGY — Do exit after printing the domains?. Type: boolean; Default: false. DOMAINS (CCENERGY); CCENERGY —. Type: array; Default: No Default. E3_SCALE (OCC); OCC — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for energy (change). See Table// Post-SCF Convergence for default convergence// criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DETCI); DETCI — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (FNOCC); FNOCC — Convergence criterion for CC energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Note that convergence is met only when E_CONVERGENCE and R_CONVERGENCE are satisfied. Type: conv double; Default: 1.0e-6. E_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for energy. Type: conv double; Default: 1e-6. E_CONVERGENCE (MRCC); MRCC — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. This becomes tol (option #16) in fort.56. Type: conv double; Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:37407,energy,energy,37407,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,"iplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible \(M_s\) value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; 1; 2; 3; 4; 5; 6; 7mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fragmented. Advanced Python¶; A named molecule in an input file is a full-fledged instance of the; powerful C++ Molecule class. Thus, all member; functions (that have been exported via pybind11) documented thereat; are accessible through the handle option_molecule_name in; molecule optional_molecule_name {...}. The molecular geometry can be got and set and manipulated as a; Matrix object. Below shows how to access; coordinates in an input file in Python.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:16469,energy,energy,16469,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['energy'],['energy']
Energy Efficiency,"ir domains. Type: string; Default: NONE. LOCAL_PAIRDEF (CCSORT); CCSORT — Definition of local pair domains, unique avaliable option is BP, Boughton-Pulay. Type: string; Default: BP. LOCAL_PRECONDITIONER (CCEOM); CCEOM — Preconditioner will be used in local CC computations. Type: string; Possible Values: HBAR, FOCK; Default: HBAR. LOCAL_WEAKP (CCENERGY); CCENERGY — Desired treatment of “weak pairs” in the local-CIS method. A value of// NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in// the same manner as strong pairs. A value of MP2 uses second-order perturbation// theory to correct the local-CIS energy computed with weak pairs ignored. Type: string; Possible Values: MP2, NEGLECT, NONE; Default: MP2. LOCAL_WEAKP (CCEOM); CCEOM — Desired treatment of “weak pairs” in the local-CCSD method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, MP2, NEGLECT; Default: NONE. LOCAL_WEAKP (CCLAMBDA); CCLAMBDA — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CCRESPONSE); CCRESPONSE — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CCSORT); CCSORT — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCK_OCC (DCFT); DCFT (Expert) — Controls whether to force the occupation to be that of the SCF guess. For practical applications only the default must be used. Type: boolean; Default: true. LOCK_SINGLET (PS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:70825,energy,energy,70825,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['energy'],['energy']
Energy Efficiency,ir functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n DIPOLE X¶. CC ROOT n DIPOLE Y¶. CC ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root n (number starts at GS = 0). CC ROOT n QUADRUPOLE XX¶. CC ROOT n QUADRUPOLE XY¶. CC ROOT n QUADRUPOLE XZ¶. CC ROOT n QUADRUPOLE YY¶. CC ROOT n QUADRUPOLE YZ¶. CC ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root n (numbering starts at GS = 0). CC ROOT n TOTAL ENERGY¶. CC ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC T1 DIAGNOSTIC¶. CC D1 DIAGNOSTIC¶. CC NEW D1 DIAGNOSTIC¶. CC D2 DIAGNOSTIC¶; Diagnostic of multireference character. CC2 TOTAL ENERGY¶. CC2 CORRE,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html:2083,energy,energy,2083,psi4manual/1.2.1/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency,ir functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n DIPOLE X¶. CC ROOT n DIPOLE Y¶. CC ROOT n DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root n (number starts at GS = 0). CC ROOT n QUADRUPOLE XX¶. CC ROOT n QUADRUPOLE XY¶. CC ROOT n QUADRUPOLE XZ¶. CC ROOT n QUADRUPOLE YY¶. CC ROOT n QUADRUPOLE YZ¶. CC ROOT n QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root n (numbering starts at GS = 0). CC ROOT n TOTAL ENERGY¶. CC ROOT n CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERG,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:2081,energy,energy,2081,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,4,['energy'],['energy']
Energy Efficiency,"ir functional level of theory. ACPF TOTAL ENERGY¶. ACPF CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged coupled-pair functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:2133,energy,energy,2133,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,16,['energy'],['energy']
Energy Efficiency,"ir functional level of theory. AQCC DIPOLE X¶. AQCC DIPOLE Y¶. AQCC DIPOLE Z¶; The three components of the dipole [Debye] for the; averaged quadratic coupled-cluster level of theory. AQCC QUADRUPOLE XX¶. AQCC QUADRUPOLE XY¶. AQCC QUADRUPOLE XZ¶. AQCC QUADRUPOLE YY¶. AQCC QUADRUPOLE YZ¶. AQCC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; averaged quadratic coupled-cluster level of theory. AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [H] and its breakdown into reference total; energy [H] and correlation correction components [H] for the compound; method requested through cbs(). CC ROOT n TOTAL ENERGY¶; The total electronic energy [H]; for the requested coupled cluster level of theory and root; n (numbering starts at GS = 0). CC TOTAL ENERGY¶. CC CORRELATION ENERGY¶. CC2 TOTAL ENERGY¶. CC2 CORRELATION ENERGY¶. CC3 TOTAL ENERGY¶. CC3 CORRELATION ENERGY¶. CC4 TOTAL ENERGY¶. CC4 CORRELATION ENERGY¶. CCnn TOTAL ENERGY¶. CCnn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the requested approximate coupled-cluster (CC2, CC3, up to CCnn); level of theory. CC DIPOLE X¶. CC DIPOLE Y¶. CC DIPOLE Z¶; The three components of the dipole [Debye] for the requested; coupled cluster level of theory and root. CC QUADRUPOLE XX¶. CC QUADRUPOLE XY¶. CC QUADRUPOLE XZ¶. CC QUADRUPOLE YY¶. CC QUADRUPOLE YZ¶. CC QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the requested; coupled cluster level of theory and root. CCSD TOTAL ENERGY¶. CCSD CORRELATION ENERGY¶. CCSDT TOTAL ENERGY¶. CCSDT CORRELATION ENERGY¶. CCSDTQ TOTAL ENERGY¶. CCSDTQ CORRELATION ENERGY¶. CCn TOTAL ENERGY¶. CCn CORRELATIO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:2333,energy,energy,2333,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,8,['energy'],['energy']
Energy Efficiency,"irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. dft-custom-mgga; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). fnocc3; Test FNO-QCISD(T) computation. scf3; File retention, docc, socc, and bond distances specified explicitly. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. dfcasscf-sp; CASSCF/6-31G** energy point. opt10; 6-31G MP2 transition-state optimization with initial, computed Hessian. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. pubchem2; Superficial test of PubChem interface. omp2p5-1; OMP2 cc-pVDZ energy for the H2O molecule. ao-dfcasscf-sp; CASSCF/6-31G** energy point. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dcft7; DCFT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. pywrap-align-chiral; testing aligner on enantiomers based on Table 1 of 10.1021/ci100219f aka J Chem Inf Model 2010 50(12) 2129-2140. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:23794,energy,energy,23794,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,8,['energy'],['energy']
Energy Efficiency,"irecting to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; # ROHF MRCC CC3 CCn methods are not implemented for ROHF reference!; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mrcc(name, **kwargs):; """"""Function selecting the algorithm for a CC* energy call; and directing to specified MRCC module. This function is unusual among ""select"" functions in that it services multiple methods and a; single module. This function could have been skipped and the methods associated directly with; run_rmcc; however, routing through this function screens for conv only while; providing uniform error messages with other select functions. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # todo fix table link anchor. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc. if func is No",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:37082,energy,energy,37082,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['energy'],['energy']
Energy Efficiency,"ired, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages’; strengths and improves maintainability of the code. table of contents. Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Easier and more rapid development; Rapid initial development using Psi4NumPy; Avoiding the need to modify Psi4, using plugins; Incorporating code into PSI4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. © Copyright 20",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_ways_to_add.html:5905,energy,energy,5905,psi4manual/master/prog_ways_to_add.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_ways_to_add.html,1,['energy'],['energy']
Energy Efficiency,"ired, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages’; strengths and improves maintainability of the code. table of contents. Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Easier and more rapid development; Rapid initial development using Psi4NumPy; Avoiding the need to modify Psi4, using plugins; Incorporating code into PSI4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. © Copyright 2021, The P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html:5896,energy,energy,5896,psi4manual/1.4.0/prog_ways_to_add-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html,2,['energy'],['energy']
Energy Efficiency,"ired, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages’; strengths and improves maintainability of the code. table of contents. Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Easier and more rapid development; Rapid initial development using Psi4NumPy; Avoiding the need to modify Psi4, using plugins; Incorporating code into PSI4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. © Copyright 2021, The P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/prog_ways_to_add-1.html:5896,energy,energy,5896,psi4manual/1.5.0/prog_ways_to_add-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/prog_ways_to_add-1.html,2,['energy'],['energy']
Energy Efficiency,"ired, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages’; strengths and improves maintainability of the code. table of contents. Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Easier and more rapid development; Rapid initial development using Psi4NumPy; Avoiding the need to modify Psi4, using plugins; Incorporating code into PSI4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. © Copyright 2022, The P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html:5896,energy,energy,5896,psi4manual/1.6.x/prog_ways_to_add.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_ways_to_add.html,1,['energy'],['energy']
Energy Efficiency,"ired, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages’; strengths and improves maintainability of the code. table of contents. Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Easier and more rapid development; Rapid initial development using Psi4NumPy; Avoiding the need to modify Psi4, using plugins; Incorporating code into PSI4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. © Copyright 2007-2022, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/prog_ways_to_add.html:5896,energy,energy,5896,psi4manual/1.7.x/prog_ways_to_add.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/prog_ways_to_add.html,1,['energy'],['energy']
Energy Efficiency,"ired, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages’; strengths and improves maintainability of the code. table of contents. Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Easier and more rapid development; Rapid initial development using Psi4NumPy; Avoiding the need to modify Psi4, using plugins; Incorporating code into PSI4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. © Copyright 2007-2023",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/prog_ways_to_add.html:5898,energy,energy,5898,psi4manual/1.8.x/prog_ways_to_add.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/prog_ways_to_add.html,1,['energy'],['energy']
Energy Efficiency,"ired, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embedding potentials that could; enter the calculation. Allowing Python to handle only the details of driving; the SCF iterations, such as external potentials and convergence acceleration; methods, but deferring to C++ to do the heavy lifting for building and; diagonalizing the Fock matrix also takes advantage of the two languages’; strengths and improves maintainability of the code. table of contents. Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Easier and more rapid development; Rapid initial development using Psi4NumPy; Avoiding the need to modify Psi4, using plugins; Incorporating code into PSI4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Adding New Code to PSI4; Ways to Add Code: Psi4NumPy, Plugins, Full Integration. © Copyright 2007-2024",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/prog_ways_to_add.html:5898,energy,energy,5898,psi4manual/1.9.x/prog_ways_to_add.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/prog_ways_to_add.html,1,['energy'],['energy']
Energy Efficiency,"irrep. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. soscf2; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. dft1-alt; DFT Functional Test. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. dcft-grad3; Restricted DF-DCFT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. cc13d; Tests analytic CC2 gradients. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. omp2-3; OMP2 cc-pVDZ energy for the NO radical. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:4761,charge,charge,4761,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,8,"['charge', 'energy']","['charge', 'energy']"
Energy Efficiency,irst argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; :param delta2_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta3_wfn: string; :param delta3_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta3_wfn_lesser: string; :param delta3_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. :type delta4_wfn: string; :param delta4_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta4_wfn_lesser: string; :param delta4_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t)'`` || etc. Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. :type delta5_wfn: string; :param delta5_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. :type delta5_wfn_lesser: string; :param delta5_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd(t,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:56688,energy,energy,56688,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,4,['energy'],['energy']
Energy Efficiency,"irst is CMakeLists.txt, which is necessary to add the test case to the suite. This file should have the following lines:; include(TestingMacros). add_regression_test(directory_name ""psi;semicolon_separated-list-of-applicable-test-labels""). The labels specify which groups of tests include the test case. The psi label should always be added, but the other labels are test-specific. The method tested should always be included, and this is often sufficient. If adding a test for an already existing module, the labels for other tests of the module will suggest other labels to add.; A test requiring over 15 minutes should be labeled longtests. A short test under 30 seconds used for general bug checking should be labeled quicktests. A test that confirms PSI4 is operational should be labeled smoketests.; The other necessary file is the input file itself, input.dat. The input file should be just a simple input file to run the test, with small additions.; #! RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxiliary basis.; #! Also a bit more to force a second line. nucenergy = 8.801466202085710 #TEST; refenergy = -76.05098402733282 #TEST. molecule h2o {; symmetry c1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pVTZ; scf_type df; df_basis_scf cc-pVTZ-RI; e_convergence 10; }. thisenergy = energy(""hf""). compare_values(nucenergy, h2o.nuclear_repulsion_energy(), 9, ""Nuclear repulsion energy"") #TEST; compare_values(refenergy, thisenergy, 9, ""Reference energy"") #TEST; compare_values(refenergy, get_variable('scf total energy'), 9, ""Reference energy"") #TEST. Of those small modifications, first, note the special comment at the top (starting with the #! comment marker). This should be descriptive since it is inlined into the manual (unless !nosample in the comment) as a sample input.; The reference values are assigned to variables for later use. The compare_values function (along with several relatives in psi4/psi4/driver/p4util/testing.py for comparing strings, mat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/add_tests-1.html:1295,energy,energy,1295,psi4manual/1.4.0/add_tests-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/add_tests-1.html,4,['energy'],['energy']
Energy Efficiency,"irst one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). _filter_renamed_methods(""energy"", lowername). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). #for precallback in hooks['energy']['pre']:; # precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6); optstash2 = p4util.OptionsState(['SCF', 'GUESS']). # Before invoking the procedure, we rename any",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:34344,energy,energy,34344,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['energy'],['energy']
Energy Efficiency,"is (AO,SO). H(self); Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. PCM_enabled(self); Whether running a PCM calculation. S(self); Returns the One-electron Overlap Matrix. X(self); Returns the Lagrangian Matrix. alpha_orbital_space(self, arg0, arg1, arg2); docstring. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self, arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self, arg0, arg1, arg2, arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key). density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potenti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:1920,energy,energy,1920,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,1,['energy'],['energy']
Energy Efficiency,"is (see non-standard basis-set input). However, the latter must be available in the supplied GENBAS file. As standard basis sets, currently the following are available. Psi4 Interface: Recommended to use instead BASIS for larger basis set selection and greater flexibility. When BASIS used, CFOUR_SPHERICAL is set appropriately. Type: string; Default: SPECIAL. CFOUR_BRUCK_CONV (CFOUR)¶CFOUR — experimental use. Type: integer; Default: 4. CFOUR_BRUECKNER (CFOUR)¶CFOUR — Specifies whether Brueckner orbitals are to be determined for the specified CC method. OFF(=0) Brueckner orbitals are not to be determined, ON (=1) they are to be determined. Type: boolean; Default: false. CFOUR_CACHE_RECS (CFOUR)¶CFOUR — The number of records held in the i/o cache used by the post-SCF programs. The maximum number of records which can be held is 100. Type: integer; Default: 10. CFOUR_CALC_LEVEL (CFOUR)¶CFOUR — Defines the level of calculation to be performed. Psi4 Interface: Keyword set from argument of computation command: CCSD if energy('c4-ccsd'), etc. See Energy (CFOUR) and Gradient (CFOUR). for all available. Type: string; Default: SCF. CFOUR_CC_CONV (CFOUR)¶CFOUR — Specifies the convergence criterion for the CC amplitude equations. The amplitudes are considered to be converged when the maximum of all (absolute) changes in the amplitudes is less than \(10^N\), where \(N\) is the value associated with the keyword. Type: integer; Default: 7. CFOUR_CC_EXPORDER (CFOUR)¶CFOUR — Specifies the maximum number of expansion vectors used in the iterative subspace to enhance convergence in the solution of the CC equations. Type: integer; Default: 5. CFOUR_CC_EXTRAPOLATION (CFOUR)¶CFOUR — Specifies the type of convergence acceleration used to solve the CC equations. RLE (=0) uses the RLE methods of Purvis and Bartlett, DIIS (=1) uses the DIIS approach by Pulay, NOJACOBI (=2) uses RLE with continuous extrapolation, OFF (=3) uses no convergence acceleration. In general, DIIS provides the best resu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:25780,energy,energy,25780,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['energy'],['energy']
Energy Efficiency,"is H0_BLOCK. Defaults to 400. Note that the program may change the given size for Ms=0 cases (MS0 is TRUE) if it determines that the H0 block includes only one member of a pair of determinants related by time reversal symmetry. For very small block sizes, this could conceivably eliminate the entire H0 block; the program should print warnings if this occurs. Type: integer; Default: 400. H0_GUESS_SIZE (DETCI); DETCI (Expert) — size of H0 block for initial guess. Type: integer; Default: 400. H_BOND_CONNECT (OPTKING); OPTKING — For now, this is a general maximum distance for the definition of H-bonds. Type: double; Default: 4.3. HD_AVG (DETCI); DETCI (Expert) — How to average H diag energies over spin coupling sets. HD_EXACT uses the exact diagonal energies which results in expansion vectors which break spin symmetry. HD_KAVE averages the diagonal energies over a spin-coupling set yielding spin pure expansion vectors. ORB_ENER employs the sum of orbital energy approximation giving spin pure expansion vectors but usually doubles the number of Davidson iterations. EVANGELISTI uses the sums and differences of orbital energies with the SCF reference energy to produce spin pure expansion vectors. LEININGER approximation which subtracts the one-electron contribution from the orbital energies, multiplies by 0.5, and adds the one-electron contribution back in, producing spin pure expansion vectors and developed by Matt Leininger and works as well as EVANGELISTI. Type: string; Possible Values: EVANGELISTI, HD_EXACT, HD_KAVE, ORB_ENER, LEININGER, Z_KAVE; Default: EVANGELISTI. HD_OTF (DETCI); DETCI (Expert) — Do compute the diagonal elements of the Hamiltonian matrix on-the-fly? Otherwise, a diagonal element vector is written to a separate file on disk. Type: boolean; Default: true. HEFF4 (PSIMRCC); PSIMRCC — Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT (PSIMRCC); PSIMRCC — Do print the effective Hamiltonian?. Typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:41958,energy,energy,41958,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,8,['energy'],['energy']
Energy Efficiency,"is \(\langle ab|cd \rangle\)). fnocc2; Test G2 method for H2O. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cbs-xtpl-alpha; Extrapolated water energies. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. cbs-xtpl-dict; Extrapolated water energies. soscf-large; Second-order SCF convergnece: Benzene. fnocc4; Test FNO-DF-CCSD(T) energy. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc9; UHF-CCSD(T)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:31130,energy,energy,31130,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"is a subdirectory; within the Psi4 scratch directory. If specified, GENBAS and/or ZMAT within will be used. :type genbas: string; :param genbas:. Indicates that contents should be used for GENBAS file. GENBAS is a complicated topic. It is quite unnecessary if the; molecule is from a molecule {...} block and basis is set through; |Psifours| BASIS keyword. In that case, a GENBAS is written from; LibMints and all is well. Otherwise, a GENBAS is looked for in; the usual places: PSIPATH, PATH, PSIDATADIR/basis. If path kwarg is; specified, also looks there preferentially for a GENBAS. Can; also specify GENBAS within an input file through a string and; setting the genbas kwarg. Note that due to the input parser's; aggression, blank lines need to be replaced by the text blankline. """"""; lowername = name.lower(); internal_p4c4_info = {}. optstash = p4util.OptionsState(; ['CFOUR', 'TRANSLATE_PSI4']). # Determine calling function and hence dertype; calledby = inspect.stack()[1][3]; dertype = ['energy', 'gradient', 'hessian'].index(calledby); #print('I am %s called by %s called by %s.\n' %; # (inspect.stack()[0][3], inspect.stack()[1][3], inspect.stack()[2][3])). # Save submission directory; current_directory = os.getcwd(). # Move into job scratch directory; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); os.chdir(psioh.get_default_path()). # Construct and move into cfour subdirectory of job scratch directory; cfour_tmpdir = kwargs['path'] if 'path' in kwargs else \; 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.cfour.' + str(random.randint(0, 99999)); if not os.path.exists(cfour_tmpdir):; os.mkdir(cfour_tmpdir); os.chdir(cfour_tmpdir). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH') + \; ':' + psi4.Process.environment[""PSIDATADIR""] + '/basis' + \; ':' + psi4.psi_top_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:4237,energy,energy,4237,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html,1,['energy'],['energy']
Energy Efficiency,"is becomes ex.lev (option #1) in fort.56. Type: integer; Default: 2. MRCC_NUM_SINGLET_ROOTS¶. Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56 | begin{tabular}{ccc} | Value & Method & Description \ | hline | 1 & CC & \ | 2 & CC(n-1)[n] & \ | 3 & CC(n-1)(n) & (CC(n-1)[n] energy is also calculated) \ | 4 & CC(n-1)(n)_L & (CC(n-1)[n] and CC(n-1)(n) energies are also calculated) \ | 5 & CC(n)-1a & \ | 6 & CC(n)-1b & \ | 7 & CCn & \ | 8 & CC(n)-3 & \ | end{tabular}. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling PSI4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 are supported. This becomes rest (option #4) in fort.56. Type: int",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__mrcc-1.html:1600,energy,energy,1600,psi4manual/4.0b2/autodir_options_c/module__mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__mrcc-1.html,8,['energy'],['energy']
Energy Efficiency,"is called a; RASSCF. CASSCF and RASSCF computations are types of multi-configurational; self-consistent-field procedures, and are described in MCSCF: Multi-Configurational Self-Consistent-Field.; As mentioned above, the DETCI module is designed for challenging; chemical systems for which simple CISD is not suitable. Because; CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,; typically the DETCI code will be used in cases where the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. As mentioned above, codes; written specifically for CISD will be more efficient than DETCI for a; CISD computation, and energy('cisd') by default will call other,; more efficient modules. To force a CISD computation with DETCI,; set QC_MODULE = DETCI.; Higher order single-reference CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specified by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:4712,energy,energy,4712,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,9,['energy'],['energy']
Energy Efficiency,"is for SCF and aug-cc-pVDZ-RI for SAPT. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ CH2 single-point energy (fzc, MO-basis ). dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. fd-gradient; SCF STO-3G finite-difference tests. psimrcc-sp1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. fnocc2; Test G2 method for H2O. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. cc12; Single point energies of multiple excited states with EOM-CCSD. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. scf-guess-r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:9308,energy,energy,9308,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"is for df-ccsd(t). Type: string; Possible Values: basis string; Default: No Default. CHOLESKY_TOLERANCE¶. tolerance for Cholesky decomposition of the ERI tensor. Type: conv double; Default: 1.0e-4. CEPA_NO_SINGLES¶. Flag to exclude singly excited configurations from a coupled-pair computation. Type: boolean; Default: false. DIPMOM¶. Compute the dipole moment? Note that dipole moments are only available in the FNOCC module for the ACPF, AQCC, CISD, and CEPA(0) methods. Type: boolean; Default: false. Advanced FNOCC Keywords¶. SCS_MP2¶. Do SCS-MP2?. Type: boolean; Default: false. MP2_SCALE_OS¶. Opposite-spin scaling factor for SCS-MP2. Type: double; Default: 1.20. MP2_SCALE_SS¶. Same-spin scaling factor for SCS-MP2. Type: double; Default: 1.0. SCS_CCSD¶. Do SCS-CCSD?. Type: boolean; Default: false. CC_SCALE_OS¶. Oppposite-spin scaling factor for SCS-CCSD. Type: double; Default: 1.27. CC_SCALE_SS¶. Same-spin scaling factor for SCS-CCSD. Type: double; Default: 1.13. RUN_MP2¶. do only evaluate mp2 energy?. Type: boolean; Default: false. RUN_MP3¶. do only evaluate mp3 energy?. Type: boolean; Default: false. RUN_MP4¶. do only evaluate mp4 energy?. Type: boolean; Default: false. RUN_CCSD¶. do ccsd rather than qcisd?. Type: boolean; Default: false. RUN_CEPA¶. Is this a CEPA job? This parameter is used internally by the pythond driver. Changing its value won’t have any effect on the procedure. Type: boolean; Default: false. COMPUTE_TRIPLES¶. Do compute triples contribution?. Type: boolean; Default: true. COMPUTE_MP4_TRIPLES¶. Do compute MP4 triples contribution?. Type: boolean; Default: false. DFCC¶. Do use density fitting or cholesky decomposition in CC? This keyword is used internally by the driver. Changing its value will have no effect on the computation. Type: boolean; Default: false. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/fnocc-1.html:18225,energy,energy,18225,psi4manual/1.3.2/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/fnocc-1.html,11,['energy'],['energy']
Energy Efficiency,"is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody._nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). for precallback in hooks['energy']['pre']:; precallback(lowername, **kwargs). optstash = driver_util._set_convergence_criterion('energy', lowername, 6, 8, 6, 8, 6). # Before invoking the procedure, we rename any file that should be read.; # This is a workaround to do restarts with the current PSI4 capabilities; # before actual, clean restarts are put in there; # Restartfile is always converted to a single-element list if; # it contains a single string; if 'restart_file' in kwargs:; restartfile = kwargs['restart_file'] # Option still available for procedure-specific action; if restartfile != list(restartfile):; restartfile = [restartfile]; # Rename the files to be read to be consistent with psi4's file system; for item in restartfile:; name_split = re.split(r'\.', item); filenum = name_split[len(name_split) - 1]; try:; filenum = int(filenum); except ValueError:; filenum = 32 # Default file number is the checkpoint one; psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); filepath = psioh.get_file_path(filenum); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; target",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:29573,energy,energy,29573,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"is in a symmetry plane of the molecule. dcft-grad1; DCFT DC-06 gradient for the O2 molecule with cc-pVDZ basis set. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:16257,energy,energy,16257,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,8,['energy'],['energy']
Energy Efficiency,"is is typically the; first layer encountered, Libmints handles the transform from AO to SO; automatically. If Cartesian functions are used, the number of functions; per shell remains (L + 1)(L + 2)/2, and the ordering remains the same; as above. Note that the individual functions are not normalized for; angular momentum as in most codes: the self-overlap of a PSI4 Cartesian D; or higher function with more than one nonzero Cartesian exponent (e.g., lx; = 1, ly = 1, lz = 0) will be less than one. If Spherical Harmonics are; used, 2L + 1 real combinations of the spherical harmonics are built from; the (L+1)(L+2)/2 Cartesian Gaussians, according to H. Schlegel and M.; Frish, IJQC, 54, 83-87, 1995. Unlike Cartesian functions these functions; are all strictly normalized. Note that in PSI4, the real combinations of; spherical harmonic functions (see the paragraph below Eq. 15 in the; Schlegel paper) are ordered as: 0, 1+, 1-, 2+, 2-, …. USO (Unique Symmetry-Adapted Orbitals): Spatial symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it’s a bit context specific. OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:10511,adapt,adapted,10511,psi4manual/1.2.1/prog_blas-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html,4,['adapt'],['adapted']
Energy Efficiency,"is last; sup.allocate(); return sup. [docs]def build_b3lyp5_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B3LYP5'); # Tab in, trailing newlines; sup.set_description(' B3LYP5 Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' P.J. Stephens et. al., J. Phys. Chem., 98, 11623-11627, 1994\n'). # Add member functionals; b3 = build_functional('B3_X'); b3.set_alpha(1.0); sup.add_x_functional(b3); lyp = build_functional('LYP_C'); lyp.set_alpha(0.81); vwn = build_functional('VWN5RPA_C'); vwn.set_alpha(0.19); sup.add_c_functional(lyp); sup.add_c_functional(vwn). # Set GKS up after adding functionals; sup.set_x_omega(0.0); sup.set_c_omega(0.0); sup.set_x_alpha(0.2); sup.set_c_alpha(0.0). # => End User-Customization <= #. # Call this last; sup.allocate(); return sup. [docs]def build_b970_superfunctional(name, npoints, deriv):. # Call this first; sup = PsiMod.SuperFunctional.blank(); sup.set_max_points(npoints); sup.set_deriv(deriv). # => User-Customization <= #. # No spaces, keep it short and according to convention; sup.set_name('B97-0'); # Tab in, trailing newlines; sup.set_description(' B97-0 Hybrid-GGA Exchange-Correlation Functional\n'); # Tab in, trailing newlines; sup.set_citation(' A.D. Becke, J. Chem. Phys., 107(20), 8554-8560, 1997\n'). # Add member functionals; X = build_functional('B97_X'); X.set_name('B97-0_X'); X.set_alpha(1.0 / 0.8057). X.set_parameter('B97_gamma', 0.004); X.set_parameter('B97_a0', 0.8094); X.set_parameter('B97_a1', 0.5073); X.set_parameter('B97_a2', 0.7481). C = build_functional('B_C'); C.set_name('B97-0_C'). C.set_parameter('B97_os_gamma', 0.006); C.set_parameter('B97_os_a0', 0.9454); C.set_parameter('B97_os_a1', 0.7471); C.set_parameter('B97_os_a2', -4.5961). C.set_parameter('B97_ss_gamma', 0.2); C.set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/functional.html:26935,allocate,allocate,26935,psi4manual/4.0b2/_modules/functional.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/functional.html,6,['allocate'],['allocate']
Energy Efficiency,"is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:3519,energy,energy,3519,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,12,['energy'],['energy']
Energy Efficiency,"is problem. Caution; In early versions (notably PSI4 alpha circa 2011; and before), frozen core was implemented incompletely and for; only selected terms. Comparisons with papers published using early; PSI4 SAPT code may show discrepancies of 0.01-0.10 kcal/mol in; individual terms, particularly \(E_{exch}^{(11)}\) and \(E_{exch}^{(12)}\). Caution; January 28th 2016, the default for all NAT_ORBS options; was changed to true. Hence the code now by default uses natural; orbital truncation to speed up the evaluation of energy terms; wherever possible, according to literature recommendations.; In early July 2016, some total SAPT energy psivars were renamed. Caution; February 7, 2020, a missing term in \(E^{(30)}_{ind}\) was added, causing; possible discrepancies with prior versions of the code on the order of; 0.01 kcal/mol. See https://github.com/psi4/psi4/issues/1677. Symmetry-adapted perturbation theory (SAPT) provides a means of directly; computing the noncovalent interaction between two molecules, that is, the; interaction energy is determined without computing the total energy of the; monomers or dimer. In addition, SAPT provides a decomposition of the; interaction energy into physically meaningful components: i.e.,; electrostatic, exchange, induction, and dispersion terms. In SAPT, the; Hamiltonian of the dimer is partitioned into contributions from each; monomer and the interaction. \[H=F_A+W_A+F_B+W_B+V\]; Here, the Hamiltonian is written as a sum of the usual monomer Fock; operators, \(F\), the fluctuation potential of each monomer, \(W\), and the; interaction potential, \(V\). The monomer Fock operators, \(F_A+F_B\), are; treated as the zeroth-order Hamiltonian and the interaction energy is; evaluated through a perturbative expansion of \(V\), \(W_A\), and \(W_B\).; Through first-order in \(V\), electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in \(V\). For; a complete description of SAPT, the reader",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:1556,adapt,adapted,1556,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,6,"['adapt', 'energy']","['adapted', 'energy']"
Energy Efficiency,"is renamed, using the PSIO handler. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. phi-ao; Test computing values of basis functions (puream and non-puream) at points. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. mbis-6; MBIS calculation on H2O. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cc13b; Tests RHF CCSD(T)gradients. soscf-large; Second-order SCF convergnece: Benzene. mints-helper; A general test of the MintsHelper function. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. extern3; External potential calculation with one Ghost atom and one point charge at the same position. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc17; Single point energies of multiple excited states with EOM-CCSD. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. scf-coverage; Lithium test for coverage. dft-grad-disk; A range-seperated gradient for SO2 to test disk algori",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:27446,energy,energy,27446,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"is set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta4_basis and xtpl_highest_1() otherwise. delta5_scheme (function) – xtpl_highest_1 || corl_xtpl_helgaker_2 || etc.; Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta5_basis and xtpl_highest_1() otherwise. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:9794,energy,energy,9794,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"is set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – corl_basis || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. delta5_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:; scf_scheme (function) – highest_1 || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy. corl_scheme (function) – highest_1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:6290,energy,energy,6290,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"is set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – corl_basis || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. delta2_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. delta3_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the third delta correction; to the correlation energy. delta4_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fourth delta correction; to the correlation energy. delta5_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the fifth delta correction; to the correlation energy. Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, 'xtpl_highest_1', which uses the best basis; set available. See Extrapolation Schemes for all available schemes. Parameters:; scf_scheme (function) – xtpl_highest_1 || scf_xtpl_helgaker_3 || etc.; Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to scf_xtpl_he",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:6412,energy,energy,6412,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,2,['energy'],['energy']
Energy Efficiency,"is set to just the carbon atoms labelled C1. This bizarre example was; constructed to demonstrate the syntax, but the flexibility of the basis set; specification is advantageous, for example, when selectively omitting diffuse; functions to make computations more tractable.; In the above example the basis sets have been assigned asymmetrically, reducing; the effective symmetry from \(D_{6h}\) to \(C_{2v}\); PSI4 will detect this; automatically and run in the appropriate point group.; Basis blocks can also be named, e.g., basis; optional_basis_name {...} and the basis defined by it later; applied to another molecule.; # sets basis keyword; basis mybas {; assign aug-cc-pvtz; assign f cc-pvtz; }. # re-sets basis keyword; set basis aug-cc-pvtz. molecule hf {; H; F 1 1.0; }. molecule h2o {; O; H 1 1.0; H 1 1.0 2 90.0; }. # runs HF and H2O with aug-cc-pvtz; energy('hf', molecule=hf); energy('hf', molecule=h2o). # re-re-sets basis keyword; set basis mybas. # runs HF with cc-pvtz on F and aug-cc-pvtz on H; energy('hf', molecule=hf). # runs H2O with aug-cc-pvtz, effectively; energy('hf', molecule=h2o). Finally, we note that the basis {...} block may also be used; for defining basis sets, as detailed in User-Defined Basis Sets.; Calculations requesting density fitting (on by default for many methods); require auxiliary fitting basis set(s) in addition to the primary; orbital one associated with the BASIS keyword.; When most popular basis sets are being used, including Dunning and; Pople-style, the SCF, DF-MP2, and SAPT codes will chose the appropriate; auxiliary basis set automatically according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input.; Should needed elements be missing from the best; auxiliary basis or should the orbital basis be unknown to PSI4,; the auxiliary basis will fall back on def2 quad-zeta fitting bases.; Note that if BASIS is known to be larger than quad-zeta,; PSI4 will not attempt to fall back on the d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/basissets-1.html:4596,energy,energy,4596,psi4manual/1.4.0/basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/basissets-1.html,4,['energy'],['energy']
Energy Efficiency,"is set to just the carbon atoms labelled C1. This bizarre example was; constructed to demonstrate the syntax, but the flexibility of the basis set; specification is advantageous, for example, when selectively omitting diffuse; functions to make computations more tractable.; In the above example the basis sets have been assigned asymmetrically, reducing; the effective symmetry from \(D_{6h}\) to \(C_{2v}\); PSI4 will detect this; automatically and run in the appropriate point group.; Basis blocks can also be named, e.g., basis; optional_basis_name {...} and the basis defined by it later; applied to another molecule.; # sets basis keyword; basis mybas {; assign aug-cc-pvtz; assign f cc-pvtz; }. # re-sets basis keyword; set basis aug-cc-pvtz. molecule hf {; H; F 1 1.0; }. molecule h2o {; O; H 1 1.0; H 1 1.0 2 90.0; }. # runs HF and H2O with aug-cc-pvtz; energy('hf', molecule=hf); energy('hf', molecule=h2o). # re-re-sets basis keyword; set basis mybas. # runs HF with cc-pvtz on F and aug-cc-pvtz on H; energy('hf', molecule=hf). # runs H2O with aug-cc-pvtz, effectively; energy('hf', molecule=h2o). Finally, we note that the basis {...} block may also be used; for defining basis sets, as detailed in User-Defined Basis Sets.; Calculations requesting density fitting (on by default for many methods); require auxiliary fitting basis set(s) in addition to the primary; orbital one associated with the BASIS keyword.; When most popular basis sets are being used, including Dunning and; Pople-style, the SCF, DF-MP2, and SAPT codes will chose the appropriate; auxiliary basis set automatically according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input.; Should needed elements be missing from the best; auxiliary basis or should the orbital basis be unknown to PSI4,; the auxiliary basis will fall back on def2 quad-zeta fitting bases; :source:`psi4/driver/qcdb/libmintsbasisset.py#L762.; Note that if BASIS is known to be larger than qua",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/basissets.html:4596,energy,energy,4596,psi4manual/1.6.x/basissets.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/basissets.html,5,['energy'],['energy']
Energy Efficiency,"is sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec cbsbanners. # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:65047,energy,energy,65047,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['energy'],['energy']
Energy Efficiency,"is sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = ['d_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy']; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:66147,energy,energy,66147,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,4,['energy'],['energy']
Energy Efficiency,"is sets, the following code can; be used:. PSIthonPsiAPIbasis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; psi4.set_options({""basis"": basis_set}); psi4.energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water. PSIthonPsiAPImolecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). h2o = psi4.geometry(""""""; O; H 1 R; H 1 R 2 A; """"""). Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). psi4.set_options({""basis"": ""cc-pvdz"",; ""e_convergence"": 11}); for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; psi4.energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The Psithon function psi4.driver.p4util.Table has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potenti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:13190,energy,energy,13190,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['energy'],['energy']
Energy Efficiency,"is sets. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. cc10; ROHF-CCSD cc-pVDZ energy for the state of the CN radical. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. dft2; DFT Functional Test. cc15; RHF-B-CCD(T)/6-31G**",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:7430,energy,energy,7430,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"is string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: Callable; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3` if three valid basis sets; present in ``psi4.driver.driver_cbs.scf_basis``, :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * :py:func:`~psi4.driver.driver_cbs.xtpl_highest_1`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_truhlar_2`; * :py:func:`~psi4.driver.driver_cbs.scf_xtpl_karton_2`. :type corl_scheme: Callable; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:39483,energy,energy,39483,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,4,['energy'],['energy']
Energy Efficiency,"is string <apdx:basisElement>`; :param delta_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the delta correction; to the correlation energy. :type delta2_basis: :ref:`basis string <apdx:basisElement>`; :param delta2_basis: ``'cc-pV[TQ]Z'`` || ``'jun-cc-pv[tq5]z'`` || ``'6-31G*'`` || etc. Indicates the sequence of basis sets employed for the second delta correction; to the correlation energy. * Schemes; Transformations of the energy through basis set extrapolation for each; stage of the CBS definition. A complaint is generated if number of basis; sets in stage_basis does not exactly satisfy requirements of stage_scheme.; An exception is the default, ``'xtpl_highest_1'``, which uses the best basis; set available. See :ref:`sec:cbs_xtpl` for all available schemes. :type scf_scheme: function; :param scf_scheme: |dl| ``xtpl_highest_1`` |dr| || ``scf_xtpl_helgaker_3`` || etc. Indicates the basis set extrapolation scheme to be applied to the reference energy.; Defaults to :py:func:`~scf_xtpl_helgaker_3` if three valid basis sets; present in ``scf_basis``, :py:func:`~scf_xtpl_helgaker_2` if two valid basis; sets present in ``scf_basis``, and :py:func:`~xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * xtpl_highest_1; * scf_xtpl_helgaker_3; * scf_xtpl_helgaker_2; * scf_xtpl_truhlar_2; * scf_xtpl_karton_2. :type corl_scheme: function; :param corl_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``corl_basis`` and :py:func:`~xtpl_highest_1` otherwise. .. hlist::; :columns: 1. * xtpl_highest_1; * corl_xtpl_helgaker_2. :type delta_scheme: function; :param delta_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the delta correcti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:39228,energy,energy,39228,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"is test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. cc56; EOM-CCSD/6-31g excited state transition data for water cation. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). fisapt-siao1; This test case shows an example of running the I-SAPT0/jun-cc-pVDZ computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups) The SIAO1 link partitioning algorithm is used. An F-SAPT partitioning follows I-SAPT. dfccsd-t-grad2; DF-CCSD(T) cc-pVDZ gradient for the NH molecule. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. scf6; Tests RHF/ROHF/UHF SCF gradients. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. cbs-xtpl-alpha; Extrapolated water energies. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dft-custom; DFT custom functional t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:14097,energy,energy,14097,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtained. delta3_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a third delta correction; to the correlation energy is to be obtained. delta3_wfn_lesser (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a third delta correction; to the correlation energy is to be obtained. delta4_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta4_wfn_lesser (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fourth delta correction; to the correlation energy is to be obtained. delta5_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a fifth delta correction; to the correlation energy is to be obtained. delta5_wfn_lesser (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a fifth delta correction; to the correlation energy is to be obtained. Basis Sets; Currently, the basis set set through set commands have no influence; on a cbs calculation. Parameters:; scf_basis (basis string) – corl_basis || 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the reference energy.; If any correlation method is specified, scf_basis can default; to corl_basis. corl_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*' || etc.; Indicates the sequence of basis sets employed for the correlation energy. delta_basis (basis string) – 'cc-pV[TQ]Z' || 'jun-cc-pv[tq5]z' || '6-31G*",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:4772,energy,energy,4772,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,4,['energy'],['energy']
Energy Efficiency,"is. (Overrides SOLVER_N_ROOT.). Type: array; Default: No Default. SOS_TYPE (DFOCC)¶DFOCC — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOS_TYPE (OCC)¶OCC — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOSCF (SCF)¶SCF — Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV (SCF)¶SCF — Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER (SCF)¶SCF — Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER (SCF)¶SCF — Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT (SCF)¶SCF — Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE (SCF)¶SCF — When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. SPIN_SCALE_TYPE (OCC)¶OCC (Expert) — Controls the spin scaling set to current energy. This is set by Psi internally. Type: string; Possible Values: NONE, CUSTOM, SCS, SCSN, SCSVDW, SOS, SOSPI; Default: NONE. SS_E_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SCALE (OCC)¶OCC — A custom scaling parameter for same-spin terms in OCC. The result goes to a CUSTOM SCS variable, exact name method-dependent. Type: double; Default: 1. SS_SKIP_DIAG (CCEOM)¶CCEOM — Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT (CCEOM)¶CCEOM — SS vectors stored per root. Type: integer; Default: 5. SSAPT0_SCALE (FISAPT)¶FISAPT — Do sSAPT0 exchange-scaling with F-SAPT. Type: boolean; Default: false. STABILITY_ADD_VEC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:224975,energy,energy,224975,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,4,['energy'],['energy']
Energy Efficiency,"is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., ‘cc-pV[Q5]Z’ is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by complete_basis_set(). validate_scheme_args(functionname, **largs)[source]¶; Function called by each extrapolation scheme in complete_basis_set().; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefunction density. fitScf()[source]¶; Function to run scf and fit a system of diffuse charges to; resulting density. populateExtern(extern)[source]¶. class QMMM[source]¶. addChargeAngstrom(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]¶; Function to add a diffuse charge field diffuse. populateExtern()[source]¶; Function to define a charge field external to the; molecule through point and diffuse charges. basislistother¶; Module with commands building BasisFamily objects; for Pople and other non-Dunning orbital basis sets. Some; plausible fitting basis sets are supplied as defaults. load_basfam_other()[source]¶. diatomic¶. functional¶; Module to provide lightweight definitions of functionals and; SuperFunctionals. build_b2plyp_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd2gr_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd2p4_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd3bj_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd3zero_superfunctional(name, npoints, deriv)[",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:24365,charge,charge,24365,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency,"is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., ‘cc-pV[Q5]Z’ is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by complete_basis_set(). validate_scheme_args(functionname, **largs)[source]¶; Function called by each extrapolation scheme in complete_basis_set().; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefunction density. fitScf()[source]¶; Function to run scf and fit a system of diffuse charges to; resulting density. populateExtern(extern)[source]¶. class QMMM[source]¶. addChargeAngstrom(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]¶; Function to add a diffuse charge field diffuse. populateExtern()[source]¶; Function to define a charge field external to the; molecule through point and diffuse charges. basislistother¶; Module with commands building BasisFamily objects; for Pople and other non-Dunning orbital basis sets. Some; plausible fitting basis sets are supplied as defaults. load_basfam_other()[source]¶. diatomic¶. functional¶; Module to provide lightweight definitions of functionals and; SuperFunctionals. build_b2plyp_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd2gr_superfunctional(name, npoints, deriv)¶. build_b2plypd2p4_superfunctional(name, npoints, deriv)¶. build_b2plypd3bj_superfunctional(name, npoints, deriv)¶. build_b2plypd3zero_superfunctional(name, npoints, deriv)¶. build_b3_x_functional(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:22193,charge,charge,22193,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency,"is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., ‘cc-pV[Q5]Z’ is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by complete_basis_set(). validate_scheme_args(functionname, **largs)[source]¶; Function called by each extrapolation scheme in complete_basis_set().; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefunction density. fitScf()[source]¶; Function to run scf and fit a system of diffuse charges to; resulting density. populateExtern(extern)[source]¶. class QMMM[source]¶. addChargeAngstrom(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]¶; Function to add a diffuse charge field diffuse. populateExtern()[source]¶; Function to define a charge field external to the; molecule through point and diffuse charges. diatomic¶. functional¶; Module to provide lightweight definitions of functionals and; SuperFunctionals. build_b2plyp_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd2gr_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd2p4_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd3bj_superfunctional(name, npoints, deriv)[source]¶. build_b2plypd3zero_superfunctional(name, npoints, deriv)[source]¶. build_b3_x_functional(name)[source]¶. build_b3lyp5_superfunctional(name, npoints, deriv)[source]¶. build_b3lyp5d2gr_superfunctional(name, npoints, deriv)[source]¶. build_b3lyp5d2p4_superfunctional(name",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:19718,charge,charge,19718,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency,"is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., ‘cc-pV[Q5]Z’ is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by complete_basis_set(). validate_scheme_args(functionname, **largs)[source]¶; Function called by each extrapolation scheme in complete_basis_set().; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefunction density. fitScf()[source]¶; Function to run scf and fit a system of diffuse charges to; resulting density. populateExtern(extern)[source]¶. class QMMM[source]¶. addChargeAngstrom(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]¶; Function to add a diffuse charge field diffuse. populateExtern()[source]¶; Function to define a charge field external to the; molecule through point and diffuse charges. functional¶; Module to provide lightweight definitions of functionals and; SuperFunctionals. build_b3_x_functional(name)[source]¶. build_b3lyp5_superfunctional(name, npoints, deriv)[source]¶. build_b3lyp5d_superfunctional(name, npoints, deriv)[source]¶. build_b3lyp_superfunctional(name, npoints, deriv)[source]¶. build_b3lypd_superfunctional(name, npoints, deriv)[source]¶. build_b88_x_functional(name)[source]¶. build_b970_superfunctional(name, npoints, deriv)[source]¶. build_b971_superfunctional(name, npoints, deriv)[source]¶. build_b972_superfunctional(name, npoints, deriv)[source]¶. build_b97_x_functional(name)[source]¶",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:14208,charge,charge,14208,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency,"is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monom",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/sapt-1.html:2059,energy,energy,2059,psi4manual/4.0b2/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html,6,['energy'],['energy']
Energy Efficiency,"is; evaluated through a perturbative expansion of , , and .; Through first-order in , electrostatic and exchange interactions are; included; induction and dispersion first appear at second-order in . For; a complete description of SAPT, the reader is referred to the excellent; review by Jeziorski, Moszynski, and Szalewicz [Jeziorski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligible errors into the SAPT energy; (often less than 0.01 kcal/mol for small dimers) and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geomet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/sapt-1.html:2323,energy,energy,2323,psi4manual/4.0b5/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/sapt-1.html,2,['energy'],['energy']
Energy Efficiency,"isChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_global_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisname); core.set_global_option(""DF_BASIS_SCF"", self.ribasisname); core.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; core.print_out(""\n""). self.fitGeneral(). core.clean(). core.set_global_option(""BASIS"", basis); core.set_global_option(""DF_BASIS_SCF"", ribasis); core.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; core.revoke_option_changed(""BASIS""); if not ribasisChanged:; core.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; core.revoke_option_changed(""SCF_TYPE""). def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]; class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:2752,charge,charges,2752,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,6,['charge'],['charges']
Energy Efficiency,"isChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_global_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisname); core.set_global_option(""DF_BASIS_SCF"", self.ribasisname); core.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; core.print_out(""\n""). self.fitGeneral(). core.clean(). core.set_global_option(""BASIS"", basis); core.set_global_option(""DF_BASIS_SCF"", ribasis); core.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; core.revoke_option_changed(""BASIS""); if not ribasisChanged:; core.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; core.revoke_option_changed(""SCF_TYPE""). def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qmmm.html:2756,charge,charges,2756,psi4manual/1.6.x/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qmmm.html,4,['charge'],['charges']
Energy Efficiency,"isChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_global_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisname); core.set_global_option(""DF_BASIS_SCF"", self.ribasisname); core.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; core.print_out(""\n""). self.fitGeneral(). core.clean(). core.set_global_option(""BASIS"", basis); core.set_global_option(""DF_BASIS_SCF"", ribasis); core.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; core.revoke_option_changed(""BASIS""); if not ribasisChanged:; core.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; core.revoke_option_changed(""SCF_TYPE""). def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qmmm.html:2740,charge,charges,2740,psi4manual/1.3.2/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qmmm.html,6,['charge'],['charges']
Energy Efficiency,"isSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. adc1; ADC/6-31G** on H2O. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. scf6; Tests RHF/ROHF/UHF SCF gradients. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. dcft-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. pywrap-db2; Database calculation, run in sow/reap mode. sad1; Test of the superposition of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:8568,energy,energy,8568,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"is_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. # Figure out lowername, dertype, and func; # If we have analytical gradients we want to pass to our wrappers, otherwise we want to run; # finite-diference energy or cbs energies; # TODO MP5/cc-pv[DT]Z behavior unkown due to ""levels""; user_dertype = kwargs.pop('dertype', None); if gradient_type == 'custom_function':; if user_dertype is None:; dertype = 0; core.print_out(""\nGradient: Custom function passed in without a defined dertype, assuming fd-energy based gradient.\n""); else:; core.print_out(""\nGradient: Custom function passed in with a dertype of %d\n"" % user_dertype); dertype = user_dertype. if dertype == 1:; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', 'scf', 8, 10, 8, 10, 8); lowername = name. elif gradient_type == 'cbs_wrapper':; cbs_methods = driver_cbs._cbs_wrapper_methods(**kwargs); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); if dertype == 1:; # Bounce to CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic grad. avail.; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:34811,energy,energy,34811,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"is_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. # Figure out lowername, dertype, and func; # If we have analytical gradients we want to pass to our wrappers, otherwise we want to run; # finite-diference energy or cbs energies; # TODO MP5/cc-pv[DT]Z behavior unkown due to ""levels""; user_dertype = kwargs.pop('dertype', None); if gradient_type == 'custom_function':; if user_dertype is None:; dertype = 0; psi4.print_out(""\nGradient: Custom function passed in without a defined dertype, assuming fd-energy based gradient.\n""); else:; psi4.print_out(""\nGradient: Custom function passed in with a dertype of %d\n"" % user_dertype); dertype = user_dertype. if dertype == 1:; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', 'scf', 8, 10, 8, 10, 8); lowername = name. elif gradient_type == 'cbs_wrapper':; cbs_methods = driver_cbs._cbs_wrapper_methods(**kwargs); dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); if dertype == 1:; # Bounce to CBS (directly) in pure-gradient mode if name is CBS and all parts have analytic grad. avail.; return name(gradient, kwargs.pop('label', 'custom function'), ptype='gradient', **kwargs); else:; optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8); lowername = name; # Pass through to G by E. elif gradient_type == 'cbs_gufunc':; cbs_methods = driver_cbs._parse_cbs_gufunc_string(name.lower())[0]; dertype = min([_find_derivative_type('gradient', method, user_dertype) for method in cbs_methods]); lowername = name.lower(); if dertype == 1:; # Bounce to CBS in pure-gradient mode if ""method/basis"" name and all parts have analytic grad. avail.; return driver_cbs._cbs_gufunc(gradient, name, ptype='",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:33580,energy,energy,33580,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['energy'],['energy']
Energy Efficiency,"ise TestComparisonError(header_diff). ref_energies = energies_from_fcidump(ref_intdump); energies = energies_from_fcidump(intdump). pass_1el = compare_values(ref_energies['ONE-ELECTRON ENERGY'], energies['ONE-ELECTRON ENERGY'], 7,; label + '. 1-electron energy'); pass_2el = compare_values(ref_energies['TWO-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'], 7,; label + '. 2-electron energy'); pass_scf = compare_values(ref_energies['SCF TOTAL ENERGY'], energies['SCF TOTAL ENERGY'], 10,; label + '. SCF total energy'); pass_mp2 = compare_values(ref_energies['MP2 CORRELATION ENERGY'], energies['MP2 CORRELATION ENERGY'], 10,; label + '. MP2 correlation energy'). if (pass_1el and pass_2el and pass_scf and pass_mp2):; success(label). return True. [docs]def energies_from_fcidump(intdump):; energies = {}; energies['NUCLEAR REPULSION ENERGY'] = intdump['enuc']; epsilon = intdump['epsilon']; Hcore = intdump['hcore']; eri = intdump['eri']. # Compute SCF energy; energies['ONE-ELECTRON ENERGY'], energies['TWO-ELECTRON ENERGY'] = _scf_energy(Hcore, eri,; np.where(epsilon < 0)[0],; intdump['uhf']); # yapf: disable; energies['SCF TOTAL ENERGY'] = energies['ONE-ELECTRON ENERGY'] + energies['TWO-ELECTRON ENERGY'] + energies['NUCLEAR REPULSION ENERGY']; # yapf: enable. # Compute MP2 energy; energies['MP2 CORRELATION ENERGY'] = _mp2_energy(eri, epsilon, intdump['uhf']). return energies. def _scf_energy(Hcore, ERI, occ_sl, unrestricted):; scf_1el_e = np.einsum('ii->', Hcore[np.ix_(occ_sl, occ_sl)]); if not unrestricted:; scf_1el_e *= 2; coulomb = np.einsum('iijj->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); exchange = np.einsum('ijij->', ERI[np.ix_(occ_sl, occ_sl, occ_sl, occ_sl)]); if unrestricted:; scf_2el_e = 0.5 * (coulomb - exchange); else:; scf_2el_e = 2.0 * coulomb - exchange. return scf_1el_e, scf_2el_e. def _mp2_energy(ERI, epsilon, unrestricted):; # Occupied and virtual slices; occ_sl = np.where(epsilon < 0)[0]; vir_sl = np.where(epsilon > 0)[0]; eocc = epsilon[occ_sl]; evi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html:14203,energy,energy,14203,psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html,1,['energy'],['energy']
Energy Efficiency,"ise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues for all methods; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); core.set_global_option('BASIS', basis); ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); core.clean(). optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # Drop out for props and freqs; if ptype in [""properties"", ""frequency""]:; raise ValidationError(""%s: Cannot extrapolate or delta correct %s yet."" % (ptype.title(), ptype)). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. # Find metho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:66682,energy,energy,66682,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"ise. .. hlist::; :columns: 1. * xtpl_highest_1; * corl_xtpl_helgaker_2. :type delta3_scheme: function; :param delta3_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the third delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta3_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta4_scheme: function; :param delta4_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fourth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta4_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type delta5_scheme: function; :param delta5_scheme: |dl| ``xtpl_highest_1`` |dr| || ``corl_xtpl_helgaker_2`` || etc. Indicates the basis set extrapolation scheme to be applied to the fifth delta correction; to the correlation energy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta5_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type scf_alpha: float. Overrides the default \alpha parameter used in the listed SCF extrapolation procedures.; Has no effect on others, including :py:func:`~xtpl_highest_1` and :py:func:`~scf_xtpl_helgaker_3`. .. hlist::; :columns: 1. * :py:func:`scf_xtpl_helgaker_2`; * :py:func:`scf_xtpl_truhlar_2`; * :py:func:`scf_xtpl_karton_2`. :type corl_alpha: float. Overrides the default \alpha parameter used in the listed :py:func:`corl_xtpl_helgaker_2` correlation; extrapolation to the corl stage. The supplied \alpha does not impact delta or any further stages. .. hlist::; :columns: 1. * :py:func:`corl_xtpl_helgaker_2`. :type delta_alpha: float. Overrides the default \alpha parameter used in the listed; :py:func:`corl_xtpl_helgaker_2` correlation extrapolation for the delta correction. Useful wh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:34661,energy,energy,34661,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['energy'],['energy']
Energy Efficiency,"ish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:9585,energy,energy,9585,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,12,['energy'],['energy']
Energy Efficiency,"ish/psi.12345.h2o.32; copy_file_to_scratch(‘/tmp/temp’, ‘psi’, ‘’, 32):; -cp /tmp/temp /scratch/parrish/psi.12345.32; copy_file_to_scratch(‘/tmp/temp’, ‘psi’, ‘’, 32, True):; -mv /tmp/temp /scratch/parrish/psi.12345.32. get_memory()[source]¶; Function to return the total memory allocation. get_num_threads()[source]¶; Function to return the number of threads to parallelize across. set_memory(bytes)[source]¶; Function to reset the total memory allocation. set_num_threads(nthread)[source]¶; Function to reset the number of threads to parallelize across. success(label)[source]¶; Function to print a ‘label...PASSED’ line to screen.; Used by util.compare_values() family when functions pass. aliases¶; Module with functions that call upon those in modules; proc, driver, and wrappers. Place in this file quickly defined procedures such as. aliases for complex methods; simple modifications to existing methods. run_mp2_5(name, **kwargs)[source]¶; Function that computes MP2.5 energy from results of a DETCI; MP3 calculation. Psi variables:. MP2.5 TOTAL ENERGY; MP2.5 CORRELATION ENERGY. >>> energy('mp2.5'). run_plugin_omega(name, **kwargs)[source]¶; Function encoding sequence of PSI module and plugin calls, as well; as typical options, to access Rob Parrish’s omega plugin.; >>> energy('plugin_omega'). sherrillgroup_gold_standard(name='mp2', **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluateo; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> energy('sherrillgroup_gold_standard'). Table Of Contents. Python Driver; input; pubchem; psiexceptions; frac; molutil; proc; procutil; driver; physconst; wrappers; qmmm; functional; text; util; aliases. Previous topic; PRINT; Next topic; PsiMod: Linking C++ and Python; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:22891,energy,energy,22891,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,2,['energy'],['energy']
Energy Efficiency,"ision of the molecular orbitals into various subspaces such as; RAS spaces, or frozen vs. active orbitals, etc., needs to be clear not; only to detci, but also at least to the transformation program; (and in the case of MCSCF, to other programs as well). Thus, orbital; subspace keywords such as RAS1,; RAS2, RAS3, FROZEN_DOCC, FROZEN_UOCC,; ACTIVE, etc., should be set; in the global section of input so they may also be read by other modules.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. Higher order; single-refernce CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specifed by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Basic DETCI Keywords¶. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for CI residual vector in the Davidson algorithm (RMS error). The default is 1e-4 for energies and 1e-7 for gradients. Type: conv double; Default: 1e-4. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavef",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/detci-1.html:4786,energy,energy,4786,psi4manual/4.0b2/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/detci-1.html,8,['energy'],['energy']
Energy Efficiency,"isk_df. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc36; CC2(RHF)/cc-pVDZ energy of H2O. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. sapt-compare; SAPT0 aug-cc-pVDZ computation of the water-water interaction energy, using the three SAPT codes. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. cepa1; cc-pvdz H2O Test CEPA(1) Energy. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. ao-dfcasscf-sp; CASSCF/6-31G** energy point. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. scf-upcast-custom-basis; test scf castup with custom basis sets. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against gri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:39956,energy,energy,39956,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"isplaced geometry output file and save in energies array; elif (freq_mode.lower() == 'reap'):; exec(banners); psi4.set_variable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); energies.append(p4util.extract_sowreap_from_output(rfile, 'HESSIAN', n, freq_linkage, True)). # S/R: Quit sow after writing files; if (freq_mode.lower() == 'sow'):; optstash.restore(); return None. # Obtain the gradient. This function stores the gradient in the wavefunction.; psi4.fd_freq_0(energies, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; psi4.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; psi4.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; psi4.get_active_molecule().reinterpret_coordentry(True). # Clear the ""parent"" symmetry now; psi4.set_parent_symmetry(""""). # The last item in the list is the reference energy, return it; optstash.restore(); psi4.set_variable('CURRENT ENERGY', energies[-1]). #TODO: return hessian matrix. [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: (*float*) Total electronic energy in Hartrees. .. note:: Analytic hessians are not available. Frequencies will proceed through; finite differences according to availability of gradients or energies. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Implement sow/reap mode for finite difference of gradients. Presently only for findif of energies. .. _`table:freq_gen`:. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:71112,ENERGY,ENERGY,71112,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['ENERGY'],['ENERGY']
Energy Efficiency,"isplacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.assemble_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from energies; H = driver_findif.assemble_hessian_from_energies(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:80499,energy,energy,80499,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['energy'],['energy']
Energy Efficiency,"istE). psi4.fd_freq_0()¶; Python Library Documentation: built-in function fd_freq_0 in module psi4; fd_freq_0(...). fd_freq_0( (Molecule)arg1, (list)arg2, (int)arg3) -> Matrix :. Performs a finite difference frequency computation, from energy points, for a given irrep.; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE fd_freq_0(N5boost10shared_ptrIN3psi8MoleculeEEE,N5boost6python4listE,i). psi4.fd_freq_1()¶; Python Library Documentation: built-in function fd_freq_1 in module psi4; fd_freq_1(...). fd_freq_1( (Molecule)arg1, (list)arg2, (int)arg3) -> Matrix :. Performs a finite difference frequency computation, from gradients, for a given irrep.; C++ signature :. N5boost10shared_ptrIN3psi6MatrixEEE fd_freq_1(N5boost10shared_ptrIN3psi8MoleculeEEE,N5boost6python4listE,i). psi4.fd_geoms_1_0()¶; Python Library Documentation: built-in function fd_geoms_1_0 in module psi4; fd_geoms_1_0(...). fd_geoms_1_0( (Molecule)arg1) -> matrix_vector :. Gets list of displacements needed for a finite difference gradient computation, from energy points.; C++ signature :. St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE fd_geoms_1_0(N5boost10shared_ptrIN3psi8MoleculeEEE). psi4.fd_geoms_freq_0()¶; Python Library Documentation: built-in function fd_geoms_freq_0 in module psi4; fd_geoms_freq_0(...). fd_geoms_freq_0( (Molecule)arg1, (int)arg2) -> matrix_vector :. Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; C++ signature :. St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE fd_geoms_freq_0(N5boost10shared_ptrIN3psi8MoleculeEEE,i). psi4.fd_geoms_freq_1()¶; Python Library Documentation: built-in function fd_geoms_freq_1 in module psi4; fd_geoms_freq_1(...). fd_geoms_freq_1( (Molecule)arg1, (int)arg2) -> matrix_vector :. Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; C++ signature :. St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE fd_ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:22479,energy,energy,22479,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"ister_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method: str, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is using c1 symmetry; self.molecule.reset_point_group('c1'); self.molecule.fix_orientation(True); self.molecule.fix_com(True); self.molecule.reinterpret_coordentry(False); self.molecule.update_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html:2546,energy,energy,2546,psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html,2,['energy'],['energy']
Energy Efficiency,"it if some is lost when displacing.; if molecule.symmetry_from_input():; disp_group = clone.find_highest_point_group(); new_bits = parent_group.bits() & disp_group.bits(); new_symm_string = qcdb.PointGroup.bits_to_full_name(new_bits); clone.reset_point_group(new_symm_string). # clean possibly necessary for n=1 if its irrep (unsorted in displacement list) different from initial G0 for freq; core.clean(). # Perform the derivative calculation; derivative, wfn = derivfunc(method, return_wfn=True, molecule=clone, **kwargs); displacement[""energy""] = core.variable('CURRENT ENERGY'). # If we computed a first or higher order derivative, set it.; if derivfunc == gradient:; displacement[""gradient""] = wfn.gradient().np.ravel().tolist(). # clean may be necessary when changing irreps of displacements; core.clean(). return wfn. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type restart_file: string; :param restart_file: ``['file.1, file.32]`` || ``./",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:7053,energy,energy,7053,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['energy'],['energy']
Energy Efficiency,"it to the docstring in optimize() below; },; 'hessian' : {; # Upon adding a method to this list, add it to the docstring in frequency() below; },; 'property' : {; 'scf' : run_scf_property,; 'cc2' : run_cc_property,; 'ccsd' : run_cc_property,; 'eom-cc2' : run_cc_property,; 'eom-ccsd' : run_cc_property,; 'eom_cc2' : run_cc_property,; 'eom_ccsd' : run_cc_property; # Upon adding a method to this list, add it to the docstring in property() below; }}. # Integrate DFT with driver routines; for ssuper in superfunctional_list():; procedures['energy'][ssuper.name().lower()] = run_dft. for ssuper in superfunctional_list():; procedures['gradient'][ssuper.name().lower()] = run_dft_gradient. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: (*float*) Total electronic energy in Hartrees. SAPT returns interaction energy. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. comment In this table immediately below, place methods that should only be called by ; .. comment developers at present. This table won't show up in the manual.; .. comment; .. comment .. _`table:energy_devel`:; .. comment ; .. comment +-------------------------+---------------------------------------------------------------------------------------+; .. comment | name | calls method |; .. comment +=========================+=======================================================================================+; .. comment | df-cc | coupled cluster with density fitting |; .. comment +-------------------------+---------------------------------------------------------------------------------------+; .. comment | mp2c | coupled MP2 (MP2C) |; .. comment +-------------------------+---------------------------------------------------------------------------------------+; .. comment | mp2-drpa | random ph",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:3322,ENERGY,ENERGY,3322,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"it to the docstring in optimize() below; },; 'hessian' : {; # Upon adding a method to this list, add it to the docstring in frequency() below; },; 'property' : {; 'scf' : run_scf_property,; 'cc2' : run_cc_property,; 'ccsd' : run_cc_property,; 'eom-cc2' : run_cc_property,; 'eom-ccsd' : run_cc_property,; 'eom_cc2' : run_cc_property,; 'eom_ccsd' : run_cc_property; # Upon adding a method to this list, add it to the docstring in property() below; }}. # Integrate DFT with driver routines; for ssuper in superfunctional_list():; procedures['energy'][ssuper.name().lower()] = run_dft. for ssuper in superfunctional_list():; procedures['gradient'][ssuper.name().lower()] = run_dft_gradient. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: (*float*) Total electronic energy in Hartrees. SAPT returns interaction energy. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. .. comment In this table immediately below, place methods that should only be called by; .. comment developers at present. This table won't show up in the manual.; .. comment; .. comment .. _`table:energy_devel`:; .. comment; .. comment +-------------------------+---------------------------------------------------------------------------------------+; .. comment | name | calls method |; .. comment +=========================+=======================================================================================+; .. comment | df-cc | coupled cluster with density fitting |; .. comment +-------------------------+---------------------------------------------------------------------------------------+; .. comment | mp2c | coupled MP2 (MP2C) |; .. comment +-------------------------+---------------------------------------------------------------------------------------+; .. comment | mp2-drpa | random phas",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:3830,ENERGY,ENERGY,3830,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,3,['ENERGY'],['ENERGY']
Energy Efficiency,"it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (i.e., each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (i.e., each monomer utilizes only its; own basis set). It is also possible to run a SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; sapt_basis='monomer' to the energy function, such as; energy('sapt2',sapt_basis='monomer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat_orbs_t2 true; freeze_core true; }. energy('sapt2+3'). To reiterate some of the options mentioned above: the; NAT_ORBS_T2 option will compute MP2 natural orbitals and use; them in the e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:19056,energy,energy,19056,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,4,['energy'],['energy']
Energy Efficiency,"it('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; tempSymm = symmetry.match(line).group(1); temp2 = re.sub('[23456789]', 'n', tempSymm).upper(); if temp2 in (item.upper() for item in self.FullPointGroupList):; self.PYsymmetry_from_input = tempSymm. # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line):; glines.append(line). # catch last default fragment cgmp; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1). # Now go through the rest of the lines looking for fragment markers; ifrag = 0; iatom = 0; tempfrag = []; atomSym = """"; atomLabel = """"; for line in glines:. # handle fragment marke",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:14937,charge,charge,14937,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,4,['charge'],['charge']
Energy Efficiency,"it('\n', text); glines = []; ifrag = 0. for line in lines:. # handle comments; if comment.match(line) or blank.match(line):; pass. # handle units; elif ang.match(line):; self.set_units('Angstrom'); self.input_units_to_au = 1.0 / psi_bohr2angstroms; elif bohr.match(line):; self.set_units('Bohr'); self.input_units_to_au = 1.0. # handle no_reorient; elif orient.match(line):; self.fix_orientation(True). # handle no_com; elif com.match(line):; self.PYmove_to_com = False. # handle symmetry; elif symmetry.match(line):; tempSymm = symmetry.match(line).group(1); temp2 = re.sub('[23456789]', 'n', tempSymm).upper(); if temp2 in (item.upper() for item in self.FullPointGroupList):; self.PYsymmetry_from_input = tempSymm. # handle variables; elif variable.match(line):; vname = variable.match(line).group(1).upper(); vval = float(variable.match(line).group(2)); tda = 360.0 * math.atan(math.sqrt(2)) / math.pi; self.geometry_variables['%s' % vname] = tda if vname == 'TDA' else vval. # handle charge and multiplicity; elif cgmp.match(line):; tempCharge = int(cgmp.match(line).group(1)); tempMultiplicity = int(cgmp.match(line).group(2)). if ifrag == 0:; self.PYcharge_specified = True; self.PYmultiplicity_specified = True; self.PYmolecular_charge = tempCharge; self.PYmultiplicity = tempMultiplicity; self.fragment_charges.append(tempCharge); self.fragment_multiplicities.append(tempMultiplicity). # handle fragment markers and default fragment cgmp; elif frag.match(line):; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1); ifrag += 1; glines.append(line). elif atom.match(line):; glines.append(line). # catch last default fragment cgmp; try:; self.fragment_charges[ifrag]; except:; self.fragment_charges.append(0); self.fragment_multiplicities.append(1). # Now go through the rest of the lines looking for fragment markers; ifrag = 0; iatom = 0; tempfrag = []; atomSym = """"; atomLabel = """"; zmatrix = False; for line in glines:. # hand",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:16159,charge,charge,16159,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,2,['charge'],['charge']
Energy Efficiency,"it. Basis set and auxiliary basis sets are assigned by atom type. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/kw-2; testing best practices options, part ii. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Test Suite and Sample Inputs. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_cfour-1.html:4468,energy,energy,4468,psi4manual/1.2.1/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_cfour-1.html,4,['energy'],['energy']
Energy Efficiency,"ital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self, arg0, arg1, arg2); docstring. build(mol[, basis]). c1_deep_copy(self, basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self, arg0); Deep copies the internal data. del_array_variable(self, arg0); Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key). density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction’s energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, arg0, arg1); Returns the requested Alpha Eigenvalues subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, arg0, arg1); Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. frequencies(). from_file(wfn_data); Summary. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). get_basisset(self, arg0); Returns the requested auxiliary basis. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Given a wavefunction and a scratch file number, canonicalizes the n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html:2555,energy,energy,2555,psi4manual/1.3.2/api/psi4.core.wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.wavefunction.html,2,['energy'],['energy']
Energy Efficiency,"itals. After SCF is; converged, the program will perform the energy computation using the ODC-12; method. By default, simultaneous algorithm will be used for the solution of; the equations. One can also request to perform geometry; optimization following example below:; 1; 2; 3; 4; 5; 6; 7; 8molecule {; H; H 1 1.0; }. set basis cc-pvdz. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the ODC-12 energy. After that, the ODC-12 analytic; gradients code will be executed and geometry optimization will be performed. Recommendations¶; Here is a list of recommendations for the DCFT module:. Generally, the use of the simultaneous algorithm together with the; AO_BASIS DISK option is recommended (set by default).; In cases when available memory is insufficient, the use of the AO_BASIS DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In cases when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by setting the; DIIS_START_CONVERGENCE option to the value greater than; \(10^{-3}\) by one or two orders of magnitude (e.g. \(10^{-2}\) or; \(10^{-1}\)). This can be particularly useful for computations using the; ODC methods, because it can greatly reduce the number of iterations.; If oscillatory convergence is observed for atoms or molecules with high; symmetry, it is recommended to use the quadratically-convergent algorithm.; When using the quadratically-convergent algorithm for the closed-shell molecules, it; is recommended to set the QC_COUPLING option to FALSE for efficiency; reasons (set by default).; For the ODC computations, the user has a ch",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dcft-1.html:14978,energy,energy,14978,psi4manual/1.2.1/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dcft-1.html,6,['energy'],['energy']
Energy Efficiency,"itation string. test_functional(self, arg0, arg1, arg2, ...); Quick testing capabilities. value(self, arg0); Returns a given internal value. values(self); Return all internal values. vv10_b(self); The VV10 b parameter. vv10_c(self); The VV10 c parameter. x_alpha(self); Amount of exact HF exchange. x_beta(self); Amount of exact HF exchange. x_functional(self, arg0); Returns the desired X Functional. x_functionals(self); Returns all X Functionals. x_omega(self); Range-seperated exchange parameter. xclib_description(self); LibXC version and citation string. Methods Documentation. static XC_build(arg0: str, arg1: bool) → psi4.core.SuperFunctional¶; Builds a SuperFunctional from a XC string. add_c_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional) → None¶; Add a correlation Functional. add_x_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional) → None¶; Add a exchange Functional. allocate(self: psi4.core.SuperFunctional) → None¶; Allocates the vectors, should be called after ansatz or npoint changes. ansatz(self: psi4.core.SuperFunctional) → int¶; SuperFunctional rung. static blank() → psi4.core.SuperFunctional¶; Initialize a blank SuperFunctional. c_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of MP2 correlation. c_functional(self: psi4.core.SuperFunctional, arg0: str) → psi4.core.Functional¶; Returns the desired C Functional. c_functionals(self: psi4.core.SuperFunctional) → List[psi4.core.Functional]¶; Returns all C Functionals. c_omega(self: psi4.core.SuperFunctional) → float¶; Range-seperated correlation parameter. c_os_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of SS MP2 correlation. c_ss_alpha(self: psi4.core.SuperFunctional) → float¶; Amount of OS MP2 correlation. citation(self: psi4.core.SuperFunctional) → str¶; SuperFunctional citation. compute_functional(self: psi4.core.SuperFunctional, vals: Dict[str, psi4.core.Vector], npoints: int = -1, singlet: bool = True) → Dict[str, psi4.core.Vector]¶; Compute",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SuperFunctional.html:4451,Allocate,Allocates,4451,psi4manual/1.8.x/api/psi4.core.SuperFunctional.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SuperFunctional.html,1,['Allocate'],['Allocates']
Energy Efficiency,"ite and Sample Inputs. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Test Suite and Sample Inputs. Test Suite and Sample Inputs¶; PSI4 is distributed with an extensive test suite, which can; be found in psi4/tests. After building the source code, these; can automatically be run by running ctest in the compilation; directory. More info on ctest options can be found; here. Sample input files; can be found in the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. ADCC; BRIANQC; CFOUR; CHEMPS2; COOKBOOK; DFTD3; DKH; LIBEFP; ERD; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. cubeprop; RHF orbitals and density for water. dft1-alt; DFT Functional Test. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. opt-multi-frozen-dimer-c2h; Frozen-fragment opt of C2h methane dimer with user-combined reference points. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Car",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/testsuite-1.html:948,energy,energy,948,psi4manual/1.4.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/testsuite-1.html,2,['energy'],['energy']
Energy Efficiency,"ite difference frequency computation, from energy points, for a given irrep.; ; C++ signature :; St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE fd_geoms_freq_0(N5boost10shared_ptrIN3psi8MoleculeEEE,i); ; fd_geoms_freq_1(...); fd_geoms_freq_1( (Molecule)arg1, (int)arg2) -> matrix_vector :; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; C++ signature :; St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE fd_geoms_freq_1(N5boost10shared_ptrIN3psi8MoleculeEEE,i); ; fisapt(...); fisapt( (Wavefunction)arg1) -> float :; Runs the functional-group intramolecular symmetry adapted perturbation theory code.; ; C++ signature :; d fisapt(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; flush_outfile(...); flush_outfile() -> None :; Flushes the output file.; ; C++ signature :; void flush_outfile(); ; fnocc(...); fnocc( (Wavefunction)arg1) -> Wavefunction :; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code; ; C++ signature :; N5boost10shared_ptrIN3psi12WavefunctionEEE fnocc(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; get_active_efp(...); get_active_efp() -> EFP :; Returns the currently active EFP object.; ; C++ signature :; N5boost10shared_ptrIN3psi3efp3EFPEEE get_active_efp(); ; get_active_molecule(...); get_active_molecule() -> Molecule :; Returns the currently active molecule object.; ; C++ signature :; N5boost10shared_ptrIN3psi8MoleculeEEE get_active_molecule(); ; get_array_variable(...); get_array_variable( (str)arg1) -> Matrix :; Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available).; ; C++ signature :; N5boost10shared_ptrIN3psi6MatrixEEE get_array_variable(Ss); ; get_array_variables(...); get_array_variables() -> dict :; Returns dictionary of the PSI variables set internally by the modules or python driver.; ; C++ signature :; N5boost6python4dictE get_array_variables(); ; get_atomic_point_charges(...); get_atomic_po",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:682058,energy,energy,682058,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['energy'],['energy']
Energy Efficiency,"ite(p4util.format_options_for_input()); p4util.format_kwargs_for_input(fmaster, 2, **kwargs); fmaster.write(""""""%s('%s', **kwargs)\n\n"""""" % (optimize.__name__, lowername)); fmaster.write(instructionsM); fmaster.close(). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1); #rfile = 'OPT-fd-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Gradient %d Computation: Displacement %d ')\n"""""" % (opt_iter, n + 1); banners += """"""psi4.print_out('\\n')\n\n"""""". if (opt_mode.lower() == 'continuous'):; # Print information to output.dat; psi4.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=""""). # Load in displacement into the active molecule; psi4.get_active_molecule().set_geometry(displacement). # Perform the energy calculation; #E = func(lowername, **kwargs); func(lowername, **kwargs); E = psi4.get_variable('CURRENT ENERGY'); #E = func(**kwargs). # Save the energy; energies.append(E). # S/R: Write each displaced geometry to an input file; elif (opt_mode.lower() == 'sow'):; psi4.get_active_molecule().set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(p4util.format_molecule_for_input(molecule)); freagent.write(p4util.format_options_for_input()); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""psi4.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:39488,energy,energy,39488,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"ite-difference frequencies from energies for H2O. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. sapt9; usapt example with empty beta. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. dft-jk; DFT JK on-disk test. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. scf-response2; Compute the dipole polarizability for water with custom basis set. fcidump; test FCIDUMP functionality for rhf/uhf. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. dft2; DFT Functional Test. fd-gradient; SCF STO-3G finite-difference tests. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). fnocc4; Test FNO-DF-CCSD(T) energy. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. dfmp2-freq1; DF-MP2 frequency by difference of energies fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:26824,energy,energy,26824,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"iteDifferenceComputer]. [docs]; def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| data and wavefunction with energy/gradient/hessian set appropriately when **return_wfn** specified. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element of a tuple. :type bsse_type: str or list; :param bsse_type: ``'cp'`` || ``['nocp', 'vmfc']`` || |dl| ``None`` |dr| || etc. Type of BSSE correction to compute: CP for counterpoise correction, NoCP; for plain supramolecular interaction energy, or VMFC for Valiron-Mayer; Function Counterpoise correction. If a list is provided, the first string in; the list determines which interaction or total energies/gradients/Hessians are; returned by this function. By default, many-body treatments are inactive. :type max_nbody: int; :param max_nbody: ``3`` || etc. Maximum n-body to compute, cannot exceed the number of fragments in the molecule. :type return_total_data: :ref:`boolean <op_py_boolean>`; :param return_total_data: ``'on'`` || |dl| ``'off'`` |dr|. If True returns the total data (energy/gradient/Hessian) of the system,; otherwise returns interaction data. Default is ``'off'`` for energies,; ``'on'`` for gradients and Hessians. Note that the calculation of total; counterpoise corrected energies implies the calculation of the energies of; monomers in the monomer basis, hence specifying ``return_total_data = True``; may carry out more computations than ``return_total_data = False``.; For gradients and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:9205,energy,energy,9205,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,6,['energy'],['energy']
Energy Efficiency,"iterCC'))] = mobj.group(3); psivar['%s TOTAL ENERGY' % (mobj.group('iterCC'))] = mobj.group(4). # Process CC(T); mobj = re.search(; r'^\s+' + r'(?:E\(SCF\))' + r'\s+=\s+' + NUMBER + r'\s+a\.u\.\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:E\(CCSD\))' + r'\s+=\s+' + NUMBER + r'\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:E\(CCSD\(T\)\))' + r'\s+=\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) vcc'); psivar['SCF TOTAL ENERGY'] = mobj.group(1); psivar['CCSD TOTAL ENERGY'] = mobj.group(2); psivar['(T) CORRECTION ENERGY'] = Decimal(mobj.group(3)) - Decimal(mobj.group(2)); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(3)) - Decimal(mobj.group(1)); psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(3). mobj = re.search(; r'^\s+' + r'(?:E\(SCF\))' + r'\s+=\s*' + NUMBER + r'\s+a\.u\.\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:CCSD energy)' + r'\s+' + NUMBER + r'\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:Total perturbative triples energy:)' + r'\s+' + NUMBER + r'\s*' +; r'^\s*(?:-+)\s*' +; r'^\s+' + r'(?:CCSD\(T\) energy)' + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) ecc'); psivar['SCF TOTAL ENERGY'] = mobj.group(1); psivar['CCSD TOTAL ENERGY'] = mobj.group(2); psivar['(T) CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(4)) - Decimal(mobj.group(1)); psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(4). mobj = re.search(; r'^\s+' + r'(?:CCSD energy)' + r'\s+' + NUMBER + r'\s*' +; r'^\s*(?:-+)\s*' +; r'^\s+' + r'(?:CCSD\(T\) energy)' + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) lamb'); psivar['CCSD TOTAL ENERGY'] = mobj.group(1); psivar['(T) CORRECTION ENERGY'] = Decimal(mobj.group(2)) - Decimal(mobj.group(1)); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(2)) - psivar['SCF TOTAL ENERGY']; psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(2). # Process SCS-CC; mobj = re.search(; r'^\s+' + r'(?P<fullCC>(?",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:13131,energy,energy,13131,psi4manual/1.0.0/_modules/qcdb/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html,2,['energy'],['energy']
Energy Efficiency,"iterature reference for dispersion parameters, if :py:attr:`dashparams`; corresponds to a defined, named, untweaked ""functional-dashlevel""; set with a citation. Otherwise, empty string.; dashcoeff_supplement : dict; See description in `qcengine.programs.empirical_dispersion_resources.from_arrays`. Used; here to ""bless"" the dispersion definitions attached to; the procedures/dft/<rung>_functionals-defined dictionaries; as legit, non-custom, and of equal validity to; `qcengine.programs.empirical_dispersion_resources.dashcoeff` itself for purposes of; validating :py:attr:`fctldash`.; engine : str; {'libdisp', 'dftd3', 'nl', 'mp2d', ""dftd4""}; Compute engine for dispersion. One of Psi4's internal libdisp; library, external Grimme or Beran projects, or nl.; disp : Dispersion; Only present for :py:attr:`engine` `=libdisp`. Psi4 class instance prepared; to compute dispersion.; ordered_params : list; Fixed-order list of relevant parameters for :py:attr:`dashlevel`. Matches; :rst:psivar:`DISPERSION CORRECTION ENERGY` ordering. Used for printing. Parameters; ----------; name_hint; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; ``dashcoeff[dashlevel][functional-without-dashlevel]`` or; ``dashcoeff_supplement[dashlevel][functional-with-dashlevel]``; can be overwritten via `param_tweaks`.; level_hint; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to one.; param_tweaks; Values for the same keys as `dashcoeff[dashlevel]['default']`; (and same order if list) used to override any or all values; initialized by `name_hint`. Extra parameters will error.; engine; Override which code computes dispersion. See above for allowed; values. Really only relevant for -D2, which can be computed by; libdisp or dftd3. """"""; def __init__(self, *, name_hint: str = None, level_hint: str =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html:4040,ENERGY,ENERGY,4040,psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,2,['ENERGY'],['ENERGY']
Energy Efficiency,"ith EOM-CCSD. casscf-sp; CASSCF/6-31G** energy point. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. fd-freq-gradient-large; SCF DZ finite difference frequencies by energies for C4NH4. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:2213,energy,energy,2213,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"ith Z-matrix input. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, at the UHF an ROHF levels of theory. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. dftd3-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN, calling Grimme’s dftd3 program for -D2 gradients. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. matrix1; An example of using BLAS and LAPACK calls directly from t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:17264,energy,energy,17264,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"ith corresponding input keywords:. Orbital-optimized MP and CC methods with conventional integrals (OMP Methods OCC keywords); Orbital-optimized MP and CC methods with DF and CD integrals (OMP Methods DFOCC keywords); Non-orbital-optimized MP and CC methods with conventional integrals (MP/CC Methods OCC keywords); Non-orbital-optimized MP and CC methods with DF and CD integrals (MP/CC Methods DFOCC keywords). Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in Psi4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OLCCD. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the orbital-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/occ-1.html:4742,energy,energy,4742,psi4manual/1.0.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/occ-1.html,2,['energy'],['energy']
Energy Efficiency,"ith disk ao algorithm. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. omp2-3; OMP2 cc-pVDZ energy for the NO radical. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. scf-guess-read3; Test if the the guess read in the same basis converges. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. ao-dfcasscf-sp; CASSCF/6-31G** energy point. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. cc52; CCSD Response for H2O2. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:14211,energy,energy,14211,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ith iterative triples (cheaper terms). mrccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). mrccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). mrccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). mrcc2; approximate CC through doubles. mrcc3; approximate CC through triples. mrcc4; approximate CC through quadruples. mrcc5; approximate CC through quintuples. mrcc6; approximate CC through sextuples. mrccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). mrccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). mrccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). mrccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. bypass_scf (boolean) – 'on' || 'off' ; Indicates whether, for name values built atop of scf calculations,; the scf step is skipped. Suitable when special steps are taken to get; the scf to converge in an explicit preceeding scf step. Examples :. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into requested basis; >>> energy('sapt0-ct',cast_up=True). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp4'). Previous topic; Notes on Options; Next topic; Property; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/energy-1.html:7375,energy,energy,7375,psi4manual/4.0b2/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/energy-1.html,6,['energy'],['energy']
Energy Efficiency,"ith mp2/v[dt]z + d:ccsd(t)/vdz. freq-masses; check nonphysical masses possible. scf-level-shift-cuhf; SCF level shift on a CUHF computation. dft-freq-analytic1; Analytic SVWN frequencies, compared to finite difference values. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. mbis-2; MBIS calculation on OH- (Expanded Arrays). sapt-sf1; Tests the Psi4 SF-SAPT code. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. cc13d; Tests analytic CC2 gradients. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. fsapt-ext-abc2; FSAPT with external charge on dimer. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. cbs-xtpl-energy; Extrapolated water energies - density-fitted version. dforemp-grad2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. nbody-vmfc-hessian; Computation of VMFC-correct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:15344,charge,charge,15344,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['charge'],['charge']
Energy Efficiency,"ith n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. fcidump; test FCIDUMP functionality for rhf/uhf. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). fci-h2o; 6-31G H2O Test FCI Energy Point. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:19266,energy,energy,19266,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ith n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. fcidump; test FCIDUMP functionality for rhf/uhf. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). fci-h2o; 6-31G H2O Test FCI Energy Point. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. numpy-a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:18386,energy,energy,18386,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['energy'],['energy']
Energy Efficiency,"ith p4Mol. harvest_DIPOL(dipol)[source]¶; Parses the contents dipol of the Cfour DIPOL file into a dipol vector. harvest_FCM(fcm)[source]¶; Parses the contents fcm of the Cfour FCMFINAL file into a hessian array. harvest_GRD(grd)[source]¶; Parses the contents grd of the Cfour GRD file into the gradient; array and coordinate information. The coordinate info is converted; into a rather dinky Molecule (no charge, multiplicity, or fragment),; but this is these coordinates that govern the reading of molecule; orientation by Cfour. Return qcdb.Molecule and gradient array. harvest_outfile_pass(outtext)[source]¶; Function to read CFOUR output file outtext and parse important; quantum chemical information from it in. harvest_output(outtext)[source]¶; Function to separate portions of a CFOUR output file outtest,; divided by xjoda. harvest_zmat(zmat)[source]¶; Parses the contents of the Cfour ZMAT file into array and; coordinate information. The coordinate info is converted into a; rather dinky Molecule (no fragment, but does read charge, mult,; unit). Return qcdb.Molecule. Written for findif zmat* where; geometry always Cartesian and Bohr. jajo2mol(jajodic)[source]¶; Returns a Molecule from entries in dictionary jajodic extracted; from JAINDX and JOBARC. muster_memory(mem)[source]¶; Transform input mem in MB into psi4-type options for cfour. muster_modelchem(name, dertype)[source]¶; Transform calculation method name and derivative level dertype; into options for cfour. While deliberately requested pieces,; generally CFOUR_DERIV_LEVEL and CFOUR_CALC_LEVEL,; are set to complain if contradicted (‘clobber’ set to True), other; ‘recommended’ settings, like CFOUR_CC_PROGRAM, can be; countermanded by keywords in input file (‘clobber’ set to False).; Occasionally, want these pieces to actually overcome keywords in; input file (‘superclobber’ set to True). muster_psi4options(opt)[source]¶; Translate psi4 keywords opt that have been explicitly set into; their Cfour counterparts. Since e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:26856,charge,charge,26856,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency,"ith the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals.; DIRECT; A threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis function, uses zero disk, and can obtain significant; speedups with negligible error loss if the INTS_TOLERANCE value; is set to 1.0E-8 or so.; DF [Default]; A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, not the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for all Dunning bases, otherwise the DF_BASIS_SCF keyword",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/scf-1.html:18822,reduce,reduce,18822,psi4manual/4.0b5/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/scf-1.html,2,['reduce'],['reduce']
Energy Efficiency,"ith the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An out-of-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; A threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast up to; 1500 basis function, uses zero disk, and can obtain significant speedups with; negligible error loss if the INTS_TOLERANCE value is set to 1.0E-8 or so.; DF [Default]; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/scf-1.html:18822,reduce,reduce,18822,psi4manual/4.0b4/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/scf-1.html,2,['reduce'],['reduce']
Energy Efficiency,"ith the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; Psi4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals.; DIRECT; A threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis function, uses zero disk, and can obtain significant; speedups with negligible error loss if the INTS_TOLERANCE value; is set to 1.0E-8 or so.; DF [Default]; A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, not the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for all Dunning bases, otherwise the DF_BASIS_SCF keyword",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:18753,reduce,reduce,18753,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['reduce'],['reduce']
Energy Efficiency,"ith the same algorithms. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. fci-h2o; 6-31G H2O Test FCI Energy Point. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. cepa1; cc-pvdz H2O Test CEPA(1) Energy. ao-casscf-sp; CASSCF/6-31G** energy point. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. tdscf-6; td-camb3lyp with DiskDF and method/basis specification. cubeprop; RHF orbitals and density for water. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. scf-level-shift-uhf; SCF level shift on a UHF computation. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dft-grad1; DF-BP86-D2 cc-pVDZ frozen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:13915,energy,energy,13915,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"ithout displacement: {:15.10f}\n""; "" Check energies below for precision!\n{}"".format(; len(displacements) + 1, findifrec[""stencil_size""], ref_energy, out_str)). data = _initialize_findif(mol, freq_irrep_only, ""2_0"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False). massweighter = np.repeat([mol.mass(a) for a in range(data[""n_atom""])], 3)**(-0.5); B_pi = []; H_pi = []; irrep_lbls = mol.irrep_labels(); max_disp = (findifrec[""stencil_size""] - 1) // 2; e_per_diag = 2 * max_disp. # Unlike in the gradient case, we have no symmetry transformations to worry about.; # We get to the task directly: assembling the force constants in each irrep block.; for h in range(data[""n_irrep""]):; salc_indices = data[""salc_indices_pi""][h]; if not salc_indices: continue. n_salcs = len(salc_indices); E = np.zeros((len(salc_indices), e_per_diag)). # Step One: Diagonals; # For asymmetric irreps, the energy at a + disp is the same as at a - disp; # Just reuse the - disp energy for the + disp energy. for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = displacements[f""{salc_index}: {-j}""][""energy""]; k = -j if h else j # Because of the +- displacement trick; E[i, max_disp + j - 1] = displacements[f""{salc_index}: {k}""][""energy""]; # Now determine all diagonal force constants for this irrep.; if findifrec[""stencil_size""] == 3:; diag_fcs = E[:, 0] + E[:, 1]; diag_fcs -= 2 * ref_energy; diag_fcs /= (findifrec[""step""][""size""]**2); elif findifrec[""stencil_size""] == 5:; diag_fcs = -E[:, 0] + 16 * E[:, 1] + 16 * E[:, 2] - E[:, 3]; diag_fcs -= 30 * ref_energy; diag_fcs /= (12 * findifrec[""step""][""size""]**2); H_irr = np.diag(diag_fcs). # TODO: It's a bit ugly to use the salc indices to grab the off-diagonals but the indices; # within the irrep to grab the diagonals. Is there a better way to do this?. # Step Two: Off-diagonals; # We need off-diagonal energies, diagonal e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:38279,energy,energy,38279,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,24,['energy'],['energy']
Energy Efficiency,"ition in; fsapt.dat. For our problem, the bottom of this file contains the finished; partition:; Frag1 Frag2 Elst Exch IndAB IndBA Disp Total; OH OH -8.425 6.216 -0.583 -1.512 -1.249 -5.553; OH PH 1.392 0.716 0.222 -0.348 -0.792 1.189; PH OH -2.742 0.749 -0.147 -0.227 -0.674 -3.040; PH PH 0.680 2.187 0.007 -0.208 -2.400 0.266; OH All -7.033 6.931 -0.362 -1.860 -2.040 -4.364; PH All -2.062 2.936 -0.140 -0.435 -3.074 -2.774; All OH -11.167 6.965 -0.730 -1.739 -1.923 -8.594; All PH 2.072 2.903 0.229 -0.556 -3.191 1.456; All All -9.095 9.867 -0.501 -2.295 -5.114 -7.138. Note that the assignment of linking sigma bond contributions is a small point of; ambiguity in F-SAPT. The fsapt.dat file presents the “links-by-charge”; assignment at the top and the “links by 50-50” assignment at the bottom. We; generally prefer the latter, but both generally give qualitatively identical; energetic partitions.; Users should check the files fragA.dat and fragB.dat to ensure that; there is not too much charge delocalization from one fragment to another. This; is presented in the “Orbital Check” section in these files – a value larger than; 0.1 docc is an indication that the picture of localizable functional groups may; be breaking down. We also strongly discourage the cutting of double,; triple, or aromatic bonding motifs when partitioning the molecule into fragments; – cuts across only simple sigma bonds are encouraged. Caution; November 2022, previous to QCEngine v0.26.0 and Psi4; v1.7.0, there was a scaling inconsistency in the pairwise analysis; such that 2-BODY PAIRWISE DISPERSION CORRECTION ANALYSIS; was doubled when generated from dftd3 compared to the output from other; programs (s-dftd3 and dftd4). This shows up in the QCVariable and in the; Empirical_Disp.dat file written during energy(""fisapt0-d3"") (all; -D3 variants). Fortunately, the fsapt.py script compensated; for dftd3 (by far the most used program for this task). Users of the; pairwise analysis should take care to use the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/fisapt.html:6450,charge,charge,6450,psi4manual/1.7.x/fisapt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/fisapt.html,4,['charge'],['charge']
Energy Efficiency,"ition in; fsapt.dat. For our problem, the bottom of this file contains the finished; partition:; Frag1 Frag2 Elst Exch IndAB IndBA Disp Total; OH OH -8.425 6.216 -0.583 -1.512 -1.249 -5.553; OH PH 1.392 0.716 0.222 -0.348 -0.792 1.189; PH OH -2.742 0.749 -0.147 -0.227 -0.674 -3.040; PH PH 0.680 2.187 0.007 -0.208 -2.400 0.266; OH All -7.033 6.931 -0.362 -1.860 -2.040 -4.364; PH All -2.062 2.936 -0.140 -0.435 -3.074 -2.774; All OH -11.167 6.965 -0.730 -1.739 -1.923 -8.594; All PH 2.072 2.903 0.229 -0.556 -3.191 1.456; All All -9.095 9.867 -0.501 -2.295 -5.114 -7.138. Note that the assignment of linking sigma bond contributions is a small point of; ambiguity in F-SAPT. The fsapt.dat file presents the “links-by-charge”; assignment at the top and the “links by 50-50” assignment at the bottom. We; generally prefer the latter, but both generally give qualitatively identical; energetic partitions.; Users should check the files fragA.dat and fragB.dat to ensure that; there is not too much charge delocalization from one fragment to another. This; is presented in the “Orbital Check” section in these files – a value larger than; 0.1 docc is an indication that the picture of localizable functional groups may; be breaking down. We also strongly discourage the cutting of double,; triple, or aromatic bonding motifs when partitioning the molecule into fragments; – cuts across only simple sigma bonds are encouraged. Order-1 Visualization with PyMol¶; The fsapt.py script above also generates a number of order-1 .pdb files; that can be used to get a quick qualitative picture of the F-SAPT partition. The; preferred way to do this is to use PyMol to make plots of the molecular geometry; with the atoms colored according to their order-1 F-SAPT contributions. We have; a set of template .pymol scripts to help with this process. These can be; obtained by running:; >>> copy_pymol.py. and then in PyMol:; >>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; Elst.pym",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fisapt-1.html:6450,charge,charge,6450,psi4manual/1.4.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fisapt-1.html,5,['charge'],['charge']
Energy Efficiency,"itional thread. Type: boolean; Default: false. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. CCD_E_CONVERGENCE¶. E converge value for CCD. Type: conv double; Default: 1e-8. CCD_MAXITER¶. Max CCD iterations. Type: integer; Default: 50. CCD_T_CONVERGENCE¶. Convergence tolerance for CCD amplitudes. Type: conv double; Default: 1e-8. CPHF_R_CONVERGENCE¶. Convergence criterion for residual of the CPHF/CPKS coefficients in the SAPT \(E_{ind,resp}^{(20)}\) term. This applies to wavefunction-based SAPT or SAPT(DFT). See CPHF_R_CONVERGENCE for fragment-partitioned or intramolecular SAPT. Type: conv double; Default: 1e-8. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to a JKFIT basis. Previous to v1.6, defaulted to DF_BASIS_SAPT See fitting notes . Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT \(E_{disp}^{(20)}\) and \(E_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__sapt.html:1593,energy,energy,1593,psi4manual/master/autodir_options_c/module__sapt.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__sapt.html,2,['energy'],['energy']
Energy Efficiency,"itioning follows I-SAPT. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). opt11; Transition-state optimizations of HOOH to both torsional transition states. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. dforemp-grad1; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O molecule. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. aediis-1; ADIIS test case, from 10.1063/1.3304922. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. scf-guess-read2; Test if the the guess read in the same basis converges. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. dft-grad-meta; meta-GGA gradients of water and ssh molecules reference gradients updated due to new BraggSlater radii. fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. scf-level-shift-cuhf; SCF level shift on a CUHF computation. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:43489,energy,energy,43489,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['energy'],['energy']
Energy Efficiency,"itrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; # Set method-dependent scf convergence criteria; if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 6); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 8); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 6); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 8). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 6). procedures['energy'][lowername](lowername, **kwargs). except KeyError:; raise ValidationError('Energy method %s not available.' % (lowername)). optstash.restore(); return PsiMod.get_variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. optstash = OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:30195,energy,energy,30195,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['energy'],['energy']
Energy Efficiency,"its are implemented right now""). psi4.print_out(""\n\nPerforming a %d-point fit\n"" % npoints). psi4.print_out(""\nOptimizing geometry based on current surface:\n\n"");; if (npoints == 5):; optx = rvals[2]; elif (npoints == 9):; optx = rvals[4]. # Molecule can be passed in be user. Look at the function definition above.; if mol == None:; mol = psi4.get_active_molecule(); natoms = mol.natom(); if natoms != 2:; raise Exception(""The current molecule must be a diatomic for this code to work!""); m1 = mol.mass(0); m2 = mol.mass(1). maxit = 30; thres = 1.0e-9; for i in range(maxit):; if (npoints == 5):; grad= first_deriv_5pt(rvals, energies, optx); secd = second_deriv_5pt(rvals, energies, optx); energy = function_5pt(rvals, energies, optx); elif (npoints == 9):; grad = first_deriv_9pt(rvals, energies, optx); secd = second_deriv_9pt(rvals, energies, optx); energy = function_9pt(rvals, energies, optx); psi4.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (energy, optx, grad)); if abs(grad) < thres:; break; optx -= grad / secd;; psi4.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (function_5pt(rvals, energies, optx), optx, grad));. if optx < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if optx > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). if (npoints == 5):; energy = function_5pt(rvals, energies, optx); first = first_deriv_5pt(rvals, energies, optx); secd = second_deriv_5pt(rvals, energies, optx) * p4const.psi_hartree2aJ; third = third_deriv_5pt(rvals, energies, optx) * p4const.psi_hartree2aJ; fourth = fourth_deriv_5pt(rvals, energies, optx) * p4const.psi_hartree2aJ; elif (npoints == 9):; energy = function_9pt(rvals, energies, optx); first = first_deriv_9pt(rvals, energies, optx); secd = second_deriv_9pt(rvals, energies, optx) * p4const.psi_hartree2aJ; third = third_deriv_9pt(rvals, energies, optx) * p4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/diatomic.html:3271,energy,energy,3271,psi4manual/4.0b5/_modules/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/diatomic.html,2,['energy'],['energy']
Energy Efficiency,"its output file. :type irrep: int or string; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] <example description>; >>> <example python command>. >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> frequencies('scf', dertype=1, irrep=4). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Compute the hessian; hessian(name, **kwargs). if not (('mode' in kwargs) and (kwargs['mode'].lower() == 'sow')):; # call thermo module; psi4.thermo(). #TODO add return current energy once satisfied that's set to energy at eq, not a findif; return psi4.get_variable('CURRENT ENERGY'). ## Aliases ##; frequencies = frequency; freq = frequency. [docs]def molden(filename):; """"""Function to write wavefunction information in molden; format to *filename*. """"""; m = psi4.MoldenWriter(psi4.wavefunction()); m.write(filename). [docs]def parse_cotton_irreps(irrep):; r""""""Function to return validated Cotton ordering index from string or integer; irreducible representation *irrep*. """"""; cotton = {; 'c1': {; 'a': 1,; '1': 1; },; 'ci': {; 'ag': 1,; 'au': 2,; '1': 1,; '2': 2; },; 'c2': {; 'a': 1,; 'b': 2,; '1': 1,; '2': 2; },; 'cs': {; 'ap': 1,; 'app': 2,; '1': 1,; '2': 2; },; 'd2': {; 'a': 1,; 'b1': 2,; 'b2': 3,; 'b3': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2v': {; 'a1': 1,; 'a2': 2,; 'b1': 3,; 'b2': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2h': {; 'ag': 1,; 'bg': 2,; 'au': 3,; 'bu': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; },; 'd2h': {; 'ag': 1,; 'b1g': 2,; 'b2g': 3,; 'b3g': 4,; 'au': 5,; 'b1u",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:73569,energy,energy,73569,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,4,['energy'],['energy']
Energy Efficiency,"its; omega_tol = kwargs.get('omega_tolerance', 1.0E-3). # By default, do up to twenty iterations; maxiter = kwargs.get('maxiter', 20). # By default, do not read previous 180 orbitals file; read = False; read180 = ''; if 'read' in kwargs:; read = True; read180 = kwargs['read']. # The molecule is required, and should be the neutral species; molecule.update_geometry(); charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). # How many electrons are there?; N = 0; for A in range(molecule.natom()):; N += molecule.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). # Work in the ot namespace for this procedure; psi4.IO.set_default_namespace(""ot""). # Burn in to determine orbital eigenvalues; if read:; psi4.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180); old_guess = psi4.get_global_option(""GUESS""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""); psi4.print_out(""""""\n\t==> IP Fitting SCF: Burn-in <==\n""""""); E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # Determine HOMO, to determine mult1; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. Na1 = Na;; Nb1 = Nb;; if HOMO > 0:; Na1 = Na1 - 1;; else:; Nb1 = Nb1 - 1;. charge1 = charge0 + 1;; mult1 = Na1 - Nb1 + 1. omegas = []; E0s = []; E1s = []; kIPs = []; IPs = []; types = []. # Right endpoint; psi4.set_global_option('DFT_OMEGA', omega_r). # Neutral; if read:; psi4.set_global_option(""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); psi4.print_out(""""""\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n""""""); E0r, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); E_HOMO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/frac.html:12757,energy,energy,12757,psi4manual/1.0.0/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html,1,['energy'],['energy']
Energy Efficiency,"itten via param_tweaks.; level_hint (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or; “formal” to one.; param_tweaks (Union[Dict, List, None]) – Values for the same keys as dashcoeff[dashlevel][‘default’]; (and same order if list) used to override any or all values; initialized by name_hint. Extra parameters will error.; engine (Optional[str]) – Override which code computes dispersion. See above for allowed; values. Formerly (pre Nov 2022) only relevant for -D2, which can be computed by; libdisp or dftd3. Now (post Nov 2022) also relevant for -D3 variants,; which can be computed by dftd3 executable or simple-dftd3 Python module.; gcp_engine (Optional[str]) – Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp (bool) – Whether to request atomic pairwise analysis. Methods Summary. compute_energy(molecule[, wfn]); Compute dispersion energy based on engine, dispersion level, and parameters in self. compute_gradient(molecule[, wfn]); Compute dispersion gradient based on engine, dispersion level, and parameters in self. compute_hessian(molecule[, wfn]); Compute dispersion Hessian based on engine, dispersion level, and parameters in self. print_out(); Format dispersion parameters of self for output file. Methods Documentation. compute_energy(molecule, wfn=None)[source]¶; Compute dispersion energy based on engine, dispersion level, and parameters in self. Parameters:. molecule (Molecule) – System for which to compute empirical dispersion correction.; wfn (Optional[Wavefunction]) – Location to set QCVariables. Returns:; Dispersion energy [Eh]. Return type:; float. Notes. DISPERSION CORRECTION ENERGYDisp always set. Overridden in SCF finalization, but that only changes for “-3C” methods. fctl DISPERSION CORRECTION ENERGYSet if fctldash nonempty. compute_gradient(molecule, wfn=None)[source]¶; Compute dispersion gradient based o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.EmpiricalDispersion.html:3797,energy,energy,3797,psi4manual/1.7.x/api/psi4.driver.EmpiricalDispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.EmpiricalDispersion.html,6,['energy'],['energy']
Energy Efficiency,"itter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta5] » ; Mod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:3997,charge,charges,3997,psi4manual/4.0b5/_modules/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html,2,['charge'],['charges']
Energy Efficiency,"itter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Bohr. """"""; self.charges.append([Q, x, y, z]). [docs] def addChargeAngstrom(self, Q, x, y, z):; """"""Function to add a point charge of magnitude *Q* at; position (*x*, *y*, *z*) Angstroms. """"""; self.charges.append([Q, x / p4const.psi_bohr2angstroms, y / p4const.psi_bohr2angstroms, z / p4const.psi_bohr2angstroms]). def __str__(self):. s = ' ==> QMMM <==\n\n'. s = s + ' => Charges (a.u.) <=\n\n'; s = s + ' %11s %11s %11s %11s\n' % ('Z', 'x', 'y', 'z'); for k in range(0, len(self.charges)):; s = s + ' %11.7f %11.3E %11.3E %11.3E\n' % (self.charges[k][0], self.charges[k][1], self.charges[k][2], self.charges[k][3]); s = s + '\n'. s = s + ' => Diffuses <=\n\n'. for k in range(0, len(self.diffuses)):; s = s + str(self.diffuses[k]). return s. [docs] def populateExtern(self):; """"""Function to define a charge field external to the; molecule through point and diffuse charges. """"""; # Charges; for charge in self.charges:; self.extern.addCharge(charge[0], charge[1], charge[2], charge[3]); # Diffuses; for diffuse in self.diffuses:; diffuse.populateExtern(self.extern). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html:4154,charge,charges,4154,psi4manual/1.0.0/_modules/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qmmm.html,1,['charge'],['charges']
Energy Efficiency,"itudes. Type: integer; Default: 50. CEPA_OS_SCALE¶. CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 1.27. CEPA_SOS_SCALE¶. CEPA Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. CEPA_SS_SCALE¶. CEPA same-spin scaling value from SCS-CCSD. Type: double; Default: 1.13. CEPA_TYPE¶. CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: CEPA0; Default: CEPA0. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 14. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. DO_SCS¶. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E3_SCALE¶. Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. EA_POLES¶. Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EKT_EA¶. Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP¶. Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EP_EA_POLES¶. Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES¶. Do compute EP-OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. EP_MAXITER¶. Maximum number of electron propagator iterations. Type: integer; Def",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__occ-1.html:2180,energy,energy,2180,psi4manual/1.3.2/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__occ-1.html,16,['energy'],['energy']
Energy Efficiency,"ity RMS convergence to stop an instruction during successive DMRG instructions. Type: double; Default: 1.e-6. DMRG_SCF_MAX_ITER (DMRG); DMRG — Maximum number of DMRG iterations. Type: integer; Default: 100. DMRG_SCF_STATE_AVG (DMRG); DMRG — Whether or not to use state-averaging for roots >=2 with DMRG-SCF. Type: boolean; Default: true. DMRG_SWEEP_DVDSON_RTOL (DMRG); DMRG — The residual tolerances for the Davidson diagonalization during DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_ENERGY_CONV (DMRG); DMRG — The energy convergence to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_MAX_SWEEPS (DMRG); DMRG — The maximum number of sweeps to stop an instruction during successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_NOISE_PREFAC (DMRG); DMRG — The noiseprefactors for successive DMRG instructions. Type: array; Default: No Default. DMRG_SWEEP_STATES (DMRG); DMRG — The number of reduced renormalized basis states to be retained during successive DMRG instructions. Type: array; Default: No Default. DMRG_UNITARY_WRITE (DMRG); DMRG — Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. DO_CCD_DISP (SAPT); SAPT (Expert) — Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_DIIS (DFOCC); DFOCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DIIS (OCC); OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT (DFOCC); DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC); OCC — Do apply level shifting?. Type: boolean; Default: true. DO_MBPT_DISP (SAPT); SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_QQR_SIEVE (CPHF); CPHF — Do we do the QQR integral sieve of Maurer et al. When false, just uses * the Schwarz sieve. Type: boolean; Default: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:109787,reduce,reduced,109787,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['reduce'],['reduced']
Energy Efficiency,"ity as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. filename (string) – destination file name for MOLDEN file (optional); do_virtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional); use_natural (bool) – write natural orbitals determined from density on wavefunction. Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; “properties” or “gradient” must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.`; The first two arguments of get_opdm can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(wfn, 'no_root1.molden', use_natural=True). write_nbo(name)¶. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; CUHF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:35831,energy,energy,35831,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,1,['energy'],['energy']
Energy Efficiency,"ity as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. filename (string) – destination file name for MOLDEN file (optional); do_virtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional); use_natural (bool) – write natural orbitals determined from density on wavefunction. Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; “properties” or “gradient” must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.`; The first two arguments of get_opdm can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(wfn, 'no_root1.molden', use_natural=True). write_nbo(name)¶. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; ROHF. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.rohf.html:36081,energy,energy,36081,psi4manual/1.4.0/api/psi4.core.rohf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.rohf.html,2,['energy'],['energy']
Energy Efficiency,"ity as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. filename (string) – destination file name for MOLDEN file (optional); do_virtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional); use_natural (bool) – write natural orbitals determined from density on wavefunction. Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; “properties” or “gradient” must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.`; The first two arguments of get_opdm can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(wfn, 'no_root1.molden', use_natural=True). write_nbo(name)¶. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; CUHF. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:37521,energy,energy,37521,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,2,['energy'],['energy']
Energy Efficiency,"ity as this is often; much more costly than the energy. In addition, the Wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns; None. Parameters. filename (string) – destination file name for MOLDEN file (optional); do_virtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional); use_natural (bool) – write natural orbitals determined from density on wavefunction. Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; “properties” or “gradient” must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.`; The first two arguments of get_opdm can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(wfn, 'no_root1.molden', use_natural=True). write_nbo(name)¶. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; ROHF. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.rohf.html:38242,energy,energy,38242,psi4manual/1.5.0/api/psi4.core.rohf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.rohf.html,2,['energy'],['energy']
Energy Efficiency,"ity in the MO basis to build alpha NO’s from (optional); density_b (Matrix) – density in the MO basis to build beta NO’s from, assumes restricted if not supplied (optional); dovirtual (bool) – do write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs, not valid for NO’s (false) (optional). Examples. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> molden(wfn, 'mycalc.molden'). Molden file for CI/MCSCF computation using NO roots.; Any method returning a CIWavefunction object will work: detci,; fci, casscf, etc. The first two arguments of get_opdm can be; set to n, n where n => 0 selects the root to write out, provided; these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> molden(wfn, 'no_root1.molden', density_a=wfn.get_opdm(0, 0, ""A"", True)). The following produces an INCORRECT Molden file, because the; molden function needs orbitals in the MO basis (which are internally; converted and written to the Molden file in the AO basis). The correct; usage is given in the next point.; >>> E, wfn = energy('ccsd', return_wfn=True); >>> molden(wfn, 'ccsd_no.molden', density_a=wfn.Da()). Molden file with the natural orbitals of the ground-state 1RDM of a; Post-HF calculation. Note the required transformation of Da (SO->MO).; >>> E, wfn = properties('ccsd', return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; molden. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.molden.html:2169,energy,energy,2169,psi4manual/1.6.x/api/psi4.driver.molden.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.molden.html,2,['energy'],['energy']
Energy Efficiency,"ity(self: psi4.core.Molecule) → int; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule) → int; Number of real and dummy atoms. name(self: psi4.core.Molecule) → str; Gets molecule name. natom(self: psi4.core.Molecule) → int; Number of real atoms. nfragments(self: psi4.core.Molecule) → int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to a specified origin. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, withe respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: List[float[3]]=[0.0, 0.0, 0.0]) → float; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, arg0: List[float[3]]) → psi4.core.Matrix; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule) → psi4.core.Matrix; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule) → bool; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule) → psi4.core.PointGroup; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule) → None; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule) → None; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule) → None; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule) → None; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule) → None; Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self: psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:45355,energy,energy,45355,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['energy'],['energy']
Energy Efficiency,"ivar['(T) CORRECTION ENERGY'] = Decimal(mobj.group(3)) - Decimal(mobj.group(2)); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(3)) - Decimal(mobj.group(1)); psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(3). mobj = re.search(; r'^\s+' + r'(?:E\(SCF\))' + r'\s+=\s*' + NUMBER + r'\s+a\.u\.\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:CCSD energy)' + r'\s+' + NUMBER + r'\s*' +; r'(?:.*?)' +; r'^\s+' + r'(?:Total perturbative triples energy:)' + r'\s+' + NUMBER + r'\s*' +; r'^\s*(?:-+)\s*' +; r'^\s+' + r'(?:CCSD\(T\) energy)' + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) ecc'); psivar['SCF TOTAL ENERGY'] = mobj.group(1); psivar['CCSD TOTAL ENERGY'] = mobj.group(2); psivar['(T) CORRECTION ENERGY'] = mobj.group(3); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(4)) - Decimal(mobj.group(1)); psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(4). mobj = re.search(; r'^\s+' + r'(?:CCSD energy)' + r'\s+' + NUMBER + r'\s*' +; r'^\s*(?:-+)\s*' +; r'^\s+' + r'(?:CCSD\(T\) energy)' + r'\s+' + NUMBER + r'\s*$',; outtext, re.MULTILINE | re.DOTALL); if mobj:; print('matched ccsd(t) lamb'); psivar['CCSD TOTAL ENERGY'] = mobj.group(1); psivar['(T) CORRECTION ENERGY'] = Decimal(mobj.group(2)) - Decimal(mobj.group(1)); psivar['CCSD(T) CORRELATION ENERGY'] = Decimal(mobj.group(2)) - psivar['SCF TOTAL ENERGY']; psivar['CCSD(T) TOTAL ENERGY'] = mobj.group(2). # Process SCS-CC; mobj = re.search(; r'^\s+' + r'(?P<fullCC>(?P<iterCC>CC(?:\w+))(?:\(T\))?)' + r'\s+(?:energy will be calculated.)\s*' +; r'(?:.*?)' +; r'^\s*' + r'(?:@CCENRG-I, Correlation energies.)' + r'\s+(?:ECCAA)\s+' + NUMBER + r'\s*' +; r'^\s+(?:ECCBB)\s+' + NUMBER + '\s*' +; r'^\s+(?:ECCAB)\s+' + NUMBER + '\s*' +; r'^\s+(?:Total)\s+' + NUMBER + '\s*',; outtext, re.MULTILINE | re.DOTALL); if mobj: # PRINT=2 to get SCS-CC components; print('matched scscc'); psivar['%s SAME-SPIN CORRELATION ENERGY' % (mobj.group('iterCC'))] = Decimal(mobj.group(3)) + Decimal(mobj.group(4))",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:13644,energy,energy,13644,psi4manual/1.0.0/_modules/qcdb/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html,2,['energy'],['energy']
Energy Efficiency,"ive eigenvalues are encountered in the totally symmetric Hessian during an NR or MANR geometry-optimization search. If ABORT (=0), the job will terminate with an error message; if SWITCH (=1) the program will just switch the eigenvalue to its absolute value and keep plugging away (this is strongly discouraged!); and if RFA (=2), the keyword CFOUR_GEO_METHOD is switched to RFA internally and the optimization is continued. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead. Type: string; Possible Values: ABORT, SWITCH, RFA; Default: ABORT. CFOUR_NEWNORM (CFOUR)¶CFOUR — All components of spherical AO’s are normalized to 1. This feature can help with numerical convergence issues if AO integrals are involved. Currently only working for single-point energy calculations. Type: boolean; Default: false. CFOUR_NONHF (CFOUR)¶CFOUR — Specifies whether the reference function used in the correlation energy calculation satisfies the (spin-orbital) HF equations or not. Usually there is no need to set this parameter (OFF = 0 and ON =1), since standard non-HF reference functions (QRHF and ROHF) set this flag automatically. Type: boolean; Default: false. CFOUR_NTOP_TAMP (CFOUR)¶CFOUR — Specifies how many t amplitudes will be printed for each spin case and excitation level. For =N, The largest N amplitudes for each spin case and excitation level will be printed. Type: integer; Default: 15. CFOUR_OCCUPATION (CFOUR)¶CFOUR — Specifies the orbital occupancy of the reference function in terms of the occupation numbers of the orbitals and their irreducible representations. The occupancy is specified by either NIRREP or 2*NIRREP integers specifying the number of occupied orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. If the ref",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:58940,energy,energy,58940,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['energy'],['energy']
Energy Efficiency,"ive. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,; energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a ti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psithoninput.html:13565,energy,energy,13565,psi4manual/1.6.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psithoninput.html,1,['energy'],['energy']
Energy Efficiency,"iver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = core.variable('SCF ITERATION ENERGY'); C = 0. if HOMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps.np[HOMO - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps.np[-HOMO - 1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). core.set_local_option(""SCF"", ""FRAC_START"", 2); # NYI core.set_local_option(""SCF"", ""FRAC_LOAD"", True); core.set_local_option(""SCF"", ""FRAC_DIIS"", frac_diis); core.set_local_option(""SCF"", ""GUESS"", ""READ""). # Set the next charge/mult; molecule.set_molecular_charge(charge); molecule.set_multiplicity(mult). # Determine HOMO; print('DGAS: What ref should this point to?'); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. stats.append("""""" %6d %6d %6d %6d %6d %6d\n"""""" % (Nintegral-1, Na, Nb, charge, mult, HOMO)). if HOMO > 0:; Na -= 1; else:; Nb -= 1; charge += 1; mult = Na - Nb + 1. core.set_local_option(""SCF"", ""DF_INTS_IO"", ""NONE""). # => Print the results out <= #; E = {}; core.print_out(""""""\n ==> Fractional Occupation Nuke Results <==\n\n""""""); core.print_out("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; core.print_out("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. core.print_out('\n'); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; core.print_out(line). core.print_out('\n ""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); core.print_out(' -Starship Troopers\n'). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.wr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:13148,charge,charge,13148,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,8,['charge'],['charge']
Energy Efficiency,"ividually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. sapt3; SAPT2+3 aug-cc-pVDZ computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). adc1; ADC/6-31G** on H2O. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, at the UHF an ROHF levels of theory. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:13695,energy,energy,13695,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['energy'],['energy']
Energy Efficiency,"iwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:135627,ENERGY,ENERGY,135627,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['ENERGY'],['ENERGY']
Energy Efficiency,"ix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float = 1e-12) → psi4.core.Dimension¶; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str = 'outfile') → None¶; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix) → None¶; Prints the matrix to the output file. pseudoinverse(self: psi4.core.Matrix, condition: float, nremoved: int) → psi4.core.Matrix¶; Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) → None¶; Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self: psi4.core.Matrix) → float¶; Returns the rms of this matrix. rotate_columns(self: psi4.core.Matrix, h: int, i: int, j: int, theta: float) → None¶; Rotates columns i and j in irrep h by angle theta. rowdim(self: psi4.core.Matrix) → psi4.core.Dimension¶; Returns the rows per irrep array. rows(self: psi4.core.Matrix, h: int = 0) → int¶; Returns the rows in irrep h. save(*args, **kwargs)¶; Overloa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Matrix.html:12083,power,power,12083,psi4manual/1.6.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Matrix.html,2,['power'],['power']
Energy Efficiency,"ix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float = 1e-12) → psi4.core.Dimension¶; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str = 'outfile') → None¶; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix) → None¶; Prints the matrix to the output file. pseudoinverse(self: psi4.core.Matrix, condition: float, nremoved: int) → psi4.core.Matrix¶; Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) → None¶; Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self: psi4.core.Matrix) → float¶; Returns the rms of this matrix. rotate_columns(self: psi4.core.Matrix, h: int, i: int, j: int, theta: float) → None¶; Rotates columns i and j in irrep h by angle theta. rowdim(self: psi4.core.Matrix) → psi4.core.Dimension¶; Returns the rows per irrep array. rows(self: psi4.core.Matrix, h: int = 0) → int¶; Returns the rows in irrep h. save(self: psi4.core.Matrix, fi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.matrix.html:12141,power,power,12141,psi4manual/1.4.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.matrix.html,4,['power'],['power']
Energy Efficiency,"ix. set_legacy_frequencies(self, arg0); Sets the frequencies of the Hessian. set_module(self, module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self, arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self, arg0, arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self, arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self, arg0); docstring. set_scalar_variable(self, arg0, arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key, val); Sets scalar or array QCVariable key to val on cls. shallow_copy(self, arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Converts a Wavefunction object to a base class. total_index(self, i, h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. variable(key); Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. variables([include_deprecated_keys]); Return all scalar or array QCVariables from cls. write_molden([filename, do_virtual, use_natural]); Function to write wavefunction information in wfn to filename in molden format. write_nbo(name). Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha orbital subset. Parameters. basis (str) – {‘SO’, AO’}; Should the subset be of symmetry orbitals or atomic orbitals?; subset (str) – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbitals should be returned?. Returns; A Pitzer-ordered matrix of the orbitals, (# basis functions, # orbitals in the subset).; Pitzer-ordering is with ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html:8058,energy,energy-sorted,8058,psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CCWavefunction.html,2,['energy'],['energy-sorted']
Energy Efficiency,"ixed-influence systems; 'DD' dispersion-dominated systems. HTR40¶. Database of Hydrogen transfer reactions.; Geometries from Bozkaya and Sherrill.; Reference energies from Bozkaya and Sherrill. benchmark; '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset; 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. NCB31¶. Database (Truhlar) of several classes of noncovalent interactions.; Geometries from Truhlar and coworkers at site http://comp.chem.umn.edu/database_noncov/noncovalent.htm; Reference energies from Truhlar and coworkers at site http://comp.chem.umn.edu/database_noncov/noncovalent.htm; First comprehensive citation JPCA 109 5656 (2005). cp 'off' || 'on'; rlxd 'off' || 'on'; benchmark; '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset; 'small' 3: HF-HF, He-Ne, HCCH-HCCH; 'large' 1: BzBz_PD; 'HB6' hydrogen-bonded; 'CT7' charge-transfer; 'DI6' dipole-interacting; 'WI7' weakly interacting; 'PPS5' pi-pi stacking. NHTBH¶. Database (Truhlar) of non-hydrogen-transfer barrier height reactions.; Geometries and Reaction energies from Truhlar and coworkers at site http://t1.chem.umn.edu/misc/database_group/database_therm_bh/non_H.htm. cp 'off'; rlxd 'off'; subset; 'small'; 'large'. NBC10¶. Database (Sherrill) of interaction energies for dissociation curves of dispersion-bound bimolecular complexes.; Geometries and Reference interaction energies from the following articles:. Benzene Dimers from Sherrill et al. JPCA 113 10146 (2009).; Benzene-Hydrogen Sulfide from Sherrill et al. JPCA 113 10146 (2009).; Benzene-Methane from Sherrill et al. JPCA 113 10146 (2009).; Methane Dimer from Takatani et al. PCCP 9 6106 (2007).; Pyridine Dimers from Hohenstein et al. JPCA 113 878 (2009).; Collection into NBC10 from Burns et al. JCP 134 084107 (2011).; Revised reference interaction energies (NBC10A) from Marshall et al. JCP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_available_databases-1.html:3906,charge,charge-transfer,3906,psi4manual/1.1.0/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_available_databases-1.html,4,['charge'],['charge-transfer']
Energy Efficiency,"ixedbas is False, prints @ plus element symbol.; prints whole dimer for unCP mono when called dir (as opposed to passing thru str; no frag markers. inertia_tensor(masswt=True, zero=1e-14)[source]¶; Compute inertia tensor.; >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. inertia_tensor_partial(part, masswt=True, zero=1e-14)[source]¶; Compute inertia tensor based on atoms in part. inertial_system(masswt=True, zero=1e-14)[source]¶; Solve inertial system. inertial_system_partial(part, masswt=True, zero=1e-14)[source]¶; Solve inertial system based on atoms in part. classmethod init_with_mol2(xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False)[source]¶; Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; no_com and no_reorient can be used to turn off shift and; rotation. If xyzfilename is a string of the contents of an XYZ; file, rather than the name of a file, set contentsNotFilename; to True.; NOTE: chg/mult NYI; >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). classmethod init_with_xyz(xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False)[source]¶; Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; no_com and no_reorient can be used to turn off shift and; rotation. If xyzfilename is a string of the contents of an XYZ; file, rather than the name of a file, set contentsNotFilename; to True.; >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). move_to_coc()[source]¶; Moves molecule to center of charge. print_ring_planes(entity1,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:21999,charge,charge,21999,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['charge'],['charge']
Energy Efficiency,"ixyz2database.py.; See Creating a Database for details. Caution; Some features are not yet implemented. Buy a developer some coffee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4; distribution, add the path to the directory containing the database; to the environment variable PYTHONPATH. Parameters. name (str) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). db_name (str) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; psi4/share/databases or PYTHONPATH. Consult that; directory for available databases and literature citations. func (function) – \(\Rightarrow\) energy \(\Leftarrow\) || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mode (str) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; Indicates whether the calculations required to complete the; database are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. cp (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the bsse_type=""cp""; function for BSSE correction in database(). Option available; (See Available Database",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/db-1.html:1834,energy,energy,1834,psi4manual/1.4.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/db-1.html,5,['energy'],['energy']
