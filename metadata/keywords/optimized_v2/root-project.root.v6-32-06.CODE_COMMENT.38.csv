quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Usability,// Handle non-continuous numbers (to make test simplification easier).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:47,simpl,simplification,47,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['simpl'],['simplification']
Usability,"// Handle non-optimized IR code like:; // %expval = call i64 @llvm.expect.i64(i64 %conv1, i64 1); // %tobool = icmp ne i64 %expval, 0; // br i1 %tobool, label %if.then, label %if.end; //; // Or the following simpler case:; // %expval = call i1 @llvm.expect.i1(i1 %cmp, i1 1); // br i1 %expval, label %if.then, label %if.end",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp:208,simpl,simpler,208,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp,1,['simpl'],['simpler']
Usability,// Handle only simple case where vector being inserted and vector; // being extracted are of same size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:15,simpl,simple,15,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simple']
Usability,"// Handle shrink case: destroy the elements in the pages that are not; // needed any more and deallocate the pages.; //; // On the other hand, we do not destroy the extra elements in the last page,; // because we might need them later and the logic is simpler if we do not; // destroy them. This means that elements are only destroyed when the; // page they belong to is destroyed. This is similar to what happens on; // access of the elements of a page, where all the elements of the page are; // constructed not only the one effectively needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:252,simpl,simpler,252,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,1,['simpl'],['simpler']
Usability,// Handle simple binary numbers 0b01010,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:10,simpl,simple,10,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,1,['simpl'],['simple']
Usability,// Handle simple but common cases only.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:10,simpl,simple,10,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['simpl'],['simple']
Usability,"// Handle simple calls for now, with legal return types and; // those that can be extended.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:10,simpl,simple,10,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['simpl'],['simple']
Usability,// Handle simple cases by querying alias analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:10,simpl,simple,10,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['simpl'],['simple']
Usability,// Handle simple inline asms.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp:10,simpl,simple,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,1,['simpl'],['simple']
Usability,"// Handle simple register locations. If we are supposed to emit; // a call site parameter expression and if that expression is just a register; // location, emit it with addBReg and offset 0, because we should emit a DWARF; // expression representing a value, rather than a location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:10,simpl,simple,10,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,1,['simpl'],['simple']
Usability,// Handle simple types only.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,simpl,simple,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simple']
Usability,// Handle simplifications when the RHS is a constant int.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:10,simpl,simplifications,10,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['simpl'],['simplifications']
Usability,"// Handle spill/fill of synthetic register classes for segment operations to; // ensure correctness in the edge case one gets spilled. There are many; // possible optimizations here, but given the extreme rarity of such spills,; // we prefer simplicity of implementation for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:242,simpl,simplicity,242,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,1,['simpl'],['simplicity']
Usability,"// Handle the case of a simple two-predecessor recurrence PHI.; // There's a lot more that could theoretically be done here, but; // this is sufficient to catch some interesting cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:24,simpl,simple,24,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,2,['simpl'],['simple']
Usability,"// Handle the case the condition of the conditional branch is constant.; // e.g.,; //; // br i1 false, label %cleanup, label %CoroEnd; //; // It is possible during the transformation. We could continue the; // simplifying in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:210,simpl,simplifying,210,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['simpl'],['simplifying']
Usability,"// Handle the case where the condition is a constant evaluatable simple integer,; // which means we don't have to separately handle the true/false blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:65,simpl,simple,65,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['simpl'],['simple']
Usability,"// Handle the really simple, really trivial case efficiently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:21,simpl,simple,21,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['simpl'],['simple']
Usability,// Handle the simple case efficiently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:14,simpl,simple,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['simpl'],['simple']
Usability,"// Handle the simple case first. A single call with a single stack id.; // In this case there is no need to create any new context nodes, simply; // assign the context node for stack id to this Call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:14,simpl,simple,14,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,2,['simpl'],"['simple', 'simply']"
Usability,// Handle the simple case of a zero index.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:14,simpl,simple,14,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['simpl'],['simple']
Usability,// Handle the simple case of non-vectors.; // NOTE: this assumes that legalization never creates vector from scalars!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:14,simpl,simple,14,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['simpl'],['simple']
Usability,// Handle the simple case where the value is contained in one uint64_t.; // It is wrong to optimize getWord(0) to VAL; there might be more than one word.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:14,simpl,simple,14,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['simpl'],['simple']
Usability,"// Handle the simple, trivial case efficiently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:14,simpl,simple,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['simpl'],['simple']
Usability,"// Handle the simple, trivial, case efficiently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:14,simpl,simple,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['simpl'],['simple']
Usability,// Handle the simplest case efficiently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:14,simpl,simplest,14,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['simpl'],['simplest']
Usability,"// Handle the special case of 'tuple' where we ignore the real implementation; // details and just overlay a 'simpler'/'simplistic' version that is easy; // for the I/O to understand and handle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:110,simpl,simpler,110,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,2,['simpl'],"['simpler', 'simplistic']"
Usability,// Handles simple types only,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:11,simpl,simple,11,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simple']
Usability,"// Hardware divide in ARM mode is part of base arch, starting from ARMv8.; // If only Thumb hwdiv is present, it must also be in base arch (ARMv7-R/M).; // It is not possible to produce DisallowDIV: if hwdiv is present in the base; // arch, supplying -hwdiv downgrades the effective arch, via ClearImpliedBits.; // AllowDIVExt is only emitted if hwdiv isn't available in the base arch;; // otherwise, the default value (AllowDIVIfExists) applies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp:293,Clear,ClearImpliedBits,293,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMTargetStreamer.cpp,1,['Clear'],['ClearImpliedBits']
Usability,// Hashing the name will be deterministic as LLVM's hashing infrastructure; // has explicit support for hashing strings and will not simply hash; // the pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp:133,simpl,simply,133,interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,1,['simpl'],['simply']
Usability,"// Having only one phase of training to reduce the test time.; // TString training1(""LearningRate=1e-2,Optimizer="" + optimizerStr +; // "",Momentum=0.9,Repetitions=1,""; // ""ConvergenceSteps=20,BatchSize=256,TestRepetitions=10,""; // ""WeightDecay=1e-4,Regularization=L2,""; // ""DropConfig=0.0+0.0+0.0+0.0,Multithreading=True"");; // TString training2(""LearningRate=1e-3,Optimizer="" + optimizerStr +; // "",Momentum=0.9,Repetitions=1,""; // ""ConvergenceSteps=20,BatchSize=256,TestRepetitions=10,""; // ""WeightDecay=1e-4,Regularization=L2,""; // ""DropConfig=0.0+0.0+0.0+0.0,Multithreading=True"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestMethodDLOptimization.h:85,Learn,LearningRate,85,tmva/tmva/test/DNN/TestMethodDLOptimization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/TestMethodDLOptimization.h,2,['Learn'],['LearningRate']
Usability,"// Helper for writeThunk,; // Selects proper bitcast operation,; // but a bit simpler then CastInst::getCastOpcode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:78,simpl,simpler,78,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,1,['simpl'],['simpler']
Usability,"// Helper function for the ""rematerializeLiveValues"". It walks use chain; // starting from the ""CurrentValue"" until it reaches the root of the chain, i.e.; // the base or a value it cannot process. Only ""simple"" values are processed; // (currently it is GEP's and casts). The returned root is examined by the; // callers of findRematerializableChainToBasePointer. Fills ""ChainToBase"" array; // with all visited values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:204,simpl,simple,204,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['simpl'],['simple']
Usability,"// Helper function of OptimizeXor(). It tries to simplify ""Opnd1 ^ ConstOpnd""; // into ""R ^ C"", where C would be 0, and R is a symbolic value.; //; // If it was successful, true is returned, and the ""R"" and ""C"" is returned; // via ""Res"" and ""ConstOpnd"", respectively; otherwise, false is returned,; // and both ""Res"" and ""ConstOpnd"" remain unchanged.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:49,simpl,simplify,49,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['simpl'],['simplify']
Usability,"// Helper function of OptimizeXor(). It tries to simplify; // ""Opnd1 ^ Opnd2 ^ ConstOpnd"" into ""R ^ C"", where C would be 0, and R is a; // symbolic value.; //; // If it was successful, true is returned, and the ""R"" and ""C"" is returned; // via ""Res"" and ""ConstOpnd"", respectively (If the entire expression is; // evaluated to a constant, the Res is set to NULL); otherwise, false is; // returned, and both ""Res"" and ""ConstOpnd"" remain unchanged.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:49,simpl,simplify,49,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['simpl'],['simplify']
Usability,"// Helper to call SimplifyDemandedBits on an operand of N where only some low; // bits are demanded. N will be added to the Worklist if it was not deleted.; // Caller should return SDValue(N, 0) if this returns true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:18,Simpl,SimplifyDemandedBits,18,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,// Helper to generate an instruction sequence that will materialise the given; // immediate value into a register. A sequence of instructions represented by a; // simple struct is produced rather than directly emitting the instructions in; // order to allow this helper to be used from both the MC layer and during; // instruction selection.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.h:163,simpl,simple,163,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.h,1,['simpl'],['simple']
Usability,"// Here is a common situation. We want to optimize:; //; // %a = ...; // %b = and i32 %a, 2; // %c = srl i32 %b, 1; // brcond i32 %c ...; //; // into; //; // %a = ...; // %b = and %a, 2; // %c = setcc eq %b, 0; // brcond %c ...; //; // However when after the source operand of SRL is optimized into AND, the SRL; // itself may not be optimized further. Look for it and add the BRCOND into; // the worklist.; //; // The also tends to happen for binary operations when SimplifyDemandedBits; // is involved.; //; // FIXME: This is unecessary if we process the DAG in topological order,; // which we plan to do. This workaround can be removed once the DAG is; // processed in topological order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:467,Simpl,SimplifyDemandedBits,467,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,"// Here we ""fuse"" clusters together if the number of clusters is too big with respect to; // the number of slots, otherwise we can incur in an overhead which is big enough; // to make parallelisation detrimental to performance.; // For example, this is the case when, following a merging of many small files, a file; // contains a tree with many entries and with clusters of just a few entries each.; // Another problematic case is a high number of slots (e.g. 256) coupled with a high number; // of files (e.g. 1000 files): the large amount of files might result in a large amount; // of tasks, but the elevated concurrency level makes the little synchronization required by; // task initialization very expensive. In this case it's better to simply process fewer, larger tasks.; // Cluster-merging can help reduce the number of tasks down to a minumum of one task per file.; //; // The criterion according to which we fuse clusters together is to have around; // TTreeProcessorMT::GetTasksPerWorkerHint() clusters per slot.; // Concretely, for each file we will cap the number of tasks to ceil(GetTasksPerWorkerHint() * nWorkers / nFiles).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProcessorMT.cxx:744,simpl,simply,744,tree/treeplayer/src/TTreeProcessorMT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProcessorMT.cxx,1,['simpl'],['simply']
Usability,// Here we iterate over the fields; this makes it simpler to both; // default-initialize fields and skip over unnamed fields.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp:50,simpl,simpler,50,interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,1,['simpl'],['simpler']
Usability,"// Here we retain a mapping from the GUID to canonical symbol name; // instead of adding it to the frame object directly to reduce memory; // overhead. This is because there can be many unique frames,; // particularly for callsite frames.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp:37,GUID,GUID,37,interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,1,['GUID'],['GUID']
Usability,"// Here we use the same DebugLoc as the scalar loop latch terminator instead; // of the corresponding compare because they may have ended up with; // different line numbers and we want to avoid awkward line stepping while; // debugging. Eg. if the compare has got a line number inside the loop.; // TODO: At the moment, CreateICmpEQ will simplify conditions with constant; // operands. Perform simplification directly on VPlan once the branch is; // modeled there.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:338,simpl,simplify,338,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,['simpl'],"['simplification', 'simplify']"
Usability,"// Here's the rough algorithm:; // - For every SSA value, construct a mapping to either an actual base; // pointer or a PHI which obscures the base pointer.; // - Construct a mapping from PHI to unknown TOP state. Use an; // optimistic algorithm to propagate base pointer information. Lattice; // looks like:; // UNKNOWN; // b1 b2 b3 b4; // CONFLICT; // When algorithm terminates, all PHIs will either have a single concrete; // base or be in a conflict state.; // - For every conflict, insert a dummy PHI node without arguments. Add; // these to the base[Instruction] = BasePtr mapping. For every; // non-conflict, add the actual base.; // - For every conflict, add arguments for the base[a] of each input; // arguments.; //; // Note: A simpler form of this would be to add the conflict form of all; // PHIs without running the optimistic algorithm. This would be; // analogous to pessimistic data flow and would likely lead to an; // overall worse solution.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:738,simpl,simpler,738,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['simpl'],['simpler']
Usability,"// Here, we handle three cases.; // (1) Not having a value means it is dead. (we can replace the value; // with undef); // (2) Simplified to undef. The argument violate noundef attriubte.; // (3) Simplified to null pointer where known to be nonnull.; // The argument is a poison value and violate noundef attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:127,Simpl,Simplified,127,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,2,['Simpl'],['Simplified']
Usability,"// Heuristically pick the better replacement -- the choice of heuristic; // isn't terribly important here, but the fact we canonicalize on some; // replacement is for exposing other simplifications.; // TODO: pull this out as a helper function and reuse w/existing; // (slightly different) logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:182,simpl,simplifications,182,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['simpl'],['simplifications']
Usability,// Hoist edges originating from branch conditions to branches; // for simple branches.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:70,simpl,simple,70,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['simpl'],['simple']
Usability,"// Hold on to a default advisor for:; // 1) the implementation of canEvictHintInterference, because we didn't; // learn that nuance yet; 2) for bootstrapping (logging) in the development; // mode case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:114,learn,learn,114,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,1,['learn'],['learn']
Usability,"// Holds call sites in this function which are part of some memory; // allocation context. We store this as a list of locations, each with its; // list of inline locations in bottom-up order i.e. from leaf to root. The; // inline location list may include additional entries, users should pick; // the last entry in the list with the same function GUID.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h:348,GUID,GUID,348,interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,1,['GUID'],['GUID']
Usability,"// Holds the resume values for reductions in the loops, used to set the; // correct start value of reduction PHIs when vectorizing the epilogue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:13,resume,resume,13,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['resume'],['resume']
Usability,// However if the input is already sign extended we expect the sign; // extension to be dropped altogether later and do not simplify.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:124,simpl,simplify,124,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['simpl'],['simplify']
Usability,"// Humm there is no space reserve to write the data,; // the data member is likely 'removed' from the class; // layout, so rather than crashing by accessing; // random memory, make it clear we can't read it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:184,clear,clear,184,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['clear'],['clear']
Usability,// I bit clear => need input FPSCR,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:9,clear,clear,9,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,1,['clear'],['clear']
Usability,"// I is an operand of U. Check if U is an arithmetic (binary) operation; // usable in a memop, where the other operand is a loaded value, and the; // result of U is stored in the same location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:76,usab,usable,76,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,1,['usab'],['usable']
Usability,"// ISel process runs DAGCombiner after legalization; this step is called; // SelectionDAG optimization phase. This post-legalization combining process; // runs DAGCombiner on each node, and if there was a change to be made,; // re-runs legalization again on it and its user nodes to make sure; // everythiing is in a legalized state.; //; // The legalization calls lowering routines, and we do our custom lowering for; // build_vectors (LowerBUILD_VECTOR), which converts undef vector elements; // into zeros. But there is a set of routines in DAGCombiner that turns unused; // (= not demanded) nodes into undef, among which SimplifyDemandedVectorElts; // turns unused vector elements into undefs. But this routine does not work; // with our custom LowerBUILD_VECTOR, which turns undefs into zeros. This; // combination can result in a infinite loop, in which undefs are converted to; // zeros in legalization and back to undefs in combining.; //; // So after DAG is legalized, we prevent SimplifyDemandedVectorElts from; // running for build_vectors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:625,Simpl,SimplifyDemandedVectorElts,625,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,2,['Simpl'],['SimplifyDemandedVectorElts']
Usability,"// Id of the next node in the circular chain.; // Definitions of nested types. Using anonymous nested structs would make; // this class definition clearer, but unnamed structs are not a part of; // the standard.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:147,clear,clearer,147,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,1,['clear'],['clearer']
Usability,"// Ideally this class would not be copyable. But SetVector requires copyable; // keys, and we want this to be usable there.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h:110,usab,usable,110,interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,1,['usab'],['usable']
Usability,"// Ideally, we would avoid deserializing the streamer info records of the streamer fields that we just serialized.; // However, this happens only once at the end of writing and only when streamer fields are used, so the; // preference here is for code simplicity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx:252,simpl,simplicity,252,tree/ntuple/v7/src/RNTupleDescriptor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx,1,['simpl'],['simplicity']
Usability,"// Identifier lists follow a really simple grammar: the identifiers can; // be followed *only* by a "", identifier"" or "")"". However, K&R; // identifier lists are really rare in the brave new modern world, and; // it is very common for someone to typo a type in a non-K&R style; // list. If we are presented with something like: ""void foo(intptr x,; // float y)"", we don't want to start parsing the function declarator as; // though it is a K&R style declarator just because intptr is an; // invalid type.; //; // To handle this, we check to see if the token after the first; // identifier is a "","" or "")"". Only then do we parse it as an; // identifier list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:36,simpl,simple,36,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['simpl'],['simple']
Usability,"// Identifier(Tok).empty() is redundant 1st time, but simplifies code",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp:54,simpl,simplifies,54,interpreter/cling/lib/Utils/SourceNormalization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp,1,['simpl'],['simplifies']
Usability,// Identify simple one-block loop,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:12,simpl,simple,12,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,1,['simpl'],['simple']
Usability,"// If ""A op C"" doesn't simplify then only go on if one of the existing; // operations ""A op' B"" and ""C op' D"" will be zapped as no longer used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:23,simpl,simplify,23,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplify']
Usability,"// If ""B op D"" doesn't simplify then only go on if one of the existing; // operations ""A op' B"" and ""C op' D"" will be zapped as no longer used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:23,simpl,simplify,23,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplify']
Usability,"// If 'X' is a constant, and we transform, then we will immediately; // try to undo the fold, thus causing endless combine loop.; // So by default, let's assume everyone prefers the fold; // iff 'X' is not a constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:79,undo,undo,79,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['undo'],['undo']
Usability,"// If -Ofast is the optimization level, then -fstrict-aliasing should be; // enabled. This alias option is being used to simplify the hasFlag logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:121,simpl,simplify,121,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['simpl'],['simplify']
Usability,"// If A s>= B && B s>= 0, ssub.with.overflow(a, b) should not overflow and; // can be simplified to a regular sub.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:86,simpl,simplified,86,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,1,['simpl'],['simplified']
Usability,"// If BB is reachable on a non-default case, then we simply know the value of; // V in this block. Substitute it and constant fold the icmp instruction; // away.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:53,simpl,simply,53,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['simpl'],['simply']
Usability,"// If BB is the last block in the path, we can simply update the one case; // successor that will be reached.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:47,simpl,simply,47,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,1,['simpl'],['simply']
Usability,"// If BFI is set, we will use it to guide the promotions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:36,guid,guide,36,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,1,['guid'],['guide']
Usability,"// If Base was int converted to pointer, simply return int and offset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUGlobalISelUtils.cpp:41,simpl,simply,41,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUGlobalISelUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUGlobalISelUtils.cpp,1,['simpl'],['simply']
Usability,"// If BinOp2 is `and`, any mask works (this only really helps for non-splat; // vecs, otherwise the mask will be simplified and the following check will; // handle it).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:113,simpl,simplified,113,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplified']
Usability,"// If Block contains an original spill, simply continue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:40,simpl,simply,40,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['simpl'],['simply']
Usability,// If C is a negative power-of-2 (high-bit mask):; // (trunc X) u< C --> (X & C) != C (are any masked-high-bits clear?),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:112,clear,clear,112,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['clear'],['clear']
Usability,// If C is not-of-power-of-2 (one clear bit):; // (trunc X) u> C --> (X & (C+1)) == C+1 (are all masked-high-bits set?),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:34,clear,clear,34,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['clear'],['clear']
Usability,"// If C-kR < 0 for all potential k's, it means that one solution; // will be negative, while the other will be positive. The positive; // solution will shift towards 0 if the parabola is moved up.; // Pick the kR closest to the lower bound (i.e. make C-kR closest; // to 0, or in other words, out of all parabolas that have solutions,; // pick the one that is the farthest ""up"").; // Since LowkR is itself a multiple of R, simply take C-LowkR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:423,simpl,simply,423,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['simpl'],['simply']
Usability,"// If ChainNode is null, it's because we replaced it on a previous; // iteration and we cleared it out of the map. Just skip it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:88,clear,cleared,88,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['clear'],['cleared']
Usability,"// If DefReg becomes empty after removal, we can remove the; // SrcCopy from the tracker's copy maps. We only remove those; // entries solely record the Def is defined by Src. If an; // entry also contains the definition record of other Def'; // registers, it cannot be cleared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:270,clear,cleared,270,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,1,['clear'],['cleared']
Usability,"// If E is a variable, then trace back through any aliases or redundant; // Phi nodes to find the canonical definition.; // The non-const version will simplify incomplete Phi nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:151,simpl,simplify,151,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,1,['simpl'],['simplify']
Usability,"// If Exp is wildly out-of-scale, simply adding it to X.exponent will; // overflow; clamp it to a safe range before adding, but ensure that the range; // is large enough that the clamp does not change the result. The range we; // need to support is the difference between the largest possible exponent and; // the normalized exponent of half the smallest denormal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:34,simpl,simply,34,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['simpl'],['simply']
Usability,"// If ExtName is set (if the ""ExtName = Name"" syntax was used), overwrite; // Name with ExtName and clear ExtName. When only creating an import; // library and not linking, the internal name is irrelevant. This avoids; // cases where writeImportLibrary tries to transplant decoration from; // symbol decoration onto ExtName.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ToolDrivers/llvm-dlltool/DlltoolDriver.cpp:100,clear,clear,100,interpreter/llvm-project/llvm/lib/ToolDrivers/llvm-dlltool/DlltoolDriver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ToolDrivers/llvm-dlltool/DlltoolDriver.cpp,1,['clear'],['clear']
Usability,"// If F is imported, a local linkage ifunc (e.g. target_clones on a; // static function) called by F will be cloned. Since summaries don't; // track ifunc, we do not know implementation functions referenced by; // the ifunc resolver need to be promoted in the exporter, and we will; // get linker errors due to cloned declarations for implementation; // functions. As a simple fix, just mark F as not eligible for import.; // Non-local ifunc is not cloned and does not have the issue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:370,simpl,simple,370,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,1,['simpl'],['simple']
Usability,// If FromRecord is not defined we need to force it to be.; // Simply calling CompleteDecl(...) for a RecordDecl will break some cases; // it will start the definition but we never finish it.; // If there are base classes they won't be imported and we will; // be missing anything that we inherit from those bases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:63,Simpl,Simply,63,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['Simpl'],['Simply']
Usability,"// If GVElType is already i1, it is already shrunk. If the type of the GV is; // an FP value, pointer or vector, don't do this optimization because a select; // between them is very expensive and unlikely to lead to later; // simplification. In these cases, we typically end up with ""cond ? v1 : v2""; // where v1 and v2 both require constant pool loads, a big loss.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:226,simpl,simplification,226,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['simpl'],['simplification']
Usability,"// If HashPDBContentsToGUID is true on the InfoStreamBuilder, Guid is filled; // with the computed PDB GUID on return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/PDBFileBuilder.h:62,Guid,Guid,62,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/PDBFileBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/PDBFileBuilder.h,2,"['GUID', 'Guid']","['GUID', 'Guid']"
Usability,"// If Inst can, then check if Inst is a simple store. If Inst is not a; // store or a store that is not simple, then we have some we do not; // understand writing to this memory implying we can not move the load; // over the write to any subsequent store that we may find.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:40,simpl,simple,40,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,2,['simpl'],['simple']
Usability,"// If Instr can be simplified to an existing VPValue, use it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,simpl,simplified,19,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['simpl'],['simplified']
Usability,// If M is the global module fragment of the current translation unit. So it; // should be usable.; // [module.global.frag]p1:; // The global module fragment can be used to provide declarations that are; // attached to the global module and usable within the module unit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:91,usab,usable,91,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,2,['usab'],['usable']
Usability,"// If M is the module we're parsing, it should be usable. This covers the; // private module fragment. The private module fragment is usable only if; // it is within the current module unit. And it must be the current; // parsing module unit if it is within the current module unit according; // to the grammar of the private module fragment. NOTE: This is covered by; // the following condition. The intention of the check is to avoid string; // comparison as much as possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:50,usab,usable,50,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,2,['usab'],['usable']
Usability,"// If MI defines a formal parameter, but is not a copy (loads are handled; // in evaluateLoad), then it's not clear what to do.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:110,clear,clear,110,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,1,['clear'],['clear']
Usability,"// If MI is a simple load or store for a frame object, return the register; // it loads or stores and set FrameIndex to the index of the frame object.; // Return 0 otherwise.; //; // Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:14,simpl,simple,14,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,3,"['Simpl', 'simpl']","['SimpleBDXLoad', 'SimpleBDXStore', 'simple']"
Usability,"// If Min and Max are known to be the same, then SimplifyDemandedBits figured; // out that the LHS or RHS is a constant. Constant fold this now, so that; // code below can assume that Min != Max.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:49,Simpl,SimplifyDemandedBits,49,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,"// If N is a constant we could fold this into a fallthrough or unconditional; // branch. However that doesn't happen very often in normal code, because; // Instcombine/SimplifyCFG should have handled the available opportunities.; // If we did this folding here, it would be necessary to update the; // MachineBasicBlock CFG, which is awkward.; // Use SimplifySetCC to simplify SETCC's.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:168,Simpl,SimplifyCFG,168,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,3,"['Simpl', 'simpl']","['SimplifyCFG', 'SimplifySetCC', 'simplify']"
Usability,"// If N is a constant we could fold this into a fallthrough or unconditional; // branch. However that doesn't happen very often in normal code, because; // Instcombine/SimplifyCFG should have handled the available opportunities.; // If we did this folding here, it would be necessary to update the; // MachineBasicBlock CFG, which is awkward.; // fold a brcond with a setcc condition into a BR_CC node if BR_CC is legal; // on the target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:168,Simpl,SimplifyCFG,168,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Simpl'],['SimplifyCFG']
Usability,"// If NewBB==NULL, then SplitCriticalEdge refused to split because all; // phi predecessors are identical. The simple thing to do is skip; // splitting in this case rather than complicate the API.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:111,simpl,simple,111,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['simpl'],['simple']
Usability,"// If NextInChain is 0 and not the LHS of a sub, we can simplify the; // sub-expression to be just TheOther.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:56,simpl,simplify,56,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,1,['simpl'],['simplify']
Usability,"// If OF is used, the instruction needs to clear it like CmpZero does.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:43,clear,clear,43,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['clear'],['clear']
Usability,"// If OldSeq is not S_Use or OldSeq is S_Use and we are tracking an; // imprecise release, clear our reverse insertion points.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:91,clear,clear,91,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,1,['clear'],['clear']
Usability,"// If OpVT and EltVT don't match, EltVT is not legal and the; // element values have been promoted/truncated earlier. Undo this;; // we don't want a v16i8 to become a v16i32 for example.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:118,Undo,Undo,118,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['Undo'],['Undo']
Usability,"// If P.SI is already at the end, then we've cleared the split tail and; // now have an end iterator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:45,clear,cleared,45,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['clear'],['cleared']
Usability,"// If RenameAs is equal to RegID, then RegID is subject to register renaming; // and false dependencies on RegID are all eliminated.; // If RenameAs references the invalid register, then we optimistically assume; // that it can be renamed. In the absence of tablegen descriptors for register; // files, RenameAs is always set to the invalid register ID. In all other; // cases, RenameAs must be either equal to RegID, or it must reference a; // super-register of RegID.; // If RenameAs is a super-register of RegID, then a write to RegID has always; // a false dependency on RenameAs. The only exception is for when the write; // implicitly clears the upper portion of the underlying register.; // If a write clears its super-registers, then it is renamed as `RenameAs`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp:641,clear,clears,641,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,2,['clear'],['clears']
Usability,"// If SFPA is clear jump over to VLLDM, otherwise execute an instruction; // which has no functional effect apart from causing context creation:; // vmovne s0, s0. In the absence of FPU we emit .inst.w 0xeeb00a40,; // which is defined as NOP if not executed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp:14,clear,clear,14,interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,1,['clear'],['clear']
Usability,"// If SFPA is clear, jump over ClearBB to DoneBB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp:14,clear,clear,14,interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,2,"['Clear', 'clear']","['ClearBB', 'clear']"
Usability,"// If TID_ENABLE is set, DATA_FORMAT specifies stride bits [14:17].; // Clear them unless we want a huge stride.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:72,Clear,Clear,72,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['Clear'],['Clear']
Usability,"// If UpdateExpr is 'x' updated with some `expr` not based on 'x',; // 'x' is simply atomically rewritten with 'expr'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:78,simpl,simply,78,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['simpl'],['simply']
Usability,"// If V is identical to V.OtherVNI (and S was live at OtherDef),; // then we can't simply prune V from S. V needs to be replaced; // with V.OtherVNI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:83,simpl,simply,83,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['simpl'],['simply']
Usability,"// If VT is not identical to any of this class's types, but is a simple; // type, check if any of the types for this class contain it under some; // mode.; // The motivating example came from RISC-V, where (likely because of being; // guarded by ""64-bit"" predicate), the type of X5 was {*:[i64]}, but the; // type in GRC was {*:[i32], m1:[i64]}.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:65,simpl,simple,65,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['simpl'],['simple']
Usability,"// If X/C can be simplified by the division-by-constant logic, lower; // X%C to the equivalent of X-X/C*C.; // Reuse the SDIVLike/UDIVLike combines - to avoid mangling nodes, the; // speculative DIV must not cause a DIVREM conversion. We guard against this; // by skipping the simplification if isIntDivCheap(). When div is not cheap,; // combine will not return a DIVREM. Regardless, checking cheapness here; // makes sense since the simplification results in fatter code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,simpl,simplified,17,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,3,['simpl'],"['simplification', 'simplified']"
Usability,// If __cxa_atexit is defined (e.g. in the case of LTO) and arg0 is not; // actually used (i.e. it's dummy/stub function as used in emscripten when; // the program never exits) we can simply return early and clear out; // @llvm.global_dtors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp:184,simpl,simply,184,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp,2,"['clear', 'simpl']","['clear', 'simply']"
Usability,"// If a SuspendIntrin is preceded by Resume or Destroy, we can eliminate the; // suspend point and replace it with nornal control flow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:37,Resume,Resume,37,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['Resume'],['Resume']
Usability,"// If a flat dSYM has been requested, things are pretty simple.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:56,simpl,simple,56,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,1,['simpl'],['simple']
Usability,"// If a memset intrinsic gets inlined by the code gen, we will miss races on it.; // So, we either need to ensure the intrinsic is not inlined, or instrument it.; // We do not instrument memset/memmove/memcpy intrinsics (too complicated),; // instead we simply replace them with regular function calls, which are then; // intercepted by the run-time.; // Since tsan is running after everyone else, the calls should not be; // replaced back with intrinsics. If that becomes wrong at some point,; // we will need to call e.g. __tsan_memset to avoid the intrinsics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:254,simpl,simply,254,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,1,['simpl'],['simply']
Usability,"// If a node as its own default namespace definition it clearly cannot have; // inherited the given default namespace, and neither will any of its; // children.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp:56,clear,clearly,56,interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/WindowsManifestMerger.cpp,1,['clear'],['clearly']
Usability,"// If a null pointer expression's type is the C++0x nullptr_t, then; // it's not necessarily a simple constant and it must be evaluated; // for its potential side effects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:95,simpl,simple,95,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['simpl'],['simple']
Usability,// If a pass has introduced virtual registers without clearing the; // NoVRegs property (or set it without allocating the vregs); // then report an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:54,clear,clearing,54,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,1,['clear'],['clearing']
Usability,"// If a region is just a sequence of regions (and the exit; // block in the case of the top level region), we can simply skip; // linearizing it, because it is already linear",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineCFGStructurizer.cpp:114,simpl,simply,114,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineCFGStructurizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineCFGStructurizer.cpp,1,['simpl'],['simply']
Usability,"// If a simple-asm-expr is present, parse it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:8,simpl,simple-asm-expr,8,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,['simpl'],['simple-asm-expr']
Usability,"// If a variable could potentially be odr-used, defer marking it so; // until we finish analyzing the full expression for any; // lvalue-to-rvalue; // or discarded value conversions that would obviate odr-use.; // Add it to the list of potential captures that will be analyzed; // later (ActOnFinishFullExpr) for eventual capture and odr-use marking; // unless the variable is a reference that was initialized by a constant; // expression (this will never need to be captured or odr-used).; //; // FIXME: We can simplify this a lot after implementing P0588R1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:512,simpl,simplify,512,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['simpl'],['simplify']
Usability,"// If a variable usable in constant expressions is referenced,; // don't warn if it isn't used: if the value of a variable is required; // for the computation of a constant expression, it doesn't make sense to; // warn even if the variable isn't odr-used. (isReferenced doesn't; // precisely reflect that, but it's a decent approximation.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:17,usab,usable,17,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['usab'],['usable']
Usability,"// If addi/subri are replaced with the exactly matching initializer,; // they amount to COPY.; // Check that the initializer is an exact match (for simplicity).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:148,simpl,simplicity,148,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,1,['simpl'],['simplicity']
Usability,"// If all bits in the inverted and shifted mask are clear:; // and (lshr X, ShAmt), Mask --> lshr X, ShAmt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:52,clear,clear,52,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['clear'],['clear']
Usability,"// If all bits in the inverted and shifted mask are clear:; // and (shl X, ShAmt), Mask --> shl X, ShAmt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:52,clear,clear,52,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['clear'],['clear']
Usability,"// If all elements are undefined, this shuffle can be considered a splat.; // Return 0 for better potential for callers to simplify.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp:123,simpl,simplify,123,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp,1,['simpl'],['simplify']
Usability,"// If all elements are undefined, this shuffle can be considered a splat; // (although it should eventually get simplified away completely).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:112,simpl,simplified,112,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['simpl'],['simplified']
Usability,"// If all indices are known integers and normalized, we can do a simple; // check for the ""inbounds"" property.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:65,simpl,simple,65,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['simpl'],['simple']
Usability,"// If all of the demanded bits on one side are known, and all of the set; // bits on that side are also known to be set on the other side, turn this; // into an AND, as we know the bits will be cleared.; // e.g. (X | C1) ^ C2 --> (X | C1) & ~C2 iff (C1&C2) == C2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:194,clear,cleared,194,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['clear'],['cleared']
Usability,"// If all of the element types mapped directly over and the type is not; // a named struct, then the type is usable as-is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:109,usab,usable,109,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,1,['usab'],['usable']
Usability,"// If all of the operands are identical or constant we have a simple solution.; // If we deal with insert/extract instructions, they all must have constant; // indices, otherwise we should gather them, not try to vectorize.; // If alternate op node with 2 elements with gathered operands - do not; // vectorize.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:62,simpl,simple,62,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['simpl'],['simple']
Usability,"// If all the line table contains is a DW_LNE_end_sequence, clear the line; // table rows, it will be inserted again in the DWARFStreamer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:60,clear,clear,60,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,2,['clear'],['clear']
Usability,"// If all variable coefficients are 0, the constraint does not provide any; // usable information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h:79,usab,usable,79,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstraintSystem.h,2,['usab'],['usable']
Usability,"// If an alias references a GlobalValue in a non-prevailing comdat, change; // it to available_externally. For simplicity we only handle GlobalValue and; // ConstantExpr with a base object. ConstantExpr without a base object is; // unlikely used in a COMDAT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:111,simpl,simplicity,111,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['simpl'],['simplicity']
Usability,// If an argument type is incomplete there is no way to get its size to; // correctly encode into the mangling scheme.; // Follow GCCs behaviour by simply breaking out of the loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Mangle.cpp:148,simpl,simply,148,interpreter/llvm-project/clang/lib/AST/Mangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Mangle.cpp,1,['simpl'],['simply']
Usability,"// If an instruction defines more than one item in the worklist, we may run; // into situations where a worklist register's value is (potentially); // described by the previous value of another register that is also defined; // by that instruction.; //; // This can for example occur in cases like this:; //; // $r1 = mov 123; // $r0, $r1 = mvrr $r1, 456; // call @foo, $r0, $r1; //; // When describing $r1's value for the mvrr instruction, we need to make sure; // that we don't finalize an entry value for $r0, as that is dependent on the; // previous value of $r1 (123 rather than 456).; //; // In order to not have to distinguish between those cases when finalizing; // entry values, we simply postpone adding new parameter registers to the; // worklist, by first keeping them in this temporary container until the; // instruction has been handled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:691,simpl,simply,691,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,1,['simpl'],['simply']
Usability,"// If an operand is zero, add-of-0 gets simplified away, so that's clearly; // better because we eliminate 1-2 instructions. This transform is still; // an improvement without zero operands because we trade 2 move constants and; // 1 add for 2 adds (LEA) as long as the constants can be represented as; // immediate asm operands (fit in 32-bits).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:40,simpl,simplified,40,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,"['clear', 'simpl']","['clearly', 'simplified']"
Usability,"// If any callee has an undeduced return type, deduce it now.; // FIXME: It's not clear how a failure here should be handled. For; // now, we produce an eager diagnostic, because that is forward; // compatible with most (all?) other reasonable options.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:82,clear,clear,82,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['clear'],['clear']
Usability,"// If any errors have occurred, clear out any temporaries that may have; // been leftover. This ensures that these temporaries won't be picked up for; // deletion in some later function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:32,clear,clear,32,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['clear'],['clear']
Usability,"// If any errors have occurred, clear out any temporaries that may have; // been leftover. This ensures that these temporaries won't be picked up; // for deletion in some later function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:32,clear,clear,32,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['clear'],['clear']
Usability,"// If any indirect uses, create a direct use to ensure allocation; // TODO: Simpler to unconditionally mark used but that regresses; // codegen in test/CodeGen/AMDGPU/noclobber-barrier.ll",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:76,Simpl,Simpler,76,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['Simpl'],['Simpler']
Usability,"// If any instructions in the clearance range are reading Reg, insert a; // dependency breaking instruction, which is inexpensive and is likely to; // be hidden in other instruction's cycles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:30,clear,clearance,30,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['clear'],['clearance']
Usability,"// If at least one bit from left in a lower word is masked out,; // all of 0 to 32-th bits of the output are cleared.; // Hence the output is already sign extended.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:109,clear,cleared,109,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['clear'],['cleared']
Usability,"// If bit 15 is cleared, it doesn't make a difference whether the last; // instruction is an ADDiu or ORi. In that case, do not call GetInstSeqLsORi.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp:16,clear,cleared,16,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp,1,['clear'],['cleared']
Usability,"// If both operands are known non-negative, then an unsigned compare is the; // same as a signed compare and there's no need to flip signbits.; // TODO: We could check for more general simplifications here since we're; // computing known bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:185,simpl,simplifications,185,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplifications']
Usability,"// If both operands have range metadata, use the metadata; // to simplify the comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:65,simpl,simplify,65,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplify']
Usability,"// If both sides simplified to the same value, then use it as the result of; // the original comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:17,simpl,simplified,17,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplified']
Usability,"// If bottom up, the pointer is in an S_None state, clear the sequence; // progress since the sequence in the bottom up state finished; // suggesting a mismatch in between retains/releases. This is true for; // all three cases that we are handling here: S_Retain, S_Use, and; // S_CanRelease.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:52,clear,clear,52,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['clear'],['clear']
Usability,"// If broadcasting from another shuffle, attempt to simplify it.; // TODO - we really need a general SimplifyDemandedVectorElts mechanism.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:52,simpl,simplify,52,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,"['Simpl', 'simpl']","['SimplifyDemandedVectorElts', 'simplify']"
Usability,"// If caller specifies new TargetFlags then use it, otherwise the; // default behavior is to copy the target flags from the existing; // MachineOperand. This means if the caller wants to clear the; // target flags it needs to do so explicitly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h:187,clear,clear,187,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h,1,['clear'],['clear']
Usability,"// If checking bits we know are clear, return zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:32,clear,clear,32,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['clear'],['clear']
Usability,"// If current argument is known to be simplified to null pointer and the; // corresponding argument position is known to have nonnull attribute,; // the argument is poison. Furthermore, if the argument is poison and; // the position is known to have noundef attriubte, this callsite is; // considered UB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:38,simpl,simplified,38,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['simpl'],['simplified']
Usability,// If current instruction is load instructions; // make sure it's a simple load (non atomic & non volatile),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:68,simpl,simple,68,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,1,['simpl'],['simple']
Usability,// If current instruction is store instruction; // make sure it's a simple store (non atomic & non volatile),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:68,simpl,simple,68,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,1,['simpl'],['simple']
Usability,"// If destroyed from the logical shape itself the pointer has already; // been cleared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLPhysicalShape.cxx:79,clear,cleared,79,graf3d/gl/src/TGLPhysicalShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLPhysicalShape.cxx,1,['clear'],['cleared']
Usability,"// If either operand is undef, bail out. The binop should be simplified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:61,simpl,simplified,61,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplified']
Usability,"// If either pointer is accessed multiple times, there may not be a clear; // src/sink relation. Bail out for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:68,clear,clear,68,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['clear'],['clear']
Usability,"// If every element is an all-sign value, see if we can use TESTP/MOVMSK; // to more efficiently extract the sign bits and compare that.; // TODO: Handle TESTC with comparison inversion.; // TODO: Can we remove SimplifyMultipleUseDemandedBits and rely on; // TESTP/MOVMSK combines to make sure its never worse than PTEST?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:211,Simpl,SimplifyMultipleUseDemandedBits,211,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['SimplifyMultipleUseDemandedBits']
Usability,"// If gap size is one, simply fill gap and return",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx:23,simpl,simply,23,roofit/roofitcore/src/RooNumRunningInt.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx,1,['simpl'],['simply']
Usability,"// If in sequential (0-slave-PROOF) mode we do not have a packetizer; // so we also send the info to update the progress bar.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:112,progress bar,progress bar,112,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['progress bar'],['progress bar']
Usability,"// If initialization order checking is disabled, a simple access to a; // dynamically initialized global is always valid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:51,simpl,simple,51,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['simpl'],['simple']
Usability,"// If instruction is in the middle of the bundle, move it before the; // bundle starts, otherwise, just unbundle it. When we get to the last; // instruction, the bundle will have been completely undone.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:195,undo,undone,195,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,1,['undo'],['undone']
Usability,"// If it folds to something simple, use it. Otherwise, don't.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:28,simpl,simple,28,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['simpl'],['simple']
Usability,"// If it is a constant, we simply add it to the argument list as a value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:27,simpl,simply,27,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,1,['simpl'],['simply']
Usability,"// If it is a false branch, we shall be guided by opposite operator,; // because the table is made assuming we are in the true branch.; // E.g. when (x <= y) is false, then (x > y) is true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:40,guid,guided,40,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['guid'],['guided']
Usability,"// If it is not a fixed vector, but not a simple NaN either, return a; // canonical NaN.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:42,simpl,simple,42,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simple']
Usability,"// If it is not a simple branch, we are in a table somewhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:18,simpl,simple,18,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['simpl'],['simple']
Usability,"// If it is not beneficial to hoist all the BackCopies, simply remove; // redundant BackCopies in speed mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:56,simpl,simply,56,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,1,['simpl'],['simply']
Usability,"// If it's in the undocumented category, just construct a header by; // concatenating all the spellings. Might not be great, but better than; // nothing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:18,undo,undocumented,18,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,1,['undo'],['undocumented']
Usability,"// If it's not a ""simple"" variable and if there is at least one ""."" or ""->""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TTabCom.cxx:18,simpl,simple,18,core/rint/src/TTabCom.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TTabCom.cxx,1,['simpl'],['simple']
Usability,"// If it's not bundled with the successor (i.e. it is the last one; // in the bundle), then we can simply unbundle it from the predecessor,; // which will take care of updating the predecessor's flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:99,simpl,simply,99,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['simpl'],['simply']
Usability,"// If it's simple or already seen, no need to add to work list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-pdbutil/TypeReferenceTracker.cpp:11,simpl,simple,11,interpreter/llvm-project/llvm/tools/llvm-pdbutil/TypeReferenceTracker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-pdbutil/TypeReferenceTracker.cpp,1,['simpl'],['simple']
Usability,"// If lookup table has more than one user,; // do not generate a relative lookup table.; // This is to simplify the analysis that needs to be done for this pass.; // TODO: Add support for lookup tables with multiple uses.; // For ex, this can happen when a function that uses a lookup table gets; // inlined into multiple call sites.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp:103,simpl,simplify,103,interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp,1,['simpl'],['simplify']
Usability,"// If mini is a minimal signed value, absolute value of it is greater; // than the maximal signed value. In order to avoid these; // complications, we simply return the whole range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:151,simpl,simply,151,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['simpl'],['simply']
Usability,"// If multiple users are using the root value, proceed with; // simplification conservatively assuming that all elements; // are needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:64,simpl,simplification,64,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['simpl'],['simplification']
Usability,"// If no caller callsites were already assigned to a clone of this; // function, we can simply assign this clone to the new func clone; // and update all callers to it, then skip to the next clone.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:88,simpl,simply,88,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['simpl'],['simply']
Usability,"// If no entry is found and GUID is different from GUID computed using; // exported name, look up ValueInfo with the exported name unconditionally.; // This is a fallback.; //; // The reason to have a fallback:; // 1. LTO could enable global value internalization via; // `enable-lto-internalization`.; // 2. The GUID in ExportedSummary is computed using exported name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:28,GUID,GUID,28,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,3,['GUID'],['GUID']
Usability,"// If no high-level/outside simplification occurred, use; // AAPotentialValues.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:28,simpl,simplification,28,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['simpl'],['simplification']
Usability,"// If no trivial unwind blocks, don't do any simplifications.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:45,simpl,simplifications,45,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['simpl'],['simplifications']
Usability,"// If none of the formulae satisfied the required registers, then we could; // clear ReqRegs and try again. Currently, we simply give up in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:79,clear,clear,79,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,2,"['clear', 'simpl']","['clear', 'simply']"
Usability,"// If none of the special cases above are triggered, then this is a; // simple const assignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:72,simpl,simple,72,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['simpl'],['simple']
Usability,// If not all references were cleared it means some variables/typenames/etc; // declared inside the pool scope are used outside of it.; // We won't try to rewrite the pool.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp:30,clear,cleared,30,interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp,1,['clear'],['cleared']
Usability,"// If not line table rows were added, clear the line table so we don't encode; // on in the GSYM file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp:38,clear,clear,38,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp,1,['clear'],['clear']
Usability,"// If nothing was set or the class is simply compatible, set it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:38,simpl,simply,38,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,1,['simpl'],['simply']
Usability,"// If one branch simplified and the other did not, and the simplified; // value is equal to the unsimplified one, return the simplified value.; // For example, select (cond, X, X & Z) & Z -> X & Z.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:17,simpl,simplified,17,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,3,['simpl'],['simplified']
Usability,"// If one branch simplified to undef, return the other one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:17,simpl,simplified,17,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplified']
Usability,"// If one side is a constant, and all of the set bits in the constant are; // also known set on the other side, turn this into an AND, as we know; // the bits will be cleared.; // e.g. (X | C1) ^ C2 --> (X | C1) & ~C2 iff (C1&C2) == C2; // NB: it is okay if more bits are known than are requested",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:167,clear,cleared,167,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['clear'],['cleared']
Usability,// If only EXTRACT_VECTOR_ELT nodes use the source vector we can; // simplify it based on the (valid) extraction indices.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:69,simpl,simplify,69,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simplify']
Usability,"// If only some of the modules were split, we cannot correctly perform; // this transformation. We already checked for the presense of type tests; // with partially split modules during the thin link, and would have emitted; // an error if any were found, so here we can simply return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:271,simpl,simply,271,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,2,['simpl'],['simply']
Usability,"// If optimising for minimum size, clear FP registers unconditionally.; // Otherwise, check the CONTROL.SFPA (Secure Floating-Point Active) bit and; // don't clear them if they belong to the non-secure state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp:35,clear,clear,35,interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,2,['clear'],['clear']
Usability,"// If original load is a SEXTLOAD then we can't simply replace it by a; // ZEXTLOAD (we could potentially replace it by a more narrow SEXTLOAD; // followed by a ZEXT, but that is not handled at the moment). Similarly if; // the original load is a ZEXTLOAD and we want to use a SEXTLOAD.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:48,simpl,simply,48,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simply']
Usability,"// If our LHS is an 'and' and if it has one use, and if any of the bits we; // are flipping are known to be set, then the xor is just resetting those; // bits to zero. We can just knock out bits from the 'and' and the 'xor',; // simplifying both of them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:229,simpl,simplifying,229,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['simpl'],['simplifying']
Usability,"// If our factoring failed (didn't achieve anything) see if we can simplify in; // other ways.; // Check to see if all of the leading entries are now opcode checks. If so,; // we can convert this Scope to be a OpcodeSwitch instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp:67,simpl,simplify,67,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp,1,['simpl'],['simplify']
Usability,// If prefixes have the same size we can simply copy the new one over.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Path.cpp:41,simpl,simply,41,interpreter/llvm-project/llvm/lib/Support/Path.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Path.cpp,1,['simpl'],['simply']
Usability,"// If replay inline is requested, simply follow the inline decision of the; // profiled binary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/CSPreInliner.cpp:34,simpl,simply,34,interpreter/llvm-project/llvm/tools/llvm-profgen/CSPreInliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/CSPreInliner.cpp,1,['simpl'],['simply']
Usability,"// If requested, simply import all functions in the index. This is used; // when testing distributed backend handling via the opt tool, when; // we have distributed indexes containing exactly the summaries to import.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:17,simpl,simply,17,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['simpl'],['simply']
Usability,"// If round-trip was not requested, simply run the parser with the real; // invocation diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:36,simpl,simply,36,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['simpl'],['simply']
Usability,"// If s is a constant pointer pointing to a string literal, we can fold; // strlen(s + x) to strlen(s) - x, when x is known to be in the range; // [0, strlen(s)] or the string has a single null terminator '\0' at the end.; // We only try to simplify strlen when the pointer s points to an array; // of CharSize elements. Otherwise, we would need to scale the offset x before; // doing the subtraction. This will make the optimization more complex, and; // it's not very useful because calling strlen for a pointer of other types is; // very uncommon.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:241,simpl,simplify,241,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['simpl'],['simplify']
Usability,// If set clears out memory with zeros.; // memcpy only,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:10,clear,clears,10,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['clear'],['clears']
Usability,"// If sign extension operations are disabled, allow sext_inreg only if operand; // is a vector extract of an i8 or i16 lane. SIMD does not depend on sign; // extension operations, but allowing sext_inreg in this context lets us have; // simple patterns to select extract_lane_s instructions. Expanding sext_inreg; // everywhere would be simpler in this file, but would necessitate large and; // brittle patterns to undo the expansion and select extract_lane_s; // instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:237,simpl,simple,237,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,3,"['simpl', 'undo']","['simple', 'simpler', 'undo']"
Usability,"// If something was stripped but there is circular reasoning we look; // for the offset. If it is positive we basically decrease the; // dereferenceable bytes in a circular loop now, which will simply; // drive them down to the known value in a very slow way which we; // can accelerate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:194,simpl,simply,194,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['simpl'],['simply']
Usability,"// If sources and destination aren't all high or all low, we may be able to; // simplify the operation by moving one of the sources to the destination; // first. But only if this doesn't clobber the other source.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp:80,simpl,simplify,80,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZPostRewrite.cpp,1,['simpl'],['simplify']
Usability,"// If targeting a location-list; simply emit the index into the raw; // byte stream as ULEB128, DwarfDebug::emitDebugLocEntry has been; // fitted with means to extract it later.; // If targeting a inlined DW_AT_location; insert a DIEBaseTypeRef; // (containing the index and a resolve mechanism during emit) into the; // DIE value list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:33,simpl,simply,33,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,1,['simpl'],['simply']
Usability,"// If that succeeded, fallthrough into the generic simple-type-id case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:51,simpl,simple-type-id,51,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['simpl'],['simple-type-id']
Usability,"// If the AndMask is zero for this bit, clear the bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:40,clear,clear,40,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['clear'],['clear']
Usability,"// If the CGSCC pass wasn't able to provide a valid updated SCC, the; // current SCC may simply need to be skipped if invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:89,simpl,simply,89,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,2,['simpl'],['simply']
Usability,"// If the CGSCC pass wasn't able to provide a valid updated SCC,; // the current SCC may simply need to be skipped if invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:89,simpl,simply,89,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,1,['simpl'],['simply']
Usability,"// If the GCC installation we found is inside of the sysroot, we want to; // prefer libraries installed in the parent prefix of the GCC installation.; // It is important to *not* use these paths when the GCC installation is; // outside of the system root as that can pick up unintended libraries.; // This usually happens when there is an external cross compiler on the; // host system, and a more minimal sysroot available that is the target of; // the cross. Note that GCC does include some of these directories in some; // configurations but this seems somewhere between questionable and simply; // a bug.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:591,simpl,simply,591,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['simpl'],['simply']
Usability,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:146,simpl,simplified,146,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['simpl'],['simplified']
Usability,"// If the PE header had a checksum, clear it, since it isn't valid; // any longer. (We don't calculate a new one.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/COFF/COFFWriter.cpp:36,clear,clear,36,interpreter/llvm-project/llvm/lib/ObjCopy/COFF/COFFWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/COFF/COFFWriter.cpp,1,['clear'],['clear']
Usability,// If the RHS is a constant we can try some simplifications.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:44,simpl,simplifications,44,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,2,['simpl'],['simplifications']
Usability,"// If the RHS is a constant zero then the V (overflow) flag will never be; // set. This can allow us to simplify GE to PL or LT to MI, which can be; // simpler for other passes (like the peephole optimiser) to deal with.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:104,simpl,simplify,104,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,['simpl'],"['simpler', 'simplify']"
Usability,"// If the RHS is a constant, check to see if the LHS would be zero without; // using the bits from the RHS. Below, we use knowledge about the RHS to; // simplify the LHS, here we're using information from the LHS to simplify; // the RHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:153,simpl,simplify,153,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,2,['simpl'],['simplify']
Usability,"// If the RHS is a constant, see if we can simplify it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:43,simpl,simplify,43,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,6,['simpl'],['simplify']
Usability,"// If the RHS is a constant, we can simplify ConditionRHS below. Otherwise; // use the default legalization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:36,simpl,simplify,36,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['simpl'],['simplify']
Usability,"// If the RHS isn't small, clear this vector and then steal its buffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:27,clear,clear,27,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,1,['clear'],['clear']
Usability,"// If the RHS isn't small, clear this vector and then steal its buffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:27,clear,clear,27,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['clear'],['clear']
Usability,"// If the SVal is 0, we can simply interpret that as `false`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:28,simpl,simply,28,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['simpl'],['simply']
Usability,"// If the Terminator is the only non-phi instruction, simplify the block.; // If LoopHeader is provided, check if the block or its successor is a loop; // header. (This is for early invocations before loop simplify and; // vectorization to keep canonical loop forms for nested loops. These blocks; // can be eliminated when the pass is invoked later in the back-end.); // Note that if BB has only one predecessor then we do not introduce new; // backedge, so we can eliminate BB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:54,simpl,simplify,54,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,2,['simpl'],['simplify']
Usability,"// If the `load` is not simple, we can't speculatively execute it,; // but we could handle this via a CFG modification. But can we?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:24,simpl,simple,24,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['simpl'],['simple']
Usability,"// If the alias is externally visible, we may still be able to simplify it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:63,simpl,simplify,63,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['simpl'],['simplify']
Usability,"// If the arguments are the same size, there are not values that need to be; // made into an argument, the argument ordering has not been change, or; // different output registers to handle. We can simply replace the called; // function in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:198,simpl,simply,198,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,1,['simpl'],['simply']
Usability,"// If the array being accessed has a ""counted_by"" attribute, generate; // bounds checking code. The ""count"" field is at the top level of the; // struct or in an anonymous struct, that's also at the top level. Future; // expansions may allow the ""count"" to reside at any place in the struct,; // but the value of ""counted_by"" will be a ""simple"" path to the count,; // i.e. ""a.b.count"", so we shouldn't need the full force of EmitLValue or; // similar to emit the correct GEP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:336,simpl,simple,336,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['simpl'],['simple']
Usability,"// If the assume was merged with another assume, we might have a use on a; // phi (which will feed the assume). Simply replace the use on the phi; // with ""true"" and leave the merged assume.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:112,Simpl,Simply,112,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,1,['Simpl'],['Simply']
Usability,"// If the base class doesn't have a simple move assignment, we'll eagerly; // declare it and perform overload resolution to determine which function; // it actually calls. If it does have a simple move assignment, this; // check is correct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:36,simpl,simple,36,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,2,['simpl'],['simple']
Usability,"// If the base class doesn't have a simple move constructor, we'll eagerly; // declare it and perform overload resolution to determine which function; // it actually calls. If it does have a simple move constructor, this; // check is correct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:36,simpl,simple,36,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,2,['simpl'],['simple']
Usability,"// If the base is not EBP/ESP/R12/R13/R20/R21/R28/R29 and there is no; // displacement, use simple indirect register encoding, this handles; // addresses like [EAX]. The encoding for [EBP], [R13], [R20], [R21], [R28]; // or [R29] with no displacement means [disp32] so we handle it by emitting; // a displacement of 0 later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp:92,simpl,simple,92,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp,1,['simpl'],['simple']
Usability,"// If the block is trivially dead, just return and let the caller nuke it.; // This simplifies other transformations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:84,simpl,simplifies,84,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['simpl'],['simplifies']
Usability,// If the branch target is simply an address then print it in hex.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp:27,simpl,simply,27,interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp,1,['simpl'],['simply']
Usability,"// If the callee can save a copy into other memory, then simply; // scanning uses of the call is insufficient. We have no way; // of tracking copies of the pointer through memory to see; // if a reloaded copy is written to, thus we must give up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:57,simpl,simply,57,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['simpl'],['simply']
Usability,"// If the callee has attribute pure, const, or warn_unused_result, warn with; // a more specific message to make it clear what is happening. If the call; // is written in a macro body, only warn if it has the warn_unused_result; // attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:116,clear,clear,116,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['clear'],['clear']
Usability,"// If the caller doesn't want us to simplify this into a zext of a compare,; // don't do it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,simpl,simplify,36,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simplify']
Usability,"// If the calling conventions mismatch because the new function is static,; // suppress the calling convention mismatch error; the error about static; // function override (err_static_overrides_virtual from; // Sema::CheckFunctionDeclaration) is more clear.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:251,clear,clear,251,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['clear'],['clear']
Usability,"// If the case number of suspended switch instruction is reduced to; // 1, then it is simplified to CmpInst in llvm::ConstantFoldTerminator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:86,simpl,simplified,86,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['simpl'],['simplified']
Usability,"// If the cast is between same-sized registers, then the check is simple.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:66,simpl,simple,66,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,1,['simpl'],['simple']
Usability,"// If the cast operand is a constant expression, there's a few things we can; // do to try to simplify it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:94,simpl,simplify,94,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['simpl'],['simplify']
Usability,"// If the char is variable but the input str and length are not we can turn; // this memchr call into a simple bit field test. Of course this only works; // when the return value is only checked against null.; //; // It would be really nice to reuse switch lowering here but we can't change; // the CFG at this point.; //; // memchr(""\r\n"", C, 2) != nullptr -> (1 << C & ((1 << '\r') | (1 << '\n'))); // != 0; // after bounds check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:104,simpl,simple,104,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['simpl'],['simple']
Usability,"// If the class constraining succeeded, we can simply replace; // the old register with the mapped one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:47,simpl,simply,47,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,1,['simpl'],['simply']
Usability,"// If the cleanup return we are simplifying unwinds to the caller, this will; // set UnwindDest to nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:32,simpl,simplifying,32,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['simpl'],['simplifying']
Usability,"// If the client is only demanding bits that we know, return the known; // constant. We can't directly simplify pointers as a constant because of; // pointer provenance.; // TODO: We could return `(inttoptr const)` for pointers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:103,simpl,simplify,103,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['simpl'],['simplify']
Usability,"// If the common prefix is non-empty we can simply insert it. If there is a; // single completion, this will insert the full completion. If there is more; // than one, this might be enough information to jog the user's memory but if; // not the user can also hit tab again to see the completions because the; // common prefix will then be empty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LineEditor/LineEditor.cpp:44,simpl,simply,44,interpreter/llvm-project/llvm/lib/LineEditor/LineEditor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LineEditor/LineEditor.cpp,1,['simpl'],['simply']
Usability,"// If the comparison is a comparison between two i1's, simplify it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:55,simpl,simplify,55,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['simpl'],['simplify']
Usability,"// If the comparison is an equality comparison with null, we can simplify it; // if we know the value (argument) can't be null",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:65,simpl,simplify,65,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['simpl'],['simplify']
Usability,"// If the concatenated source types match this extract, it's a direct; // simplification:; // extract_subvec (concat V1, V2, ...), i --> Vi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:74,simpl,simplification,74,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simplification']
Usability,"// If the concept is; // template <class A, class B> concept CD = f<A, B>();; // And the concept specialization is; // CD<int, T>; // Then we're substituting T for B, so we want to make f<A, B>() true; // by adding members to B - i.e. believe(f<A, B>(), B);; //; // For simplicity:; // - we don't attempt to substitute int for A; // - when T is used in other ways (like CD<T*>) we ignore it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:270,simpl,simplicity,270,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['simpl'],['simplicity']
Usability,"// If the condition is an And, SimplifyDemandedBits may have changed; // (xor Z, 1) to (not Z).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:31,Simpl,SimplifyDemandedBits,31,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,"// If the content is a simple numerical value, return its type (see TDataType).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h:23,simpl,simple,23,io/io/inc/TGenCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h,1,['simpl'],['simple']
Usability,"// If the coroutine don't have unwind coro end, we could omit the store to; // the final suspend point since we could infer the coroutine is suspended; // at the final suspend point by the nullness of ResumeFnAddr.; // However, we can't skip it if the coroutine have unwind coro end. Since; // the coroutine reaches unwind coro end is considered suspended at the; // final suspend point (the ResumeFnAddr is null) but in fact the coroutine; // didn't complete yet. We need the IndexVal for the final suspend point; // to make the states clear.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:201,Resume,ResumeFnAddr,201,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,3,"['Resume', 'clear']","['ResumeFnAddr', 'clear']"
Usability,"// If the current token is a possible simple key, keep parsing until we; // can confirm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp:38,simpl,simple,38,interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,1,['simpl'],['simple']
Usability,"// If the def and use are in different blocks, do a simple CFG dominator; // tree query.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp:52,simpl,simple,52,interpreter/llvm-project/llvm/lib/IR/Dominators.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp,1,['simpl'],['simple']
Usability,"// If the destination block is terminated by an unconditional branch,; // try to move it; otherwise, create a new block following the jump; // table that branches back to the actual target. This is a very simple; // heuristic. FIXME: We can definitely improve it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp:205,simpl,simple,205,interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,1,['simpl'],['simple']
Usability,"// If the destination or first source register operand is [W]SP, print; // UXTW/UXTX as LSL, and if the shift amount is also zero, print nothing at; // all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp:75,UX,UXTW,75,interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp,2,['UX'],"['UXTW', 'UXTX']"
Usability,"// If the destructor is explicitly defaulted and not trivial or not public; // or if the destructor is deleted, we clear HasIrrelevantDestructor in; // finishedDefaultedOrDeletedMember.; // C++11 [class.dtor]p5:; // A destructor is trivial if [...] the destructor is not virtual.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:115,clear,clear,115,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,1,['clear'],['clear']
Usability,"// If the divisor is a select-of-constants, try to constant fold all div ops:; // C / (select Cond, TrueC, FalseC) --> select Cond, (C / TrueC), (C / FalseC); // TODO: Adapt simplifyDivRemOfSelectWithZeroOp to allow this and other folds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:174,simpl,simplifyDivRemOfSelectWithZeroOp,174,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['simpl'],['simplifyDivRemOfSelectWithZeroOp']
Usability,"// If the divisor is a select-of-constants, try to constant fold all rem ops:; // C % (select Cond, TrueC, FalseC) --> select Cond, (C % TrueC), (C % FalseC); // TODO: Adapt simplifyDivRemOfSelectWithZeroOp to allow this and other folds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:174,simpl,simplifyDivRemOfSelectWithZeroOp,174,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['simpl'],['simplifyDivRemOfSelectWithZeroOp']
Usability,"// If the divisor is not a constant, DAGCombiner will convert it to a; // multiplication by a magic constant. It isn't clear if it is worth; // introducing control flow to get a narrower multiply.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:119,clear,clear,119,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,1,['clear'],['clear']
Usability,"// If the expression changed non-trivially then clear out all subclass data; // starting from the operator specified in ExpressionChanged, and compactify; // the operators to just before the expression root to guarantee that the; // expression tree is dominated by all of Ops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:48,clear,clear,48,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['clear'],['clear']
Usability,"// If the false value simplified to false, then the result of the compare; // is equal to ""Cond && TCmp"". This also catches the case when the false; // value simplified to false and the true value to true, returning ""Cond"".; // Folding select to and/or isn't poison-safe in general; impliesPoison; // checks whether folding it does not convert a well-defined value into; // poison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:22,simpl,simplified,22,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,['simpl'],['simplified']
Usability,"// If the family name is known, we can link with the device-specific libgcc.; // Without it, libgcc will simply not be linked. This matches avr-gcc; // behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AVR.cpp:105,simpl,simply,105,interpreter/llvm-project/clang/lib/Driver/ToolChains/AVR.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AVR.cpp,1,['simpl'],['simply']
Usability,"// If the field doesn't have a simple move assignment, we'll eagerly; // declare the move assignment for this class and we'll decide whether; // it's trivial then.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:31,simpl,simple,31,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,1,['simpl'],['simple']
Usability,"// If the field doesn't have a simple move constructor, we'll eagerly; // declare the move constructor for this class and we'll decide whether; // it's trivial then.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:31,simpl,simple,31,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,1,['simpl'],['simple']
Usability,"// If the function has a frame pointer (i.e. has an allocframe),; // then the CFA has been defined in terms of FP. Any offsets in; // the following CFI instructions have to be defined relative; // to FP, which points to the bottom of the stack frame.; // The function getFrameIndexReference can still choose to use SP; // for the offset calculation, so we cannot simply call it here.; // Instead, get the offset (relative to the FP) directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:363,simpl,simply,363,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,1,['simpl'],['simply']
Usability,"// If the function has fewer parameters than the call has arguments, we simply; // do not bind any values to them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:72,simpl,simply,72,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,1,['simpl'],['simply']
Usability,"// If the hash of top-level entities differs from the hash of the top-level; // entities the last time we rebuilt the preamble, clear out the completion; // cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:128,clear,clear,128,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,1,['clear'],['clear']
Usability,"// If the initializer expression is usable, but the InitCaptureType; // is not, then an error has occurred - so ignore the capture for now.; // for e.g., [n{0}] { }; <-- if no <initializer_list> is included.; // FIXME: we should create the init capture variable and mark it invalid; // in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:36,usab,usable,36,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,1,['usab'],['usable']
Usability,"// If the input DIE corresponds to the compile unit, it can be:; // a) Simple DWARF: a standard DIE. Ignore the skeleton DIE (is empty).; // b) Split DWARF: the DIE for the split DWARF. The skeleton is the DIE; // for the skeleton DWARF. Process both DIEs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVELFReader.cpp:71,Simpl,Simple,71,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVELFReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVELFReader.cpp,1,['Simpl'],['Simple']
Usability,"// If the input is an extend_invec and the SimplifyDemandedBits call didn't; // convert it to any_extend_invec, due to the LegalOperations check, do the; // conversion directly to a vector shuffle manually. This exposes combine; // opportunities missed by combineEXTEND_VECTOR_INREG not calling; // combineX86ShufflesRecursively on SSE4.1 targets.; // FIXME: This is basically a hack around several other issues related to; // ANY_EXTEND_VECTOR_INREG.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:43,Simpl,SimplifyDemandedBits,43,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,"// If the input is known to be positive (the sign bit is known clear),; // the output of the NEG has the same number of sign bits as the input.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:63,clear,clear,63,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['clear'],['clear']
Usability,"// If the input is known to be positive (the sign bit is known clear),; // the output of the NEG has the same number of sign bits as the; // input.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:63,clear,clear,63,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['clear'],['clear']
Usability,// If the input value is provably positive and we could not simplify; // away the sext build a zext instead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:60,simpl,simplify,60,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['simpl'],['simplify']
Usability,"// If the input vector has a single use, simplify it based on this use; // property.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:41,simpl,simplify,41,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['simpl'],['simplify']
Usability,"// If the input vector has multiple uses, simplify it based on a union; // of all elements used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:42,simpl,simplify,42,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['simpl'],['simplify']
Usability,"// If the instruction can be easily simplified then do so now in preference; // to value numbering it. Value numbering often exposes redundancies, for; // example if it determines that %y is equal to %x then the instruction; // ""%z = and i32 %x, %y"" becomes ""%z = and i32 %x, %x"" which we now simplify.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:36,simpl,simplified,36,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,2,['simpl'],"['simplified', 'simplify']"
Usability,// If the instruction can be simplified (e.g. X+0 = X) then replace it with; // its simpler value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:29,simpl,simplified,29,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,2,['simpl'],"['simpler', 'simplified']"
Usability,"// If the instruction has a single def, then simply delegate the search.; // For unmerge however with multiple defs, we need to compute the offset; // into the source of the unmerge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizationArtifactCombiner.h:45,simpl,simply,45,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizationArtifactCombiner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizationArtifactCombiner.h,1,['simpl'],['simply']
Usability,"// If the instruction simplified to a constant, there is no cost to this; // instruction. Visit the instructions using our InstVisitor to account for; // all of the per-instruction logic. The visit tree returns true if we; // consumed the instruction in any way, and false if the instruction's base; // cost should count against inlining.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:22,simpl,simplified,22,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['simpl'],['simplified']
Usability,"// If the instructions aren't in the same BB, bail out and clear the; // kill flag on all uses of the imp-def'd register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:59,clear,clear,59,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['clear'],['clear']
Usability,"// If the lanes written by this instruction were all undef in OtherVNI, it is; // still safe to join the live ranges. This can't be done with a simple value; // mapping, though - OtherVNI will map to multiple values:; //; // 1 %dst:ssub0 = FOO <-- OtherVNI; // 2 %src = BAR <-- VNI; // 3 %dst:ssub1 = COPY killed %src <-- Eliminate this copy.; // 4 BAZ killed %dst; // 5 QUUX killed %src; //; // Here OtherVNI will map to itself in [1;2), but to VNI in [2;5). CR_Replace; // handles this complex value mapping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:144,simpl,simple,144,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['simpl'],['simple']
Usability,"// If the last component of the (optional) nested-name-specifier is; // template[opt] simple-template-id, it has already been annotated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:86,simpl,simple-template-id,86,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['simpl'],['simple-template-id']
Usability,"// If the list contains only RangeSet or std::optional<RangeSet>, simply; // return that range set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:66,simpl,simply,66,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['simpl'],['simply']
Usability,// If the load that we're shrinking is an extload and we're not just; // discarding the extension we can't simply shrink the load. Bail.; // TODO: It would be possible to merge the extensions in some cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:107,simpl,simply,107,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simply']
Usability,"// If the lower bound was in something that no longer dominates us, we; // have to reset it.; // We can't simply track stack size, because the stack may have had; // pushes/pops in the meantime.; // XXX: This is non-optimal, but only is slower cases with heavily; // branching dominator trees. To get the optimal number of queries would; // be to make lowerbound and lastkill a per-loc stack, and pop it until; // the top of that stack dominates us. This does not seem worth it ATM.; // A much cheaper optimization would be to always explore the deepest; // branch of the dominator tree first. This will guarantee this resets on; // the smallest set of blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:106,simpl,simply,106,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['simpl'],['simply']
Usability,"// If the lowest bit is clear then the first ptr_data entry is a SourceManager; // pointer, or the CXSourceLocation is a null location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXSourceLocation.cpp:24,clear,clear,24,interpreter/llvm-project/clang/tools/libclang/CXSourceLocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXSourceLocation.cpp,1,['clear'],['clear']
Usability,"// If the mask value has been legalized to a non-boolean vector, try to; // simplify ops leading up to it. We only demand the MSB of each lane.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:76,simpl,simplify,76,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['simpl'],['simplify']
Usability,"// If the masked bit in V is clear, clear or set the bit in the result:; // (V & AndMaskC) == 0 ? TC : FC --> (V & AndMaskC) ^ TC; // (V & AndMaskC) == 0 ? TC : FC --> (V & AndMaskC) | TC",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:29,clear,clear,29,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,2,['clear'],['clear']
Usability,"// If the masked bit in V is set, set or clear the bit in the result:; // (V & AndMaskC) != 0 ? TC : FC --> (V & AndMaskC) | FC; // (V & AndMaskC) != 0 ? TC : FC --> (V & AndMaskC) ^ FC",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:41,clear,clear,41,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['clear'],['clear']
Usability,"// If the most significant bit of immediate in ANDIS is zero,; // all of 0 to 32-th bits are cleared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:93,clear,cleared,93,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['clear'],['cleared']
Usability,"// If the name ends with ""*"", create 2 logical types: a pointer and a; // pointee type. TypeIndex is composed of a SympleTypeMode byte followed; // by a SimpleTypeKind byte. The logical pointer will be identified by; // the full TypeIndex value and the pointee by the SimpleTypeKind.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp:153,Simpl,SimpleTypeKind,153,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,2,['Simpl'],['SimpleTypeKind']
Usability,"// If the name is a simple identifier (by far the common case), or a; // zero-argument selector, just return a reference to that identifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp:20,simpl,simple,20,interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CodeCompleteConsumer.cpp,1,['simpl'],['simple']
Usability,"// If the negate was simplified, revisit the users to see if we can; // reassociate further.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:21,simpl,simplified,21,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,2,['simpl'],['simplified']
Usability,"// If the offset is simply too big, don't convert to a scratch wave offset; // relative index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:20,simpl,simply,20,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['simpl'],['simply']
Usability,"// If the old decl is NOT MultiVersioned yet, and we don't cause that; // to change, this is a simple redeclaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:95,simpl,simple,95,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['simpl'],['simple']
Usability,"// If the only instruction in the block is a seteq/setne comparison against a; // constant, try to simplify the block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:99,simpl,simplify,99,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['simpl'],['simplify']
Usability,"// If the operands are constants, see if we can simplify them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:48,simpl,simplify,48,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,2,['simpl'],['simplify']
Usability,"// If the operands are constants, see if we can simplify them.; // This is similar to ShrinkDemandedConstant, but for a select we want to; // try to keep the selected constants the same as icmp value constants, if; // we can. This helps not break apart (or helps put back together); // canonical patterns like min and max.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:48,simpl,simplify,48,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['simpl'],['simplify']
Usability,"// If the operation failed to simplify, or simplified to a different value; // to previously, then give up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:30,simpl,simplify,30,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,4,['simpl'],"['simplified', 'simplify']"
Usability,"// If the operation is an AND/OR/XOR and the bits to clear are zero in the; // other side, BitsToClear is ok.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:53,clear,clear,53,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['clear'],['clear']
Usability,"// If the parameter name ends with the ""_exponential_inverted"" suffix,; // this means that it was exported from a RooFit object where the; // parameter first needed to be transformed on export to match the HS3; // specification. But when re-importing such a parameter, we can simply; // skip the transformation and use the original RooFit parameter without; // the suffix.; //; // A concrete example: take the following RooFit pdf in the factory language:; //; // ""Exponential::exponential_1(x[0, 10], c[-0.1])""; //; // It defines en exponential exp(c * x). However, in HS3 the exponential; // is defined as exp(-c * x), to RooFit would export these dictionaries; // to the JSON:; //; // {; // ""name"": ""exponential_1"", // HS3 exponential_dist with transformed parameter; // ""type"": ""exponential_dist"",; // ""x"": ""x"",; // ""c"": ""c_exponential_inverted""; // },; // {; // ""name"": ""c_exponential_inverted"", // transformation function created on-the-fly on export; // ""type"": ""generic_function"",; // ""expression"": ""-c""; // }; //; // On import, we can directly take the non-transformed parameter, which is; // we check for the suffix and optionally remove it from the requested; // name next:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/JSONFactories_RooFitCore.cxx:276,simpl,simply,276,roofit/hs3/src/JSONFactories_RooFitCore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/JSONFactories_RooFitCore.cxx,1,['simpl'],['simply']
Usability,"// If the previous block unconditionally falls through to this block and; // this block has no other predecessors, move the contents of this block; // into the prior block. This doesn't usually happen when SimplifyCFG; // has been used, but it can happen if tail merging splits a fall-through; // predecessor of a block.; // This has to check PrevBB->succ_size() because EH edges are ignored by; // analyzeBranch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:206,Simpl,SimplifyCFG,206,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['Simpl'],['SimplifyCFG']
Usability,"// If the previous token could have been a simple key, insert the key token; // into the token queue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp:43,simpl,simple,43,interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,1,['simpl'],['simple']
Usability,"// If the previous value was a simple mapping, add liveness for it now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:31,simpl,simple,31,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,1,['simpl'],['simple']
Usability,"// If the prior block falls through into us, turn it into an; // explicit branch to us to make updates simpler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:103,simpl,simpler,103,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['simpl'],['simpler']
Usability,"// If the quadratic term is 0, we simply; // use a linear equation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/RooBarlowBeestonLL.cxx:34,simpl,simply,34,roofit/histfactory/src/RooBarlowBeestonLL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/RooBarlowBeestonLL.cxx,1,['simpl'],['simply']
Usability,"// If the register simply lives through the CodeBB, we don't have; // to rewrite anything since the register is not defined in this; // part of the code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineCFGStructurizer.cpp:19,simpl,simply,19,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineCFGStructurizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineCFGStructurizer.cpp,1,['simpl'],['simply']
Usability,"// If the result and operand types are the same after promotion, simplify; // to an in-register extension. Unless this is a VP_*_EXTEND.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:65,simpl,simplify,65,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['simpl'],['simplify']
Usability,"// If the result is *not* empty, then we know the; // optional must have been holding a value. If; // `ExprVal` is true, though, we don't learn; // anything definite about `has_value`, so we; // don't add any corresponding implications to; // the flow condition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp:138,learn,learn,138,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,1,['learn'],['learn']
Usability,"// If the result is clearly ignored, return now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:20,clear,clearly,20,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,2,['clear'],['clearly']
Usability,"// If the resulting expr has constant-addend, this constant-addend is; // desirable to reside at the top of the resulting expression tree. Placing; // constant close to super-expr(s) will potentially reveal some; // optimization opportunities in super-expr(s). Here we do not implement; // this logic intentionally and rely on SimplifyAssociativeOrCommutative; // call later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:327,Simpl,SimplifyAssociativeOrCommutative,327,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['Simpl'],['SimplifyAssociativeOrCommutative']
Usability,"// If the resulting vector is smaller than the size of the source; // vectors being concatenated, we won't be able to replace the; // shuffle vector into a concat_vectors.; //; // Note: We may still be able to produce a concat_vectors fed by; // extract_vector_elt and so on. It is less clear that would; // be better though, so don't bother for now.; //; // If the destination is a scalar, the size of the sources doesn't; // matter. we will lower the shuffle to a plain copy. This will; // work only if the source and destination have the same size. But; // that's covered by the next condition.; //; // TODO: If the size between the source and destination don't match; // we could still emit an extract vector element in that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:287,clear,clear,287,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['clear'],['clear']
Usability,"// If the return type has changed, then get rid of 'returned' on the; // call site. The alternative is to make all 'returned' attributes on; // call sites keep the return value alive just like 'returned'; // attributes on function declaration, but it's less clearly a win and; // this is not an expected case anyway",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:258,clear,clearly,258,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,1,['clear'],['clearly']
Usability,// If the right operand is a concrete int location then we have nothing; // better but to treat it as a simple nonloc.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:104,simpl,simple,104,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,1,['simpl'],['simple']
Usability,"// If the root of either pattern isn't a simple operator, ignore it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp:41,simpl,simple,41,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp,1,['simpl'],['simple']
Usability,"// If the scalar is poison, or it is undef and there is no risk of; // propagating poison from the vector value, simplify to the vector value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:113,simpl,simplify,113,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplify']
Usability,"// If the scores are the same, but the Reg is simpler for the target; // (for example {x,+,1} as opposed to {x+C,+,1}, where the target can; // handle +C but not -C), opt for the simpler formula.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:46,simpl,simpler,46,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,2,['simpl'],['simpler']
Usability,// If the sdiv has an 'exact' bit we can use a simpler lowering.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:47,simpl,simpler,47,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['simpl'],['simpler']
Usability,// If the sdiv has an 'exact' flag we can use a simpler lowering.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:48,simpl,simpler,48,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['simpl'],['simpler']
Usability,"// If the select constants differ by exactly one bit and that's the same; // bit that is masked and checked by the select condition, the select can; // be replaced by bitwise logic to set/clear one bit of the constant result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:188,clear,clear,188,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['clear'],['clear']
Usability,"// If the select has a single user, and this user is a select instruction that; // we can simplify, skip the cmpxchg simplification for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:90,simpl,simplify,90,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,2,['simpl'],"['simplification', 'simplify']"
Usability,"// If the selected successor is the landing pad, clear the chunk; // successors to avoid creating a regular branch to the landing pad which; // would result in invalid IR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceBasicBlocks.cpp:49,clear,clear,49,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceBasicBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceBasicBlocks.cpp,1,['clear'],['clear']
Usability,"// If the shift amount is as large as the result size (but, presumably,; // no larger than the source) then the useful bits of the result are; // zero; we can't simply return the shortened shift, because the result; // of that operation is undefined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:161,simpl,simply,161,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simply']
Usability,"// If the shuffled source vector simplifies, cast that value to this; // shuffle's type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:33,simpl,simplifies,33,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['simpl'],['simplifies']
Usability,"// If the sign bit of the input is known set or clear, then we know the; // top bits of the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:48,clear,clear,48,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,2,['clear'],['clear']
Usability,"// If the sign bit of the input is known set or clear, then we know the; // top bits of the result.; // If the input sign bit is known zero, convert this into a zero extension.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:48,clear,clear,48,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['clear'],['clear']
Usability,"// If the sizes are the same, simply drop the memset instead of generating; // a replacement with zero size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:30,simpl,simply,30,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['simpl'],['simply']
Usability,// If the sizes match we can simply try to replace the register,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizationArtifactCombiner.h:29,simpl,simply,29,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizationArtifactCombiner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizationArtifactCombiner.h,1,['simpl'],['simply']
Usability,"// If the skipped block has no labels in it, just emit the executed block.; // This avoids emitting dead code and simplifies the CFG substantially.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp:114,simpl,simplifies,114,interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,1,['simpl'],['simplifies']
Usability,"// If the stack id list is empty, this callsite info was synthesized for; // a missing tail call frame. Ensure that the callee's GUID gets a value; // id. Normally we only generate these for defined summaries, which in; // the case of distributed ThinLTO is only the functions already defined; // in the module or that we want to import. We don't bother to include; // all the callee symbols as they aren't normally needed in the backend.; // However, for the synthesized callsite infos we do need the callee; // GUID in the backend so that we can correlate the identified callee; // with this callsite info (which for non-tail calls is done by the; // ordering of the callsite infos and verified via stack ids).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:129,GUID,GUID,129,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,2,['GUID'],['GUID']
Usability,"// If the stack restore is in a return, resume, or unwind block and if there; // are no allocas or calls between the restore and the return, nuke the; // restore.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:40,resume,resume,40,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['resume'],['resume']
Usability,"// If the start is a non-zero constant, shift the range to simplify things.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:59,simpl,simplify,59,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['simpl'],['simplify']
Usability,"// If the subvector vector is a fixed-length type, we cannot use subregister; // manipulation to simplify the codegen; we don't know which register of a; // LMUL group contains the specific subvector as we only know the minimum; // register size. Therefore we must slide the vector group down the full; // amount.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:97,simpl,simplify,97,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['simpl'],['simplify']
Usability,"// If the subvector vector is a fixed-length type, we cannot use subregister; // manipulation to simplify the codegen; we don't know which register of a; // LMUL group contains the specific subvector as we only know the minimum; // register size. Therefore we must slide the vector group up the full; // amount.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:97,simpl,simplify,97,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['simpl'],['simplify']
Usability,"// If the suspend returns a single scalar value, we can just do a simple; // replacement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:66,simpl,simple,66,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['simpl'],['simple']
Usability,// If the switch has been simplified to the point where it can be replaced; // by a branch then do so now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:26,simpl,simplified,26,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,1,['simpl'],['simplified']
Usability,"// If the target doesn't provide itinerary information, use a simple; // non-zero default value for all instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrItineraries.h:62,simpl,simple,62,interpreter/llvm-project/llvm/include/llvm/MC/MCInstrItineraries.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrItineraries.h,1,['simpl'],['simple']
Usability,"// If the target has andn, bsl, or a similar bit-select instruction,; // we want to unfold masked merge, with canonical pattern of:; // | A | |B|; // ((x ^ y) & m) ^ y; // | D |; // Into:; // (x & m) | (y & ~m); // If y is a constant, m is not a 'not', and the 'andn' does not work with; // immediates, we unfold into a different pattern:; // ~(~x & m) & (m | y); // If x is a constant, m is a 'not', and the 'andn' does not work with; // immediates, we unfold into a different pattern:; // (x | ~m) & ~(~m & ~y); // NOTE: we don't unfold the pattern if 'xor' is actually a 'not', because at; // the very least that breaks andnpd / andnps patterns, and because those; // patterns are simplified in IR and shouldn't be created in the DAG",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:684,simpl,simplified,684,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simplified']
Usability,"// If the target has hardware branch prediction that can handle indirect; // branches, duplicating them can often make them predictable when there; // are common paths through the code. The limit needs to be high enough; // to allow undoing the effects of tail merging and other optimizations; // that rearrange the predecessors of the indirect branch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:233,undo,undoing,233,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,1,['undo'],['undoing']
Usability,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:100,simpl,simplify,100,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,5,['simpl'],['simplify']
Usability,"// If the terminator is a simple branch, continue to the next block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:26,simpl,simple,26,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['simpl'],['simple']
Usability,"// If the terminator of this block is branching on a constant, simplify the; // terminator to an unconditional branch. This can occur due to threading in; // other blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:63,simpl,simplify,63,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['simpl'],['simplify']
Usability,"// If the top 3 bits of imm are clear, this is a VMOV (immediate)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:32,clear,clear,32,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,2,['clear'],['clear']
Usability,"// If the true value simplified to true, then the result of the compare; // is equal to ""Cond || FCmp"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:21,simpl,simplified,21,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplified']
Usability,"// If the true/false operands are swapped and the conditions are compares; // with inverted predicates, the selects are equal:; // select (icmp Pred, X, Y), A, B <--> select (icmp InvPred, X, Y), B, A; //; // This also handles patterns with a double-negation in the sense of not +; // inverse, because we looked through a 'not' in the matching function and; // swapped A/B:; // select (cmp Pred, X, Y), A, B <--> select (not (cmp InvPred, X, Y)), B, A; //; // This intentionally does NOT handle patterns with a double-negation in; // the sense of not + not, because doing so could result in values; // comparing; // as equal that hash differently in the min/max cases like:; // select (cmp slt, X, Y), X, Y <--> select (not (not (cmp slt, X, Y))), X, Y; // ^ hashes as min ^ would not hash as min; // In the context of the EarlyCSE pass, however, such cases never reach; // this code, as we simplify the double-negation before hashing the second; // select (and so still succeed at CSEing them).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:891,simpl,simplify,891,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['simpl'],['simplify']
Usability,"// If the two computed results can be simplified separately, separate them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:38,simpl,simplified,38,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simplified']
Usability,"// If the two extracted lanes are from the same place and adjacent, this; // simplifies into a f32 lane move.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:77,simpl,simplifies,77,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['simpl'],['simplifies']
Usability,"// If the type of the GlobalValue::GUID changes, then we need to update; // the reader and the writer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h:35,GUID,GUID,35,interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,1,['GUID'],['GUID']
Usability,"// If the types are the same, we won't learn anything by unwrapping; // them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:39,learn,learn,39,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['learn'],['learn']
Usability,"// If the union value is considered to be simple, fold it into the; // current line to save some vertical space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp:42,simpl,simple,42,interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp,1,['simpl'],['simple']
Usability,"// If the unreachable instruction is the first in the block, take a gander; // at all of the predecessors of this instruction, and simplify them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:131,simpl,simplify,131,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['simpl'],['simplify']
Usability,"// If the updated SCC was the one containing the deleted function, clear it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:67,clear,clear,67,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,1,['clear'],['clear']
Usability,"// If the user wants to use the extended "".help scopeName"" command to access; // the online reference guide, we first check if the command starts correctly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:102,guid,guide,102,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['guid'],['guide']
Usability,"// If the value coming around the backedge is an add with the symbolic; // value we just inserted, possibly with casts that we can ignore under; // an appropriate runtime guard, then we found a simple induction variable!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:194,simpl,simple,194,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['simpl'],['simple']
Usability,"// If the value is not extended, a simple load will suffice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMCallLowering.cpp:35,simpl,simple,35,interpreter/llvm-project/llvm/lib/Target/ARM/ARMCallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMCallLowering.cpp,1,['simpl'],['simple']
Usability,"// If the value is unavailable in one of predecessors, we will end up; // inserting a new instruction into them. It is only valid if all the; // instructions before LoadI are guaranteed to pass execution to its; // successor, or if LoadI is safe to speculate.; // TODO: If this logic becomes more complex, and we will perform PRE insertion; // farther than to a predecessor, we need to reuse the code from GVN's PRE.; // It requires domination tree analysis, so for this simple case it is an; // overkill.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:471,simpl,simple,471,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['simpl'],['simple']
Usability,"// If the value of a flag is unset, ignore it.; // If it's set, it always takes precedence over the existing value so; // clear/set the corresponding bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp:122,clear,clear,122,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp,1,['clear'],['clear']
Usability,"// If the value used in the zext/sext is the select condition, or the negated; // of the select condition, the binop can be simplified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:124,simpl,simplified,124,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplified']
Usability,"// If the value wasn't vectorized, we must maintain the original scalar; // type. Skip those here, after incrementing NumProcessedRecipes. Also; // skip casts which do not need to be handled explicitly here, as; // redundant casts will be removed during recipe simplification.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:261,simpl,simplification,261,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,1,['simpl'],['simplification']
Usability,"// If the variable doesn't have any initializer (shouldn't this be; // invalid?), it's not clear what we should do. Maybe capture as; // zero?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:91,clear,clear,91,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,1,['clear'],['clear']
Usability,"// If the variable is clearly identified as non-odr-used and the full; // expression is not instantiation dependent, only then do we not; // need to check enclosing lambda's for speculative captures.; // For e.g.:; // Even though 'x' is not odr-used, it should be captured.; // int test() {; // const int x = 10;; // auto L = [=](auto a) {; // (void) +x + a;; // };; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:22,clear,clearly,22,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['clear'],['clearly']
Usability,"// If the vector is a vector of floating point, convert it to vector of int; // to simplify things.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:83,simpl,simplify,83,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['simpl'],['simplify']
Usability,"// If there are any pending errors, report them now. Clients wishing; // to avoid report_fatal_error calls should check for errors with; // has_error() and clear the error flag with clear_error() before; // destructing raw_ostream objects which may have errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp:156,clear,clear,156,interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,1,['clear'],['clear']
Usability,"// If there are exiting blocks with branches on undef, resolve the undef in; // the direction which will exit the loop. This will help simplify loop; // trip count computations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:135,simpl,simplify,135,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,1,['simpl'],['simplify']
Usability,"// If there are more elements between the insertion point and the end of the; // range than there are being inserted, we can use a simple approach to; // insertion. Since we already reserved space, we know that this won't; // reallocate the vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTVector.h:131,simpl,simple,131,interpreter/llvm-project/clang/include/clang/AST/ASTVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTVector.h,4,['simpl'],['simple']
Usability,"// If there are more elements between the insertion point and the end of the; // range than there are being inserted, we can use a simple approach to; // insertion. Since we already reserved space, we know that this won't; // reallocate the vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:131,simpl,simple,131,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,2,['simpl'],['simple']
Usability,"// If there are multiple defs, we can't do a simple analysis, so just; // go with what the kill flag says.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:45,simpl,simple,45,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,1,['simpl'],['simple']
Usability,"// If there are multiple uses of this value and we aren't at the root, then; // we can't do any simplifications of the operands, because DemandedMask; // only reflects the bits demanded by *one* of the users.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:96,simpl,simplifications,96,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['simpl'],['simplifications']
Usability,"// If there are no nans, it's safe to simply replace this with the non-IEEE; // version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:38,simpl,simply,38,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['simpl'],['simply']
Usability,"// If there are no simultaneous component p.d.f. do simple processing through addPdf()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimultaneous.cxx:52,simpl,simple,52,roofit/roofitcore/src/RooSimultaneous.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimultaneous.cxx,1,['simpl'],['simple']
Usability,"// If there are no usable killed product operands, then this; // transformation is likely not profitable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp:19,usab,usable,19,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXFMAMutate.cpp,1,['usab'],['usable']
Usability,// If there are zero or one non-zeros we can handle this very simply.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:62,simpl,simply,62,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simply']
Usability,// If there aren't any synthesized ivars then reuse the interface; // entry. Note we can't cache this because we simply free all; // entries later; however we shouldn't look up implementations; // frequently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:113,simpl,simply,113,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['simpl'],['simply']
Usability,"// If there is a cleanup stack, then we it isn't worth trying to; // simplify this block (we would need to remove it from the scope map; // and cleanup entry).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp:69,simpl,simplify,69,interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,1,['simpl'],['simplify']
Usability,// If there is a clear successor ordering we make sure that one block; // will fall through to the next,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:17,clear,clear,17,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['clear'],['clear']
Usability,"// If there is a function with a live 'returned' argument but a dead return; // value, then there are two possible actions:; // 1) Eliminate the return value and take off the 'returned' attribute on the; // argument.; // 2) Retain the 'returned' attribute and treat the return value (but not the; // entire function) as live so that it is not eliminated.; //; // It's not clear in the general case which option is more profitable because,; // even in the absence of explicit uses of the return value, code generation; // is free to use the 'returned' attribute to do things like eliding; // save/restores of registers across calls. Whether this happens is target and; // ABI-specific as well as depending on the amount of register pressure, so; // there's no good way for an IR-level pass to figure this out.; //; // Fortunately, the only places where 'returned' is currently generated by; // the FE are places where 'returned' is basically free and almost always a; // performance win, so the second option can just be used always for now.; //; // This should be revisited if 'returned' is ever applied more liberally.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:372,clear,clear,372,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,1,['clear'],['clear']
Usability,"// If there is a sequence of one or more load instructions, each loaded; // value is used as address of later load instruction, bitcast is; // necessary to change the value type, don't optimize it. For; // simplicity we give up if the load address comes from another load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:206,simpl,simplicity,206,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['simpl'],['simplicity']
Usability,"// If there is a single definition of the variable, then working out it's; // value everywhere is very simple: it's every block dominated by the; // definition. At the dominance frontier, the usual algorithm would:; // * Place PHIs,; // * Propagate values into them,; // * Find there's no incoming variable value from the other incoming branches; // of the dominance frontier,; // * Specify there's no variable value in blocks past the frontier.; // This is a common case, hence it's worth special-casing it.; // Pick out the variables value from the block transfer function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:103,simpl,simple,103,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['simpl'],['simple']
Usability,"// If there is already an edge between these nodes, simply update it and; // return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:52,simpl,simply,52,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['simpl'],['simply']
Usability,"// If there is exactly one non-simplified value, we can insert a copy of the; // operation in that block. However, if this is a critical edge, we would be; // inserting the computation on some other paths (e.g. inside a loop). Only; // do this if the pred block is unconditionally branching into the phi block.; // Also, make sure that the pred block is not dead code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:31,simpl,simplified,31,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplified']
Usability,"// If there is no Symbol associated with the relocation, we set the undef; // boolean value to 'true'. This will prevent us from calling functions that; // requires the relocation to be associated with a symbol.; //; // In SHT_REL case we would need to read the addend from section data.; // GNU objdump does not do that and we just follow for simplicity atm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/ELFDump.cpp:344,simpl,simplicity,344,interpreter/llvm-project/llvm/tools/llvm-objdump/ELFDump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/ELFDump.cpp,1,['simpl'],['simplicity']
Usability,"// If there is no more loop, all traversable bits should have been cleared.; // This property is needed by subsequent calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/GCOV.cpp:67,clear,cleared,67,interpreter/llvm-project/llvm/lib/ProfileData/GCOV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/GCOV.cpp,1,['clear'],['cleared']
Usability,"// If there is no obvious reason to prefer the left-hand side over the; // right-hand side, ensure the longest lived term is on the right-hand side,; // so the shortest lived term will be replaced by the longest lived.; // This tends to expose more simplifications.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:249,simpl,simplifications,249,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['simpl'],['simplifications']
Usability,// If there is no simple vector type with this many elements then there; // cannot be a larger legal vector type. Note that this assumes that; // there are no skipped intermediate vector types in the simple types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:18,simpl,simple,18,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,2,['simpl'],['simple']
Usability,"// If there is only one use of save exec register and that use is SI_END_CF,; // we can optimize SI_IF by returning the full saved exec mask instead of; // just cleared bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp:161,clear,cleared,161,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,1,['clear'],['cleared']
Usability,"// If there was a clear winner, user it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:18,clear,clear,18,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['clear'],['clear']
Usability,"// If there was a local def before us, we must have the same effect it; // did. Because every may-def is the same, any phis/etc we would create, it; // would also have created. If there was no local def before us, we; // performed a global update, and have to search all successors and make; // sure we update the first def in each of them (following all paths until; // we hit the first def along each path). This may also insert phi nodes.; // TODO: There are other cases we can skip this work, such as when we have a; // single successor, and only used a straight line of single pred blocks; // backwards to find the def. To make that work, we'd have to track whether; // getDefRecursive only ever used the single predecessor case. These types; // of paths also only exist in between CFG simplifications.; // If this is the first def in the block and this insert is in an arbitrary; // place, compute IDF and place phis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:791,simpl,simplifications,791,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['simpl'],['simplifications']
Usability,"// If there was only one symbol and we're removing it, just clear info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:60,clear,clear,60,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,2,['clear'],['clear']
Usability,"// If there were truly no free SGPRs, we need to undo everything.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:49,undo,undo,49,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['undo'],['undo']
Usability,"// If there's any remaining input less than a full chunk, add it to the chunk; // state. In that case, also do a final merge loop to make sure the subtree; // stack doesn't contain any unmerged pairs. The remaining input means we; // know these merges are non-root. This merge loop isn't strictly necessary; // here, because hasher_push_chunk_cv already does its own merge loop, but it; // simplifies blake3_hasher_finalize below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:390,simpl,simplifies,390,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,1,['simpl'],['simplifies']
Usability,"// If there's no usable candidate, we're done unless we can rewrite a; // '<=>' in terms of '==' and '<'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:17,usab,usable,17,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['usab'],['usable']
Usability,"// If there's only one spelling, we can simply use that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:40,simpl,simply,40,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,1,['simpl'],['simply']
Usability,"// If these friends don't have constraints, they aren't constrained, and; // thus don't fall under temp.friend p9. Else the simple presence of a; // constraint makes them unique.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:124,simpl,simple,124,interpreter/llvm-project/clang/lib/AST/Decl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp,1,['simpl'],['simple']
Usability,"// If they simplified to the same value, then return the common value.; // If they both failed to simplify then return null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,simpl,simplified,11,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,['simpl'],"['simplified', 'simplify']"
Usability,"// If this 'and' clears the sign-bits added by ashr, replace with lshr:; // and (ashr X, ShiftC), C --> lshr X, ShiftC",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:17,clear,clears,17,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['clear'],['clears']
Usability,"// If this GUID doesn't have a value id, it doesn't have a function; // summary and we don't need to record any calls to it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:11,GUID,GUID,11,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,1,['GUID'],['GUID']
Usability,"// If this a VZEXT_MOVL of a VBROADCAST_LOAD, we don't need the broadcast; // and can just use a VZEXT_LOAD.; // FIXME: Is there some way to do this with SimplifyDemandedVectorElts?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:154,Simpl,SimplifyDemandedVectorElts,154,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['SimplifyDemandedVectorElts']
Usability,"// If this already evenly divisible, we can create a simple unmerge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:53,simpl,simple,53,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,1,['simpl'],['simple']
Usability,"// If this block is 'Cleared', then nothing LiveIn to this block can be; // available after this block completes. Note: This turns out to be; // really important for reducing memory consuption of the initial available; // sets and thus peak memory usage by this verifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:21,Clear,Cleared,21,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['Clear'],['Cleared']
Usability,"// If this block is not done, it makes little sense to make any decisions; // based on clearance information. We need to make a second pass anyway,; // and by then we'll have better information, so we can avoid doing the work; // to try and break dependencies now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:87,clear,clearance,87,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,2,['clear'],['clearance']
Usability,"// If this case is the last edge into the exit block, we can simply reuse it; // as it will no longer be a loop exit. No mapping necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:61,simpl,simply,61,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['simpl'],['simply']
Usability,"// If this cleared the root, switch to height=0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:11,clear,cleared,11,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,1,['clear'],['cleared']
Usability,"// If this code is reachable then emit a stop point (if generating; // debug info). We have to do this ourselves because we are on the; // ""simple"" statement path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:140,simpl,simple,140,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,4,['simpl'],['simple']
Usability,"// If this fails, either the callee has lost track of some allocation,; // or the callee isn't tracking allocations and should just call; // clear() before deleting the Recycler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Recycler.h:141,clear,clear,141,interpreter/llvm-project/llvm/include/llvm/Support/Recycler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Recycler.h,1,['clear'],['clear']
Usability,"// If this happens, we want to determine a sensible culprit of this.; // Intuitively, watching the chain of member expressions from right to; // left, we start with the required alignment (as required by the field; // type) but some packed attribute in that chain has reduced the alignment.; // It may happen that another packed structure increases it again. But if; // we are here such increase has not been enough. So pointing the first; // FieldDecl that either is packed or else its RecordDecl is,; // seems reasonable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:73,Intuit,Intuitively,73,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['Intuit'],['Intuitively']
Usability,"// If this identifier isn't 'defined' or one of the special; // preprocessor keywords and it wasn't macro expanded, it turns; // into a simple 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:136,simpl,simple,136,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,1,['simpl'],['simple']
Usability,"// If this instruction can be simplified after the operands are updated,; // just use the simplified value instead. This frequently happens due to; // phi translation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:30,simpl,simplified,30,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,2,['simpl'],['simplified']
Usability,"// If this instruction follows any data, there is no clear; // instruction boundary, inserting a nop/prefix would change semantic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:53,clear,clear,53,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,1,['clear'],['clear']
Usability,"// If this is ((X << C1) >>u ShAmt), see if we can simplify this into a; // single shift. We can do this if the top bits (which are shifted out); // are never demanded.; // TODO - support non-uniform vector amounts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:51,simpl,simplify,51,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['simpl'],['simplify']
Usability,"// If this is ((X << C1) >>u ShAmt), see if we can simplify this into a; // single shift. We can do this if the top bits (which are shifted; // out) are never demanded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:51,simpl,simplify,51,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplify']
Usability,"// If this is ((X >>u C1) << ShAmt), see if we can simplify this into a; // single shift. We can do this if the bottom bits (which are shifted; // out) are never demanded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:51,simpl,simplify,51,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['simpl'],['simplify']
Usability,"// If this is ((X >>u C1) << ShAmt), see if we can simplify this into a; // single shift. We can do this if the bottom bits (which are shifted; // out) are never demanded.; // TODO - support non-uniform vector amounts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:51,simpl,simplify,51,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['simpl'],['simplify']
Usability,"// If this is (add $FI, $S16Imm), the alignment flags are already set; // based on the immediate. We just need to clear the alignment flags; // if the FI alignment is weaker.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:114,clear,clear,114,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['clear'],['clear']
Usability,"// If this is a ""cmp"" instruction, only used for branching (and nowhere; // else), then we can simply invert the predicate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:95,simpl,simply,95,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,1,['simpl'],['simply']
Usability,"// If this is a chain of recurrences, turn it into a closed form, using the; // folders, then expandCodeFor the closed form. This allows the folders to; // simplify the expression without having to build a bunch of special code; // into this folder.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:156,simpl,simplify,156,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['simpl'],['simplify']
Usability,"// If this is a defaulted or implicitly-declared function, then; // it was implicitly deleted. Make it clear that the deletion was; // implicit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:103,clear,clear,103,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['clear'],['clear']
Usability,"// If this is a direct recursion, simply skip the duplicate; // entries, to be consistent with how the summary ids were; // generated during ModuleSummaryAnalysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:34,simpl,simply,34,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['simpl'],['simply']
Usability,"// If this is a direct recursion, simply skip the duplicate; // entries. If this is mutual recursion, handling is left to; // the LTO link analysis client.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:34,simpl,simply,34,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,1,['simpl'],['simply']
Usability,"// If this is a funcref call, to avoid hidden GC roots, we need to clear the; // table slot with ref.null upon call_indirect return.; //; // This generates the following code, which comes right after a call_indirect; // of a funcref:; //; // i32.const 0; // ref.null func; // table.set __funcref_call_table",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:67,clear,clear,67,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,1,['clear'],['clear']
Usability,"// If this is a logical 'and' with a mask that clears bits, recurse then; // unset the appropriate bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:47,clear,clears,47,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['clear'],['clears']
Usability,"// If this is a really simple expression (like x ? 4 : 5), emit this as a; // select instead of as control flow. We can only do this if it is cheap and; // safe to evaluate the LHS and RHS unconditionally.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:23,simpl,simple,23,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['simpl'],['simple']
Usability,"// If this is a really simple value, emit this with the Value* version; // of X86FastEmitStore. If it isn't simple, we don't want to do this,; // as it can cause us to reevaluate the argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:23,simpl,simple,23,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,2,['simpl'],['simple']
Usability,"// If this is a scalar to vector to v1i1 from an AND with 1, bypass the and.; // This occurs frequently in our masked scalar intrinsic code and our; // floating point select lowering with AVX512.; // TODO: SimplifyDemandedBits instead?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:206,Simpl,SimplifyDemandedBits,206,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,"// If this is a simple instruction that we can value number, process it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:16,simpl,simple,16,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['simpl'],['simple']
Usability,"// If this is a simple integer displacement that doesn't require a; // relocation, emit it now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp:16,simpl,simple,16,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp,1,['simpl'],['simple']
Usability,"// If this is a simple intrinsic (that is, we just need to add a def of; // a vreg, and uses for each arg operand, then translate it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:16,simpl,simple,16,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,1,['simpl'],['simple']
Usability,"// If this is a simple name there is a chance to find it in the; // StreamerInfo even if we did not find it in the RealData.; // For example an array name would be fArray[3] in RealData but; // just fArray in the streamerInfo.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:16,simpl,simple,16,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['simpl'],['simple']
Usability,"// If this is a simple operand, or a complex operand with a custom match; // class, then we can match is verbatim.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenInstAlias.cpp:16,simpl,simple,16,interpreter/llvm-project/llvm/utils/TableGen/CodeGenInstAlias.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenInstAlias.cpp,1,['simpl'],['simple']
Usability,"// If this is a simple string that doesn't need escaping, just append it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Mangler.cpp:16,simpl,simple,16,interpreter/llvm-project/llvm/lib/IR/Mangler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Mangler.cpp,1,['simpl'],['simple']
Usability,"// If this is a simple type, use the ComputeRegisterProp mechanism.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:16,simpl,simple,16,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['simpl'],['simple']
Usability,"// If this is a splat fed by a swap, we can simplify modify; // the splat to splat the other value from the swap's input; // parameter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:44,simpl,simplify,44,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['simpl'],['simplify']
Usability,"// If this is a stack pointer and the offset needs to be simplified then put; // the alloca address into a register, set the base type back to register and; // continue. This should almost never happen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:57,simpl,simplified,57,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,1,['simpl'],['simplified']
Usability,"// If this is a stack pointer and the offset needs to be simplified then; // put the alloca address into a register, set the base type back to; // register and continue. This should almost never happen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:57,simpl,simplified,57,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,2,['simpl'],['simplified']
Usability,"// If this is a store of a simple constant, fold the constant into the store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:27,simpl,simple,27,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,1,['simpl'],['simple']
Usability,"// If this is a top function that we have already processed, do not; // update its profile again. This happens in the presence of; // function aliases. Since these aliases share the same function; // body, there will be identical replicated profiles for the; // original function. In this case, we simply not bother updating; // the profile of the original function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp:298,simpl,simply,298,interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,1,['simpl'],['simply']
Usability,"// If this is a trivial cleanup pad that executes no instructions, it can be; // eliminated. If the cleanup pad continues to the caller, any predecessor; // that is an EH pad will be updated to continue to the caller and any; // predecessor that terminates with an invoke instruction will have its invoke; // instruction converted to a call instruction. If the cleanup pad being; // simplified does not continue to the caller, each predecessor will be; // updated to continue to the unwind destination of the cleanup pad being; // simplified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:383,simpl,simplified,383,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,2,['simpl'],['simplified']
Usability,"// If this is a very simple BUILD_VECTOR with first element being a ZERO_EXTEND,; // and all other elements being constant zero's, granularize the BUILD_VECTOR's; // element width, absorbing the ZERO_EXTEND, turning it into a constant zero op.; // This patten can appear during legalization.; //; // NOTE: This can be generalized to allow more than a single; // non-constant-zero op, UNDEF's, and to be KnownBits-based,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,simpl,simple,21,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simple']
Usability,"// If this is an all-zero array, return a ConstantAggregateZero object. If; // all undef, return an UndefValue, if ""all simple"", then return a; // ConstantDataArray.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:120,simpl,simple,120,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp,1,['simpl'],['simple']
Usability,"// If this is an insert of an extracted vector into an undef vector, we can; // just use the input to the extract if the types match, and can simplify; // in some cases even if they don't.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:142,simpl,simplify,142,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simplify']
Usability,"// If this is an insertion of 32-bits into the low 32-bits of; // a vector, we prefer to generate a blend with immediate rather; // than an insertps. Blends are simpler operations in hardware and so; // will always have equal or better performance than insertps.; // But if optimizing for size and there's a load folding opportunity,; // generate insertps because blendps does not have a 32-bit memory; // operand form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:161,simpl,simpler,161,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simpler']
Usability,"// If this is an otherwise-unfoldable branch on a XOR, see if we can simplify.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:69,simpl,simplify,69,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['simpl'],['simplify']
Usability,"// If this is an otherwise-unfoldable branch on a phi node or freeze(phi) in; // the current block, see if we can simplify.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:114,simpl,simplify,114,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['simpl'],['simplify']
Usability,"// If this is checking if all elements of a vector compare are set or not,; // invert the casted vector equality compare and test if all compare; // elements are clear or not. Compare against zero is generally easier for; // analysis and codegen.; // icmp eq/ne (bitcast (not X) to iN), -1 --> icmp eq/ne (bitcast X to iN), 0; // Example: are all elements equal? --> are zero elements not equal?; // TODO: Try harder to reduce compare of 2 freely invertible operands?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:162,clear,clear,162,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['clear'],['clear']
Usability,"// If this is checking if all elements of an extended vector are clear or not,; // compare in a narrow type to eliminate the extend:; // icmp eq/ne (bitcast (ext X) to iN), 0 --> icmp eq/ne (bitcast X to iM), 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:65,clear,clear,65,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['clear'],['clear']
Usability,"// If this is dependent, we need to record that. If not, we simply; // mangle it as the underlying type since they are equivalent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:60,simpl,simply,60,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['simpl'],['simply']
Usability,"// If this is syntactically a simple assignment using a trivial; // assignment operator, start the lifetimes of union members as needed,; // per C++20 [class.union]5.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:30,simpl,simple,30,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['simpl'],['simple']
Usability,"// If this is the GNU "", ## __VA_ARGS__"" extension, and we just learned; // that __VA_ARGS__ expands to multiple tokens, avoid a pasting error when; // the expander tries to paste ',' with the first token of the __VA_ARGS__; // expansion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:64,learn,learned,64,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['learn'],['learned']
Usability,"// If this is the root being simplified, allow it to have multiple uses,; // just set the DemandedMask to all bits so that we can try to simplify the; // operands. This allows visitTruncInst (for example) to simplify the; // operand of a trunc without duplicating all the logic below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:29,simpl,simplified,29,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,3,['simpl'],"['simplified', 'simplify']"
Usability,"// If this is the top level that represents the concrete function,; // there will be no name and we shoud clear the inline stack. Otherwise; // we have found an inline call stack that we need to insert.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/InlineInfo.cpp:106,clear,clear,106,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/InlineInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/InlineInfo.cpp,1,['clear'],['clear']
Usability,"// If this is true, the PDB contents are hashed and this hash is used as; // PDB GUID and as Signature. The age is always 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/InfoStreamBuilder.h:81,GUID,GUID,81,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/InfoStreamBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/InfoStreamBuilder.h,1,['GUID'],['GUID']
Usability,"// If this is: (X >> C3) & C2 != C1 (where any shift and any compare could; // exist), turn it into (X & (C2 << C3)) != (C1 << C3). This happens a LOT in; // code produced by the clang front-end, for bitfield access.; // This seemingly simple opportunity to fold away a shift turns out to be; // rather complicated. See PR17827 for details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:236,simpl,simple,236,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['simpl'],['simple']
Usability,"// If this isn't a bundled call, and the target doesn't need a special; // inline-asm marker, we're done: return now, and undo objc-arc-expand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:122,undo,undo,122,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,1,['undo'],['undo']
Usability,"// If this logic op has not been simplified yet, just bail out and let that; // happen first. Otherwise, the code below may wrongly invert.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:33,simpl,simplified,33,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['simpl'],['simplified']
Usability,// If this lookup was resumed after auto-suspension but all candidates; // have already been generated (by some previous call to the generator); // treat the lookup as if it had completed generation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:22,resume,resumed,22,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['resume'],['resumed']
Usability,"// If this loop has multiple exits and the exits all go to the same; // block, attempt to merge the exits. This helps several passes, such; // as LoopRotation, which do not support loops with multiple exits.; // SimplifyCFG also does this (and this code uses the same utility; // function), however this code is loop-aware, where SimplifyCFG is; // not. That gives it the advantage of being able to hoist; // loop-invariant instructions out of the way to open up more; // opportunities, and the disadvantage of having the responsibility; // to preserve dominator information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:212,Simpl,SimplifyCFG,212,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,2,['Simpl'],['SimplifyCFG']
Usability,"// If this memory access can be shown to *statically* extend outside the; // bounds of the allocation, it's behavior is undefined, so simply; // ignore it. Note that this is more strict than the generic clamping; // behavior of insertUse. We also try to handle cases which might run the; // risk of overflow.; // FIXME: We should instead consider the pointer to have escaped if this; // function is being instrumented for addressing bugs or race conditions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:134,simpl,simply,134,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['simpl'],['simply']
Usability,"// If this proxy or the loop info is going to be invalidated, we also need; // to clear all the keys coming from that analysis. We also completely blow; // away the loop analyses if any of the standard analyses provided by the; // loop pass manager go away so that loop analyses can freely use these; // without worrying about declaring dependencies on them etc.; // FIXME: It isn't clear if this is the right tradeoff. We could instead make; // loop analyses declare any dependencies on these and use the more general; // invalidation logic below to act on that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:82,clear,clear,82,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,2,['clear'],['clear']
Usability,"// If this simple subvector or scalar/subvector broadcast_load is inserted; // into both halves, use a larger broadcast_load. Update other uses to use; // an extracted subvector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:11,simpl,simple,11,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simple']
Usability,"// If this value is a nonnull pointer, record it's range and bailout. Note; // that for all other pointer typed values, we terminate the search at the; // definition. We could easily extend this to look through geps, bitcasts,; // and the like to prove non-nullness, but it's not clear that's worth it; // compile time wise. The context-insensitive value walk done inside; // isKnownNonZero gets most of the profitable cases at much less expense.; // This does mean that we have a sensitivity to where the defining; // instruction is placed, even if it could legally be hoisted much higher.; // That is unfortunate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:280,clear,clear,280,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['clear'],['clear']
Usability,"// If this variable might have a constant initializer or might be usable in; // constant expressions, check whether or not it actually is now. We can't; // do this lazily, because the result might depend on things that change; // later, such as which constexpr functions happen to be defined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:66,usab,usable,66,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['usab'],['usable']
Usability,"// If this was a flag setting version of the instruction, we use the original; // instruction by just clearing the dead marked on the implicit-def of NCZV.; // Therefore, we should not erase this instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CondBrTuning.cpp:102,clear,clearing,102,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CondBrTuning.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CondBrTuning.cpp,1,['clear'],['clearing']
Usability,"// If truncating the setcc operands is not desirable, we can still; // simplify the expression in some cases:; // setcc ([sz]ext (setcc x, y, cc)), 0, setne) -> setcc (x, y, cc); // setcc ([sz]ext (setcc x, y, cc)), 0, seteq) -> setcc (x, y, inv(cc)); // setcc (zext (setcc x, y, cc)), 1, setne) -> setcc (x, y, inv(cc)); // setcc (zext (setcc x, y, cc)), 1, seteq) -> setcc (x, y, cc); // setcc (sext (setcc x, y, cc)), -1, setne) -> setcc (x, y, inv(cc)); // setcc (sext (setcc x, y, cc)), -1, seteq) -> setcc (x, y, cc)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:71,simpl,simplify,71,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['simpl'],['simplify']
Usability,"// If upgrading the SSP attribute, clear out the old SSP Attributes first.; // Having multiple SSP attributes doesn't actually hurt, but it adds useless; // clutter to the IR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp:35,clear,clear,35,interpreter/llvm-project/llvm/lib/IR/Attributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp,1,['clear'],['clear']
Usability,// If upper demanded elements are not demanded then simplify to a; // scalar_to_vector(load()).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:52,simpl,simplify,52,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplify']
Usability,"// If value numbering later sees that an instruction in the scope is equal; // to 'LHS' then ensure it will be turned into 'RHS'. In order to preserve; // the invariant that instructions only occur in the leader table for their; // own value number (this is used by removeFromLeaderTable), do not do this; // if RHS is an instruction (if an instruction in the scope is morphed into; // LHS then it will be turned into RHS by the next GVN iteration anyway, so; // using the leader table is about compiling faster, not optimizing better).; // The leader table only tracks basic blocks, not edges. Only add to if we; // have the simple case where the edge dominates the end.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:626,simpl,simple,626,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['simpl'],['simple']
Usability,"// If we are a multi-level pointer, it's possible that our issue is simply; // one of qualification - e.g. char ** -> const char ** is not allowed. If; // the eventual target type is the same and the pointers have the same; // level of indirection, this must be the issue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:68,simpl,simply,68,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['simpl'],['simply']
Usability,"// If we are clearing the sign bit of a floating-point value, convert this to; // fabs, then cast back to integer.; //; // This is a generous interpretation for noimplicitfloat, this is not a true; // floating-point operation.; //; // Assumes any IEEE-represented type has the sign bit in the high bit.; // TODO: Unify with APInt matcher. This version allows undef unlike m_APInt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:13,clear,clearing,13,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['clear'],['clearing']
Usability,"// If we are done linking global value bodies (i.e. we are performing; // metadata linking), don't link in the global value due to this; // reference, simply map it to null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:151,simpl,simply,151,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,1,['simpl'],['simply']
Usability,"// If we are here, we know that the value is none of those cases listed in; // PredCases. If there are any cases in ThisCases that are in PredCases, we; // can simplify TI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:160,simpl,simplify,160,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['simpl'],['simplify']
Usability,"// If we are in a cancellable parallel region, barriers are cancellation; // points.; // TODO: Check why we would force simple calls or to ignore the cancel flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:120,simpl,simple,120,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['simpl'],['simple']
Usability,"// If we are only simplifying targeted instructions and the user is an; // instruction in the loop body, add it to our set of targeted; // instructions. Because we process defs before uses (outside of PHIs); // we won't have visited it yet.; //; // We also skip any uses outside of the loop being simplified. Those; // should always be PHI nodes due to LCSSA form, and we don't want to; // try to simplify those away.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:18,simpl,simplifying,18,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,3,['simpl'],"['simplified', 'simplify', 'simplifying']"
Usability,"// If we are planning to perform ThinLTO later, we don't bloat the code with; // unrolling/vectorization/... now. Just simplify the module as much as we; // can.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:119,simpl,simplify,119,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['simpl'],['simplify']
Usability,"// If we are positive, we need to increment the significand.; // We only cross a binade boundary that requires adjusting the exponent if; // the input is not a denormal and all of said input's significand bits; // are set. If all of said conditions are true: clear the significand, set; // the integral bit to 1, and increment the exponent. If we have a; // denormal always increment since moving denormals and the numbers in the; // smallest normal binade have the same exponent in our representation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:259,clear,clear,259,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['clear'],['clear']
Usability,"// If we are rebuilding the map, clear out any existing state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ParentMap.cpp:33,clear,clear,33,interpreter/llvm-project/clang/lib/AST/ParentMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ParentMap.cpp,1,['clear'],['clear']
Usability,"// If we are selecting between only two cases transform into a simple; // select or a two-way select if default is possible.; // Example:; // switch (a) { %0 = icmp eq i32 %a, 10; // case 10: return 42; %1 = select i1 %0, i32 42, i32 4; // case 20: return 2; ----> %2 = icmp eq i32 %a, 20; // default: return 4; %3 = select i1 %2, i32 2, i32 %1; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:63,simpl,simple,63,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['simpl'],['simple']
Usability,"// If we are skipping the region of a non conditional, remove the exit; // block, and clear the builder's insertion point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:86,clear,clear,86,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['clear'],['clear']
Usability,"// If we are subtracting a low-bit masked subset of some value from an add; // of that same value with no low bits changed, that is clearing some low bits; // of the sum:; // sub (X + AddC), (X & AndC) --> and (X + AddC), ~AndC",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:132,clear,clearing,132,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['clear'],['clearing']
Usability,"// If we are testing for all-bits-clear, we might be able to do that with; // less shifting since bit-order does not matter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:34,clear,clear,34,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['clear'],['clear']
Usability,"// If we break the token inside a parameter list, we need to break before; // the next parameter on all levels, so that the next parameter is clearly; // visible. Line comments already introduce a break.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:142,clear,clearly,142,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['clear'],['clearly']
Usability,"// If we can represent this as a simple value, we have to build the actual; // value to store, which requires expanding the byte present in memset to; // a sensible representation for the alloca type. This is essentially; // splatting the byte to a sufficiently wide integer, splatting it across; // any desired vector width, and bitcasting to the final type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:33,simpl,simple,33,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['simpl'],['simple']
Usability,"// If we can simplify this instruction to some other value, simply add; // a mapping to that value rather than inserting a new instruction into; // the basic block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:13,simpl,simplify,13,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,2,['simpl'],"['simplify', 'simply']"
Usability,"// If we can't get a second FP type, return a simple half or float.; // avx512fp16-abi.c:pr51813_2 shows it works to return float for; // {float, i8} too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:46,simpl,simple,46,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['simpl'],['simple']
Usability,"// If we can't walk the GEP, clear the offset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:29,clear,clear,29,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,1,['clear'],['clear']
Usability,"// If we can, encode the offset directly into the instruction. If this is a; // normal PPC ""ri"" instruction, any 16-bit value can be safely encoded. If; // this is a PPC64 ""ix"" instruction, only a 16-bit value with the low two bits; // clear can be encoded. This is extremely uncommon, because normally you; // only ""std"" to a stack slot that is at least 4-byte aligned, but it can; // happen in invalid code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:236,clear,clear,236,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,1,['clear'],['clear']
Usability,"// If we could not find a frame destroy opcode, then it has already; // been simplified, so we don't care.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:77,simpl,simplified,77,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['simpl'],['simplified']
Usability,"// If we couldn't simplify, we may have to create a phi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:18,simpl,simplify,18,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['simpl'],['simplify']
Usability,"// If we decided not to elide the constructor, proceed as if; // it's a simple temporary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:72,simpl,simple,72,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,1,['simpl'],['simple']
Usability,// If we demand no bits from the vector then we must have demanded; // bits from the implict zext - simplify to zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:100,simpl,simplify,100,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplify']
Usability,"// If we did not find the correct this-region, it would be pointless; // to inline the constructor. Instead we will simply invalidate; // the fake temporary target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:116,simpl,simply,116,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,1,['simpl'],['simply']
Usability,"// If we did not find the correct this-region, it would be pointless; // to inline the destructor. Instead we will simply invalidate; // the fake temporary target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:115,simpl,simply,115,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,1,['simpl'],['simply']
Usability,"// If we don't actually need a state machine we are done here. This can; // happen if there simply are no parallel regions. In the resulting kernel; // all worker threads will simply exit right away, leaving the main thread; // to do the work alone.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:92,simpl,simply,92,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,2,['simpl'],['simply']
Usability,"// If we don't demand all elements, then attempt to combine to a simpler; // shuffle.; // We need to convert the depth to something combineX86ShufflesRecursively; // can handle - so pretend its Depth == 0 again, and reduce the max depth; // to match. This prevents combineX86ShuffleChain from returning a; // combined shuffle that's the same as the original root, causing an; // infinite loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:65,simpl,simpler,65,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simpler']
Usability,"// If we don't have a PtrInfo, infer the trivial frame index case to simplify; // clients.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:69,simpl,simplify,69,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,3,['simpl'],['simplify']
Usability,"// If we don't have a valid method decl, simply return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:41,simpl,simply,41,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['simpl'],['simply']
Usability,"// If we don't have red zones, we need to compute the expected return; // address prior to the call and store it in a register that lives across; // the call.; //; // In some ways, this is doubly satisfying as a mitigation because it will; // also successfully detect stack smashing bugs in some cases (typically,; // when a callee-saved register is used and the callee doesn't push it onto; // the stack). But that isn't our primary goal, so we only use it as; // a fallback.; //; // FIXME: It isn't clear that this is reliable in the face of; // rematerialization in the register allocator. We somehow need to force; // that to not occur for this particular instruction, and instead to spill; // or otherwise preserve the value computed *prior* to the call.; //; // FIXME: It is even less clear why MachineCSE can't just fold this when we; // end up having to use identical instructions both before and after the; // call to feed the comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:501,clear,clear,501,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,2,['clear'],['clear']
Usability,"// If we don't need to suppress any of the nodes because they are; // post-dominated by a sink, simply add all the nodes in the equivalence class; // to 'Nodes'. Any of the reports will serve as a ""representative"" report.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:96,simpl,simply,96,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['simpl'],['simply']
Usability,"// If we don't use the flag result, simplify back to a generic ADD/SUB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,simpl,simplify,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplify']
Usability,"// If we find a cast instruction here, it means we've found a cast which is; // not simply a pointer cast (i.e. an inttoptr). We don't know how to; // handle int->ptr conversion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:84,simpl,simply,84,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['simpl'],['simply']
Usability,"// If we folded the first phi, PN dangles at this point. Refresh it. If; // we ran out of PHIs then we simplified them all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:103,simpl,simplified,103,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['simpl'],['simplified']
Usability,"// If we found a non-repeated factor, we still need to get its square; // root. We then multiply that by the value that was simplified out; // of the square root calculation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:124,simpl,simplified,124,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['simpl'],['simplified']
Usability,"// If we found the mapping from the extracted function to the overall; // function, we simply add it to the argument list. We use the same; // value, it just needs to honor the new order of arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:87,simpl,simply,87,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,1,['simpl'],['simply']
Usability,"// If we get this far, we've committed to the tuple interpretation, but; // we can still fail if there actually isn't a usable ::value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:120,usab,usable,120,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['usab'],['usable']
Usability,"// If we got a constantexpr back, try to simplify it with DL info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:41,simpl,simplify,41,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,1,['simpl'],['simplify']
Usability,"// If we got a simplified select_cc node back from SimplifySelectCC, then; // break it down into a new SETCC node, and a new SELECT node, and then return; // the SELECT node, since we were called with a SELECT node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:15,simpl,simplified,15,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,"['Simpl', 'simpl']","['SimplifySelectCC', 'simplified']"
Usability,"// If we had a token, we need a path; empty means to undo a redirect",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/MetaProcessor/MetaParser.cpp:53,undo,undo,53,interpreter/cling/lib/MetaProcessor/MetaParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/MetaProcessor/MetaParser.cpp,1,['undo'],['undo']
Usability,"// If we have ""0 || X"", simplify the code. ""1 || X"" would have constant; // folded if the case was simple enough.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:24,simpl,simplify,24,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,2,['simpl'],"['simple', 'simplify']"
Usability,"// If we have ""1 && X"", simplify the code. ""0 && X"" would have constant; // folded if the case was simple enough.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:24,simpl,simplify,24,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,2,['simpl'],"['simple', 'simplify']"
Usability,"// If we have ""X && 1"", simplify the code to use an uncond branch.; // ""X && 0"" would have been constant folded to 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:24,simpl,simplify,24,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['simpl'],['simplify']
Usability,"// If we have ""X || 0"", simplify the code to use an uncond branch.; // ""X || 1"" would have been constant folded to 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:24,simpl,simplify,24,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['simpl'],['simplify']
Usability,"// If we have a VST forward declaration record, but have already; // parsed the VST (just above, when the first function body was; // encountered here), then we are resuming the parse after; // materializing functions. The ResumeBit points to the; // start of the last function block recorded in the; // DeferredFunctionInfo map. Skip it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:223,Resume,ResumeBit,223,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['Resume'],['ResumeBit']
Usability,"// If we have a bitconvert with a resolved type and if the source and; // destination types are the same, then the bitconvert is useless, remove it.; //; // We make an exception if the types are completely empty. This can come up; // when the pattern being simplified is in the Fragments list of a PatFrags,; // so that the operand is just an untyped ""node"". In that situation we leave; // bitconverts unsimplified, and simplify them later once the fragment is; // expanded into its true context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:257,simpl,simplified,257,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,2,['simpl'],"['simplified', 'simplify']"
Usability,"// If we have a native target, initialize it to ensure it is linked in and; // usable by the JIT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:79,usab,usable,79,interpreter/llvm-project/llvm/tools/lli/lli.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp,2,['usab'],['usable']
Usability,"// If we have a prior definition that is not visible, treat this as; // simply making that previous definition visible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:72,simpl,simply,72,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['simpl'],['simply']
Usability,"// If we have a scalar equality comparison, then we know the value in one of; // the arms of the select. See if substituting this value into the arm and; // simplifying the result yields the same value as the other arm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:157,simpl,simplifying,157,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifying']
Usability,"// If we have a simple case, just return now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:16,simpl,simple,16,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['simpl'],['simple']
Usability,// If we have a srl that only generates signbits that we will discard in; // the truncation then we can use PACKSS by converting the srl to a sra.; // SimplifyDemandedBits often relaxes sra to srl so we need to reverse it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:151,Simpl,SimplifyDemandedBits,151,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,"// If we have a type expressed as a template-id, this cannot be a; // declarator-id (such a type cannot be redeclared in a simple-declaration).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:123,simpl,simple-declaration,123,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['simpl'],['simple-declaration']
Usability,"// If we have a type, we implicitly emit a G_CONSTANT, except for G_CONSTANT; // itself where we emit a CImm.; //; // No type means we emit a simple imm.; // G_CONSTANT is a special case and needs a CImm though so this is likely a; // mistake.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp:142,simpl,simple,142,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,1,['simpl'],['simple']
Usability,"// If we have a vector form, just clear it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h:34,clear,clear,34,interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h,1,['clear'],['clear']
Usability,"// If we have a xor as the branch input to this block, and we know that the; // LHS or RHS of the xor in any predecessor is true/false, then we can clone; // the condition into the predecessor and fix that value to true, saving some; // logical ops on that path and encouraging other paths to simplify.; //; // This copies something like this:; //; // BB:; // %X = phi i1 [1], [%X']; // %Y = icmp eq i32 %A, %B; // %Z = xor i1 %X, %Y; // br i1 %Z, ...; //; // Into:; // BB':; // %Y = icmp ne i32 %A, %B; // br i1 %Y, ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:293,simpl,simplify,293,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['simpl'],['simplify']
Usability,"// If we have an explicit value to collapse to, do that round of the; // simplification loop by hand initially.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:73,simpl,simplification,73,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplification']
Usability,"// If we have and (icmp ne a, b), x and for a==b we can simplify x to false,; // then we can drop the icmp, as x will already be false in the case where; // the icmp is false. Similar for or and true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,simpl,simplify,56,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplify']
Usability,"// If we have fptrunc(OpI (fpextend x), (fpextend y)), we would like to; // simplify this expression to avoid one or more of the trunc/extend; // operations if we can do so without changing the numerical results.; //; // The exact manner in which the widths of the operands interact to limit; // what we can and cannot do safely varies from operation to operation, and; // is explained below in the various case statements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:76,simpl,simplify,76,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['simpl'],['simplify']
Usability,"// If we have init expression, it might be simply a reference; // to a variable, so we can use it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:43,simpl,simply,43,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,1,['simpl'],['simply']
Usability,"// If we have only a symbol than there's no need for complex rewrite,; // simply skip everything after it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:74,simpl,simply,74,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,1,['simpl'],['simply']
Usability,"// If we have plugins after the main consumer, which may be the codegen; // action, they likely will need the ASTContext, so don't clear it in the; // codegen action.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:131,clear,clear,131,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,1,['clear'],['clear']
Usability,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:611,simpl,simplified,611,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,1,['simpl'],['simplified']
Usability,"// If we haven't overrun the buffer yet, we can continue.; // Set the branch weights based on the simplifying assumption that this is; // like a while-loop, i.e., ignoring that the false branch fetches more; // elements and then returns to the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:98,simpl,simplifying,98,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['simpl'],['simplifying']
Usability,"// If we instantiated a definition, check that it's usable, even if; // instantiation produced an error, so that repeated calls to this; // function give consistent answers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:52,usab,usable,52,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['usab'],['usable']
Usability,"// If we know that all of the high bits of the shift amount are zero, then we; // can do this as a couple of simple shifts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:109,simpl,simple,109,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['simpl'],['simple']
Usability,"// If we know that any of the high bits of the shift amount are one, then we; // can do this as a couple of simple shifts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:108,simpl,simple,108,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['simpl'],['simple']
Usability,"// If we know we've failed in parsing, simply eat until end of the; // statement. This ensures that we don't process any other statements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:39,simpl,simply,39,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,1,['simpl'],['simply']
Usability,"// If we looked through casts, we can only handle a constant simplification; // because we are not allowed to create a cast instruction here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:61,simpl,simplification,61,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplification']
Usability,"// If we need to zero extend the backedge count, check if we can add one to; // it prior to zero extending without overflow. Provided this is safe, it; // allows better simplification of the +1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:169,simpl,simplification,169,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['simpl'],['simplification']
Usability,"// If we never found a PHI that needs to be simplified in the next; // iteration, we're done.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:44,simpl,simplified,44,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,1,['simpl'],['simplified']
Usability,"// If we only demand the element that is being inserted and that element; // was extracted from the same index in another vector with the same type,; // replace this insert with that other vector.; // Note: This is attempted before the call to simplifyAndSetOp because that; // may change PoisonElts to a value that does not match with Vec.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:244,simpl,simplifyAndSetOp,244,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['simpl'],['simplifyAndSetOp']
Usability,"// If we only have one non-empty code section, we can use the simpler; // AT_low_pc and AT_high_pc attributes.; // Find the first (and only) non-empty text section",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:62,simpl,simpler,62,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,1,['simpl'],['simpler']
Usability,"// If we optimize for code size, try to move the call to free before the null; // test so that simplify cfg can remove the empty block and dead code; // elimination the branch. I.e., helps to turn something like:; // if (foo) free(foo);; // into; // free(foo);; //; // Note that we can only do this for 'free' and not for any flavor of; // 'operator delete'; there is no 'operator delete' symbol for which we are; // permitted to invent a call, even if we're passing in a null pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:95,simpl,simplify,95,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplify']
Usability,"// If we own the allocator, simply reset it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:28,simpl,simply,28,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,1,['simpl'],['simply']
Usability,"// If we reach this point, the expression cannot be simplified.; // Make a SymbolVal for the entire expression, after converting the RHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:52,simpl,simplified,52,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,1,['simpl'],['simplified']
Usability,"// If we remove the template<> and the name is not a; // template-id, we're actually silently creating a problem:; // the friend declaration will refer to an untemplated decl,; // and clearly the user wants a template specialization. So; // we need to insert '<>' after the name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:184,clear,clearly,184,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['clear'],['clearly']
Usability,"// If we see an opening parentheses at this point, we are; // actually parsing an expression that starts with a; // function-style cast, e.g.,; //; // postfix-expression:; // simple-type-specifier ( expression-list [opt] ); // typename-specifier ( expression-list [opt] ); //; // Parse the remainder of this case, then the (optional); // postfix-expression suffix, followed by the (optional); // right-hand side of the binary expression. We have an; // instance method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:175,simpl,simple-type-specifier,175,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['simpl'],['simple-type-specifier']
Usability,"// If we see an unconditional branch, reset our state, clear any; // fallthrough, and set this is the ""else"" successor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:55,clear,clear,55,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['clear'],['clear']
Usability,"// If we see bad encoding for unprefixed character literals, warn and; // simply copy the byte values, for compatibility with gcc and; // older versions of clang.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:74,simpl,simply,74,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,1,['simpl'],['simply']
Usability,"// If we see bad encoding for unprefixed string literals, warn and; // simply copy the byte values, for compatibility with gcc and older; // versions of clang.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:71,simpl,simply,71,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,1,['simpl'],['simply']
Usability,"// If we see two releases in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second release, which may allow us to; // eliminate the first release too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:370,simpl,simple,370,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,1,['simpl'],['simple']
Usability,"// If we see two retains in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second retain, which may allow us to; // eliminate the first retain too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:367,simpl,simple,367,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,1,['simpl'],['simple']
Usability,"// If we selected just the header for the loop top, look for a potentially; // profitable exit block in the event that rotating the loop can eliminate; // branches by placing an exit edge at the bottom.; //; // Loops are processed innermost to uttermost, make sure we clear; // PreferredLoopExit before processing a new loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:268,clear,clear,268,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['clear'],['clear']
Usability,"// If we simplified the operands, the LHS is no longer an input, but Res; // is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:9,simpl,simplified,9,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,1,['simpl'],['simplified']
Usability,"// If we still couldn't find a reasonable default alignment, fall back; // to a simple heuristic that the alignment is the first power of two; // greater-or-equal to the store size of the type. This is a reasonable; // approximation of reality, and if the user wanted something less; // less conservative, they should have specified it explicitly in the data; // layout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:80,simpl,simple,80,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,1,['simpl'],['simple']
Usability,"// If we succeed, copy S's RRInfo into the Release -> {Retain Set; // Map}. Then we clear S.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:84,clear,clear,84,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['clear'],['clear']
Usability,"// If we were in the middle of a block we stop processing that block.; //; // NOTE: If a ""return"" or ""co_return"" appears in the middle of a block, this; // means that the code afterwards is DEAD (unreachable). We still keep; // a basic block for that code; a simple ""mark-and-sweep"" from the entry; // block will be able to report such dead blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:259,simpl,simple,259,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['simpl'],['simple']
Usability,"// If we would have cleared the state foregoing the fact that we are known; // safe, stop code motion. This is because whether or not it is safe to; // remove RR pairs via KnownSafe is an orthogonal concept to whether we; // are allowed to perform code motion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:20,clear,cleared,20,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['clear'],['cleared']
Usability,"// If we're allowed to modify and the block ends in a unconditional branch; // which could simply fallthrough, remove the branch. (Note: This case only; // matters when we can't understand the whole sequence, otherwise it's also; // handled by BranchFolding.cpp.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:91,simpl,simply,91,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['simpl'],['simply']
Usability,"// If we're asked to expand a strict vector floating-point operation,; // by default we're going to simply unroll it. That is usually the; // best approach, except in the case where the resulting strict (scalar); // operations would themselves use the fallback mutation to non-strict.; // In that specific case, just do the fallback on the vector op.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:100,simpl,simply,100,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['simpl'],['simply']
Usability,"// If we're caching global code-completion results, and the top-level; // declarations have changed, clear out the code-completion cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:101,clear,clear,101,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,1,['clear'],['clear']
Usability,// If we're demanding all elements don't bother trying to simplify the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:58,simpl,simplify,58,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplify']
Usability,// If we're extracting an upper subvector from a broadcast we should just; // extract the lowest subvector instead which should allow; // SimplifyDemandedVectorElts do more simplifications.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:138,Simpl,SimplifyDemandedVectorElts,138,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,"['Simpl', 'simpl']","['SimplifyDemandedVectorElts', 'simplifications']"
Usability,"// If we're filling in a static method where we used to have an; // implicit member access, rewrite to a simple decl ref.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:105,simpl,simple,105,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['simpl'],['simple']
Usability,"// If we're guaranteeing tail-calls will be honoured, the callee must; // pop its own argument stack on return. But this call is *not* a tail call so; // we need to undo that after it returns to restore the status-quo.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:165,undo,undo,165,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['undo'],['undo']
Usability,"// If we're in a loop with a hole, not all blocks in the loop are; // reachable from all other blocks. That implies we can't simply jump to; // the loop's exit blocks, as that exit might need to pass through an; // excluded block. Clear Outer so we process BB's successors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp:125,simpl,simply,125,interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp,2,"['Clear', 'simpl']","['Clear', 'simply']"
Usability,"// If we're inserting an element from a vbroadcast load, fold the; // load into the X86insertps instruction. We need to convert the scalar; // load to a vector and clear the source lane of the INSERTPS control.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:164,clear,clear,164,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['clear'],['clear']
Usability,"// If we're left with only a single word for the divisor, Knuth doesn't work; // so we implement the short division algorithm here. This is much simpler; // and faster because we are certain that we can divide a 64-bit quantity; // by a 32-bit quantity at hardware speed and short division is simply a; // series of such operations. This is just like doing short division but we; // are using base 2^32 instead of base 10.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:145,simpl,simpler,145,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,2,['simpl'],"['simpler', 'simply']"
Usability,// If we're mid-GlobalISel and we already triggered the fallback path then; // it's expected that the MIR is somewhat broken but that's ok since we'll; // reset it and clear the FailedISel attribute in ResetMachineFunctions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:168,clear,clear,168,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,1,['clear'],['clear']
Usability,"// If we're not stripping comments, this is simpler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/LineIterator.cpp:44,simpl,simpler,44,interpreter/llvm-project/llvm/lib/Support/LineIterator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/LineIterator.cpp,1,['simpl'],['simpler']
Usability,"// If we're only demanding signbits, then we can simplify to OR/AND node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:49,simpl,simplify,49,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['simpl'],['simplify']
Usability,"// If we're scanning for a simple node, see if it occurs later in the; // sequence. If so, and if we can move it up, it might be contradictory; // or the same as what we're looking for. If so, reorder it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp:27,simpl,simple,27,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp,1,['simpl'],['simple']
Usability,"// If we're simply supposed to record the declarations, do so now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:12,simpl,simply,12,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['simpl'],['simply']
Usability,"// If we're spilling an Argument, make sure we clear 'nocapture'; // from the coroutine function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:47,clear,clear,47,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['clear'],['clear']
Usability,"// If we're storing a truncated constant, see if we can simplify it.; // TODO: Move this to targetShrinkDemandedConstant?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:56,simpl,simplify,56,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simplify']
Usability,"// If we're testing a constant value against the result of a three way; // comparison, the result can be expressed directly in terms of the; // original values being compared. Note: We could possibly be more; // aggressive here and remove the hasOneUse test. The original select is; // really likely to simplify or sink when we remove a test of the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:303,simpl,simplify,303,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['simpl'],['simplify']
Usability,"// If we're transforming ""in-place"" (we're not creating new local; // declarations), assume we're replacing the old label statement; // and clear out the reference to it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:140,clear,clear,140,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['clear'],['clear']
Usability,"// If we're using no sort mode, then we can start getting immediate output; // from the tool by just filtering as we go, rather than processing; // everything up front so that we can sort it. This makes the tool more; // responsive. So only precompute the filtered/sorted set of classes if; // necessary due to the specified options.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-pdbutil/PrettyTypeDumper.cpp:221,responsiv,responsive,221,interpreter/llvm-project/llvm/tools/llvm-pdbutil/PrettyTypeDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-pdbutil/PrettyTypeDumper.cpp,1,['responsiv'],['responsive']
Usability,"// If we've already analyzed a Module or set of Modules, so we must clear; // the SimilarityCandidates to make sure we do not have only old values; // hanging around.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:68,clear,clear,68,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,1,['clear'],['clear']
Usability,"// If we've already cleared out the location for the default argument,; // that means we're parsing it right now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:20,clear,cleared,20,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['clear'],['cleared']
Usability,"// If we've folded a store into an instruction labelled with debug-info,; // record a substitution from the old operand to the memory operand. Handle; // the simple common case where operand 0 is the one being folded, plus when; // the destination operand is also a tied def. More values could be; // substituted / preserved with more analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:158,simpl,simple,158,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['simpl'],['simple']
Usability,"// If we've just learned that the range is actually an Objective-C; // collection, treat this as an Objective-C fast enumeration loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:17,learn,learned,17,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['learn'],['learned']
Usability,"// If we've reached this line, the actual type of the symbolic; // expression is not supported for advanced inference.; // In this case, we simply backoff to the default ""let's simply; // infer the range from the expression's type"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:140,simpl,simply,140,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,2,['simpl'],['simply']
Usability,"// If we've split on a CR logical that is fed by a CR logical,; // recompute the source CR logical as it may be usable for splitting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:112,usab,usable,112,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,1,['usab'],['usable']
Usability,"// If zero is poison, then the input can be assumed to be ""true"", so the; // instruction simplifies to ""false"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:89,simpl,simplifies,89,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['simpl'],['simplifies']
Usability,"// If-conversion doesn't change loop structure, and it doesn't mess with back; // edges, so updating LoopInfo is simply removing the dead blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:113,simpl,simply,113,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,1,['simpl'],['simply']
Usability,"// Ignore any callees that aren't actually functions. This could happen; // in the case of GUID hash collisions. It could also happen in theory; // for SamplePGO profiles collected on old versions of the code after; // renaming, since we synthesize edges to any inlined callees appearing; // in the profile.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:91,GUID,GUID,91,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['GUID'],['GUID']
Usability,// Ignore vector types to simplify matching the two constants.; // TODO: do this for vectors and scalars via a demanded bits analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:26,simpl,simplify,26,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['simpl'],['simplify']
Usability,// Immediate forms - may simply be convertable to an LI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:25,simpl,simply,25,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['simpl'],['simply']
Usability,"// Implement a simple matching for functions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/SelectionRules.cxx:15,simpl,simple,15,core/dictgen/src/SelectionRules.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/SelectionRules.cxx,1,['simpl'],['simple']
Usability,// Implement cbuffer layout in; // https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-packing-rules,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/CBufferDataLayout.cpp:43,learn,learn,43,interpreter/llvm-project/llvm/lib/Target/DirectX/CBufferDataLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/CBufferDataLayout.cpp,1,['learn'],['learn']
Usability,"// Implement some heroics to detect shifts of masked values where the mask can; // be replaced by extending the shift and undoing that in the addressing mode; // scale. Patterns such as (shl (srl x, c1), c2) are canonicalized into (and; // (srl x, SHIFT), MASK) by DAGCombines that don't know the shl can be done in; // the addressing mode. This results in code such as:; //; // int f(short *y, int *lookup_table) {; // ...; // return *y + lookup_table[*y >> 11];; // }; //; // Turning into:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $11, %ecx; // addl (%rsi,%rcx,4), %eax; //; // Instead of:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $9, %ecx; // andl $124, %rcx; // addl (%rsi,%rcx), %eax; //; // Note that this function assumes the mask is provided as a mask *after* the; // value is shifted. The input chain may or may not match that, but computing; // such a mask is trivial.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:122,undo,undoing,122,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['undo'],['undoing']
Usability,// Implement the interface used by simplifyUsersOfIV.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:35,simpl,simplifyUsersOfIV,35,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['simpl'],['simplifyUsersOfIV']
Usability,"// Implementation note: We don't bake a simple std::pair<> here as it requires; // significantly more effort to parse. A simple test with a large array of; // struct-pairs (N=100000) took clang-10 6s to parse. The same array of; // std::pair<uint64_t, uint64_t> took 242s. Instead we allow the user to; // define the pair type.; //; // FIXME: It may make sense to emit these as ULEB sequences instead of; // pairs of uint64_t.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DFAEmitter.cpp:40,simpl,simple,40,interpreter/llvm-project/llvm/utils/TableGen/DFAEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DFAEmitter.cpp,2,['simpl'],['simple']
Usability,// Implicit null checks act as unconditional branches and their comparisons; // should be treated as simplified and free of cost.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:101,simpl,simplified,101,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['simpl'],['simplified']
Usability,"// In 'T ...V;', the type of the declaration 'V' is 'T...', but the type of; // a reference to 'V' is simply (unexpanded) 'T'. The type, like the value,; // is expanded by some outer '...' in the context of the use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:102,simpl,simply,102,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['simpl'],['simply']
Usability,"// In C++'s specification, the coroutine should be marked as done; // if promise.unhandled_exception() throws. The frontend will; // call coro.end(true) along this path.; //; // FIXME: We should refactor this once there is other language; // which uses Switch-Resumed style other than C++.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:260,Resume,Resumed,260,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['Resume'],['Resumed']
Usability,"// In C++17, this could be a type template for class template argument; // deduction. Try to form a type annotation for it. If we're in a; // template template argument, we'll undo this when checking the; // validity of the argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:176,undo,undo,176,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['undo'],['undo']
Usability,"// In CL mode, don't error on apparently non-existent linker inputs, because; // they can be influenced by linker flags the clang driver might not; // understand.; // Examples:; // - `clang-cl main.cc ole32.lib` in a non-MSVC shell will make the driver; // module look for an MSVC installation in the registry. (We could ask; // the MSVCToolChain object if it can find `ole32.lib`, but the logic to; // look in the registry might move into lld-link in the future so that; // lld-link invocations in non-MSVC shells just work too.); // - `clang-cl ... /link ...` can pass arbitrary flags to the linker,; // including /libpath:, which is used to find .lib and .obj files.; // So do not diagnose this on the driver level. Rely on the linker diagnosing; // it. (If we don't end up invoking the linker, this means we'll emit a; // ""'linker' input unused [-Wunused-command-line-argument]"" warning instead; // of an error.); //; // Only do this skip after the typo correction step above. `/Brepo` is treated; // as TY_Object, but it's clearly a typo for `/Brepro`. It seems fine to emit; // an error if we have a flag that's within an edit distance of 1 from a; // flag. (Users can use `-Wl,` or `/linker` to launder the flag past the; // driver in the unlikely case they run into this.); //; // Don't do this for inputs that start with a '/', else we'd pass options; // like /libpath: through to the linker silently.; //; // Emitting an error for linker inputs can also cause incorrect diagnostics; // with the gcc driver. The command; // clang -fuse-ld=lld -Wl,--chroot,some/dir /file.o; // will make lld look for some/dir/file.o, while we will diagnose here that; // `/file.o` does not exist. However, configure scripts check if; // `clang /GR-` compiles without error to see if the compiler is cl.exe,; // so we can't downgrade diagnostics for `/GR-` from an error to a warning; // in cc mode. (We can in cl mode because cl.exe itself only warns on; // unknown flags.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:1028,clear,clearly,1028,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['clear'],['clearly']
Usability,"// In LoopDeletion pass Loop can be deleted when ExitingBlocks.size() > 1.; // We obviate multiple ExitingBlocks case for simplicity.; // TODO: If we see testcase with multiple ExitingBlocks can be deleted; // after exit value rewriting, we can enhance the logic here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:122,simpl,simplicity,122,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,1,['simpl'],['simplicity']
Usability,"// In Verilog the quote is not a character literal.; //; // Make the backtick and double backtick identifiers to match against them; // more easily.; //; // In Verilog an escaped identifier starts with backslash and ends with; // whitespace. Unless that whitespace is an escaped newline. A backslash can; // also begin an escaped newline outside of an escaped identifier. We check; // for that outside of the Regex since we can't use negative lookhead; // assertions. Simply changing the '*' to '+' breaks stuff as the escaped; // identifier may have a length of 0 according to Section A.9.3.; // FIXME: If there is an escaped newline in the middle of an escaped; // identifier, allow for pasting the two lines together, But escaped; // identifiers usually occur only in generated code anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp:468,Simpl,Simply,468,interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,1,['Simpl'],['Simply']
Usability,"// In a pseudo-probe based profile, a callsite is simply represented by the; // ID of the probe associated with the call instruction. The probe ID is; // encoded in the Discriminator field of the call instruction's debug; // metadata.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProf.cpp:50,simpl,simply,50,interpreter/llvm-project/llvm/lib/ProfileData/SampleProf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProf.cpp,1,['simpl'],['simply']
Usability,"// In a situation like the following:; // %0:subreg = instr ; DefMI, subreg = DstIdx; // %1 = copy %0:subreg ; CopyMI, SrcIdx = 0; // instead of widening %1 to the register class of %0 simply do:; // %1 = instr",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:185,simpl,simply,185,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['simpl'],['simply']
Usability,"// In any case, we'll start to request the chunks.; // This implementation simply reads all the chunks in advance; // in the async way.; // Use the async readv instead of single reads",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx:75,simpl,simply,75,io/io/src/TFileCacheRead.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx,1,['simpl'],['simply']
Usability,"// In asan mode emit a function call instead of a regular load and let the; // run-time deal with it: if the shadow is properly poisoned return the; // cookie, otherwise return 0 to avoid an infinite loop calling DTORs.; // We can't simply ignore this load using nosanitize metadata because; // the metadata may be lost.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:233,simpl,simply,233,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['simpl'],['simply']
Usability,"// In async-lowering, one of the arguments is an async context as determined; // by the `llvm.coro.id.async` intrinsic. We can retrieve the async context of; // the resume function from the async context projection function associated; // with the active suspend. The frame is located as a tail to the async; // context header.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:165,resume,resume,165,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['resume'],['resume']
Usability,// In case demanded bits didn't clear the bits that will be shifted out.; // This is needed for X86.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:32,clear,clear,32,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['clear'],['clear']
Usability,"// In case of a comparison with two select instructions having the same; // condition, check whether one of the resulting branches can be simplified.; // If so, just compare the other branch and select the appropriate result.; // For example:; // %tmp1 = select i1 %cmp, i32 %y, i32 %x; // %tmp2 = select i1 %cmp, i32 %z, i32 %x; // %cmp2 = icmp slt i32 %tmp2, %tmp1; // The icmp will result false for the false value of selects and the result; // will depend upon the comparison of true values of selects if %cmp is; // true. Thus, transform this into:; // %cmp = icmp slt i32 %y, %z; // %sel = select i1 %cond, i1 %cmp, i1 false; // This handles similar cases to transform.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:138,simpl,simplified,138,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['simpl'],['simplified']
Usability,"// In case of a concrete region, it should always be possible to model; // the base-to-derived cast by undoing a previous derived-to-base cast,; // otherwise the cast is most likely ill-formed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h:103,undo,undoing,103,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h,1,['undo'],['undoing']
Usability,"// In case of alloc, clear OMP_MAP_TO and OMP_MAP_FROM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:21,clear,clear,21,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['clear'],['clear']
Usability,"// In case of from, clear OMP_MAP_TO.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:20,clear,clear,20,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['clear'],['clear']
Usability,"// In case of to, clear OMP_MAP_FROM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:18,clear,clear,18,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['clear'],['clear']
Usability,"// In case we were expanding a pack when we attempted to declare deduction; // guides, turn off pack expansion for everything we're about to do.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:79,guid,guides,79,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,2,['guid'],['guides']
Usability,"// In case when the prvalue is returned from the function (kind is one of; // SimpleReturnedValueKind, CXX17ElidedCopyReturnedValueKind), then; // it's materialization happens in context of the caller.; // We pass BldrCtx explicitly, as currBldrCtx always refers to callee's context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:78,Simpl,SimpleReturnedValueKind,78,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,1,['Simpl'],['SimpleReturnedValueKind']
Usability,"// In case when we print non paren inits like int i = h->Draw();; // not int i(h->Draw()). This simplifies the LifetimeHandler's; // constructor, there we don't need to add parenthesis while; // wrapping the expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp:96,simpl,simplifies,96,interpreter/cling/lib/Interpreter/DynamicLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp,1,['simpl'],['simplifies']
Usability,"// In cases `Init` is `new T[n]` and there is no explicit cast over; // `Init`, we know that `Init` must evaluates to a pointer to `n` objects; // of `T`. So the extent is `n` unless `n` has side effects. Similar but; // simpler for the case where `Init` is `new T`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:221,simpl,simpler,221,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['simpl'],['simpler']
Usability,"// In cases of multiple users it seems better to keep the simple; // instruction as they are one cycle faster, and it also helps in cases; // where both inputs share a common node.; // The widening or narrowing is expected to be free. Counting widening; // or narrowing as a saved operation will result in preferring an R*SBG; // over a simple shift/logical instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:58,simpl,simple,58,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,2,['simpl'],['simple']
Usability,"// In debug builds, ensure that the terminator of the block is never replaced; // or deleted by these simplifications. The idea of simplification is that it; // cannot introduce new instructions, and there is no way to replace the; // terminator of a block without introducing a new instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:102,simpl,simplifications,102,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,2,['simpl'],"['simplification', 'simplifications']"
Usability,"// In dependent contexts, we do ADL twice, and the first time around,; // the base type might be a dependent TemplateSpecializationType, or a; // TemplateTypeParmType. If that happens, simply ignore it.; // FIXME: If we want to support export, we probably need to add the; // namespace of the template in a TemplateSpecializationType, or even; // the classes and namespaces of known non-dependent arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:185,simpl,simply,185,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['simpl'],['simply']
Usability,"// In each SimplifyCFG run, only the current processed block can be erased.; // Otherwise, it will break the iteration of SimplifyCFG pass. So instead; // of erasing TrivialBB, we only remove the branch to the common resume; // block so that we can later erase the resume block since it has no; // predecessors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:11,Simpl,SimplifyCFG,11,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,4,"['Simpl', 'resume']","['SimplifyCFG', 'resume']"
Usability,"// In general, we return true for unknown calls, but there are; // some simple checks that we can do for functions that; // will never call back into the module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:72,simpl,simple,72,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,1,['simpl'],['simple']
Usability,"// In general, when both constants are non-zero, we would need an offset to; // replace the select. This would require more instructions than we started; // with. But there's one special-case that we handle here because it can; // simplify/reduce the instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:231,simpl,simplify,231,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['simpl'],['simplify']
Usability,"// In i1, negation can simply be ignored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp:23,simpl,simply,23,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp,1,['simpl'],['simply']
Usability,"// In order for the iterator to stay valid, we must; // prevent the removal of the object (dir) from the list; // (which is done in TFile::Close). We can also can not; // just move to the next iterator since the Close might; // also (indirectly) remove that file.; // So we SetObject to a harmless value, so that 'dir'; // is not seen as part of the list.; // We will later, remove all the object (see files->Clear()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:409,Clear,Clear,409,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,3,['Clear'],['Clear']
Usability,"// In order to be consistent, we clear the top down pointers when by adding; // BottomUpPathCount becomes OverflowOccurredValue even though ""true"" overflow; // has not occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:33,clear,clear,33,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['clear'],['clear']
Usability,"// In order to be consistent, we clear the top down pointers when by adding; // TopDownPathCount becomes OverflowOccurredValue even though ""true"" overflow; // has not occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:33,clear,clear,33,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['clear'],['clear']
Usability,"// In order to lower the learning rate even more, we need to apply sqrt instead of square.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx:25,learn,learning,25,tmva/tmva/src/MethodMLP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx,1,['learn'],['learning']
Usability,"// In order to use this index for testing, specifically import testing, we; // need to update any indirect call edges created from SamplePGO, so that they; // point to the correct GUIDs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:180,GUID,GUIDs,180,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,1,['GUID'],['GUIDs']
Usability,"// In principle, for simplicity, we preserve the old behavior of; // delivering diagnostics to just one consumer (that is why we don't emit; // to both), but we allow the ""sink"" to be changed.; // Note, however, that consumers might update their internal state in; // calls to, e.g. `BeginSourceFile()` or `EndSourceFile()` (actually,; // `TextDiagnosticPrinter` is an example of this), so in order to be able; // to restore the original consumer, we need to keep forwarding these; // calls also to `m_PrevClient` (see above).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp:21,simpl,simplicity,21,interpreter/cling/lib/Interpreter/IncrementalParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp,1,['simpl'],['simplicity']
Usability,"// In rare occasion, the symbol used to initialize GlobalRes has a different; // IRName from the inspected Symbol. This can happen on macOS + iOS, when a; // symbol is referenced through its mangled name, say @""\01_symbol"" while; // the IRName is @symbol (the prefix underscore comes from MachO mangling).; // In that case, we have the same actual Symbol that can get two different; // GUID, leading to some invalid internalization. Workaround this by marking; // the GlobalRes external.; // FIXME: instead of this check, it would be desirable to compute GUIDs; // based on mangled name, but this requires an access to the Target Triple; // and would be relatively invasive on the codebase.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:386,GUID,GUID,386,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,2,['GUID'],"['GUID', 'GUIDs']"
Usability,"// In simple words, if an instruction is not in the assumed to _not_; // cause UB, then it is assumed UB (that includes those; // in the KnownUBInsts set). The rest is boilerplate; // is to ensure that it is one of the instructions we test; // for UB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:6,simpl,simple,6,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['simpl'],['simple']
Usability,"// In some case, for example TParallelCoord, a list (the pad's list of; // primitives) will contain both the container and the containees; // (the TParallelCoorVar) but if the Clear is being called from; // the destructor of the container of this list, one of the first; // thing done will be the remove the container (the pad) for the; // list (of Primitives of the canvas) that was connecting it; // (indirectly) to the list of cleanups.; // To preserve this connection (without introducing one when there was none),; // we re-use fCache to inform RecursiveRemove of the node currently; // being cleared/deleted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TList.cxx:176,Clear,Clear,176,core/cont/src/TList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TList.cxx,2,"['Clear', 'clear']","['Clear', 'cleared']"
Usability,"// In some case, for example TParallelCoord, a list (the pad's list of; // primitives) will contain both the container and the containees; // (the TParallelCoordVar) but if the Clear is being called from; // the destructor of the container of this list, one of the first; // thing done will be the remove the container (the pad) for the; // list (of Primitives of the canvas) that was connecting it; // (indirectly) to the list of cleanups.; // Note: The Code in TParallelCoordVar was changed (circa June 2017),; // to no longer have this behavior and thus rely on this code (by moving; // from using Draw to Paint) but the structure might still exist elsewhere; // so we keep this comment here.; // To preserve this connection (without introducing one when there was none),; // we re-use fCache to inform RecursiveRemove of the node currently; // being cleared/deleted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TList.cxx:177,Clear,Clear,177,core/cont/src/TList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TList.cxx,2,"['Clear', 'clear']","['Clear', 'cleared']"
Usability,"// In some case, for example TParallelCoord, a list (the pad's list of; // primitives) will contain both the container and the containees; // (the TParallelCoordVar) but if the Clear is being called from; // the destructor of the container of this list, one of the first; // thing done will be the remove the container (the pad) from the; // list (of Primitives of the canvas) that was connecting it; // (indirectly) to the list of cleanups.; // Note: The Code in TParallelCoordVar was changed (circa June 2017),; // to no longer have this behavior and thus rely on this code (by moving; // from using Draw to Paint) but the structure might still exist elsewhere; // so we keep this comment here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TObjArray.cxx:177,Clear,Clear,177,core/cont/src/TObjArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TObjArray.cxx,1,['Clear'],['Clear']
Usability,"// In switch lowering, replace coro.suspend with the appropriate value; // for the type of function we're extracting.; // Replacing coro.suspend with (0) will result in control flow proceeding to; // a resume label associated with a suspend point, replacing it with (1) will; // result in control flow proceeding to a cleanup label associated with this; // suspend point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:202,resume,resume,202,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['resume'],['resume']
Usability,"// In switch-lowering, we built a resume-entry block in the original; // function. Make the entry block branch to this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:34,resume,resume-entry,34,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['resume'],['resume-entry']
Usability,"// In the capture loop for speculation, we want to stop the processor from; // speculating as fast as possible. On Intel processors, the PAUSE instruction; // will block speculation without consuming any execution resources. On AMD; // processors, the PAUSE instruction is (essentially) a nop, so we also use an; // LFENCE instruction which they have advised will stop speculation as well; // with minimal resource utilization. We still end the capture with a jump to; // form an infinite loop to fully guarantee that no matter what implementation; // of the x86 ISA, speculating this code path never escapes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp:137,PAUSE,PAUSE,137,interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp,2,['PAUSE'],['PAUSE']
Usability,"// In the case of an if statement, we try to hoist an invoke.; // FIXME: Can we define a safety predicate for CallBr?; // FIXME: Test case llvm/test/Transforms/SimplifyCFG/2009-06-15-InvokeCrash.ll; // removed in 4c923b3b3fd0ac1edebf0603265ca3ba51724937 commit?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:160,Simpl,SimplifyCFG,160,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['Simpl'],['SimplifyCFG']
Usability,"// In the case of loops, the scope of the subgraph is all the; // basic blocks (and instructions within them) belonging to the loop. We; // simply ignore all the edges coming from (or going into) instructions; // or basic blocks outside of this range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:140,simpl,simply,140,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,1,['simpl'],['simply']
Usability,"// In the case of multiple select instructions in the same group, the order; // of non-dependent instructions (instructions of different dependence; // slices) in the true/false blocks appears to affect performance.; // Interleaving the slices seems to experimentally be the optimal approach.; // This interleaving scheduling allows for more ILP (with a natural downside; // of increasing a bit register pressure) compared to a simple ordering of; // one whole chain after another. One would expect that this ordering would; // not matter since the scheduling in the backend of the compiler would; // take care of it, but apparently the scheduler fails to deliver optimal; // ILP with a naive ordering here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:428,simpl,simple,428,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,1,['simpl'],['simple']
Usability,"// In the failing case, where we don't execute the store-conditional, the; // target might want to balance out the load-linked with a dedicated; // instruction (e.g., on ARM, clearing the exclusive monitor).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:175,clear,clearing,175,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,1,['clear'],['clearing']
Usability,"// In the input is a constant expr, we might be able to recursively simplify.; // If not, we definitely can't do anything.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:68,simpl,simplify,68,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['simpl'],['simplify']
Usability,"// In the more general case, we can clear the high bits after the shift:; // srl (trunc (srl x, c1)), c2 --> trunc (and (srl x, (c1+c2)), Mask)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,clear,clear,36,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['clear'],['clear']
Usability,"// In the non-overloaded case, we warn about self-assignment (x = x) for; // both simple assignment and certain compound assignments where algebra; // tells us the operation yields a constant result. When the operator is; // overloaded, we can't do the latter because we don't want to assume that; // those algebraic identities still apply; for example, a path-building; // library might use operator/= to append paths. But it's still reasonable; // to assume that simple assignment is just moving/copying values around; // and so self-assignment is likely a bug.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:82,simpl,simple,82,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['simpl'],['simple']
Usability,"// In the normal case, we're just lexing from a simple file buffer, return; // the file id from FileLoc with the offset specified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:48,simpl,simple,48,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['simpl'],['simple']
Usability,"// In the resume function, we remove the last case (when coro::Shape is built,; // the final suspend point (if present) is always the last element of; // CoroSuspends array) since it is an undefined behavior to resume a coroutine; // suspended at the final suspend point.; // In the destroy function, if it isn't possible that the ResumeFnAddr is NULL; // and the coroutine doesn't suspend at the final suspend point actually (this; // is possible since the coroutine is considered suspended at the final suspend; // point if promise.unhandled_exception() exits via an exception), we can; // remove the last case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:10,resume,resume,10,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,3,"['Resume', 'resume']","['ResumeFnAddr', 'resume']"
Usability,"// In the simple case, just pass the coerced loaded value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:10,simpl,simple,10,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['simpl'],['simple']
Usability,"// In the state emulated, BuildOld would recalculate the offset and undo the offset update.; // Note: we should consider adding a new state just for this (the hints indicates that we are mapping a compiled class but; // then we would have to investigate all use of the state with <= and >= condition to make sure they are still appropriate).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:68,undo,undo,68,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,1,['undo'],['undo']
Usability,"// In the worst case, for a full 64-bit constant, a sequence of 8 instructions; // (i.e., LUI+ADDIW+SLLI+ADDI+SLLI+ADDI+SLLI+ADDI) has to be emitted. Note; // that the first two instructions (LUI+ADDIW) can contribute up to 32 bits; // while the following ADDI instructions contribute up to 12 bits each.; //; // On the first glance, implementing this seems to be possible by simply; // emitting the most significant 32 bits (LUI+ADDIW) followed by as many left; // shift (SLLI) and immediate additions (ADDI) as needed. However, due to the; // fact that ADDI performs a sign extended addition, doing it like that would; // only be possible when at most 11 bits of the ADDI instructions are used.; // Using all 12 bits of the ADDI instructions, like done by GAS, actually; // requires that the constant is processed starting with the least significant; // bit.; //; // In the following, constants are processed from LSB to MSB but instruction; // emission is performed from MSB to LSB by recursively calling; // generateInstSeq. In each recursion, first the lowest 12 bits are removed; // from the constant and the optimal shift amount, which can be greater than; // 12 bits if the constant is sparse, is determined. Then, the shifted; // remaining constant is processed recursively and gets emitted as soon as it; // fits into 32 bits. The emission of the shifts and additions is subsequently; // performed when the recursion returns.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:376,simpl,simply,376,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,1,['simpl'],['simply']
Usability,"// In theory, different compile units may have different address byte; // sizes, but for simplicity we just use the address byte size of the; // first compile unit. In practice the address size field is repeated across; // various DWARF headers (at least in version 5) to make it easier to dump; // them independently, not to enable varying the address size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp:89,simpl,simplicity,89,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,1,['simpl'],['simplicity']
Usability,"// In this case, we can use a refined formula for computing backedge taken; // count. The general formula remains:; // ""End-Start /uceiling Stride"" where ""End = max(RHS,Start)""; // We want to use the alternate formula:; // ""((End - 1) - (Start - Stride)) /u Stride""; // Let's do a quick case analysis to show these are equivalent under; // our precondition that max(RHS,Start) > Start - Stride.; // * For RHS <= Start, the backedge-taken count must be zero.; // ""((End - 1) - (Start - Stride)) /u Stride"" reduces to; // ""((Start - 1) - (Start - Stride)) /u Stride"" which simplies to; // ""Stride - 1 /u Stride"" which is indeed zero for all non-zero values; // of Stride. For 0 stride, we've use umin(1,Stride) above, reducing; // this to the stride of 1 case.; // * For RHS >= Start, the backedge count must be ""RHS-Start /uceil Stride"".; // ""((End - 1) - (Start - Stride)) /u Stride"" reduces to; // ""((RHS - 1) - (Start - Stride)) /u Stride"" reassociates to; // ""((RHS - (Start - Stride) - 1) /u Stride"".; // Our preconditions trivially imply no overflow in that form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:571,simpl,simplies,571,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['simpl'],['simplies']
Usability,"// In this function, we try to deal with the following pattern:; //; // if (parameter); // parameter(...);; //; // It's not good to show a warning here because clearly 'parameter'; // couldn't and shouldn't be called on the 'else' path.; //; // Let's check if this if statement has a check involving one of; // the tracked parameters.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:160,clear,clearly,160,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,1,['clear'],['clearly']
Usability,"// In wasm EH, even though a catchpad may not catch an exception if a tag does; // not match, it is OK to add only the first unwind destination catchpad to the; // successors, because there will be at least one invoke instruction within the; // catch scope that points to the next unwind destination, if one exists, so; // CFGSort cannot mess up with BB sorting order.; // (All catchpads with 'catch (type)' clauses have a 'llvm.rethrow' intrinsic; // call within them, and catchpads only consisting of 'catch (...)' have a; // '__cxa_end_catch' call within them, both of which generate invokes in case; // the next unwind destination exists, i.e., the next unwind destination is not; // the caller.); //; // Having at most one EH pad successor is also simpler and helps later; // transformations.; //; // For example,; // current:; // invoke void @foo to ... unwind label %catch.dispatch; // catch.dispatch:; // %0 = catchswitch within ... [label %catch.start] unwind label %next; // catch.start:; // ...; // ... in this BB or some other child BB dominated by this BB there will be an; // invoke that points to 'next' BB as an unwind destination; //; // next: ; We don't need to add this to 'current' BB's successor; // ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:753,simpl,simpler,753,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['simpl'],['simpler']
Usability,"// Inconsistent address spaces at this point is invalid, even if the; // address spaces would be compatible.; // FIXME: This doesn't catch address space mismatches for pointers of; // different nesting levels, like:; // __local int *** a;; // int ** b = a;; // It's not clear how to actually determine when such pointers are; // invalidly incompatible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:270,clear,clear,270,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['clear'],['clear']
Usability,// Incrementation should be a simple increment or decrement; // operator call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp:30,simpl,simple,30,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/LoopUnrolling.cpp,1,['simpl'],['simple']
Usability,// Indent relative to the RHS of the expression unless this is a simple; // assignment without binary expression on the RHS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:65,simpl,simple,65,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['simpl'],['simple']
Usability,"// Index of the first element of the vector.; // PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:70,Guid,Guide,70,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['Guid'],['Guide']
Usability,// Indicate we no longer have a fixed byte size for this; // abbreviation by clearing the FixedAttributeSize optional value; // so it doesn't have a value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAbbreviationDeclaration.cpp:77,clear,clearing,77,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAbbreviationDeclaration.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAbbreviationDeclaration.cpp,1,['clear'],['clearing']
Usability,"// Info argument of coro.id is; // fresh out of the frontend: null ;; // outlined : {Init, Return, Susp1, Susp2, ...} ;; // postsplit : [resume, destroy, cleanup] ;; //; // If parts of the coroutine were outlined to protect against undesirable; // code motion, these functions will be stored in a struct literal referred to; // by the Info parameter. Note: this is only needed before coroutine is split.; //; // After coroutine is split, resume functions are stored in an array; // referred to by this parameter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h:137,resume,resume,137,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInstr.h,2,['resume'],['resume']
Usability,// Information on REP string instructions that require manual mitigation can; // be found here:; // https://software.intel.com/security-software-guidance/insights/deep-dive-load-value-injection#specialinstructions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:145,guid,guidance,145,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,1,['guid'],['guidance']
Usability,// Information on control-flow instructions that require manual mitigation can; // be found here:; // https://software.intel.com/security-software-guidance/insights/deep-dive-load-value-injection#specialinstructions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:147,guid,guidance,147,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,1,['guid'],['guidance']
Usability,"// Initialization is not going well, but we still have to commit what; // we've been given. Don't clear the DiagnosticsConsumer so the caller; // can inspect any errors that have been generated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:98,clear,clear,98,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,1,['clear'],['clear']
Usability,"// Initialize data structures for this pass. In particular, clear the; // swap vector and allocate the equivalence class mapping before; // processing each function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:60,clear,clear,60,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,1,['clear'],['clear']
Usability,"// Initialize the alloca with the same value as used by the allocation; // function. We can skip undef as the initial value of an alloc is; // undef, and the memset would simply end up being DSEd.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:171,simpl,simply,171,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['simpl'],['simply']
Usability,"// Initializes PhysRegEntries (instead of a SmallVector, PhysRegEntries is a; // buffer of size NumPhysRegs to speed up alloc/clear for targets with large; // reg files). Calloced memory is used for good form, and quites tools like; // Valgrind too, but zero initialized memory is not required by the algorithm:; // this is because PhysRegEntries works like a SparseSet and its entries are; // only valid when there is a corresponding CacheEntries assignment. There is; // also support for when pass managers are reused for targets with different; // numbers of PhysRegs: in this case PhysRegEntries is freed and reinitialized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp:126,clear,clear,126,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.cpp,1,['clear'],['clear']
Usability,"// Initializing a base sub-object is an instance method call on an; // object of the derived class. Otherwise, we have an instance method; // call on an object of the constructed type.; //; // FIXME: If we have a parent, we're initializing the base class subobject; // in aggregate initialization. It's not clear whether the object class; // should be the base class or the derived class in that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:307,clear,clear,307,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['clear'],['clear']
Usability,"// Inline fast path, particularly for constant strings where a sufficiently; // smart compiler will simplify strlen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:100,simpl,simplify,100,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,1,['simpl'],['simplify']
Usability,// Inline the common simple case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:21,simpl,simple,21,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,1,['simpl'],['simple']
Usability,// InnerAM is cleared in a moved from state where there is nothing to do.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:14,clear,cleared,14,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,2,['clear'],['cleared']
Usability,// Input vectors need to be swapped if the leading element; // of the result is one of the 3 left elements of the first vector; // (or if we're shifting by 4 - thereby simply swapping the vectors).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:168,simpl,simply,168,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['simpl'],['simply']
Usability,// Insert $noreg if we didn't find a usable constant and had to drop it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/MachineIRBuilder.cpp:37,usab,usable,37,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/MachineIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/MachineIRBuilder.cpp,1,['usab'],['usable']
Usability,"// InsertionSort; //; // Just a simple insertion sort using; // pointers and back pointers to sort the Active; // Edge Table.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASPolyUtils.c:32,simpl,simple,32,graf2d/asimage/src/TASPolyUtils.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASPolyUtils.c,1,['simpl'],['simple']
Usability,// InstCombine converts:; // `(-x << C0) & C1`; // to; // `(x * (Pow2_Ceil(C1) - (1 << C0))) & C1`; // This saves an IR instruction but on x86 the neg/shift version is preferable; // so undo the transform.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:186,undo,undo,186,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['undo'],['undo']
Usability,// Install the new array. Clear all the buckets to empty.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp:26,Clear,Clear,26,interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp,2,['Clear'],['Clear']
Usability,"// Instantiate the macro, then resume at this directive to recheck the; // condition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp:31,resume,resume,31,interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,1,['resume'],['resume']
Usability,"// Instead of creating a new BB and PHI node, just append the call to; // _Unwind_Resume to the end of the single resume block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:114,resume,resume,114,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,1,['resume'],['resume']
Usability,"// Instead of having an apply function, just build here to simplify things.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp:59,simpl,simplify,59,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp,1,['simpl'],['simplify']
Usability,"// InstructionSelector walks backwards through the instructions. For an; // explicit conditional branch with no fallthrough, we use both a G_BR and a; // G_BRCOND to create an OpBranchConditional. We should hit G_BR first, and; // generate the OpBranchConditional in selectBranch above.; //; // If an OpBranchConditional has been generated, we simply return, as the work; // is alread done. If there is no OpBranchConditional, LLVM must be relying on; // implicit fallthrough to the next basic block, so we need to create an; // OpBranchConditional with an explicit ""false"" argument pointing to the next; // basic block that LLVM would fall through to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:344,simpl,simply,344,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,1,['simpl'],['simply']
Usability,// Instructions processed by SimplifyIndvar for CurrIV.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:29,Simpl,SimplifyIndvar,29,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,1,['Simpl'],['SimplifyIndvar']
Usability,"// Int_t TGraph2D::DoFit(TF2 *f2 ,Option_t *option ,Option_t *goption) {; // // internal graph2D fitting methods; // Foption_t fitOption;; // ROOT::Fit::FitOptionsMake(option,fitOption);; // // create range and minimizer options with default values; // ROOT::Fit::DataRange range(2);; // ROOT::Math::MinimizerOptions minOption;; // return ROOT::Fit::FitObject(this, f2 , fitOption , minOption, goption, range);; // }; // function to compute the simple chi2 for graphs and histograms",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitImpl.cxx:445,simpl,simple,445,hist/hist/src/HFitImpl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitImpl.cxx,1,['simpl'],['simple']
Usability,"// IntervalTree is a light tree data structure to hold intervals. It allows; // finding all intervals that overlap with any given point. At this time,; // it does not support any deletion or rebalancing operations.; //; // The IntervalTree is designed to be set up once, and then queried without; // any further additions.; //; // Synopsis:; // Closed intervals delimited by PointT objects are mapped to ValueT objects.; //; // Restrictions:; // PointT must be a fundamental type.; // ValueT must be a fundamental or pointer type.; //; // template <typename PointT, typename ValueT, typename DataT>; // class IntervalTree {; // public:; //; // IntervalTree();; // ~IntervalTree():; //; // using IntervalReferences = SmallVector<IntervalData *>;; //; // void create();; // void insert(PointT Left, PointT Right, ValueT Value);; //; // IntervalReferences getContaining(PointT Point);; // static void sortIntervals(IntervalReferences &Intervals, Sorting Sort);; //; // find_iterator begin(PointType Point) const;; // find_iterator end() const;; //; // bool empty() const;; // void clear();; //; // void print(raw_ostream &OS, bool HexFormat = true);; // };; //; //===----------------------------------------------------------------------===//; //; // In the below given dataset; //; // [a, b] <- (x); //; // 'a' and 'b' describe a range and 'x' the value for that interval.; //; // The following data are purely for illustrative purposes:; //; // [30, 35] <- (3035), [39, 50] <- (3950), [55, 61] <- (5561),; // [31, 56] <- (3156), [12, 21] <- (1221), [25, 41] <- (2541),; // [49, 65] <- (4965), [71, 79] <- (7179), [11, 16] <- (1116),; // [20, 30] <- (2030), [36, 54] <- (3654), [60, 70] <- (6070),; // [74, 80] <- (7480), [15, 40] <- (1540), [43, 43] <- (4343),; // [50, 75] <- (5075), [10, 85] <- (1085); //; // The data represents a set of overlapping intervals:; //; // 30--35 39------------50 55----61; // 31------------------------56; // 12--------21 25------------41 49-------------65 71-----79; /",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h:1078,clear,clear,1078,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,1,['clear'],['clear']
Usability,// Intervals to the right of middle point.; // Working vector used during the tree creation to sort the intervals. It is; // cleared once the tree is created.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h:125,clear,cleared,125,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,1,['clear'],['cleared']
Usability,"// Intuitively, objc_retain and others are nocapture, however in practice; // they are not, because they return their argument value. And objc_release; // calls finalizers which can have arbitrary side effects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:3,Intuit,Intuitively,3,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['Intuit'],['Intuitively']
Usability,"// Invalidate the destination (regular invalidation without pointer-escaping; // the address of the top-level region). This must happen before we set the; // C string length because invalidation will clear the length.; // FIXME: Even if we can't perfectly model the copy, we should see if we; // can use LazyCompoundVals to copy the source values into the destination.; // This would probably remove any existing bindings past the end of the; // string, but that's still an improvement over blank invalidation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:200,clear,clear,200,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,1,['clear'],['clear']
Usability,// Invert the map from local to index into a simple vector. There should be; // no holes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:45,simpl,simple,45,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['simpl'],['simple']
Usability,// Invert the mask to only clear the lower bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:27,clear,clear,27,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['clear'],['clear']
Usability,"// Invoke results are only usable in the normal destination, not in the; // exceptional destination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp:27,usab,usable,27,interpreter/llvm-project/llvm/lib/IR/Dominators.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp,1,['usab'],['usable']
Usability,// InvokeInst simplification,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:14,simpl,simplification,14,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['simpl'],['simplification']
Usability,"// Is SetEntriesRange() simply ignored as it should be?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/test/basic.cxx:24,simpl,simply,24,tree/treeplayer/test/basic.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/test/basic.cxx,1,['simpl'],['simply']
Usability,"// Is it clear that the fits can infer the value of lambda when generating in mu?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/vectorisedPDFs/testJohnson.cxx:9,clear,clear,9,roofit/roofit/test/vectorisedPDFs/testJohnson.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/vectorisedPDFs/testJohnson.cxx,1,['clear'],['clear']
Usability,"// Is the LearnPrefill enabled (using an Int_t here to allow for future; // extension to alternative Prefilling).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:10,Learn,LearnPrefill,10,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['Learn'],['LearnPrefill']
Usability,// Is the Token a simple or qualifier type,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.h:18,simpl,simple,18,interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.h,1,['simpl'],['simple']
Usability,// Is the level-1 Branch usable?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:25,usab,usable,25,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,1,['usab'],['usable']
Usability,// Is the sign bit clear?; // (X >s -1) ? MINVAL : X ==> (X <u MINVAL) ? MINVAL : X ==> UMAX; // (X >s -1) ? X : MINVAL ==> (X <u MINVAL) ? X : MINVAL ==> UMIN,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:19,clear,clear,19,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['clear'],['clear']
Usability,// Is this a simple intrinsic?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:13,simpl,simple,13,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,1,['simpl'],['simple']
Usability,"// Is this parameter simply a dummy?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/Measurement.cxx:21,simpl,simply,21,roofit/histfactory/src/Measurement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/Measurement.cxx,1,['simpl'],['simply']
Usability,"// Is this the first addition of a branch (and we are learning and we are in; // the expected TTree), then prefill the cache. (We expect that in future; // release the Prefill-ing will be the default so we test for that inside the; // LearnPrefill call).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:54,learn,learning,54,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,"['Learn', 'learn']","['LearnPrefill', 'learning']"
Usability,// IsConsecutiveLoadWithZeros - we need to create a shuffle of the loaded; // vector and a zero vector to clear out the zero elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:106,clear,clear,106,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['clear'],['clear']
Usability,"// It didn't simplify. However, if composed comparison is equivalent; // to the select condition (%cond) then we can replace it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:13,simpl,simplify,13,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplify']
Usability,"// It does! Now see if ""V + Y"" simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,simpl,simplifies,31,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// It does! Now see if ""V - Y"" simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,simpl,simplifies,31,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// It does! Now see if ""V - Z"" simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,simpl,simplifies,31,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// It does! Now see if ""X + V"" simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,simpl,simplifies,31,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// It does! Now see if ""Y + V"" simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,simpl,simplifies,31,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// It does! Now see if ""trunc V"" simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:33,simpl,simplifies,33,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// It does! Return ""A op V"" if it simplifies or is already available.; // If V equals B then ""A op V"" is just the LHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:34,simpl,simplifies,34,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// It does! Return ""B op V"" if it simplifies or is already available.; // If V equals C then ""B op V"" is just the RHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:34,simpl,simplifies,34,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// It does! Return ""V op B"" if it simplifies or is already available.; // If V equals A then ""V op B"" is just the LHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:34,simpl,simplifies,34,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// It does! Return ""V op C"" if it simplifies or is already available.; // If V equals B then ""V op C"" is just the RHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:34,simpl,simplifies,34,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// It does, return the simplified ""trunc V"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:23,simpl,simplified,23,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplified']
Usability,// It doesn't matter if we can't check all uses as we can simply; // conservatively ignore those that can not be visited.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:58,simpl,simply,58,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['simpl'],['simply']
Usability,"// It is kind of more intuitive to apply a plain rotation around the text anchor set by x and y; // but when the user supplies an arbitrary transformation matrix, the x and y offsets should be applied; // in the coordinate system established by this matrix",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:22,intuit,intuitive,22,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['intuit'],['intuitive']
Usability,// It is not clear.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:13,clear,clear,13,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['clear'],['clear']
Usability,"// It is not currently possible for clang to generate an invariant.start; // intrinsic with scalable vector types because we don't support thread local; // sizeless types and we don't permit sizeless types in structs or classes.; // Furthermore, even if support is added for this in future the intrinsic; // itself is defined to have a size of -1 for variable sized objects. This; // makes it impossible to verify if the intrinsic envelops our region of; // interest. For example, both <vscale x 32 x i8> and <vscale x 16 x i8>; // types would have a -1 parameter, but the former is clearly double the size; // of the latter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:583,clear,clearly,583,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['clear'],['clearly']
Usability,"// It is okay to *not* make anonymous top-level namespaces distinct, because; // all nodes that have an anonymous namespace as their parent scope are; // guaranteed to be unique and/or are linked to their containing; // DICompileUnit. This decision is an explicit tradeoff of link time versus; // memory usage versus code simplicity and may get revisited in the future.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp:322,simpl,simplicity,322,interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp,1,['simpl'],['simplicity']
Usability,"// It is possible for very late stage optimizations (such as SimplifyCFG); // to introduce PHI nodes too late to be cleaned up. If we detect such a; // trivial PHI, go ahead and zap it here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:61,Simpl,SimplifyCFG,61,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['Simpl'],['SimplifyCFG']
Usability,"// It is pretty hard to reason about operands with different signs; // (and especially with possibly different signs). We simply check if it; // can be zero. In order to conclude that the result could not be zero,; // at least one of the operands should be definitely not zero itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:122,simpl,simply,122,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['simpl'],['simply']
Usability,"// It is redundant to fully-specify this here, but nice to make it explicit; // so that it is clear the DXIL module version is different.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp:94,clear,clear,94,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,1,['clear'],['clear']
Usability,"// It is simpler to work with 2x instead of 0.5p, and we do not need to lose; // any fraction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:9,simpl,simpler,9,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['simpl'],['simpler']
Usability,"// It is valid for MachineBasicBlocks to not finish with a branch instruction.; // In such cases, they will simply fallthrough their immediate successor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:108,simpl,simply,108,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,1,['simpl'],['simply']
Usability,"// It might simply be an unmangled global name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:12,simpl,simply,12,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['simpl'],['simply']
Usability,// It overflows only when both arguments are negative and the true; // product is exactly the minimum negative number.; // E.g. mul i16 with 17 sign bits: 0xff00 * 0xff80 = 0x8000; // For simplicity we just check if at least one side is not negative.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:188,simpl,simplicity,188,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['simpl'],['simplicity']
Usability,"// It really isn't clear at all what this means, since properties; // are ""dynamic by default"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:19,clear,clear,19,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['clear'],['clear']
Usability,// It should also work without multilibs in a simplified toolchain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:46,simpl,simplified,46,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['simpl'],['simplified']
Usability,// It should be used in a GEP or a simple arithmetic like; // ZEXT/SEXT which is used for GEP.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp:35,simpl,simple,35,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,1,['simpl'],['simple']
Usability,// It should not be 'pause' f3 90,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp:21,pause,pause,21,interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,1,['pause'],['pause']
Usability,"// It simplifies to V. Form ""A op V"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:6,simpl,simplifies,6,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplifies']
Usability,"// It simplifies to V. Form ""B op V"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:6,simpl,simplifies,6,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplifies']
Usability,"// It simplifies to V. Form ""V op B"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:6,simpl,simplifies,6,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplifies']
Usability,"// It simplifies to V. Form ""V op C"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:6,simpl,simplifies,6,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplifies']
Usability,"// It would be incorrect to import an appending linkage variable,; // since it would cause global constructors/destructors to be; // executed multiple times. This should have already been handled; // by linkIfNeeded, and we will assert in shouldLinkFromSource; // if we try to import, so we simply return AppendingLinkage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:291,simpl,simply,291,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,1,['simpl'],['simply']
Usability,// It's a simple name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/Archive.cpp:10,simpl,simple,10,interpreter/llvm-project/llvm/lib/Object/Archive.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/Archive.cpp,1,['simpl'],['simple']
Usability,// It's a simple symbol reference with no addend.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:10,simpl,simple,10,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,1,['simpl'],['simple']
Usability,// It's always cheaper to replace a xor+movd with xorps and simplifies further; // combines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:60,simpl,simplifies,60,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplifies']
Usability,// It's an undefined behaviour to divide by 0 and it seems like we know; // for sure that RHS is 0. Let's say that the resulting range is; // simply infeasible for that matter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:142,simpl,simply,142,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['simpl'],['simply']
Usability,"// It's in a private header; we can't #include it.; // FIXME: If there's a public header in some module that re-exports it,; // then we could suggest including that, but it's not clear that's the; // expected way to make this entity visible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:179,clear,clear,179,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['clear'],['clear']
Usability,"// It's legal for numElements to be zero. This can happen both; // dynamically, because x can be zero in 'new A[x]', and statically,; // because of GCC extensions that permit zero-length arrays. There; // are probably legitimate places where we could assume that this; // doesn't happen, but it's not clear that it's worth it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:301,clear,clear,301,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,1,['clear'],['clear']
Usability,"// It's less confusing if notes that don't actually have ranges don't have; // markers. For example, a marker for 'with ""VAR"" equal to ""5""' would; // seem to indicate where ""VAR"" matches, but the location we actually have; // for the marker simply points to the start of the match/search range for; // the full pattern of which the substitution is potentially just one; // component.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/FileCheck/FileCheck.cpp:241,simpl,simply,241,interpreter/llvm-project/llvm/utils/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/FileCheck/FileCheck.cpp,1,['simpl'],['simply']
Usability,"// It's not completely clear under the standard whether we can; // const_cast bit-field gl-values. Doing so would not be; // intrinsically complicated, but for now, we say no for; // consistency with other compilers and await the word of the; // committee.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:23,clear,clear,23,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,1,['clear'],['clear']
Usability,"// It's not impossible to split EHPad blocks, but if BlockColors already exist; // it require updating BlockColors for all offspring blocks accordingly. By; // skipping such corner case, we can make updating BlockColors after splitting; // predecessor fairly simple.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:259,simpl,simple,259,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['simpl'],['simple']
Usability,"// It's possible the bits taken off by the truncate were all sign bits. If; // so, we should be able to simplify this further.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:104,simpl,simplify,104,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['simpl'],['simplify']
Usability,"// It's possible the bits taken off by the truncate were all zero bits. If; // so, we should be able to simplify this further.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:104,simpl,simplify,104,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['simpl'],['simplify']
Usability,"// It's possible there were simply no /valid/ return statements.; // In this case, the first one we found may have at least given us a type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:28,simpl,simply,28,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,1,['simpl'],['simply']
Usability,// It's simpler if this doesn't need to consider alignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h:8,simpl,simpler,8,interpreter/llvm-project/clang/include/clang/Sema/Overload.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h,1,['simpl'],['simpler']
Usability,"// It's unsafe to duplicate convergent instructions in this context, so set; // BBI.CannotBeCopied to true if MI is convergent. To see why, consider the; // following CFG, which is subject to our ""simple"" transformation.; //; // BB0 // if (c1) goto BB1; else goto BB2;; // / \; // BB1 |; // | BB2 // if (c2) goto TBB; else goto FBB;; // | / |; // | / |; // TBB |; // | |; // | FBB; // |; // exit; //; // Suppose we want to move TBB's contents up into BB1 and BB2 (in BB1 they'd; // be unconditional, and in BB2, they'd be predicated upon c2), and suppose; // TBB contains a convergent instruction. This is safe iff doing so does; // not add a control-flow dependency to the convergent instruction -- i.e.,; // it's safe iff the set of control flows that leads us to the convergent; // instruction does not get smaller after the transformation.; //; // Originally we executed TBB if c1 || c2. After the transformation, there; // are two copies of TBB's instructions. We get to the first if c1, and we; // get to the second if !c1 && c2.; //; // There are clearly fewer ways to satisfy the condition ""c1"" than; // ""c1 || c2"". Since we've shrunk the set of control flows which lead to; // our convergent instruction, the transformation is unsafe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:197,simpl,simple,197,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,2,"['clear', 'simpl']","['clearly', 'simple']"
Usability,// Iterate over all equivalence classes and try to simplify them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:51,simpl,simplify,51,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['simpl'],['simplify']
Usability,"// Iterate over all symbols and try to simplify them. Once a symbol is; // simplified then we check if we can merge the simplified symbol's equivalence; // class to this class. This way, we simplify not just the symbols but the; // classes as well: we strive to keep the number of the classes to be the; // absolute minimum.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:39,simpl,simplify,39,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,4,['simpl'],"['simplified', 'simplify']"
Usability,// Iterate the symbols in the input file and if the input has preserved symbol; // compute the GUID for the symbol.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:95,GUID,GUID,95,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,1,['GUID'],['GUID']
Usability,// Iterate through all the GUID in the index and create slots for them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:27,GUID,GUID,27,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,1,['GUID'],['GUID']
Usability,"// Iterate through the fields setting bitFieldInfo and the Fields array. Also; // locate the ""most appropriate"" storage type. The heuristic for finding the; // storage type isn't necessary, the first (non-0-length-bitfield) field's; // type would work fine and be simpler but would be different than what we've; // been doing and cause lit tests to change.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp:264,simpl,simpler,264,interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,1,['simpl'],['simpler']
Usability,"// Iterates over all clusters of `source` and merges their pages into `destination`.; // It is assumed that all columns in `commonColumns` are present (and compatible) in both the source and; // the destination's schemas.; // The pages may be ""fast-merged"" (i.e. simply copied with no decompression/recompression) if the target; // compression is unspecified or matches the original compression settings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:263,simpl,simply,263,tree/ntuple/v7/src/RNTupleMerger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx,1,['simpl'],['simply']
Usability,"// Iterating over NewPhiNodes is deterministic, so it is safe to try to; // simplify and RAUW them as we go. If it was not, we could add uses to; // the values we replace with in a non-deterministic order, thus creating; // non-deterministic def->use chains.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:76,simpl,simplify,76,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['simpl'],['simplify']
Usability,"// Join the environment with itself so that we discard the entries from; // `ExprToLoc` and `ExprToVal`.; // FIXME: We could consider writing special-case code for this that only; // does the discarding, but it's not clear if this is worth it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp:217,clear,clear,217,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp,1,['clear'],['clear']
Usability,"// JsMVA progress bar maximum (100%)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDNN.cxx:9,progress bar,progress bar,9,tmva/tmva/src/MethodDNN.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDNN.cxx,1,['progress bar'],['progress bar']
Usability,"// June2023: Added this because found that generation was otherwise getting progressively slower; // the RooAbsPdf::generate does a clone, and it seems that the RooCacheManager of the original pdf; // is getting polluted on each generate call, causing it to grow larger and therefore the clone of it; // to take longer and longer. So sterilize to clear the caches of all components",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooFit.cxx:347,clear,clear,347,roofit/xroofit/src/xRooFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooFit.cxx,1,['clear'],['clear']
Usability,// Just add the constraint to the expression without trying to simplify.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp:63,simpl,simplify,63,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleConstraintManager.cpp,2,['simpl'],['simplify']
Usability,// Just because a file with a matching name was found and it was an actual; // PDB file doesn't mean it matches. For it to match the InfoStream's GUID; // must match the GUID specified in the TypeServer2 record.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewReader.cpp:146,GUID,GUID,146,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewReader.cpp,2,['GUID'],['GUID']
Usability,"// Just delegate to the generic legality, clear masks aren't special.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:42,clear,clear,42,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['clear'],['clear']
Usability,// Just do a simple loop over ever-increasing unit sizes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp:13,simpl,simple,13,interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,1,['simpl'],['simple']
Usability,// Just recognize a simple case for now. In future we'll need to match; // indexing patterns for base + index + constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:20,simpl,simple,20,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,1,['simpl'],['simple']
Usability,"// Just transferring between blocks in the same function, simply update the; // parent fields in the instructions...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SymbolTableListTraitsImpl.h:58,simpl,simply,58,interpreter/llvm-project/llvm/lib/IR/SymbolTableListTraitsImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SymbolTableListTraitsImpl.h,1,['simpl'],['simply']
Usability,"// KERNEL_CODE_ENTRY_BYTE_OFFSET; // So far no directive controls this for Code Object V3, so simply skip for; // disassembly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp:94,simpl,simply,94,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,1,['simpl'],['simply']
Usability,"// KNL does not recognize dependency-breaking idioms for mask registers,; // so kxnor %k1, %k1, %k2 has a RAW dependence on %k1.; // Using %k0 as the undef input register is a performance heuristic based; // on the assumption that %k0 is used less frequently than the other mask; // registers, since it is not usable as a write mask.; // FIXME: A more advanced approach would be to choose the best input mask; // register based on context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:310,usab,usable,310,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['usab'],['usable']
Usability,// Keep things simple. Don't touch loop-variant strides unless they're; // only used outside the loop and we can simplify them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:15,simpl,simple,15,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,2,['simpl'],"['simple', 'simplify']"
Usability,"// Keep track of implicit defs of CSMI and MI, to clear possibly; // made-redundant kill flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:50,clear,clear,50,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['clear'],['clear']
Usability,"// Keep track of the TypeTests array index needing a forward reference.; // We will save the location of the GUID needing an update, but; // can only do so once the std::vector is finalized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:109,GUID,GUID,109,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['GUID'],['GUID']
Usability,"// Keep track of the array index needing a forward reference.; // We will save the location of the GUID needing an update, but; // can only do so once the caller's std::vector is finalized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:99,GUID,GUID,99,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['GUID'],['GUID']
Usability,"// Keeps track of which resources are busy, and how many cycles are left; // before those become usable again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:97,usab,usable,97,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['usab'],['usable']
Usability,"// Kernel function with a kernel parameter gamma for; // each input variable. Described in ""An Introduction to; // Support Vector Machines and Other Kernel-based Learning; // Methods"" by Cristianini and Shawe-Taylor, Section 3.5",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SVKernelFunction.cxx:162,Learn,Learning,162,tmva/tmva/src/SVKernelFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SVKernelFunction.cxx,1,['Learn'],['Learning']
Usability,"// Kill flags are going to be wrong if the live ranges were overlapping.; // Eventually, we should simply clear all kill flags when computing live; // ranges. They are reinserted after register allocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:99,simpl,simply,99,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,2,"['clear', 'simpl']","['clear', 'simply']"
Usability,// LHBRX and LWBRX always clear the higher-order bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:26,clear,clear,26,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['clear'],['clear']
Usability,"// LLVM arranges the stack as follows:; // ...; // ARG2; // ARG1; // RETADDR; // PUSH RBP <-- RBP points here; // PUSH CSRs; // ~~~~~~~ <-- possible stack realignment (non-win64); // ...; // STACK OBJECTS; // ... <-- RSP after prologue points here; // ~~~~~~~ <-- possible stack realignment (win64); //; // if (hasVarSizedObjects()):; // ... <-- ""base pointer"" (ESI/RBX) points here; // DYNAMIC ALLOCAS; // ... <-- RSP points here; //; // Case 1: In the simple case of no stack realignment and no dynamic; // allocas, both ""fixed"" stack objects (arguments and CSRs) are addressable; // with fixed offsets from RSP.; //; // Case 2: In the case of stack realignment with no dynamic allocas, fixed; // stack objects are addressed with RBP and regular stack objects with RSP.; //; // Case 3: In the case of dynamic allocas and stack realignment, RSP is used; // to address stack arguments for outgoing calls and nothing else. The ""base; // pointer"" points to local variables, and RBP points to fixed objects.; //; // In cases 2 and 3, we can only answer for non-fixed stack objects, and the; // answer we give is relative to the SP after the prologue, and not the; // SP in the middle of the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:454,simpl,simple,454,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['simpl'],['simple']
Usability,"// LM: change to 4 (piece-wise linear to 6th order polynomial interpolation + linear extrapolation ); //interp.setAllInterpCodes(0); // simple linear interpolation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx:136,simpl,simple,136,roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,1,['simpl'],['simple']
Usability,"// LMUL1 should be kind of VectorTypeModifier, but that might come with; // Widening2XVector for widening reduction.; // However that might require VectorTypeModifier become bitmask rather than; // simple enum, so we decide keek LMUL1 in TypeModifier for code size; // optimization of clang binary size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Support/RISCVVIntrinsicUtils.h:198,simpl,simple,198,interpreter/llvm-project/clang/include/clang/Support/RISCVVIntrinsicUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Support/RISCVVIntrinsicUtils.h,1,['simpl'],['simple']
Usability,"// LOCAL_ESCAPE uses a single offset, with no register. It only works in the; // simple FP case, and doesn't work with stack realignment. On 32-bit, the; // offset is from the traditional base pointer location. On 64-bit, the; // offset is from the SP at the end of the prologue, not the FP location. This; // matches the behavior of llvm.frameaddress.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp:81,simpl,simple,81,interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp,1,['simpl'],['simple']
Usability,"// LOGSEVERITY_VERBOSE, LOGSEVERITY_INFO, LOGSEVERITY_WARNING,; // LOGSEVERITY_ERROR, LOGSEVERITY_DISABLE; // settings.uncaught_exception_stack_size = 100;; // settings.ignore_certificate_errors = true;; // settings.remote_debugging_port = 7890;; // SimpleApp implements application-level callbacks for the browser process.; // It will create the first browser instance in OnContextInitialized() after; // CEF has initialized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/src/RCefWebDisplayHandle.cxx:250,Simpl,SimpleApp,250,gui/cefdisplay/src/RCefWebDisplayHandle.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/src/RCefWebDisplayHandle.cxx,1,['Simpl'],['SimpleApp']
Usability,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:559,usab,usability,559,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,2,"['simpl', 'usab']","['simplify', 'usability']"
Usability,"// LSE has an atomic load-clear instruction, but not a load-and.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:26,clear,clear,26,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['clear'],['clear']
Usability,"// LSR sets the insertion point for AddRec start/step values to the; // block start to simplify value reuse, even though it's an invalid; // position. SCEVExpander must correct for this in all cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:87,simpl,simplify,87,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['simpl'],['simplify']
Usability,// Last MI in the BB is an unconditional branch. Can we simply invert the; // condition and swap destinations:; // beq L1; // b L2; // =>; // bne L2; // b L1,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp:56,simpl,simply,56,interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,1,['simpl'],['simply']
Usability,// Last MI in the BB is an unconditional branch. Can we simply invert the; // condition and swap destinations:; // beqz L1; // b L2; // =>; // bnez L2; // b L1,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:56,simpl,simply,56,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,2,['simpl'],['simply']
Usability,// Last MI in the BB is an unconditional branch. We can simply invert the; // condition and swap destinations:; // beq L1; // b L2; // =>; // bne L2; // b L1,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:56,simpl,simply,56,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,1,['simpl'],['simply']
Usability,"// Last bit should always be clear.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/TBasket.cxx:29,clear,clear,29,tree/tree/test/TBasket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/TBasket.cxx,1,['clear'],['clear']
Usability,// Later tables overwrite earlier ones.; // FIXME: Modules will have some trouble with this. This is clearly not; // the right way to do this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:101,clear,clearly,101,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['clear'],['clearly']
Usability,// Learn unreachability from ExportSummary if ExportSummary is present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:3,Learn,Learn,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['Learn'],['Learn']
Usability,"// Learn whether the last use/def of each cross-iteration register is a use or; // def. If it is a def, RegisterPressure will implicitly increase max pressure; // and we do not have to add the pressure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:3,Learn,Learn,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['Learn'],['Learn']
Usability,"// Learning Rate Scheduler",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx:3,Learn,Learning,3,tmva/pymva/src/MethodPyTorch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx,1,['Learn'],['Learning']
Usability,"// Learning mode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:3,Learn,Learning,3,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['Learn'],['Learning']
Usability,"// Learning mode; // The learning phase should start from the minimum entry in the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:3,Learn,Learning,3,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,"['Learn', 'learn']","['Learning', 'learning']"
Usability,// Leave final.suspend to handleFinalSuspend since it is undefined behavior; // to resume a coroutine suspended at the final suspend point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:83,resume,resume,83,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['resume'],['resume']
Usability,// Leave loop by going to the immediate dominator of the loop header.; // This is a bigger stride than simply walking up the dominator tree.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:103,simpl,simply,103,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,1,['simpl'],['simply']
Usability,// Leave simple R +/- imm12 operands for LDRi12,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:9,simpl,simple,9,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['simpl'],['simple']
Usability,// Leaving bits 0-2 clear indicates catch.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:20,clear,clear,20,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,1,['clear'],['clear']
Usability,"// LegalizeUpdates function simplifies updates assuming a graph structure.; // This function serves double purpose:; // a) It removes redundant updates, which makes it easier to reverse-apply; // them when traversing CFG.; // b) It optimizes away updates that cancel each other out, as the end result; // is the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CFGUpdate.h:28,simpl,simplifies,28,interpreter/llvm-project/llvm/include/llvm/Support/CFGUpdate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CFGUpdate.h,1,['simpl'],['simplifies']
Usability,// Lift some types from the dependent base class into this class for; // simplicity of referring to them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:73,simpl,simplicity,73,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,2,['simpl'],['simplicity']
Usability,"// Like the similar transform in instsimplify, this requires 'nsz' because; // sqrt(-0.0) = -0.0, and -0.0 * -0.0 does not simplify to -0.0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:123,simpl,simplify,123,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['simpl'],['simplify']
Usability,"// Likewise, if this is a context where the identifier could be a template; // name, check whether this is a deduction guide declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:119,guid,guide,119,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['guid'],['guide']
Usability,// Limit this to simple scalars for now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:17,simpl,simple,17,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,2,['simpl'],['simple']
Usability,"// List of canonical arch names (use getArchSynonym).; // This table also provides the build attribute fields for CPU arch; // and Arch ID, according to the Addenda to the ARM ABI, chapters; // 2.4 and 2.3.5.2 respectively.; // FIXME: SubArch values were simplified to fit into the expectations; // of the triples and are not conforming with their official names.; // Check to see if the expectation should be changed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/ARMTargetParser.h:255,simpl,simplified,255,interpreter/llvm-project/llvm/include/llvm/TargetParser/ARMTargetParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/ARMTargetParser.h,1,['simpl'],['simplified']
Usability,// Lists simply expand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/SetTheory.cpp:9,simpl,simply,9,interpreter/llvm-project/llvm/lib/TableGen/SetTheory.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/SetTheory.cpp,1,['simpl'],['simply']
Usability,"// Lists that keep the information for each dependency. All the lists are; // meant to be updated in sync. We are adopting separate lists instead of a; // list of structs, because that simplifies forwarding the actions list to; // initialize the inputs of the base Action class.; /// The dependence actions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Action.h:185,simpl,simplifies,185,interpreter/llvm-project/clang/include/clang/Driver/Action.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Action.h,1,['simpl'],['simplifies']
Usability,// Little endian intrinsics are simple and don't require any argument; // swapping.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:32,simpl,simple,32,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,1,['simpl'],['simple']
Usability,// Load FP Control Word from stack slot and clear RM field (bits 11:10).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:44,clear,clear,44,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['clear'],['clear']
Usability,// Load MXCSR from stack slot and clear RM field (bits 14:13).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,clear,clear,34,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['clear'],['clear']
Usability,// Load the block and do a simple retain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:27,simpl,simple,27,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,1,['simpl'],['simple']
Usability,"// Load the first entry in the range. SetEntry() will also call SetProxies(),; // thus adding all the branches to the cache and triggering the learning phase.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx:143,learn,learning,143,tree/treeplayer/src/TTreeReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx,1,['learn'],['learning']
Usability,"// Local to global var promotion used by optimization like thinlto; // will rename the var and add suffix like "".llvm.xxx"" to the; // original local name. In sample profile, the suffixes of function; // names are all stripped. Since it is possible that the mapper is; // built in post-thin-link phase and var promotion has been done,; // we need to add the substring of function name without the suffix; // into the GUIDToFuncNameMap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:416,GUID,GUIDToFuncNameMap,416,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['GUID'],['GUIDToFuncNameMap']
Usability,"// Locate FeedBackCanvas",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:10,FeedBack,FeedBackCanvas,10,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['FeedBack'],['FeedBackCanvas']
Usability,"// Look at blocks (IBB) with multiple predecessors (PBB).; // We change each predecessor to a canonical form, by; // (1) temporarily removing any unconditional branch from the predecessor; // to IBB, and; // (2) alter conditional branches so they branch to the other block; // not IBB; this may require adding back an unconditional branch to IBB; // later, where there wasn't one coming in. E.g.; // Bcc IBB; // fallthrough to QBB; // here becomes; // Bncc QBB; // with a conceptual B to IBB after that, which never actually exists.; // With those changes, we see whether the predecessors' tails match,; // and merge them if so. We change things out of canonical form and; // back to the way they were later in the process. (OptimizeBranches; // would undo some of this, but we can't use it, because we'd get into; // a compile-time infinite loop repeatedly doing and undoing the same; // transformations.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:752,undo,undo,752,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,2,['undo'],"['undo', 'undoing']"
Usability,"// Look for X == 0, X == 1, X != 0, or X != 1. We can simplify some forms of; // these.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:54,simpl,simplify,54,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,1,['simpl'],['simplify']
Usability,"// Look for X == 0, X == 1, X != 0, or X != 1. We can simplify some forms; // of these.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:54,simpl,simplify,54,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplify']
Usability,"// Look for a FP Saturation pattern, where the instruction can be simplified to; // a fptosi.sat. max(min(fptosi)). The constant in this case is always free.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:66,simpl,simplified,66,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,1,['simpl'],['simplified']
Usability,// Look for a deduction guide template<T> A(...) -> A<...>;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:24,guid,guide,24,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['guid'],['guide']
Usability,"// Look for a math+logic pattern that corresponds to sext-in-register of a; // value with cleared high bits. Convert that into a pair of shifts:; // add (xor X, 0x80), 0xF..F80 --> (X << ShAmtC) >>s ShAmtC; // add (xor X, 0xF..F80), 0x80 --> (X << ShAmtC) >>s ShAmtC",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:90,clear,cleared,90,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['clear'],['cleared']
Usability,"// Look for a sign/zero/fpextend extend of a larger than legal load. This can be; // split into multiple extending loads, which are simpler to deal with than an; // arbitrary extend. For fp extends we use an integer extending load and a VCVTL; // to convert the type to an f32.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:132,simpl,simpler,132,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['simpl'],['simpler']
Usability,// Look for a simple IV counter LHS,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:14,simpl,simple,14,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['simpl'],['simple']
Usability,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:40,simpl,simple,40,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,2,['simpl'],['simple']
Usability,"// Look for simple operators",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:12,simpl,simple,12,hist/hist/src/TFormula_v5.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx,1,['simpl'],['simple']
Usability,// Look for simplifications involving one or two shuffle instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:12,simpl,simplifications,12,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplifications']
Usability,// Look for suitable value in simple conditions at the loop exits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:30,simpl,simple,30,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['simpl'],['simple']
Usability,// Look through extract element. At the moment we keep this simple and skip; // tracking the specific element. But at least we might find information; // valid for all elements of the vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:60,simpl,simple,60,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['simpl'],['simple']
Usability,"// Look through extract element. At the moment we keep this simple and; // skip tracking the specific element. But at least we might find; // information valid for all elements of the vector (for example if vector; // is sign extended, shifted, etc).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:60,simpl,simple,60,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['simpl'],['simple']
Usability,// Look up ValueInfo with the GUID in the current linkage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:30,GUID,GUID,30,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['GUID'],['GUID']
Usability,"// Look up the analysis usage from the pass instance (different instances; // of the same pass can produce different results), but unique the; // resulting object to reduce memory usage. This helps to greatly reduce; // memory usage when we have many instances of only a few pass types; // (e.g. instcombine, simplifycfg, etc...) which tend to share a fixed set; // of dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:309,simpl,simplifycfg,309,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,1,['simpl'],['simplifycfg']
Usability,"// Loop Unrolling might create new loops. While we do preserve LoopInfo, we; // might break loop-simplified form for these loops (as they, e.g., would; // share the same exit blocks). We'll keep track of loops for which we can; // break this so that later we can re-simplify them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:97,simpl,simplified,97,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,2,['simpl'],"['simplified', 'simplify']"
Usability,"// Loop is not in LoopSimplify form, no need to re simplify after; // splitting edge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:51,simpl,simplify,51,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,1,['simpl'],['simplify']
Usability,// Loop must be in loop simplify form.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:24,simpl,simplify,24,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,1,['simpl'],['simplify']
Usability,"// Loop over all of the PHI nodes, looking for a simple counter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:49,simpl,simple,49,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['simpl'],['simple']
Usability,"// Loop over the set of registered outer invalidation mappings and if any; // of them map to an analysis that is now invalid, clear it out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:126,clear,clear,126,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['clear'],['clear']
Usability,"// Loop-simplify form can be preserved, if we can split all in-loop; // predecessors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:8,simpl,simplify,8,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,2,['simpl'],['simplify']
Usability,"// LoopSimplify might fail to simplify some loops (e.g. when indirect; // branches are involved). In such situations, it might happen that an; // exit for Loop L1 is the header of a disjoint Loop L2. Thus, when we; // create PHIs in such an exit block, we are also inserting PHIs into L2's; // header. This could break LCSSA form for L2 because these inserted PHIs; // can also have uses outside of L2. Remember all PHIs in such situation; // as to revisit than later on. FIXME: Remove this if indirectbr support; // into LoopSimplify gets improved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:30,simpl,simplify,30,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,1,['simpl'],['simplify']
Usability,// LoopSink (and other loop passes since the last simplifyCFG) might have; // resulted in single-entry-single-exit or empty blocks. Clean up the CFG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:50,simpl,simplifyCFG,50,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['simpl'],['simplifyCFG']
Usability,"// LoopSink pass sinks instructions hoisted by LICM, which serves as a; // canonicalization pass that enables other optimizations. As a result,; // LoopSink pass needs to be a very late IR pass to avoid undoing LICM; // result too early.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:203,undo,undoing,203,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,2,['undo'],['undoing']
Usability,// Lower a node with an INSERT_SUBVECTOR opcode. This may result in a; // simple superregister reference or explicit instructions to insert; // the upper bits of a vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:74,simpl,simple,74,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simple']
Usability,"// Lower fpround and fpextend nodes that target the FP stack to be store and; // load to the stack. This is a gross hack. We would like to simply mark; // these as being illegal, but when we do that, legalize produces these when; // it expands calls, then expands these in the same legalize pass. We would; // like dag combine to be able to hack on these between the call expansion; // and the node legalization. As such this pass basically does ""really; // late"" legalization of these inline with the X86 isel pass.; // FIXME: This should only happen when not compiled with -O0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:139,simpl,simply,139,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['simpl'],['simply']
Usability,// Lower llvm.expect to metadata before attempting transforms.; // Compare/branch metadata may alter the behavior of passes like; // SimplifyCFG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:133,Simpl,SimplifyCFG,133,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['Simpl'],['SimplifyCFG']
Usability,// MB-ME+63 ME MB; // +----------------------+ +----------------------+; // |0000001111111111111111| -> |0001111100000011111111|; // +----------------------+ +----------------------+; // 0 63 0 63; // Rotate back by 64 - OnesOnLeft to undo previous rotate. Then clear on the; // left the number of ones we previously added.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:235,undo,undo,235,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,2,"['clear', 'undo']","['clear', 'undo']"
Usability,"// MCELFStreamer clear's the assembler's e_flags. However, for; // arm we manually set the ABI version on streamer creation, so; // do the same here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp:17,clear,clear,17,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp,1,['clear'],['clear']
Usability,"// MD5 version of NamesInProfile. Either NamesInProfile or GUIDsInProfile is; // populated, depends on whether the profile uses MD5. Because the name table; // generally contains several magnitude more entries than the number of; // functions, we do not want to convert all names from one form to another.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:59,GUID,GUIDsInProfile,59,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['GUID'],['GUIDsInProfile']
Usability,// MI should be moved right before v_or_b32.; // For this we should clear all kill flags on uses of MI src-operands or else; // we can encounter problem with use of killed operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPeepholeSDWA.cpp:68,clear,clear,68,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPeepholeSDWA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPeepholeSDWA.cpp,1,['clear'],['clear']
Usability,"// MINImize [maxcalls] [tolerance]; // also SIMplex, MIGrad and FUMili",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx:44,SIMpl,SIMplex,44,math/fumili/src/TFumili.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx,1,['SIMpl'],['SIMplex']
Usability,"// MOVMSK(SHUFFLE(X,u)) -> MOVMSK(X) iff every element is referenced.; // Since we peek through a bitcast, we need to be careful if the base vector; // type has smaller elements than the MOVMSK type. In that case, even if; // all the elements are demanded by the shuffle mask, only the ""high""; // elements which have highbits that align with highbits in the MOVMSK vec; // elements are actually demanded. A simplification of spurious operations; // on the ""low"" elements take place during other simplifications.; //; // For example:; // MOVMSK64(BITCAST(SHUF32 X, (1,0,3,2))) even though all the elements are; // demanded, because we are swapping around the result can change.; //; // To address this, we check that we can scale the shuffle mask to MOVMSK; // element width (this will ensure ""high"" elements match). Its slightly overly; // conservative, but fine for an edge case fold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:407,simpl,simplification,407,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['simpl'],"['simplification', 'simplifications']"
Usability,// MSVC appears to mangle GUIDs as if they were variables of type; // 'const struct __s_GUID'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:26,GUID,GUIDs,26,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,1,['GUID'],['GUIDs']
Usability,"// MXCSR: mask all floating-point exceptions, sets rounding to nearest, clear; // all exceptions, sets DAZ and FTZ to 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:72,clear,clear,72,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['clear'],['clear']
Usability,"// MachO large model always goes via a GOT, simply to get a single 8-byte; // absolute relocation on all global addresses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp:44,simpl,simply,44,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp,1,['simpl'],['simply']
Usability,// Machine architectures; // See current registered ELF machine architectures at:; // http://www.uxsglobal.com/developers/gabi/latest/ch4.eheader.html,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:97,ux,uxsglobal,97,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['ux'],['uxsglobal']
Usability,// Machine loop info is used to; // guide some heuristics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:36,guid,guide,36,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,1,['guid'],['guide']
Usability,// MachineIRBuilder::DebugLoc can outlive the DILocation it holds. Clear it; // to avoid accessing free’d memory (in runOnMachineFunction) and to avoid; // destroying it twice (in ~IRTranslator() and ~LLVMContext()),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:67,Clear,Clear,67,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,1,['Clear'],['Clear']
Usability,"// Macro fusion doesn't happen indeed, clear the pending.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:39,clear,clear,39,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,1,['clear'],['clear']
Usability,"// Macros to set, clear or test bits of the ""flags"" field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h:18,clear,clear,18,gui/guihtml/inc/TGHtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h,1,['clear'],['clear']
Usability,// Make A > 0 for simplicity. Negate cannot overflow at this point because; // the bit width has increased.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:18,simpl,simplicity,18,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['simpl'],['simplicity']
Usability,// Make a 32-bit mask w/ the referenced bits clear and all other bits set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:45,clear,clear,45,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['clear'],['clear']
Usability,"// Make a copy of the reference, and try issue it again.; // Do not take the instruction reference because SI.clear() will; // invalidate it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/InOrderIssueStage.cpp:110,clear,clear,110,interpreter/llvm-project/llvm/lib/MCA/Stages/InOrderIssueStage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/InOrderIssueStage.cpp,1,['clear'],['clear']
Usability,"// Make a second pass over the PHINodes now that all of them have been; // remapped into the new function, simplifying the PHINode and performing any; // recursive simplifications exposed. This will transparently update the; // WeakTrackingVH in the VMap. Notably, we rely on that so that if we coalesce; // two PHINodes, the iteration over the old PHIs remains valid, and the; // mapping will just map us to the new node (which may not even be a PHI; // node).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:107,simpl,simplifying,107,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,2,['simpl'],"['simplifications', 'simplifying']"
Usability,// Make an edge by using the previous probe id and current GUID.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:59,GUID,GUID,59,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,1,['GUID'],['GUID']
Usability,// Make sure all loads in the bundle are simple - we can't vectorize; // atomic or volatile loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:41,simpl,simple,41,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['simpl'],['simple']
Usability,// Make sure all stores in the bundle are simple - we can't vectorize; // atomic or volatile stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:42,simpl,simple,42,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['simpl'],['simple']
Usability,// Make sure everything beyond the low halfword gets set to zero since the SRL; // 16 will clear the top bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:91,clear,clear,91,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['clear'],['clear']
Usability,// Make sure method definition entries are all clear for next implementation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:47,clear,clear,47,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['clear'],['clear']
Usability,"// Make sure that all coro.save, coro.suspend and the fallthrough coro.end; // intrinsics are in their own blocks to simplify the logic of building up; // SuspendCrossing data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:117,simpl,simplify,117,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['simpl'],['simplify']
Usability,// Make sure that created prolog loop is in simplified form,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:44,simpl,simplified,44,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,1,['simpl'],['simplified']
Usability,// Make sure that loop-simplify form is preserved. We want to simplify; // at least one layer outside of the loop that was unrolled so that any; // changes to the parent loop exposed by the unrolling are considered.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:23,simpl,simplify,23,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,2,['simpl'],['simplify']
Usability,"// Make sure the cache is clear. It is important to clear it here, because; // the cache might be invalid even when just the firstPOI was changed, for which; // no accessor has to be called. (Fixes a bug when ToyMCSampler is; // used with the Neyman Construction)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCSampler.cxx:26,clear,clear,26,roofit/roostats/src/ToyMCSampler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCSampler.cxx,2,['clear'],['clear']
Usability,// Make sure the loop is in simplified form,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:28,simpl,simplified,28,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,1,['simpl'],['simplified']
Usability,"// Make sure the user's intent is clear (e.g. they're comparing against two; // int literals, or two things from the same enum)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:34,clear,clear,34,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['clear'],['clear']
Usability,"// Make sure this is not tied to an output register (or otherwise; // constrained). This is true for ST?UX registers, for example, which; // are tied to their output registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:104,UX,UX,104,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['UX'],['UX']
Usability,// Make sure unused high bits are cleared,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:34,clear,cleared,34,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['clear'],['cleared']
Usability,"// Make sure we didn't select an unusable deduction guide, and mark it; // as referenced.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:52,guid,guide,52,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['guid'],['guide']
Usability,"// Make sure we only rewrite using simple induction variables;; // otherwise, we can make the trip count of a loop unanalyzable; // to SCEV.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:35,simpl,simple,35,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['simpl'],['simple']
Usability,// Make the fixed object stored to mutable so that the load instructions; // referencing it have their memory dependencies added.; // Set the frame object as isAliased which clears the underlying objects; // vector in ScheduleDAGInstrs::buildSchedGraph() resulting in addition of all; // stores as dependencies for loads referencing this fixed object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:174,clear,clears,174,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['clear'],['clears']
Usability,// Make the ranges of the start and end point self-consistent with adjacent edges; // by forcing to use only the beginning of the range. This simplifies the layout; // logic for clients.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp:142,simpl,simplifies,142,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp,1,['simpl'],['simplifies']
Usability,"// Make the user use NewResult instead, and clear its kill flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:44,clear,clear,44,interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,1,['clear'],['clear']
Usability,// Making CFG changes likely means a loop got vectorized. Indicate that; // extra simplification passes should be run.; // TODO: MadeCFGChanges is not a prefect proxy. Extra passes should only; // be run if runtime checks have been added.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:82,simpl,simplification,82,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['simpl'],['simplification']
Usability,"// Making a call will trash LR and clear LO_BRANCH_INFO, so there's little; // point in generating a hardware loop if that's going to happen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:35,clear,clear,35,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,1,['clear'],['clear']
Usability,// Mangle a GUID object as if it were a variable with the corresponding; // mangled name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:12,GUID,GUID,12,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,1,['GUID'],['GUID']
Usability,// Manually implement a move constructor as we must clear the old allocator's; // slabs as a matter of correctness.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h:52,clear,clear,52,interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Allocator.h,1,['clear'],['clear']
Usability,"// Many other things have subexpressions, so we have to test those.; // Some are simple:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:81,simpl,simple,81,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,1,['simpl'],['simple']
Usability,// Map from function guid to real function names. Only used in md5 mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleContextTracker.h:21,guid,guid,21,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleContextTracker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleContextTracker.h,1,['guid'],['guid']
Usability,"// Map to save ValueId to ValueInfo association that was recorded in the; // ValueSymbolTable. It is used after the VST is parsed to convert; // call graph edges read from the function summary from referencing; // callees by their ValueId to using the ValueInfo instead, which is how; // they are recorded in the summary index being built.; // We save a GUID which refers to the same global as the ValueInfo, but; // ignoring the linkage, i.e. for values other than local linkage they are; // identical (this is the second tuple member).; // The third tuple member is the real GUID of the ValueInfo.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:354,GUID,GUID,354,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,2,['GUID'],['GUID']
Usability,// Maps codeview::SimpleTypeKind of a built-in type to the parameters necessary; // to instantiate a NativeBuiltinSymbol for that type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/SymbolCache.cpp:18,Simpl,SimpleTypeKind,18,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/SymbolCache.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/SymbolCache.cpp,1,['Simpl'],['SimpleTypeKind']
Usability,"// Mark a coroutine as done, which implies that the coroutine is finished and; // never get resumed.; //; // In resume-switched ABI, the done state is represented by storing zero in; // ResumeFnAddr.; //; // NOTE: We couldn't omit the argument `FramePtr`. It is necessary because the; // pointer to the frame in splitted function is not stored in `Shape`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:92,resume,resumed,92,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,3,"['Resume', 'resume']","['ResumeFnAddr', 'resume-switched', 'resumed']"
Usability,"// Mark all suspend blocks and indicate that they kill everything they; // consume. Note, that crossing coro.save also requires a spill, as any code; // between coro.save and coro.suspend may resume the coroutine and all of the; // state needs to be saved by that time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:192,resume,resume,192,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['resume'],['resume']
Usability,// Mark that the function is fully simplified and that it shouldn't be; // simplified again if we somehow revisit it due to CGSCC mutations unless; // it's been modified since.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:35,simpl,simplified,35,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,2,['simpl'],['simplified']
Usability,// Mark the new function `noreturn` if applicable. Terminators which resume; // exception propagation are treated as returning instructions. This is to; // avoid inserting traps after calls to outlined functions which unwind.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:69,resume,resume,69,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,1,['resume'],['resume']
Usability,// Mask of discriminators before this pass.; // TODO(xur): simplify this once we switch to ImprovedFSDiscriminator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp:59,simpl,simplify,59,interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp,1,['simpl'],['simplify']
Usability,"// Masking the negated extension of a boolean is just the zero-extended; // boolean:; // and (sub 0, zext(bool X)), 1 --> zext(bool X); // and (sub 0, sext(bool X)), 1 --> zext(bool X); //; // Note: the SimplifyDemandedBits fold below can make an information-losing; // transform, and then we have no way to find this better fold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:203,Simpl,SimplifyDemandedBits,203,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,"// Match a simple increment by constant operation. Note that if a sub is; // matched, the step is negated (as if the step had been canonicalized to; // an add, even though we leave the instruction alone.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:11,simpl,simple,11,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['simpl'],['simple']
Usability,"// Match a simple recurrence of the form: <start, ShiftOp, Step>, and then; // use information about the trip count to improve our available range. Note; // that the trip count independent cases are already handled by known bits.; // WARNING: The definition of recurrence used here is subtly different than; // the one used by AddRec (and thus most of this file). Step is allowed to; // be arbitrarily loop varying here, where AddRec allows only loop invariant; // and other addrecs in the same loop (for non-affine addrecs). The code; // below intentionally handles the case where step is not loop invariant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:11,simpl,simple,11,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['simpl'],['simple']
Usability,"// Match a simple, non-extended load that can be converted to a; // legal {z/s}ext-load.; // TODO: Allow widening of an existing {z/s}ext-load?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:11,simpl,simple,11,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simple']
Usability,// Match failed: clear all the PHITag values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:17,clear,clear,17,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,1,['clear'],['clear']
Usability,// Match prototypes and calling conventions of resume function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:47,resume,resume,47,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['resume'],['resume']
Usability,// Match simple R + imm12 operands.; // Base only.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:9,simpl,simple,9,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,2,['simpl'],['simple']
Usability,// Match simple R - imm8 operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:9,simpl,simple,9,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['simpl'],['simple']
Usability,// Match simple Reg + uimm6 operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp:9,simpl,simple,9,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,1,['simpl'],['simple']
Usability,"// Match the following pattern, which is a common idiom when writing; // overflow-safe integer arithmetic functions. The source performs an addition; // in wider type and explicitly checks for overflow using comparisons against; // INT_MIN and INT_MAX. Simplify by using the sadd_with_overflow intrinsic.; //; // TODO: This could probably be generalized to handle other overflow-safe; // operations if we worked out the formulas to compute the appropriate magic; // constants.; //; // sum = a + b; // if (sum+128 >u 255) ... -> llvm.sadd.with.overflow.i8",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:253,Simpl,Simplify,253,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['Simpl'],['Simplify']
Usability,"// Match this pattern so that we can generate simpler code:; //; // %a = ...; // %b = and i32 %a, 2; // %c = srl i32 %b, 1; // brcond i32 %c ...; //; // into; //; // %a = ...; // %b = and i32 %a, 2; // %c = setcc eq %b, 0; // brcond %c ...; //; // This applies only when the AND constant value has one bit set and the; // SRL constant is equal to the log2 of the AND constant. The back-end is; // smart enough to convert the result into a TEST/JMP sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:46,simpl,simpler,46,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simpler']
Usability,// Materialized typedefs/type alias for implicit deduction guides may require; // instantiation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:59,guid,guides,59,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['guid'],['guides']
Usability,// Maximum of set/clear bits is the bit width.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:18,clear,clear,18,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['clear'],['clear']
Usability,// Maybe a usable Header Unit,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:11,usab,usable,11,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['usab'],['usable']
Usability,// Maybe a usable clang header module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:11,usab,usable,11,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['usab'],['usable']
Usability,// Maybe the AND has been removed by simplify-demanded-bits; // or is useful because it discards more bits,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:37,simpl,simplify-demanded-bits,37,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['simpl'],['simplify-demanded-bits']
Usability,"// Meanwhile, the user might have requested clusters outside the look-ahead window, so that we don't; // need the cluster anymore, in which case we simply discard it right away, before moving it to the pool",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:148,simpl,simply,148,tree/ntuple/v7/src/RClusterPool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx,1,['simpl'],['simply']
Usability,"// Member pointer types need to be expanded, but it's a simple form of; // expansion that 'Direct' can handle. Note that CanBeFlattened should be; // true for this to work.; // 'void' needs to be ignored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp:56,simpl,simple,56,interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,1,['simpl'],['simple']
Usability,"// MemorySSA cares whether the cloned instruction was inserted or not, and; // not whether it can be remapped to a simplified value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:115,simpl,simplified,115,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,1,['simpl'],['simplified']
Usability,// Merging blocks may remove blocks reference in the block disposition cache. Clear the cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:78,Clear,Clear,78,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,1,['Clear'],['Clear']
Usability,"// Message sends are expected to return a zero value when the; // receiver is nil. At one point, this was only guaranteed for; // simple integer and pointer types, but expectations have grown; // over time.; //; // Given a nil receiver, the GNU runtime's message lookup will; // return a stub function that simply sets various return-value; // registers to zero and then returns. That's good enough for us; // if and only if (1) the calling conventions of that stub are; // compatible with the signature we're using and (2) the registers; // it sets are sufficient to produce a zero value of the return type.; // Rather than doing a whole target-specific analysis, we assume it; // only works for void, integer, and pointer types, and in all; // other cases we do an explicit nil check is emitted code. In; // addition to ensuring we produce a zero value for other types, this; // sidesteps the few outright CC incompatibilities we know about that; // could otherwise lead to crashes, like when a method is expected to; // return on the x87 floating point stack or adjust the stack pointer; // because of an indirect return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:130,simpl,simple,130,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,2,['simpl'],"['simple', 'simply']"
Usability,"// MetadataAsValue uses a canonical format which strips the actual MDNode for; // MDNode with just a single constant value, storing just a ConstantAsMetadata; // This undoes this canonicalization, reconstructing the MDNode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp:167,undo,undoes,167,interpreter/llvm-project/llvm/lib/IR/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp,1,['undo'],['undoes']
Usability,"// Mixed:; // (icmp eq (A & B), C) & (icmp eq (A & D), E); // We already know that B & C == C && D & E == E.; // If we can prove that (B & D) & (C ^ E) == 0, that is, the bits of; // C and E, which are shared by both the mask B and the mask D, don't; // contradict, then we can transform to; // -> (icmp eq (A & (B|D)), (C|E)); // Currently, we only handle the case of B, C, D, and E being constant.; // We can't simply use C and E because we might actually handle; // (icmp ne (A & B), B) & (icmp eq (A & D), D); // with B and D, having a single bit set.; // NotMixed:; // (icmp ne (A & B), C) & (icmp ne (A & D), E); // -> (icmp ne (A & (B & D)), (C & E)); // Check the intersection (B & D) for inequality.; // Assume that (B & D) == B || (B & D) == D, i.e B/D is a subset of D/B; // and (B & D) & (C ^ E) == 0, bits of C and E, which are shared by both the; // B and the D, don't contradict.; // Note that we can assume (~B & C) == 0 && (~D & E) == 0, previous; // operation should delete these icmps if it hadn't been met.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:413,simpl,simply,413,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['simpl'],['simply']
Usability,// Mixing calling conventions here is very clearly an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:43,clear,clearly,43,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['clear'],['clearly']
Usability,"// Modifiers to guide how an ISD::SETCC node's result is to be computed; // in a GPR.; // ZExtOrig - use the original condition code, zero-extend value; // ZExtInvert - invert the condition code, zero-extend value; // SExtOrig - use the original condition code, sign-extend value; // SExtInvert - invert the condition code, sign-extend value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:16,guid,guide,16,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['guid'],['guide']
Usability,// More general: canonicalize 'equality with set bits mask' to; // 'equality with clear bits mask'.; // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC; // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:82,clear,clear,82,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['clear'],['clear']
Usability,// More than one non-simplified value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:21,simpl,simplified,21,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplified']
Usability,"// Most compilers support at least 255 variants (256 - 1 value for the empty variant).; // Some compilers switch to a two-byte tag field already with 254 variants.; // MSVC only supports 163 variants in older versions, 250 in newer ones. It switches to a 2 byte; // tag as of 128 variants (at least in debug mode), so for simplicity we set the limit to 125 variants.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldSTLMisc.hxx:322,simpl,simplicity,322,tree/ntuple/v7/inc/ROOT/RField/RFieldSTLMisc.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldSTLMisc.hxx,1,['simpl'],['simplicity']
Usability,// Most of the intrinsics with no operands have some kind of side effect.; // Don't simplify.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:84,simpl,simplify,84,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplify']
Usability,// Most simplifications for memcmp also apply to bcmp.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:8,simpl,simplifications,8,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['simpl'],['simplifications']
Usability,"// Move H <-> R, clearing top 16 bits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:17,clear,clearing,17,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,1,['clear'],['clearing']
Usability,"// Move the last case to the default successor. This is valid as if the; // default got unswitched it cannot be reached. This has the advantage of; // being simple and keeping the number of edges from this switch to; // successors the same, and avoiding any PHI update complexity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:157,simpl,simple,157,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['simpl'],['simple']
Usability,// Mul distributes over Add. Try some generic simplifications based on this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:46,simpl,simplifications,46,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifications']
Usability,"// Multi-level aliases are not supported. This just simplifies option; // tracking, it is not an inherent limitation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Option/Option.cpp:52,simpl,simplifies,52,interpreter/llvm-project/llvm/lib/Option/Option.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Option/Option.cpp,1,['simpl'],['simplifies']
Usability,// Must be a simple rip-relative address.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:13,simpl,simple,13,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp,1,['simpl'],['simple']
Usability,// Must be in loop simplified form: we need a preheader and dedicated exits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:19,simpl,simplified,19,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['simpl'],['simplified']
Usability,// Must point to a simple identifier,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp:19,simpl,simple,19,interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/DLangDemangle.cpp,1,['simpl'],['simple']
Usability,// My reading of the MIPS DSP 3.01 specification isn't as clear as I; // would like about whether bit 20 always gets overwritten by addwc.; // Hence take an extremely conservative view and presume it's sticky. We; // therefore need to clear it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:58,clear,clear,58,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,2,['clear'],['clear']
Usability,// N clear,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:5,clear,clear,5,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['clear'],['clear']
Usability,"// NB!!! Several arithmetic instructions only *partially* update; // flags. Theoretically, we could generate MI code sequences that; // would rely on this fact and observe different flags independently.; // But currently LLVM models all of these instructions as clobbering; // all the flags in an undef way. We rely on that to simplify the; // logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:327,simpl,simplify,327,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,1,['simpl'],['simplify']
Usability,"// NEON Thumb2 data-processsing encodings are very simple: bit 24 is moved; // to bit 12 of the high half-word (i.e. bit 28), and bits 27-24 are; // set to 1111.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:51,simpl,simple,51,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,1,['simpl'],['simple']
Usability,"// NOTE(gparolini): these TFile and TTree are created on the heap to work around a know bug that can; // cause a TObject to be incorrectly marked as ""on heap"" and attempted to be freed despite; // living on the stack.; // The bug is caused by the magic bit pattern `kObjectAllocMemValue` used by TStorage to; // mark a heap object appearing by chance on the stack.; // This is not a problem with a clear solution and in fact the whole heap detection system relies on UB,; // so for now we are forced to work around the bug rather than fixing it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx:398,clear,clear,398,tree/dataframe/test/dataframe_simple.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx,1,['clear'],['clear']
Usability,"// NOTE: ClassMembers are as simple as back pointers for ClassMap,; // so comparing constraint ranges and class maps should be; // sufficient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:29,simpl,simple,29,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['simpl'],['simple']
Usability,"// NOTE: If BEValue is loop invariant, we know that the PHI node just; // has a special value for the first iteration of the loop.; // If the value coming around the backedge is an add with the symbolic; // value we just inserted, then we found a simple induction variable!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:247,simpl,simple,247,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['simpl'],['simple']
Usability,// NOTE: SimplifyDemandedBits won't do this for constants.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:9,Simpl,SimplifyDemandedBits,9,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,// NOTE: We can't apply this simplifications based on the value of Op1; // because we need to preserve provenance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:29,simpl,simplifications,29,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifications']
Usability,"// NOTE: the explicit multiple argument versions of these functions are; // deprecated.; // Please use the SimplifyQuery versions in new code.; /// Given operands for an Add, fold the result or return null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:107,Simpl,SimplifyQuery,107,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,1,['Simpl'],['SimplifyQuery']
Usability,"// NOTE: we could handle setcc instructions with multiple uses here, but; // InstCombine does it as well for simple uses, it's not clear that it; // occurs enough in real life to handle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:109,simpl,simple,109,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,2,"['clear', 'simpl']","['clear', 'simple']"
Usability,"// Name to GUID map, used as caching/memoization for speed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.h:11,GUID,GUID,11,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.h,1,['GUID'],['GUID']
Usability,"// Named metadata with simple list-like behavior, so that it's valid to remove; // operands individually.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceMetadata.cpp:23,simpl,simple,23,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceMetadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceMetadata.cpp,1,['simpl'],['simple']
Usability,"// Need extra check for icmp. Note if this check is true, it generally means; // the icmp will simplify to true/false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:95,simpl,simplify,95,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplify']
Usability,// Need to clear CommonCost since the final shuffle cost is included into; // vector cost.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:11,clear,clear,11,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['clear'],['clear']
Usability,"// Need to handle ""id<xx>"" explicitly.; // GCC allows qualified id and any Objective-C type to devolve to; // id. Currently localizing to here until clear this should be; // part of ObjCQualifiedIdTypesAreCompatible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:149,clear,clear,149,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['clear'],['clear']
Usability,"// Need to insert a BitCast.; // For an integer Load instruction with a single use, the load + IntToPtr; // cast will be simplified into a pointer load:; // %v = load i64, i64* %a.ip, align 8; // %v.cast = inttoptr i64 %v to float **; // ==>; // %v.ptrp = bitcast i64 * %a.ip to float **; // %v.cast = load float *, float ** %v.ptrp, align 8",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:121,simpl,simplified,121,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,1,['simpl'],['simplified']
Usability,// Need to resize this on each safepoint - we need the two to stay in sync and; // the clear patterns of a SelectionDAGBuilder have no relation to; // FunctionLoweringInfo. Also need to ensure used bits get cleared.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:87,clear,clear,87,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,2,['clear'],"['clear', 'cleared']"
Usability,"// Never initialized, or already cleared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Timer.cpp:33,clear,cleared,33,interpreter/llvm-project/llvm/lib/Support/Timer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Timer.cpp,1,['clear'],['cleared']
Usability,"// Never print ""instantiations"" for deduction guides (they don't really; // have them).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:46,guid,guides,46,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,1,['guid'],['guides']
Usability,// New lines may start a simple key.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp:25,simpl,simple,25,interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,2,['simpl'],['simple']
Usability,"// Next code should be emitted for reduction:; //; // static kmp_critical_name lock = { 0 };; //; // void reduce_func(void *lhs[<n>], void *rhs[<n>]) {; // *(Type0*)lhs[0] = ReductionOperation0(*(Type0*)lhs[0], *(Type0*)rhs[0]);; // ...; // *(Type<n>-1*)lhs[<n>-1] = ReductionOperation<n>-1(*(Type<n>-1*)lhs[<n>-1],; // *(Type<n>-1*)rhs[<n>-1]);; // }; //; // ...; // void *RedList[<n>] = {&<RHSExprs>[0], ..., &<RHSExprs>[<n>-1]};; // switch (__kmpc_reduce{_nowait}(<loc>, <gtid>, <n>, sizeof(RedList),; // RedList, reduce_func, &<lock>)) {; // case 1:; // ...; // <LHSExprs>[i] = RedOp<i>(*<LHSExprs>[i], *<RHSExprs>[i]);; // ...; // __kmpc_end_reduce{_nowait}(<loc>, <gtid>, &<lock>);; // break;; // case 2:; // ...; // Atomic(<LHSExprs>[i] = RedOp<i>(*<LHSExprs>[i], *<RHSExprs>[i]));; // ...; // [__kmpc_end_reduce(<loc>, <gtid>, &<lock>);]; // break;; // default:;; // }; //; // if SimpleReduction is true, only the next code is generated:; // ...; // <LHSExprs>[i] = RedOp<i>(*<LHSExprs>[i], *<RHSExprs>[i]);; // ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:888,Simpl,SimpleReduction,888,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['Simpl'],['SimpleReduction']
Usability,"// Next, clear the sign bit from the first operand (magnitude).; // TODO: If we had general constant folding for FP logic ops, this check; // wouldn't be necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:9,clear,clear,9,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['clear'],['clear']
Usability,"// Next, see if the two FRs have the same super-region.; // FIXME: This doesn't handle casts yet, and simply stripping the casts; // doesn't help.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:102,simpl,simply,102,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,1,['simpl'],['simply']
Usability,// No Gro variable was allocated. Simply emit the call to; // get_return_object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:34,Simpl,Simply,34,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,1,['Simpl'],['Simply']
Usability,// No change.; // Clear the IsRenamable bit to keep it conservatively correct.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:18,Clear,Clear,18,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,1,['Clear'],['Clear']
Usability,"// No compounds are available. It is not clear whether we should; // even process such extenders where the initializer cannot be; // a single instruction, but do it for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:41,clear,clear,41,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,1,['clear'],['clear']
Usability,"// No details on how the decision was made, simply return always or never.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:44,simpl,simply,44,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['simpl'],['simply']
Usability,// No further simplifications.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:14,simpl,simplifications,14,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplifications']
Usability,// No linking to be performed or linking from the source: simply create an; // identical version of the symbol over in the dest module... the; // initializer will be filled in later by LinkGlobalInits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:58,simpl,simply,58,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,1,['simpl'],['simply']
Usability,"// No longer a simple mapping. Switch to a complex mapping. If the; // interval has subranges, make it a forced mapping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:15,simpl,simple,15,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,1,['simpl'],['simple']
Usability,// No longer need a call to coro.resume or coro.destroy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:33,resume,resume,33,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['resume'],['resume']
Usability,"// No matter which version is given to `g`, we always set imafd to default; // version since the we don't have clear version scheme for that on; // ISA spec.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/RISCVISAInfo.cpp:111,clear,clear,111,interpreter/llvm-project/llvm/lib/Support/RISCVISAInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/RISCVISAInfo.cpp,1,['clear'],['clear']
Usability,"// No need to clear Queries here, since LiveIntervalUnion::Query doesn't; // have anything important to clear and LiveRegMatrix's runOnFunction(); // does a std::unique_ptr::reset anyways.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:14,clear,clear,14,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,2,['clear'],['clear']
Usability,// No need to clear the tag byte.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:14,clear,clear,14,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,1,['clear'],['clear']
Usability,"// No need to print anything, simply forward to the subexpression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtPrinter.cpp:30,simpl,simply,30,interpreter/llvm-project/clang/lib/AST/StmtPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtPrinter.cpp,1,['simpl'],['simply']
Usability,"// No need to re-simplify, it wasn't to start with.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:17,simpl,simplify,17,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,1,['simpl'],['simplify']
Usability,"// No progress bar if not tty or explicitly not requested (i.e. for ctest)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:6,progress bar,progress bar,6,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,1,['progress bar'],['progress bar']
Usability,// No simplification done.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:6,simpl,simplification,6,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simplification']
Usability,// No simplifications for Alloca and it can't be constant folded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:6,simpl,simplifications,6,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifications']
Usability,"// No spills in subtree, simply continue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:25,simpl,simply,25,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['simpl'],['simply']
Usability,// No target I know of cares about va_end. Certainly no in-tree target; // does. Simplest intrinsic ever!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:81,Simpl,Simplest,81,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,1,['Simpl'],['Simplest']
Usability,"// No terminator: simply read the data we know is (or should; // be) available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx:18,simpl,simply,18,net/net/src/TWebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx,1,['simpl'],['simply']
Usability,"// No writeback, simply build the MachineInstr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:17,simpl,simply,17,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['simpl'],['simply']
Usability,"// No-op there is not equivalent state (to be cleared) in Cling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:46,clear,cleared,46,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['clear'],['cleared']
Usability,// Node simplified. Try simplifying again.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:8,simpl,simplified,8,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['simpl'],"['simplified', 'simplifying']"
Usability,// Non-phi producers are simple to remap. Insert as many phis as the; // difference between the consumer and producer stages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:25,simpl,simple,25,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['simpl'],['simple']
Usability,// Non-variadic macros are simple.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:27,simpl,simple,27,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['simpl'],['simple']
Usability,"// None of the checks below are needed for functions that don't have; // simple names (e.g., C++ conversion functions).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:73,simpl,simple,73,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['simpl'],['simple']
Usability,"// Not a text macro; not usable in TextItem context. Since we haven't used; // the token, put it back for better error recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp:25,usab,usable,25,interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,1,['usab'],['usable']
Usability,// Not clear how to truncate FP values.; // TODO: Handle truncation of build_vector constants,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:7,clear,clear,7,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['clear'],['clear']
Usability,// Not from same pointer.; // This only handles simple types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:48,simpl,simple,48,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simple']
Usability,"// Not having an unwind dest for this user might indicate that it; // doesn't unwind, so can't be taken as proof that the cleanup itself; // may unwind to caller (see e.g. SimplifyUnreachable and; // RemoveUnwindEdge).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:172,Simpl,SimplifyUnreachable,172,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,1,['Simpl'],['SimplifyUnreachable']
Usability,"// Not really a cost consideration, but check for unsupported cases here to; // simplify the logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:80,simpl,simplify,80,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['simpl'],['simplify']
Usability,"// Not so simple, we need two successive comparisons.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMInstructionSelector.cpp:10,simpl,simple,10,interpreter/llvm-project/llvm/lib/Target/ARM/ARMInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMInstructionSelector.cpp,1,['simpl'],['simple']
Usability,// Note - simple and compound requirements are both represented by the same; // class (ExprRequirement).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprConcepts.h:10,simpl,simple,10,interpreter/llvm-project/clang/include/clang/AST/ExprConcepts.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprConcepts.h,1,['simpl'],['simple']
Usability,// Note that -1 is chosen to make clear() efficiently implementable with; // memset and because it's not a valid pointer value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:34,clear,clear,34,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,1,['clear'],['clear']
Usability,"// Note that Sema::MergeCompatibleFunctionDecls already takes care of; // merging storage classes and visibility attributes, so we don't have to; // look at previous decls in here.; // In C++, then if the type of the function uses a type with; // unique-external linkage, it's not legally usable from outside; // this translation unit. However, we should use the C linkage; // rules instead for extern ""C"" declarations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:289,usab,usable,289,interpreter/llvm-project/clang/lib/AST/Decl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp,1,['usab'],['usable']
Usability,"// Note that if 'I' is a load being replaced by some operation,; // for example, by an arithmetic operation, then andIRFlags(); // would just erase all math flags from the original arithmetic; // operation, which is clearly not wanted and not needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:216,clear,clearly,216,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['clear'],['clearly']
Usability,"// Note that it is possible to have an interval that is live-in or live-out; // while only covering a single block - A phi-def can use undef values from; // predecessors, and the block could be a single-block loop.; // We don't bother doing anything clever about such a case, we simply assume; // that the interval is continuous from FirstInstr to LastInstr. We should; // make sure that we don't do anything illegal to such an interval, though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:279,simpl,simply,279,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,1,['simpl'],['simply']
Usability,"// Note that recursion is limited for each vector element, so if any element; // exceeds the limit, this will fail to simplify.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:118,simpl,simplify,118,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplify']
Usability,"// Note that the AtPseudoVariable is enabled for instantiations of .irp.; // This is undocumented, but GAS seems to support it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:85,undo,undocumented,85,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,1,['undo'],['undocumented']
Usability,"// Note that the AtPseudoVariable is enabled for instantiations of .irpc.; // This is undocumented, but GAS seems to support it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:86,undo,undocumented,86,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,1,['undo'],['undocumented']
Usability,"// Note that the LoopInfo may be stale at this point, however the loop; // objects themselves remain the only viable keys that could be in the; // analysis manager's cache. So we just walk the keys and forcibly clear; // those results. Note that the order doesn't matter here as this will just; // directly destroy the results without calling methods on them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:211,clear,clear,211,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,1,['clear'],['clear']
Usability,"// Note that the meanings of the ""object"" are slightly different in the; // following contexts:; // c1: llvm::getObjectSize(); // c2: llvm.objectsize() intrinsic; // c3: isObjectSmallerThan(); // c1 and c2 share the same meaning; however, the meaning of ""object"" in c3; // refers to the ""entire object"".; //; // Consider this example:; // char *p = (char*)malloc(100); // char *q = p+80;; //; // In the context of c1 and c2, the ""object"" pointed by q refers to the; // stretch of memory of q[0:19]. So, getObjectSize(q) should return 20.; //; // However, in the context of c3, the ""object"" refers to the chunk of memory; // being allocated. So, the ""object"" has 100 bytes, and q points to the middle; // the ""object"". In case q is passed to isObjectSmallerThan() as the 1st; // parameter, before the llvm::getObjectSize() is called to get the size of; // entire object, we should:; // - either rewind the pointer q to the base-address of the object in; // question (in this case rewind to p), or; // - just give up. It is up to caller to make sure the pointer is pointing; // to the base address the object.; //; // We go for 2nd option for simplicity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:1141,simpl,simplicity,1141,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['simpl'],['simplicity']
Usability,"// Note that this could be folded into the above `MemRefs` member if doing so; // is advantageous at some point. We don't need to store this in most cases.; // However, at the moment this doesn't appear to make the allocation any; // smaller and makes the code somewhat simpler to read.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:270,simpl,simpler,270,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['simpl'],['simpler']
Usability,// Note that this won't clear read/write descriptors; // or other non-trivial fields,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Instruction.cpp:24,clear,clear,24,interpreter/llvm-project/llvm/lib/MCA/Instruction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Instruction.cpp,1,['clear'],['clear']
Usability,"// Note that we do not check access along this path; other than that,; // this is the same as shouldDeleteForSubobjectCall(Base, BaseCtor, false);; // FIXME: Check that the base has a usable destructor! Sink this into; // shouldDeleteForClassSubobject.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:184,usab,usable,184,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['usab'],['usable']
Usability,"// Note that we don't preserve LCSSA in the new PM, if you need it run LCSSA; // after simplifying the loops. MemorySSA is preserved if it exists.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:87,simpl,simplifying,87,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,1,['simpl'],['simplifying']
Usability,// Note that we don't wrap the expression with ExprWithCleanups here; // because that might interfere with tailcall contract (e.g. inserting; // clean up instructions in-between tailcall and return). Instead; // ExprWithCleanups is wrapped within maybeTailCall() prior to the resume; // call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:276,resume,resume,276,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,1,['resume'],['resume']
Usability,"// Note that, since we are merging phi nodes and BB and Succ might; // have common predecessors, we could end up with a phi node with; // identical incoming branches. This will be cleaned up later (and; // will trigger asserts if we try to clean it up now, without also; // simplifying the corresponding conditional branch).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:274,simpl,simplifying,274,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['simpl'],['simplifying']
Usability,"// Note we might need support for typedefs and simple types!; // TDataType *objType = GetType(name, load);; //if (objType) {; // const char *typdfName = objType->GetTypeName();; // if (typdfName && strcmp(typdfName, name)) {; // cl = GetClass(typdfName, load);; // return cl;; // }; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:47,simpl,simple,47,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['simpl'],['simple']
Usability,"// Note, the num operands is used to compute the offset of the operand, so; // the order here matters. Clearing the operand then clearing the num; // operands ensures we have the correct offset to the operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp:103,Clear,Clearing,103,interpreter/llvm-project/llvm/lib/IR/Globals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp,2,"['Clear', 'clear']","['Clearing', 'clearing']"
Usability,"// Note, we are skipping cases:; // if Y % 2 != 0 AND X % 2 != 0; // (false/true); // if X non-zero and Y non-zero and NoOverflow(X * Y); // (false/true); // Those can be simplified later as we would have already replaced the (icmp; // eq/ne (mul X, Y)) with (icmp eq/ne X/Y) and if X/Y is known non-zero that; // will fold to a constant elsewhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:171,simpl,simplified,171,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['simpl'],['simplified']
Usability,"// Note: GEP indices generally traverse nested types, and so a GepNode; // (representing a single index) can be associated with some composite; // type. The exception is the GEP input, which is a pointer, and not; // a composite type (at least not in the sense of having sub-types).; // Also, the corresponding index plays a different role as well: it is; // simply added to the input pointer. Since pointer types are becoming; // opaque (i.e. are no longer going to include the pointee type), the; // two pieces of information (1) the fact that it's a pointer, and; // (2) the pointee type, need to be stored separately. The pointee type; // will be stored in the PTy member, while the fact that the node; // operates on a pointer will be reflected by the flag ""Pointer"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp:359,simpl,simply,359,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCommonGEP.cpp,1,['simpl'],['simply']
Usability,// Note: Here the `IsExplicit` parameter refers to the semantics in clang; // modules. All the non-explicit submodules in clang modules will be exported; // too. Here we simplify the implementation by using the concept.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:170,simpl,simplify,170,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,1,['simpl'],['simplify']
Usability,"// Note: If we've gotten to the point of visiting the outer OR, then the; // inner one couldn't be simplified. If it was a constant, then it won't; // be simplified by a later pass either, so we try swapping the inner/outer; // ORs in the hopes that we'll be able to simplify it this way.; // (X|C) | V --> (X|V) | C",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:99,simpl,simplified,99,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,3,['simpl'],"['simplified', 'simplify']"
Usability,"// Note: There's nothing inherent which prevents predicated loads and; // stores from being uniform. The current lowering simply doesn't handle; // it; in particular, the cost model distinguishes scatter/gather from; // scalar w/predication, and we currently rely on the scalar path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:122,simpl,simply,122,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['simpl'],['simply']
Usability,"// Note: This is duplicating a particular part on SimplifyIndVars reasoning.; // We need to duplicate it because given icmp zext(small-iv), C, IVUsers; // never reaches the icmp since the zext doesn't fold to an AddRec unless; // it already has flags. The alternative to this would be to extending the; // set of ""interesting"" IV users to include the icmp, but doing that; // regresses results in practice by querying SCEVs before trip counts which; // rely on them which results in SCEV caching sub-optimal answers. The; // concern about caching sub-optimal results is why we only query SCEVs of; // the loop invariant RHS here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:50,Simpl,SimplifyIndVars,50,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['Simpl'],['SimplifyIndVars']
Usability,// Note: This needs to return a SmallSetVector as the elements of; // ActiveBlocks will be later copied to Blocks using std::copy. The; // resultant order of elements in Blocks needs to be deterministic.; // Using SmallPtrSet instead causes non-deterministic order while; // copying. And we cannot simply sort Blocks as they need to match the; // corresponding Values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:298,simpl,simply,298,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,1,['simpl'],['simply']
Usability,// Note: We assume simple value types because this should only be called with; // legal operations/types.; // TODO: This can be extended to handle extraction to 256-bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:19,simpl,simple,19,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simple']
Usability,"// Note: We explicitly leave Matches unmodified if there isn't a clear best; // option, so we can potentially give the user a better error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:65,clear,clear,65,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['clear'],['clear']
Usability,// Note: We leave the subreg number around a little longer in case of defs.; // This is so that the register freeing logic in allocateInstruction can still; // recognize this as subregister defs. The code there will clear the number.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:216,clear,clear,216,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['clear'],['clear']
Usability,"// Note: We need to do erasing for ""Loaded"" stage because; // if live analysys failed then we will have ""Loaded"" stage; // with marking from ""LivenessAnalysisDone"" stage partially; // done. That marking should be cleared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:213,clear,cleared,213,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,1,['clear'],['cleared']
Usability,"// Note: can't re-use Utility::AddClass here, as there's the risk of; // a recursive call. Simply add method directly, as we're guaranteed; // that it doesn't exist yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx:91,Simpl,Simply,91,bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx,1,['Simpl'],['Simply']
Usability,"// Note: given the guard above, which guarantees we only ever insert; // unique elements, we could use a simple list (like `vector`) for; // `Successors`, rather than a set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp:105,simpl,simple,105,interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp,1,['simpl'],['simple']
Usability,"// Note: historically, the PruneEH pass was run first to deduce nounwind and; // generally clean up exception handling overhead. It isn't clear this is; // valuable as the inliner doesn't currently care whether it is inlining an; // invoke or a call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:138,clear,clear,138,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['clear'],['clear']
Usability,"// Note: historically, the PruneEH pass was run first to deduce nounwind and; // generally clean up exception handling overhead. It isn't clear this is; // valuable as the inliner doesn't currently care whether it is inlining an; // invoke or a call.; // Run the inliner now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:138,clear,clear,138,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['clear'],['clear']
Usability,"// Note: the IR at this point is broken. We cannot use SE to create any new; // SCEV and then expand it, hoping that SCEV's simplification will give us; // a more optimal code. Unfortunately, attempt of doing so on invalid IR may; // lead to various SCEV crashes. So all we can do is to use builder and rely; // on InstCombine for future simplifications. Here we handle some trivial; // cases only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:124,simpl,simplification,124,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,['simpl'],"['simplification', 'simplifications']"
Usability,"// Note: these tests could be simpler; the models were just copied; // from testLikelihoodSerial for convenience.; // Introspection tests",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/TestStatistics/testRooAbsL.cxx:30,simpl,simpler,30,roofit/roofitcore/test/TestStatistics/testRooAbsL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/TestStatistics/testRooAbsL.cxx,1,['simpl'],['simpler']
Usability,"// Note: this feature (register) is broken. When used as a 32-bit operand,; // it returns a wrong value (all zeroes?). The real value is in the upper 32; // bits.; //; // To work around the issue, directly emit a 64 bit mov from this register; // then extract the high bits. Note that this shouldn't even result in a; // shift being emitted and simply become a pair of registers (e.g.):; // s_mov_b64 s[6:7], src_shared_base; // v_mov_b32_e32 v1, s7; //; // FIXME: It would be more natural to emit a CopyFromReg here, but then copy; // coalescing would kick in and it would think it's okay to use the ""HI""; // subregister directly (instead of extracting the HI 32 bits) which is an; // artificial (unusable) register.; // Register TableGen definitions would need an overhaul to get rid of the; // artificial ""HI"" aperture registers and prevent this kind of issue from; // happening.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:345,simpl,simply,345,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['simpl'],['simply']
Usability,// Note: this is only valid because SimplifyBinOp doesn't look at; // the operands to Op0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:36,Simpl,SimplifyBinOp,36,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['Simpl'],['SimplifyBinOp']
Usability,"// Note: this simplification does not work with Clad as of v1.1!; // return gaussian(x, mean, x < mean ? sigmaL : sigmaR);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h:14,simpl,simplification,14,roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h,1,['simpl'],['simplification']
Usability,"// Nothing to decide, nothing to learn.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:33,learn,learn,33,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,1,['learn'],['learn']
Usability,"// Now a set of simpler things to delete. See the same ordering in; // TROOT::~TROOT",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:16,simpl,simpler,16,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['simpl'],['simpler']
Usability,// Now apply simplifications that do not require rounding.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:13,simpl,simplifications,13,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifications']
Usability,// Now clear and re-populate the map for the next iteration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:7,clear,clear,7,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['clear'],['clear']
Usability,// Now clear any kill flags for recorded registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:7,clear,clear,7,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['clear'],['clear']
Usability,// Now delete the dead child loops. This raw delete will clear them; // recursively.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:57,clear,clear,57,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['clear'],['clear']
Usability,"// Now do a similar search up through the graph to find where the value; // actually returned by the ""tail call"" comes from. In the simple case without; // a ""returned"" attribute, the search will be blocked immediately and the loop; // a Noop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:132,simpl,simple,132,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,1,['simpl'],['simple']
Usability,// Now gather the cross-half inputs and place them into a free dword of; // their target half.; // FIXME: This operation could almost certainly be simplified dramatically to; // look more like the 3-1 fixing operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:147,simpl,simplified,147,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplified']
Usability,"// Now gather the simplifiable factors, removing them from Ops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:18,simpl,simplifiable,18,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['simpl'],['simplifiable']
Usability,// Now get a register that contains the value of the flag input to the; // arithmetic. We require exactly this flag to simplify the arithmetic; // required to materialize it back into the flag.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:119,simpl,simplify,119,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,1,['simpl'],['simplify']
Usability,"// Now include the start value in the operation.; // Note that we must return the start value when no elements are operated; // upon. The vcpop instructions we've emitted in each case above will return; // 0 for an inactive vector, and so we've already received the neutral value:; // AND gives us (0 == 0) -> 1 and OR/XOR give us (0 != 0) -> 0. Therefore we; // can simply include the start value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:367,simpl,simply,367,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['simpl'],['simply']
Usability,// Now insert something that simplifycfg will turn into an unreachable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:29,simpl,simplifycfg,29,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['simpl'],['simplifycfg']
Usability,"// Now need to have in ASIMOV the data sets also the global observables; // Their values must be the one satisfying the constraint.; // to do it make a nuisance pdf with all product of constraints and then; // assign to each constraint a glob observable value = to the current fitted nuisance parameter value; // IN general one should solve in general the system of equations f( gobs| nuispar ) = 0 where f are the; // derivatives of the constraint with respect the nuisance parameter and they are evaluated at the best fit nuisance; // parameter points; // As simple solution assume that constrain has a direct dependence on the nuisance parameter, i.e.; // Constraint (gobs, func( nuispar) ) and the condition is satisfied for; // gobs = func( nuispar) where nunispar is at the MLE value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/AsymptoticCalculator.cxx:561,simpl,simple,561,roofit/roostats/src/AsymptoticCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/AsymptoticCalculator.cxx,1,['simpl'],['simple']
Usability,// Now query the MCInstrAnalysis object to obtain information about which; // register writes implicitly clear the upper portion of a super-register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp:105,clear,clear,105,interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,1,['clear'],['clear']
Usability,"// Now set new state on the added workers (on all workers for simplicity); // use fEnabledPackages, fLoadedMacros,; // gSystem->GetDynamicPath() and gSystem->GetIncludePath(); // no need to load packages that are only loaded and not enabled (dyn mode)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:62,simpl,simplicity,62,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['simpl'],['simplicity']
Usability,"// Now test the complete 2D case where the y variable is also distributed; // with non-uniform binning. To make things simple, the histogram has only; // 2 bins.; //; // The x-histogram will have the following content for the entries where y; // is in the [0, 2.5] bin (12 entries):; //; // - bin1 [0.0, 1.0]: 3 counts (bin volume x counts = 3); // - bin2 [1.0, 3.0]: 1 count (bin volume x counts = 2); // - bin3 [3.0, 3.5]: 8 counts (bin volume x counts = 4); //; // Then, there are some more entries with y in the [2.5, 3.5] bin (4 entries);; //; // - bin6 [0.0, 1.0]: 1 counts (bin volume x counts = 1); // - bin7 [1.0, 3.0]: 2 counts (bin volume x counts = 4); // - bin8 [3.0, 3.5]: 1 counts (bin volume x counts = 0.5)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataHist.cxx:119,simpl,simple,119,roofit/roofitcore/test/testRooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataHist.cxx,1,['simpl'],['simple']
Usability,"// Now test the simple 2D case where there just an additional dummy variable y that is always in the first bin; // This should consistently give the same results as the 1D case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataHist.cxx:16,simpl,simple,16,roofit/roofitcore/test/testRooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataHist.cxx,1,['simpl'],['simple']
Usability,"// Now that all loop invariants have been removed from the loop, promote any; // memory references to scalars that we can.; // Don't sink stores from loops without dedicated block exits. Exits; // containing indirect branches are not transformed by loop simplify,; // make sure we catch that. An additional load may be generated in the; // preheader for SSA updater, so also avoid sinking when no preheader; // is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:254,simpl,simplify,254,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['simpl'],['simplify']
Usability,"// Now that the extend is gone, we want to expose it's uses for potential; // further simplification. We don't need to directly inform SimplifyIVUsers; // of the new users, because their parent IV will be processed later as a; // new loop phi. If we preserved IVUsers analysis, we would also want to; // push the uses of WideDef here.; // No further widening is needed. The deceased [sz]ext had done it for us.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:86,simpl,simplification,86,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,2,"['Simpl', 'simpl']","['SimplifyIVUsers', 'simplification']"
Usability,"// Now that we are done with loop unrolling, be it either by LoopVectorizer,; // or LoopUnroll passes, some variable-offset GEP's into alloca's could have; // become constant-offset, thus enabling SROA and alloca promotion. Do so.; // NOTE: we are very late in the pipeline, and we don't have any LICM; // or SimplifyCFG passes scheduled after us, that would cleanup; // the CFG mess this may created if allowed to modify CFG, so forbid that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:309,Simpl,SimplifyCFG,309,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,2,['Simpl'],['SimplifyCFG']
Usability,"// Now that we have ""cmp select(Cond, TV, FV), RHS"", analyse it.; // Does ""cmp TV, RHS"" simplify?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:88,simpl,simplify,88,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplify']
Usability,"// Now that we have a place to insert the conditional branch, create a place; // to branch to: this is the exit block out of the loop that we are; // unswitching. We need to split this if there are other loop predecessors.; // Because the loop is in simplified form, *any* other predecessor is enough.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:250,simpl,simplified,250,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['simpl'],['simplified']
Usability,"// Now that we have an instruction, try combining it to simplify it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:56,simpl,simplify,56,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplify']
Usability,"// Now that we have deleted the functions that are unnecessary for the; // program, try to remove instructions that are not necessary to cause the; // crash. To do this, we loop through all of the instructions in the; // remaining functions, deleting them (replacing any values produced with; // nulls), and then running ADCE and SimplifyCFG. If the transformed input; // still triggers failure, keep deleting until we cannot trigger failure; // anymore.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:330,Simpl,SimplifyCFG,330,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['Simpl'],['SimplifyCFG']
Usability,"// Now that we've done the deed, simplify the switch instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:33,simpl,simplify,33,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,1,['simpl'],['simplify']
Usability,"// Now that we've formed fast to execute loop structures, we do further; // optimizations. These are run afterward as they might block doing complex; // analyses and transforms such as what are needed for loop vectorization.; // Cleanup after loop vectorization, etc. Simplification passes like CVP and; // GVN, loop transforms, and others have already run, so it's now better to; // convert to more optimized IR using more aggressive simplify CFG options.; // The extra sinking transform can create larger basic blocks, so do this; // before SLP vectorization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:268,Simpl,Simplification,268,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,2,"['Simpl', 'simpl']","['Simplification', 'simplify']"
Usability,"// Now that we've moved things into the new RefSCCs, clear out our current; // one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:53,clear,clear,53,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,1,['clear'],['clear']
Usability,"// Now the chunk_state is clear, and we have more input. If there's more than; // a single chunk (so, definitely not the root chunk), hash the largest whole; // subtree we can, with the full benefits of SIMD (and maybe in the future,; // multi-threading) parallelism. Two restrictions:; // - The subtree has to be a power-of-2 number of chunks. Only subtrees along; // the right edge can be incomplete, and we don't know where the right edge; // is going to be until we get to finalize().; // - The subtree must evenly divide the total number of chunks up until this; // point (if total is not 0). If the current incomplete subtree is only; // waiting for 1 more chunk, we can't hash a subtree of 4 chunks. We have; // to complete the current subtree first.; // Because we might need to break up the input to form powers of 2, or to; // evenly divide what we already have, this part runs in a loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:26,clear,clear,26,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,1,['clear'],['clear']
Usability,"// Now the diagnostic state is clear, produce a C++98 compatibility; // warning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:31,clear,clear,31,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['clear'],['clear']
Usability,// Now try SimplifyDemandedBits which can simplify the nodes used by our; // operands if this node is the only user.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:11,Simpl,SimplifyDemandedBits,11,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,2,"['Simpl', 'simpl']","['SimplifyDemandedBits', 'simplify']"
Usability,"// Now try to simplify the ops to avoid placing a phi.; // This may return null if we never created a phi yet, that's okay",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:14,simpl,simplify,14,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['simpl'],['simplify']
Usability,// Now unhook the successor relationship as we'll be replacing; // the terminator with a direct branch. This is much simpler for branches; // than switches so we handle those first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:117,simpl,simpler,117,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['simpl'],['simpler']
Usability,"// Now use binding to return a usable class. Upcast: result is a base.; // Downcast: result is a derived.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/TClassPyz.cxx:31,usab,usable,31,bindings/pyroot/pythonizations/src/TClassPyz.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/TClassPyz.cxx,1,['usab'],['usable']
Usability,"// Now we assume that every member of an equivalence class interferes; // with every other member of that class, and with no members of other classes.; // Convert the EquivalenceClasses to a simpler set of sets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp:191,simpl,simpler,191,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp,1,['simpl'],['simpler']
Usability,// Now we know that the RHS is a BlockAddress or simple constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:49,simpl,simple,49,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['simpl'],['simple']
Usability,"// Now we know that the RHS is a GlobalValue, BlockAddress or simple; // constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:62,simpl,simple,62,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['simpl'],['simple']
Usability,"// Now we need to properly set the TTreeCache. We do this in steps:; // 1. We set the entry range according to the entry range of the TTreeReader; // 2. We add to the cache the branches identifying them by the name the user provided; // upon creation of the TTreeReader{Value, Array}s; // 3. We stop the learning phase.; // Operations 1, 2 and 3 need to happen in this order. See:; // https://sft.its.cern.ch/jira/browse/ROOT-9773?focusedCommentId=87837",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx:304,learn,learning,304,tree/treeplayer/src/TTreeReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx,1,['learn'],['learning']
Usability,"// Now we've inserted dispatch blocks, some register uses can have incoming; // paths without a def. For example, before this pass register %a was; // defined in BB1 and used in BB2, and there was only one path from BB1 and; // BB2. But if this pass inserts a dispatch block having multiple; // predecessors between the two BBs, now there are paths to BB2 without; // visiting BB1, and %a's use in BB2 is not dominated by its def. Adding; // IMPLICIT_DEFs to all regs is one simple way to fix it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:475,simpl,simple,475,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,1,['simpl'],['simple']
Usability,"// Now were done, clear the list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:18,clear,clear,18,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['clear'],['clear']
Usability,"// Now were done, clear the list but do not delete the objects as; // they have been moved to the list of closed objects and must be; // deleted from there in order to avoid a double delete from a; // use objects (on the interpreter stack).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:18,clear,clear,18,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['clear'],['clear']
Usability,"// Now, all exit blocks that are not marked as live are dead, if all their; // predecessors are in the loop. This may not be the case, as the input loop; // may not by in loop-simplify/canonical form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:176,simpl,simplify,176,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,1,['simpl'],['simplify']
Usability,"// Now, simply replace OldV with NewV in Root.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:8,simpl,simply,8,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,1,['simpl'],['simply']
Usability,"// Now, we simply replace the cleanupret with a branch to the unwind; // destination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:11,simpl,simply,11,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['simpl'],['simply']
Usability,"// Null member function pointers on ARM clear the low bit of Adj,; // so the zero condition has to check that neither low bit is set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:40,clear,clear,40,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['clear'],['clear']
Usability,// Null single inheritance member functions are encoded as a simple nullptr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:61,simpl,simple,61,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,1,['simpl'],['simple']
Usability,"// Number of bits needed for decimal literal is; // ceil(NumDigits * log2(10)) Integral part; // + Scale Fractional part; // + ceil(Exponent * log2(10)) Exponent; // --------------------------------------------------; // ceil((NumDigits + Exponent) * log2(10)) + Scale; //; // But for simplicity in handling integers, we can round up log2(10) to 4,; // making:; // 4 * (NumDigits + Exponent) + Scale; //; // Number of digits needed for hexadecimal literal is; // 4 * NumDigits Integral part; // + Scale Fractional part; // + Exponent Exponent; // --------------------------------------------------; // (4 * NumDigits) + Scale + Exponent",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:285,simpl,simplicity,285,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,1,['simpl'],['simplicity']
Usability,"// Number of color levels for rainbowed display modes,; // It does not apply for simple display modes; // algorithm group",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrumpainter/src/TSpectrum2Painter.cxx:81,simpl,simple,81,hist/spectrumpainter/src/TSpectrum2Painter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrumpainter/src/TSpectrum2Painter.cxx,1,['simpl'],['simple']
Usability,"// Number of pure workers, which are not simply divisible by mergers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:41,simpl,simply,41,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['simpl'],['simply']
Usability,"// Numeric substitution reads the value of a variable directly, not via; // GlobalNumericVariableTable. Therefore, we clear local variables by; // clearing their value which will lead to a numeric substitution failure. We; // also mark the variable for removal from GlobalNumericVariableTable since; // this is what defineCmdlineVariables checks to decide that no global; // variable has been defined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:118,clear,clear,118,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,2,['clear'],"['clear', 'clearing']"
Usability,"// ODRHash is used to calculate a hash based on AST node contents that; // does not rely on pointer addresses. This allows the hash to not vary; // between runs and is usable to detect ODR problems in modules. To use,; // construct an ODRHash object, then call Add* methods over the nodes that; // need to be hashed. Then call CalculateHash to get the hash value.; // Typically, only one Add* call is needed. clear can be called to reuse the; // object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ODRHash.h:168,usab,usable,168,interpreter/llvm-project/clang/include/clang/AST/ODRHash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ODRHash.h,2,"['clear', 'usab']","['clear', 'usable']"
Usability,// OK - this is a hack that needs to be improved. We really need to analyze; // the instructions performed on the initial value. This works on the simplest; // cases only.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:147,simpl,simplest,147,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,1,['simpl'],['simplest']
Usability,"// OK, feedback was requested, setup the timer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:7,feedback,feedback,7,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,3,['feedback'],['feedback']
Usability,"// Object-like macros are very simple, just read their body.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:31,simpl,simple,31,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['simpl'],['simple']
Usability,"// Objects in fExternalCuts are not owned and should not be deleted; // fExternalCuts.Clear();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:86,Clear,Clear,86,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['Clear'],['Clear']
Usability,"// Objects stored in maps are already deleted when merging the feedback",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:63,feedback,feedback,63,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['feedback'],['feedback']
Usability,// Occupancy was not improved for all regions that were at MinOccupancy.; // Undo sinking and remove newly rematerialized instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:77,Undo,Undo,77,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['Undo'],['Undo']
Usability,// Off/StartIdx is in the unit of bytes. So we need to convert to number of; // elements. Simply bail out if that isn't possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:90,Simpl,Simply,90,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['Simpl'],['Simply']
Usability,// Offset is simply an immediate operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:13,simpl,simply,13,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,1,['simpl'],['simply']
Usability,// Offsets for objects with fixed locations (IE: those saved by libcall) are; // simply calculated from the frame index.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:81,simpl,simply,81,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['simpl'],['simply']
Usability,"// Offsets for second (middle) corner of simplex in (i,j) coords",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs:41,simpl,simplex,41,js/modules/three_addons.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs,1,['simpl'],['simplex']
Usability,"// Offsets for second corner of simplex in (i,j,k) coords",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs:32,simpl,simplex,32,js/modules/three_addons.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs,1,['simpl'],['simplex']
Usability,"// Offsets for third corner of simplex in (i,j,k) coords",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs:31,simpl,simplex,31,js/modules/three_addons.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs,1,['simpl'],['simplex']
Usability,"// Ok, if we are here the guard above guarantee us that; // QueryInst is a non-atomic or unordered load/store.; // SI is atomic with monotonic or release semantic (seq_cst for store; // is actually a release semantic plus total order over other seq_cst; // instructions, as soon as QueryInst is not seq_cst we can consider it; // as simple release semantic).; // Monotonic and Release semantic allows re-ordering before store; // so we are safe to go further and check the aliasing. It will prohibit; // re-ordering in case locations are may or must alias.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:333,simpl,simple,333,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['simpl'],['simple']
Usability,"// Ok, the LHS is known to be a constantexpr. The RHS can be any of a; // constantexpr, a global, block address, or a simple constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:118,simpl,simple,118,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['simpl'],['simple']
Usability,"// Ok, the add recurrence looks usable.; // Remember this PHI, even in post-inc mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:32,usab,usable,32,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['usab'],['usable']
Usability,"// Ok, this is a two entry PHI node. Check to see if this is a simple ""if; // statement"", which has a very simple dominance structure. Basically, we; // are trying to find the condition that is being branched on, which; // subsequently causes this merge to happen. We really want control; // dependence information for this check, but simplifycfg can't keep it up; // to date, and this catches most of the cases we care about anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:63,simpl,simple,63,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,3,['simpl'],"['simple', 'simplifycfg']"
Usability,"// Okay, it's possible to fold this. Check to see if it is actually; // *profitable* to do so. We use a simple cost model to avoid increasing; // register pressure too much.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:104,simpl,simple,104,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['simpl'],['simple']
Usability,"// Okay, the CFG is simple enough, try to sink this instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:20,simpl,simple,20,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simple']
Usability,"// Okay, turn that back into the original value or atomic (for non-simple; // lvalues) type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:67,simpl,simple,67,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,1,['simpl'],['simple']
Usability,"// Okay, turn that back into the original value or whole atomic (for; // non-simple lvalues) type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:77,simpl,simple,77,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,1,['simpl'],['simple']
Usability,"// Okay, we decided not to do this, remove any inserted MBB's and clear; // SwitchCases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:66,clear,clear,66,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,2,['clear'],['clear']
Usability,"// Okay, we know that only that the single bit specified by UnknownBits; // could be set on input to the CTLZ node. If this bit is set, the SRL; // will return 0, if it is clear, it returns 1. Change the CTLZ/SRL pair; // to an SRL/XOR pair, which is likely to simplify more.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:172,clear,clear,172,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,"['clear', 'simpl']","['clear', 'simplify']"
Usability,"// Okay. Undo some of what StartFunction did.; // At -O0 we generate an explicit alloca for the BlockPointer, so the RA; // won't delete the dbg.declare intrinsics for captured variables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:9,Undo,Undo,9,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,1,['Undo'],['Undo']
Usability,"// OldReg may have been unused but is used now, clear the Dead flag",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:48,clear,clear,48,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['clear'],['clear']
Usability,"// On 32-bit Arm, the low bit of a function pointer indicates whether; // it's using the Arm or Thumb instruction set. The actual first; // instruction lives at the same address either way, so we must clear; // that low bit before using the function address to find the prefix; // structure.; //; // This applies to both Arm and Thumb target triples, because; // either one could be used in an interworking context where it; // might be passed function pointers of both types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:201,clear,clear,201,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['clear'],['clear']
Usability,"// On Windows, vectors are passed directly if registers are available, or; // indirectly if not. This avoids the need to align argument memory. Pass; // user-defined vector types larger than 512 bits indirectly for simplicity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:215,simpl,simplicity,215,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['simpl'],['simplicity']
Usability,"// On targets without red zone, the SP needs to be restored last, so that; // all live contents of the stack frame are upwards of the SP. This means; // that we cannot restore SP just now, since there may be more registers; // to restore from the stack frame (e.g. R31). If the frame size is not; // a simple immediate value, we will need a spare register to hold the; // restored SP. If the frame size is known and small, we can simply adjust; // the offsets of the registers to be restored, and still use SP to restore; // them. In such case, the final update of SP will be to add the frame; // size to it.; // To simplify the code, set RBReg to the base register used to restore; // values from the stack, and set SPAdd to the value that needs to be added; // to the SP at the end. The default values are as if red zone was present.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:302,simpl,simple,302,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,3,['simpl'],"['simple', 'simplify', 'simply']"
Usability,"// On the first pass over the loop body we try to simplify every instruction.; // On subsequent passes, we can restrict this to only simplifying instructions; // where the inputs have been updated. We end up needing two sets: one; // containing the instructions we are simplifying in *this* pass, and one for; // the instructions we will want to simplify in the *next* pass. We use; // pointers so we can swap between two stably allocated sets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:50,simpl,simplify,50,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,4,['simpl'],"['simplify', 'simplifying']"
Usability,"// On the off-chance that this simplifies to an instruction in the old; // function, map it back into the new function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:31,simpl,simplifies,31,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,1,['simpl'],['simplifies']
Usability,"// On v6m cores, there are very few registers available. We can easily end up; // spilling and reloading more registers in an unrolled loop. Look at the; // number of LCSSA phis as a rough measure of how many registers will need to; // be live out of the loop, reducing the default unroll count if more than 1; // value is needed. In the long run, all of this should be being learnt by a; // machine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:376,learn,learnt,376,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,1,['learn'],['learnt']
Usability,"// Once LVI learns to handle vector types, we could also add support; // for vector type constants that are not all zeroes or all ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:12,learn,learns,12,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,1,['learn'],['learns']
Usability,"// Once it is known that the brackets are matched, only a simple count of the; // braces is needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:58,simpl,simple,58,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['simpl'],['simple']
Usability,"// Once legalized, we need to structurize the CFG to follow the spec.; // This is done through the following 8 steps.; // TODO(#75801): add the remaining steps.; // 1. Simplify loop for subsequent transformations. After this steps, loops; // have the following properties:; // - loops have a single entry edge (pre-header to loop header).; // - all loop exits are dominated by the loop pre-header.; // - loops have a single back-edge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp:168,Simpl,Simplify,168,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVTargetMachine.cpp,1,['Simpl'],['Simplify']
Usability,"// Once we accumulate enough bits to fill our scalar type or process the; // last element, insert into our vector and clear our accumulated data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:118,clear,clear,118,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['clear'],['clear']
Usability,"// Once we encounter a branch, the rest of the instructions must also be; // branches. We can't rewrite in place here, so we handle them below.; //; // Note that we don't have to handle tail calls here, even conditional; // tail calls, as those are not introduced into the X86 MI until post-RA; // branch folding or black placement. As a consequence, we get to deal; // with the simpler formulation of conditional branches followed by tail; // calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:379,simpl,simpler,379,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,1,['simpl'],['simpler']
Usability,"// Once we have Perm, represent it as cycles. Denote the maximum log2; // (equal to log2(VecLen)-1) as M. The cycle containing M can then be; // written as (M a1 a2 a3 ... an). That cycle can be broken up into; // simple swaps as (M a1)(M a2)(M a3)...(M an), with the composition; // order being from left to right. Any (contiguous) segment where the; // values ai, ai+1...aj are either all increasing or all decreasing,; // can be implemented via a single vshuffvdd/vdealvdd respectively.; //; // If there is a cycle (a1 a2 ... an) that does not involve M, it can; // be written as (M an)(a1 a2 ... an)(M a1). The first two cycles can; // then be folded to get (M a1 a2 ... an)(M a1), and the above procedure; // can be used to generate a sequence of vshuffvdd/vdealvdd.; //; // Example:; // Assume M = 4 and consider a permutation (0 1)(2 3). It can be written; // as (4 0 1)(4 0) composed with (4 2 3)(4 2), or simply; // (4 0 1)(4 0)(4 2 3)(4 2).; // It can then be expanded into swaps as; // (4 0)(4 1)(4 0)(4 2)(4 3)(4 2),; // and broken up into ""increasing"" segments as; // [(4 0)(4 1)] [(4 0)(4 2)(4 3)] [(4 2)].; // This is equivalent to; // (4 0 1)(4 0 2 3)(4 2),; // which can be implemented as 3 vshufvdd instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:214,simpl,simple,214,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,2,['simpl'],"['simple', 'simply']"
Usability,"// One does not simply walk into a map and assign a reference to a possibly; // new location. That can cause an invalidation before the assignment; // happens, like so:; //; // OffsetInfoMap[Usr] = OffsetInfoMap[CurPtr]; /* bad idea! */; //; // The RHS is a reference that may be invalidated by an insertion caused by; // the LHS. So we ensure that the side-effect of the LHS happens first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:16,simpl,simply,16,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['simpl'],['simply']
Usability,"// One return type? Just a simple value then, but only if we didn't use to; // return a struct with that simple value before.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:27,simpl,simple,27,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,2,['simpl'],['simple']
Usability,"// One special case: if we add a module initializer that imports another; // module, and that module's only initializer is an ImportDecl, simplify.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:138,simpl,simplify,138,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['simpl'],['simplify']
Usability,// Only a subset of lanes needs to be copied. The following is a simple; // heuristic to construct a sequence of COPYs. We could add a target; // specific callback if this turns out to be suboptimal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:65,simpl,simple,65,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,1,['simpl'],['simple']
Usability,"// Only accept truncates for now. We would really like a nice recursive; // predicate like SimplifyDemandedBits, but which goes downwards the use-def; // chain to see which bits of a value are actually demanded. If the; // original add had another add which was then immediately truncated, we; // could still do the transformation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:91,Simpl,SimplifyDemandedBits,91,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,// Only allow simple or unordered-atomic loads,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:14,simpl,simple,14,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['simpl'],['simple']
Usability,"// Only consider values with pointer types.; //; // It seemes intuitive to exclude function pointer types as well, since; // functions are never retainable object pointers, however clang occasionally; // bitcasts retainable object pointers to function-pointer type temporarily.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:62,intuit,intuitive,62,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,1,['intuit'],['intuitive']
Usability,"// Only draw the progress bar once in a while, doing this every event causes the evaluation to be ridiculously slow",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx:17,progress bar,progress bar,17,tmva/tmva/src/MethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx,1,['progress bar'],['progress bar']
Usability,// Only generate if Attr can be handled simply.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:40,simpl,simply,40,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,1,['simpl'],['simply']
Usability,// Only handle simple cases of up to 8 GPR and FPR each.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:15,simpl,simple,15,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,1,['simpl'],['simple']
Usability,// Only handle simple cases. i.e. All arguments are directly mapped to; // registers of the appropriate type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:15,simpl,simple,15,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,1,['simpl'],['simple']
Usability,// Only handle simple cases. i.e. Up to 4 i8/i16/i32 scalar arguments; // which are passed in r0 - r3.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:15,simpl,simple,15,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,1,['simpl'],['simple']
Usability,// Only handle simple cases. i.e. Up to 6 i32/i64 scalar arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:15,simpl,simple,15,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,1,['simpl'],['simple']
Usability,// Only handle simple types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:15,simpl,simple,15,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,9,['simpl'],['simple']
Usability,// Only handle simple values that are a power of two bytes in size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:15,simpl,simple,15,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['simpl'],['simple']
Usability,"// Only inline simple if's (no nested if or else), unless specified",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:15,simpl,simple,15,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,1,['simpl'],['simple']
Usability,// Only inspect on simple loop structure,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:19,simpl,simple,19,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['simpl'],['simple']
Usability,// Only matching constant steps matching the AllocSize are supported at the; // moment. This simplifies the difference computation. Can be extended in the; // future.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:93,simpl,simplifies,93,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['simpl'],['simplifies']
Usability,// Only merge two nodes if they are both simple nodes and the consecutive; // instructions after merging belong to the same BB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp:41,simpl,simple,41,interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,1,['simpl'],['simple']
Usability,"// Only perform this optimization on vectors of the same size for simplicity.; // Don't perform this optimization for i1 vectors.; // FIXME: Support i1 vectors, maybe by promoting to i8?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:66,simpl,simplicity,66,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['simpl'],['simplicity']
Usability,"// Only set weights if there is at least one non-zero weight.; // In any other case, let the analyzer set weights.; // Do not set weights if the weights are present unless under; // OverwriteExistingWeights. In ThinLTO, the profile annotation is done; // twice. If the first annotation already set the weights, the second pass; // does not need to set it. With OverwriteExistingWeights, Blocks with zero; // weight should have their existing metadata (possibly annotated by LTO; // prelink) cleared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:491,clear,cleared,491,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['clear'],['cleared']
Usability,// Only simple jump-conditional (with or without negation).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp:8,simpl,simple,8,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,1,['simpl'],['simple']
Usability,// Only the first valid type for a type index will be printed: don't; // overwrite it later so it's always clear which type was expected:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:107,clear,clear,107,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,1,['clear'],['clear']
Usability,// Only treat the destruction as constant destruction if we formally have; // constant initialization (or are usable in a constant expression).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:110,usab,usable,110,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['usab'],['usable']
Usability,// Opcode N U L G E Intuitive operation,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:20,Intuit,Intuitive,20,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['Intuit'],['Intuitive']
Usability,// Opcode U L G E Intuitive operation,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:18,Intuit,Intuitive,18,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['Intuit'],['Intuitive']
Usability,"// OpenACC 3.3, section 2.10:; // A 'var' in a cache directive must be a single array element or a simple; // subarray. In C and C++, a simple subarray is an array name followed by; // an extended array range specification in brackets, with a start and; // length such as:; //; // arr[lower:length]; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:99,simpl,simple,99,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,2,['simpl'],['simple']
Usability,"// OpenACC 3.3, section 2.16:; // the term 'async-argument' means a nonnegative scalar integer expression, or; // one of the special values 'acc_async_noval' or 'acc_async_sync', as defined; // in the C header file and the Fortran opacc module.; //; // We are parsing this simply as list of assignment expressions (to avoid; // comma being troublesome), and will ensure it is an integral type. The; // 'special' types are defined as macros, so we can't really check those; // (other than perhaps as values at one point?), but the standard does say it; // is implementation-defined to use any other negative value.; //; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:273,simpl,simply,273,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,1,['simpl'],['simply']
Usability,"// OpenMP 5.2 [Section 5.4.6, linear clause]; // step-simple-modifier is exclusive, can't be used with 'val', 'uval', or; // 'ref'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:54,simpl,simple-modifier,54,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['simpl'],['simple-modifier']
Usability,"// OpenMP, 2.7.1, Loop Construct, Restrictions; // The nonmonotonic modifier can only be specified with schedule(dynamic) or; // schedule(guided).; // OpenMP 5.0 does not have this restriction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:138,guid,guided,138,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['guid'],['guided']
Usability,// Operands of BUILD_VECTOR are signed and we use this to print operands; // of XXSPLTIB which are unsigned. So we simply truncate to 8 bits and; // print as unsigned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:115,simpl,simply,115,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp,1,['simpl'],['simply']
Usability,"// Operands with the same APO can be reordered. We therefore need to count; // how many of them we have for each APO, like this: Cnt[APO] = x.; // Since we only have two APOs, namely true and false, we can avoid using; // a map. Instead we can simply count the number of operands that; // correspond to one of them (in this case the 'true' APO), and calculate; // the other by subtracting it from the total number of operands.; // Operands with the same instruction opcode and parent are more; // profitable since we don't need to move them in many cases, with a high; // probability such lane already can be vectorized effectively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:244,simpl,simply,244,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['simpl'],['simply']
Usability,"// Optimize (srl (and X, C2), C) ->; // (srli (slli X, (XLen-C3), (XLen-C3) + C); // Where C2 is a mask with C3 trailing ones.; // Taking into account that the C2 may have had lower bits unset by; // SimplifyDemandedBits. This avoids materializing the C2 immediate.; // This pattern occurs when type legalizing right shifts for types with; // less than XLen bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:200,Simpl,SimplifyDemandedBits,200,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,// Optimize globals now that functions are fully simplified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:49,simpl,simplified,49,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['simpl'],['simplified']
Usability,"// Optimize one of these forms:; // and i1 Op, SI / select i1 Op, i1 SI, i1 false (if IsAnd = true); // or i1 Op, SI / select i1 Op, i1 true, i1 SI (if IsAnd = false); // into simplier select instruction using isImpliedCondition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:176,simpl,simplier,176,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,1,['simpl'],['simplier']
Usability,// Optimize some simple tbz/tbnz cases. Returns the new operand and bit to test; // as well as whether the test should be inverted. This code is required to; // catch these cases (as opposed to standard dag combines) because; // AArch64ISD::TBZ is matched during legalization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:17,simpl,simple,17,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['simpl'],['simple']
Usability,"// Options are stored in sorted order, with '\0' at the end of the; // alphabet. Since the only options which can accept a string must; // prefix it, we iteratively search for the next option which could; // be a prefix.; //; // FIXME: This is searching much more than necessary, but I am; // blanking on the simplest way to make it fast. We can solve this; // problem when we move to TableGen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Option/OptTable.cpp:309,simpl,simplest,309,interpreter/llvm-project/llvm/lib/Option/OptTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Option/OptTable.cpp,1,['simpl'],['simplest']
Usability,// Or distributes over And. Try some generic simplifications based on this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:45,simpl,simplifications,45,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifications']
Usability,"// OrOpd0 = AND Src, #Mask; // So BFM simplifies away one AND node from Src and doesn't simplify away; // nodes from Dst. If ORR with left-shifted operand also simplifies away; // one node (from Rd), ORR is better since it has higher throughput and; // smaller latency than BFM on many AArch64 processors (and for the rest; // ORR is at least as good as BFM).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:38,simpl,simplifies,38,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,3,['simpl'],"['simplifies', 'simplify']"
Usability,// Ordering on Info. The logic should match with the consumer-side function in; // llvm/Option/OptTable.h.; // FIXME: Make this take StringRefs instead of null terminated strings to; // simplify callers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/OptEmitter.cpp:186,simpl,simplify,186,interpreter/llvm-project/llvm/utils/TableGen/OptEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/OptEmitter.cpp,1,['simpl'],['simplify']
Usability,"// Original line should be top of undo buffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/Editor.cpp:34,undo,undo,34,core/textinput/src/textinput/Editor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/Editor.cpp,1,['undo'],['undo']
Usability,"// Originally, we could not get the debugger (lldb) to play nicely with ZeroMQ; every time we paused a process, it; // said it crashed because of SIGSTOP, but SIGSTOP should just pause it... this test was meant to reproduce this; // behavior and fix it, which was done by more carefully handling exceptions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Messenger.cxx:94,pause,paused,94,roofit/multiprocess/test/test_Messenger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Messenger.cxx,2,['pause'],"['pause', 'paused']"
Usability,"// Otherwise default to creating a SimpleCompiler, or ConcurrentIRCompiler,; // depending on the number of threads requested.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp:35,Simpl,SimpleCompiler,35,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/LLJIT.cpp,1,['Simpl'],['SimpleCompiler']
Usability,"// Otherwise do coercion through memory. This is stupid, but simple.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:61,simpl,simple,61,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['simpl'],['simple']
Usability,"// Otherwise do coercion through memory. This is stupid, but; // simple.; // Generally SrcSize is never greater than DstSize, since this means we are; // losing bits. However, this can happen in cases where the structure has; // additional padding, for example due to a user specified alignment.; //; // FIXME: Assert that we aren't truncating non-padding bits when have access; // to that information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:65,simpl,simple,65,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['simpl'],['simple']
Usability,"// Otherwise implement simplified merge. We could be smarter about; // this, but it isn't worth it and would be harder to verify.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:23,simpl,simplified,23,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['simpl'],['simplified']
Usability,// Otherwise just do a simple store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:23,simpl,simple,23,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,1,['simpl'],['simple']
Usability,// Otherwise resume the next lookup.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:13,resume,resume,13,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['resume'],['resume']
Usability,"// Otherwise return ""A op V"" if it simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:35,simpl,simplifies,35,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// Otherwise return ""B op V"" if it simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:35,simpl,simplifies,35,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// Otherwise return ""V op B"" if it simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:35,simpl,simplifies,35,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// Otherwise return ""V op C"" if it simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:35,simpl,simplifies,35,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,// Otherwise see what can be done with some simple reasoning.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:44,simpl,simple,44,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['simpl'],['simple']
Usability,// Otherwise simply add the cost for merely making the call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:13,simpl,simply,13,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['simpl'],['simply']
Usability,// Otherwise the existing one comes first so just clear out the value in; // this slot.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h:50,clear,clear,50,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h,1,['clear'],['clear']
Usability,// Otherwise use simple demangling to return the function name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.cpp:17,simpl,simple,17,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVUtils.cpp,1,['simpl'],['simple']
Usability,// Otherwise we can still at least try to simplify multiple use bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:42,simpl,simplify,42,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplify']
Usability,"// Otherwise we emit a cvt that saturates to a higher BW, and saturate the; // result. This is only valid if the legal cvt is larger than the saturate; // width. For double, as we don't have MIN/MAX, it can be simpler to scalarize; // (at least until sqxtn is selected).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:210,simpl,simpler,210,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['simpl'],['simpler']
Usability,"// Otherwise we want to do a simple load, suppressing the; // final autorelease.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:29,simpl,simple,29,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['simpl'],['simple']
Usability,"// Otherwise, (landingpad model), create a conditional branch that leads; // either to a cleanup block or a block with EH resume instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:122,resume,resume,122,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,1,['resume'],['resume']
Usability,"// Otherwise, create a machine node so that target independent DAG combine; // doesn't undo this optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:87,undo,undo,87,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['undo'],['undo']
Usability,"// Otherwise, do some simple heuristics to try to avoid it:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:22,simpl,simple,22,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,1,['simpl'],['simple']
Usability,"// Otherwise, fall back on a bunch of options which don't use multiarch; // layouts for simplicity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:88,simpl,simplicity,88,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['simpl'],['simplicity']
Usability,"// Otherwise, fall back to the generic logic for simplifying and handling; // instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:49,simpl,simplifying,49,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['simpl'],['simplifying']
Usability,"// Otherwise, if the current region does indeed contain the value; // we are looking for, we can look for a region where this value; // was before.; //; // It can be useful for situations like:; // new = identity(old); // where the analyzer knows that 'identity' returns the value of its; // first argument.; //; // NOTE: If the region R is not a simple var region, it can contain; // V in one of its subregions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:347,simpl,simple,347,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,1,['simpl'],['simple']
Usability,"// Otherwise, if this is a comparison of the sign bit, simplify to and/test.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:55,simpl,simplify,55,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['simpl'],['simplify']
Usability,"// Otherwise, insert unreachable instructions and call simplifycfg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp:55,simpl,simplifycfg,55,interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp,1,['simpl'],['simplifycfg']
Usability,"// Otherwise, it didn't fit. Pull in what we can to simplify the immed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:52,simpl,simplify,52,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['simpl'],['simplify']
Usability,"// Otherwise, just use the general rule.; //; // The PPC64 ABI passes some arguments in integer registers, even to variadic; // functions. To allow va_list to use the simple ""void*"" representation,; // variadic calls allocate space in the argument area for the integer argument; // registers, and variadic functions spill their integer argument registers to; // this area in their prologues. When aggregates smaller than a register are; // passed this way, they are passed in the least significant bits of the; // register, which means that after spilling on big-endian targets they will; // be right-aligned in their argument slot. This is uncommon; for a variety of; // reasons, other big-endian targets don't end up right-aligning aggregate; // types this way, and so right-alignment only applies to fundamental types.; // So on PPC64, we must force the use of right-alignment even for aggregates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp:167,simpl,simple,167,interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,1,['simpl'],['simple']
Usability,"// Otherwise, let's simply infer from the destination type.; // We couldn't figure out nothing else about that expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:20,simpl,simply,20,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['simpl'],['simply']
Usability,"// Otherwise, offset doesn't fit. Pull in what we can to simplify",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp:57,simpl,simplify,57,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2InstrInfo.cpp,1,['simpl'],['simplify']
Usability,"// Otherwise, return ""L op' R"" if it simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:37,simpl,simplifies,37,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// Otherwise, save and clear the IP if we don't have fallthrough; // because the cleanup is inactive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:23,clear,clear,23,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,1,['clear'],['clear']
Usability,"// Otherwise, see if ""A EqP B"" simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,simpl,simplifies,31,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,['simpl'],['simplifies']
Usability,"// Otherwise, see if ""A InvEqP B"" simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:34,simpl,simplifies,34,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,['simpl'],['simplifies']
Usability,"// Otherwise, see if we can simplify the input to this truncstore with; // knowledge that only the low bits are being used. For example:; // ""truncstore (or (shl x, 8), y), i8"" -> ""truncstore y, i8""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:28,simpl,simplify,28,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simplify']
Usability,"// Otherwise, the instruction may have multiple operands, and we need to; // verify that none of them are a predecessor of the load. This is exactly; // the same check that would be done by common code if the CC setter were; // glued to the CC user, so simply invoke that check here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:253,simpl,simply,253,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['simpl'],['simply']
Usability,"// Otherwise, try to undo objc-arc-expand.; // Don't use GetArgRCIdentityRoot because we don't want to look through bitcasts; // and such; to do the replacement, the argument must have type i8*.; // Function for replacing uses of Arg dominated by Inst.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:21,undo,undo,21,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,1,['undo'],['undo']
Usability,"// Otherwise, we can potentially simplify the comparison. We know that it; // will always come through as an integer value and we know the constant is; // not a NAN (it would have been previously simplified).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:33,simpl,simplify,33,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,2,['simpl'],"['simplified', 'simplify']"
Usability,"// Otherwise, we can't fold it. However, we can simplify it to SETUO/SETO; // if it is not already.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:48,simpl,simplify,48,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['simpl'],['simplify']
Usability,"// Otherwise, we have a simple constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:24,simpl,simple,24,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,1,['simpl'],['simple']
Usability,"// Otherwise, we have to do a simple load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:30,simpl,simple,30,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['simpl'],['simple']
Usability,"// Otherwise, we know the RHS is not a NaN. Simplify the node to drop the; // constant if knowing that the operand is non-nan is enough. We prefer to; // have SETO(x,x) instead of SETO(x, 0.0) because this avoids having to; // materialize 0.0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:44,Simpl,Simplify,44,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['Simpl'],['Simplify']
Usability,"// Otherwise, we know we have a load(ext), see if any of the Extends are a; // vmull. This is a simple heuristic and certainly not perfect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp:96,simpl,simple,96,interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp,1,['simpl'],['simple']
Usability,"// Otherwise, we may have changed fundamental function attributes, so clear; // out all the passes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp:70,clear,clear,70,interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp,1,['clear'],['clear']
Usability,"// Otherwise, we need to emit the diagnostic. First clear the diagnostic; // builder itself so it won't emit the diagnostic in its own destructor.; //; // This seems wasteful, in that as written the DiagnosticBuilder dtor will; // do its own needless checks to see if the diagnostic needs to be; // emitted. However, because we take care to ensure that the builder; // objects never escape, a sufficiently smart compiler will be able to; // eliminate that code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:52,clear,clear,52,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['clear'],['clear']
Usability,"// Otherwise, we need to make a new block. If the normal cleanup; // isn't being used at all, we could actually reuse the normal; // entry block, but this is simpler, and it avoids conflicts with; // dead optimistic fixup branches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:158,simpl,simpler,158,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,1,['simpl'],['simpler']
Usability,"// Our algorithm is very simple at the moment. We assume that in instruction; // order stores are writing to incremeneting consecutive addresses. So when; // we walk the block in reverse order, the next eligible store must write to; // an offset one store width lower than CurrentLowestOffset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h:25,simpl,simple,25,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h,1,['simpl'],['simple']
Usability,// Our value is represented as simply T if there is no external AST source.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h:31,simpl,simply,31,interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,1,['simpl'],['simply']
Usability,// Out of process mode using SimpleRemoteEPC depends on threads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:29,Simpl,SimpleRemoteEPC,29,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,2,['Simpl'],['SimpleRemoteEPC']
Usability,"// OuterL includes all loops for which we can break loop-simplify, so; // it's sufficient to simplify only it (it'll recursively simplify inner; // loops too).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:57,simpl,simplify,57,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,3,['simpl'],['simplify']
Usability,// Overflow Clear,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h:12,Clear,Clear,12,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.h,2,['Clear'],['Clear']
Usability,"// Overload resolution checks whether the deduction guide is declared; // explicit for us.; // When looking for a converting constructor, deduction guides that; // could never be called with one argument are not interesting to; // check or note.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:52,guid,guide,52,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,2,['guid'],"['guide', 'guides']"
Usability,// Oversized shifts are simplified to zero in InstSimplify.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:24,simpl,simplified,24,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,2,['simpl'],['simplified']
Usability,// PAUSE instruction support,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp:3,PAUSE,PAUSE,3,interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,1,['PAUSE'],['PAUSE']
Usability,// PC32DBL accesses require the low bit to be clear.; //; // FIXME: Explicitly check for functions: the datalayout is currently; // missing information about function pointers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:46,clear,clear,46,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,1,['clear'],['clear']
Usability,// PHINode simplification; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:11,simpl,simplification,11,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,1,['simpl'],['simplification']
Usability,"// PPCEarlyReturn pass - For simple functions without epilogue code, move; // returns up, and create conditional returns, to avoid unnecessary; // branch-to-blr sequences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCEarlyReturn.cpp:29,simpl,simple,29,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCEarlyReturn.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCEarlyReturn.cpp,1,['simpl'],['simple']
Usability,"// PPCTOCRegDeps pass - For simple functions without epilogue code, move; // returns up, and create conditional returns, to avoid unnecessary; // branch-to-blr sequences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:28,simpl,simple,28,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,1,['simpl'],['simple']
Usability,"// PR9614. Avoid cases where the source code is lying to us. An available; // externally function should have an equivalent function somewhere else,; // but a function that calls itself through asm label/`__builtin_` trickery is; // clearly not equivalent to the real implementation.; // This happens in glibc's btowc and in some configure checks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:233,clear,clearly,233,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['clear'],['clearly']
Usability,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter than; // 32-bits are sign extended or zero extended, depending on whether; // they are signed or unsigned types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:24,Guid,Guide,24,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['Guid'],['Guide']
Usability,"// PTX Interoperability Guide 3.3(A): [Integer] Values shorter; // than 32-bits are sign extended or zero extended, depending on; // whether they are signed or unsigned types. This case applies; // only to scalar parameters and not to aggregate values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:24,Guid,Guide,24,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['Guid'],['Guide']
Usability,"// Paint the axis body as a simple line.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TParallelCoordVar.cxx:28,simpl,simple,28,tree/treeviewer/src/TParallelCoordVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TParallelCoordVar.cxx,1,['simpl'],['simple']
Usability,"// Parent DIEs are added to the AddrDieMap prior to the Children DIEs to; // simplify the logic to update AddrDieMap. The child's range will always; // be equal or smaller than the parent's range. With this assumption, when; // adding one range into the map, it will at most split a range into 3; // sub-ranges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp:77,simpl,simplify,77,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp,1,['simpl'],['simplify']
Usability,"// Parse -fsanitize-coverage-(allow|ignore)list options if coverage enabled.; // This also validates special case lists format.; // Here, OptSpecifier() acts as a never-matching command-line argument.; // So, there is no way to clear coverage lists but you can append to them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:228,clear,clear,228,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['clear'],['clear']
Usability,"// Parse a C++ typename-specifier, e.g., ""typename T::type"".; //; // typename-specifier:; // 'typename' '::' [opt] nested-name-specifier identifier; // 'typename' '::' [opt] nested-name-specifier template [opt]; // simple-template-id",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:215,simpl,simple-template-id,215,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['simpl'],['simple-template-id']
Usability,// Parse inline stack like @ GUID:11:12 @ GUID:1:11 @ GUID:3:21,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:29,GUID,GUID,29,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,3,['GUID'],['GUID']
Usability,// Parse simple general-purpose registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp:9,simpl,simple,9,interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/AsmParser/M68kAsmParser.cpp,1,['simpl'],['simple']
Usability,// Parse the (optional) class name or simple-template-id.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:38,simpl,simple-template-id,38,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['simpl'],['simple-template-id']
Usability,// Parse the class-name (or template-name in a simple-template-id).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:47,simpl,simple-template-id,47,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['simpl'],['simple-template-id']
Usability,// Parse the expression; // C++11 [dcl.type.simple]p4:; // The operand of the decltype specifier is an unevaluated operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:44,simpl,simple,44,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['simpl'],['simple']
Usability,"// Parse the unqualified-id. We allow parsing of both constructor and; // destructor names and allow the action module to diagnose any semantic; // errors.; //; // C++11 [class.qual]p2:; // [...] in a using-declaration that is a member-declaration, if the name; // specified after the nested-name-specifier is the same as the identifier; // or the simple-template-id's template-name in the last component of the; // nested-name-specifier, the name is [...] considered to name the; // constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:348,simpl,simple-template-id,348,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['simpl'],['simple-template-id']
Usability,"// Parses simple list:; // simple-variable-list:; // '(' id-expression {, id-expression} ')'; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:10,simpl,simple,10,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,2,['simpl'],"['simple', 'simple-variable-list']"
Usability,// Partial ordering did not produce a clear winner. Complain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:38,clear,clear,38,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,2,['clear'],['clear']
Usability,"// Pass in both instructions and nodes. Instruction information (e.g.,; // instruction type) helps interpret profiles and make implementation clearer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:142,clear,clearer,142,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,1,['clear'],['clearer']
Usability,// Pass things indirectly for now because it is simple.; // FIXME: This is incompatible with MSVC for arguments with a dtor and no; // copy ctor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:48,simpl,simple,48,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['simpl'],['simple']
Usability,"// Pattern : {zeros}{33-bit value}{ones}; // Shift right the Imm by (30 - LZ) bits to construct a negative 34 bit value,; // therefore we can take advantage of PLI's sign-extension semantics, and then; // mask them off after rotation.; //; // +--LZ--||-33-bit-||--TO--+ +-------------|--34-bit--+; // |00000001bbbbbbbbb1111111| -> |00000000000001bbbbbbbbb1|; // +------------------------+ +------------------------+; // 63 0 63 0; //; // +----sext-----|--34-bit--+ +clear-|-----------------+; // |11111111111111bbbbbbbbb1| -> |00000001bbbbbbbbb1111111|; // +------------------------+ +------------------------+; // 63 0 63 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:466,clear,clear,466,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['clear'],['clear']
Usability,"// Pattern c. is non-canonical, and is expanded into pattern d. iff there; // is no extra use of the mask. Clearly, there was one since we are here.; // But at the same time, if we need to negate the shift amount,; // then we don't want the mask to stick around, else it's unprofitable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:107,Clear,Clearly,107,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['Clear'],['Clearly']
Usability,// Pattern match a special case; // (x & ~2^z) == y --> x == y || x == y|2^z; // This undoes a transformation done by instcombine to fuse 2 compares.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:86,undo,undoes,86,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['undo'],['undoes']
Usability,// Pattern-match simple GEPs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:17,simpl,simple,17,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,1,['simpl'],['simple']
Usability,"// Pause button constructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/Tetris.cxx:3,Pause,Pause,3,test/Tetris.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/Tetris.cxx,1,['Pause'],['Pause']
Usability,"// Pause the game",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/Tetris.cxx:3,Pause,Pause,3,test/Tetris.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/Tetris.cxx,1,['Pause'],['Pause']
Usability,"// Pauses replaying",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/src/TRecorder.cxx:3,Pause,Pauses,3,gui/recorder/src/TRecorder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/src/TRecorder.cxx,1,['Pause'],['Pauses']
Usability,"// Peek through a bitcasted shuffle operand by scaling the mask. If the; // simulated shuffle can simplify, then this shuffle is unnecessary:; // shuf (bitcast X), undef, Mask --> bitcast X'; // TODO: This could be extended to allow length-changing shuffles.; // The transform might also be obsoleted if we allowed canonicalization; // of bitcasted shuffles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:98,simpl,simplify,98,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['simpl'],['simplify']
Usability,"// Per C++17 [temp.explicit]p10, we may instantiate despite an explicit; // instantiation declaration if a variable is usable in a constant; // expression (among other cases).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:119,usab,usable,119,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['usab'],['usable']
Usability,// Perform TBI simplification if supported by the target and try to break up; // nontemporal loads larger than 256-bits loads for odd types so LDNPQ 256-bit; // load instructions can be selected.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:15,simpl,simplification,15,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['simpl'],['simplification']
Usability,// Perform a simple cost/benefit analysis to decide whether or not to permit; // splitting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:13,simpl,simple,13,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,1,['simpl'],['simple']
Usability,// Perform one round of simplifcation. Resimplify flag will be set if; // another iteration is requested.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:24,simpl,simplifcation,24,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['simpl'],['simplifcation']
Usability,"// Perform simple binned accept/reject procedure to get to exact event count",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:11,simpl,simple,11,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,2,['simpl'],['simple']
Usability,// Perform simple cse.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:11,simpl,simple,11,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['simpl'],['simple']
Usability,// Perform simple layout on the elements in cacheEnd..<end.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ConstantInitBuilder.cpp:11,simpl,simple,11,interpreter/llvm-project/clang/lib/CodeGen/ConstantInitBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ConstantInitBuilder.cpp,1,['simpl'],['simple']
Usability,// Perform simple memcpy for simple copying.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:11,simpl,simple,11,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,2,['simpl'],['simple']
Usability,// Perform simple memcpy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:11,simpl,simple,11,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,2,['simpl'],['simple']
Usability,// Perform simplification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:11,simpl,simplification,11,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['simpl'],['simplification']
Usability,"// Perform simplifications of 2x64 vector swaps and splats.; // A swap is identified by an immediate value of 2, and a splat; // is identified by an immediate value of 0 or 3.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:11,simpl,simplifications,11,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['simpl'],['simplifications']
Usability,// Perform splitting after instruction scan to simplify iteration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:47,simpl,simplify,47,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['simpl'],['simplify']
Usability,// Perform the actual simplification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:22,simpl,simplification,22,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,2,['simpl'],['simplification']
Usability,// Perform various simplifications.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:19,simpl,simplifications,19,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['simpl'],['simplifications']
Usability,// Periodically do an explicit clear to remove tombstones when processing; // large scc's.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:31,clear,clear,31,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,1,['clear'],['clear']
Usability,// Phis in a loop that are observed outside the loop receive a simple but; // conservatively correct treatment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp:63,simpl,simple,63,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp,1,['simpl'],['simple']
Usability,"// PhysReg is available, but there may be a better choice.; // If we missed a simple hint, try to cheaply evict interference from the; // preferred register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:78,simpl,simple,78,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,1,['simpl'],['simple']
Usability,"// Physical registers like SCC aren't tracked by default anyway, so just; // removing the ranges we computed is the simplest option for maintaining; // the analysis results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:116,simpl,simplest,116,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['simpl'],['simplest']
Usability,"// Physicals should have been cleared elsewhere as they are managed; // by the scene. But this could change.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx:30,clear,cleared,30,graf3d/gl/src/TGLLogicalShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx,1,['clear'],['cleared']
Usability,// Pipeline is paused.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Pipeline.h:15,pause,paused,15,interpreter/llvm-project/llvm/include/llvm/MCA/Pipeline.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Pipeline.h,1,['pause'],['paused']
Usability,// Place the list of instructions to simplify on the next loop iteration; // into ToSimplify.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp:37,simpl,simplify,37,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,1,['simpl'],['simplify']
Usability,// Plain scalars can be simple keys.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp:24,simpl,simple,24,interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,1,['simpl'],['simple']
Usability,"// Point-in-time: we didn't learn this, so we always delegate to the; // default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:28,learn,learn,28,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,1,['learn'],['learn']
Usability,"// Pointer to simple string to be displayed.; // This is a pointer into the TGTextLayout's; // string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx:14,simpl,simple,14,gui/gui/src/TGFont.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx,1,['simpl'],['simple']
Usability,"// Pointers to simple types without any options can use SimpleTypeMode, rather; // than having a dedicated pointer type record.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:15,simpl,simple,15,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,2,"['Simpl', 'simpl']","['SimpleTypeMode', 'simple']"
Usability,"// Populate map of GUID to the prevailing copy for any multiply defined; // symbols. Currently assume first copy is prevailing, or any strong; // definition. Can be refined with Linker information in the future.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:19,GUID,GUID,19,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,1,['GUID'],['GUID']
Usability,// Populate our simplified values by mapping from function arguments to call; // arguments with known important simplifications.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:16,simpl,simplified,16,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,2,['simpl'],"['simplifications', 'simplified']"
Usability,"// Populate the loop queue in reverse program order. There is no clear need to; // process sibling loops in either forward or reverse order. There may be some; // advantage in deleting uses in a later loop before optimizing the; // definitions in an earlier loop. If we find a clear reason to process in; // forward order, then a forward variant of LoopPassManager should be created.; //; // Note that LoopInfo::iterator visits loops in reverse program; // order. Here, reverse_iterator gives us a forward order, and the LoopQueue; // reverses the order a third time by popping from the back.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:65,clear,clear,65,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,2,['clear'],['clear']
Usability,// Ported from Stefan Gustavson's java implementation; // http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf; // Read Stefan's excellent paper for details on how this code works.; //; // Sean McCullough banksean@gmail.com; //; // Added 4D noise; /**; * You can pass in a random number generator object if you like.; * It is assumed to have a random() method.; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs:92,simpl,simplexnoise,92,js/modules/three_addons.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs,2,['simpl'],['simplexnoise']
Usability,"// Post process the profile after trace aggregation, we will do simple range; // overlap computation for AutoFDO, or unwind for CSSPGO(hybrid sample).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h:64,simpl,simple,64,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h,1,['simpl'],['simple']
Usability,// PostIncNormalization effectively simplifies the expression under; // pre-increment assumptions. Those assumptions (no wrapping) might not; // hold for the post-inc value. Catch such cases by making sure the; // transformation is invertible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:36,simpl,simplifies,36,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,1,['simpl'],['simplifies']
Usability,// Potentially simplifiable operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:15,simpl,simplifiable,15,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,1,['simpl'],['simplifiable']
Usability,"// PowerPC specific version of setSpecialOperandAttr that copies Flags to MI; // and clears nuw, nsw, and exact flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:85,clear,clears,85,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,1,['clear'],['clears']
Usability,"// PowerPC supports unaligned memory access for simple non-vector types.; // Although accessing unaligned addresses is not as efficient as accessing; // aligned addresses, it is generally more efficient than manual expansion,; // and generally only traps for software emulation when crossing page; // boundaries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:48,simpl,simple,48,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['simpl'],['simple']
Usability,"// Prebranched fallthrough was forwarded earlier.; // Non-prebranched fallthrough doesn't need to be forwarded.; // Either way, all we need to do is restore the IP we cleared before.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:167,clear,cleared,167,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,1,['clear'],['cleared']
Usability,"// Prefer simplifying to the splat-shuffle, if possible. This is legal if; // every undef mask element in the splat-shuffle has a corresponding undef; // element in the user-shuffle's mask or if the composition of mask elements; // would result in undef.; // Examples for (shuffle (shuffle v, undef, SplatMask), undef, UserMask):; // * UserMask=[0,2,u,u], SplatMask=[2,u,2,u] -> [2,2,u,u]; // In this case it is not legal to simplify to the splat-shuffle because we; // may be exposing the users of the shuffle an undef element at index 1; // which was not there before the combine.; // * UserMask=[0,u,2,u], SplatMask=[2,u,2,u] -> [2,u,2,u]; // In this case the composition of masks yields SplatMask, so it's ok to; // simplify to the splat-shuffle.; // * UserMask=[3,u,2,u], SplatMask=[2,u,2,u] -> [u,u,2,u]; // In this case the composed mask includes all undef elements of SplatMask; // and in addition sets element zero to undef. It is safe to simplify to; // the splat-shuffle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,simpl,simplifying,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,4,['simpl'],"['simplify', 'simplifying']"
Usability,// Prefer something that doesn't involve a cast to make things simpler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:63,simpl,simpler,63,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['simpl'],['simpler']
Usability,// Prefer uxtb mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:10,ux,uxtb,10,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['ux'],['uxtb']
Usability,// Prefer uxth mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:10,ux,uxth,10,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['ux'],['uxth']
Usability,// Prepare for the iteration by collecting any simplified entry or backedge; // inputs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:47,simpl,simplified,47,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['simpl'],['simplified']
Usability,"// Prepare to clear out remaining short vectors before returning",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:14,clear,clear,14,hist/histpainter/src/TGraphPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx,2,['clear'],['clear']
Usability,"// Present PROOF query feedback",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TDrawFeedback.h:23,feedback,feedback,23,proof/proofplayer/inc/TDrawFeedback.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TDrawFeedback.h,2,['feedback'],['feedback']
Usability,"// Prevent redirection from stealing our console handle,; // simply open our own.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TerminalDisplayWin.cpp:61,simpl,simply,61,core/textinput/src/textinput/TerminalDisplayWin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TerminalDisplayWin.cpp,1,['simpl'],['simply']
Usability,"// Previously we used getIRPGOFuncName() here. If F is local linkage,; // getIRPGOFuncName() returns FuncName with prefix 'FileName;'. But; // llvm-profdata uses FuncName in dwarf to create GUID which doesn't; // contain FileName's prefix. It caused local linkage function can't; // find MemProfRecord. So we use getName() now.; // 'unique-internal-linkage-names' can make MemProf work better for local; // linkage function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:190,GUID,GUID,190,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,1,['GUID'],['GUID']
Usability,// Primitive types are simply returned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeStmtGen.cpp:23,simpl,simply,23,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeStmtGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeStmtGen.cpp,1,['simpl'],['simply']
Usability,// Print all type id that correspond to this GUID.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:45,GUID,GUID,45,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,2,['GUID'],['GUID']
Usability,"// Prior to DWARF v5, we derive the contribution size from the; // index table (in a package file). In a .dwo file it is simply; // the length of the string offsets section.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp:121,simpl,simply,121,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp,1,['simpl'],['simply']
Usability,"// Prior to LLVM 10.0, the strictfp attribute could be used on individual; // callsites within a function that did not also have the strictfp attribute.; // Since 10.0, if strict FP semantics are needed within a function, the; // function must have the strictfp attribute and all calls within the function; // must also have the strictfp attribute. This latter restriction is; // necessary to prevent unwanted libcall simplification when a function is; // being cloned (such as for inlining).; //; // The ""dangling"" strictfp attribute usage was only used to prevent constant; // folding and other libcall simplification. The nobuiltin attribute on the; // callsite has the same effect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:418,simpl,simplification,418,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,2,['simpl'],['simplification']
Usability,"// Private flag to resume from current node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNode.h:19,resume,resume,19,geom/geom/inc/TGeoNode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNode.h,1,['resume'],['resume']
Usability,// Process resume instructions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:11,resume,resume,11,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,1,['resume'],['resume']
Usability,"// Process the new cell. (Cells beyond the maximum number of; // cells are simply ignored.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx:75,simpl,simply,75,gui/guihtml/src/TGHtmlTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx,1,['simpl'],['simply']
Usability,"// Produced e.g. by `csc /debug`. The encoded data is its own mini-stream; // with the following layout (in little endian):; // GUID LanguageTypeGuid;; // GUID LanguageVendorGuid;; // GUID DocumentTypeGuid;; // GUID HashFunctionGuid;; // uint32_t HashDataSize;; // uint32_t CompressedDataSize;; // Followed by HashDataSize bytes containing a hash checksum,; // followed by CompressedDataSize bytes containing source contents.; //; // CompressedDataSize can be 0, in this case only the hash data is present.; // (CompressedDataSize is != 0 e.g. if `/embed` is passed to csc.exe.); // The compressed data format is:; // uint32_t UncompressedDataSize;; // If UncompressedDataSize is 0, the data is stored uncompressed and; // CompressedDataSize stores the uncompressed size.; // If UncompressedDataSize is != 0, then the data is in raw deflate; // encoding as described in rfc1951.; //; // A GUID is 16 bytes, stored in the usual; // uint32_t; // uint16_t; // uint16_t; // uint8_t[24]; // layout.; //; // Well-known GUIDs for LanguageTypeGuid are:; // 63a08714-fc37-11d2-904c-00c04fa302a1 C; // 3a12d0b7-c26c-11d0-b442-00a0244a1dd2 C++; // 3f5162f8-07c6-11d3-9053-00c04fa302a1 C#; // af046cd1-d0e1-11d2-977c-00a0c9b4d50c Cobol; // ab4f38c9-b6e6-43ba-be3b-58080b2ccce3 F#; // 3a12d0b4-c26c-11d0-b442-00a0244a1dd2 Java; // 3a12d0b6-c26c-11d0-b442-00a0244a1dd2 JScript; // af046cd2-d0e1-11d2-977c-00a0c9b4d50c Pascal; // 3a12d0b8-c26c-11d0-b442-00a0244a1dd2 Visual Basic; //; // Well-known GUIDs for LanguageVendorGuid are:; // 994b45c4-e6e9-11d2-903f-00c04fa302a1 Microsoft; //; // Well-known GUIDs for DocumentTypeGuid are:; // 5a869d0b-6611-11d3-bd2a-0000f80849bd Text; //; // Well-known GUIDs for HashFunctionGuid are:; // 406ea660-64cf-4c82-b6f0-42d48172a799 MD5 (HashDataSize is 16); // ff1816ec-aa5e-4d10-87f7-6f4963833460 SHA1 (HashDataSize is 20); // 8829d00f-11b8-4213-878b-770e8597ac16 SHA256 (HashDataSize is 32)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBTypes.h:128,GUID,GUID,128,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBTypes.h,9,['GUID'],"['GUID', 'GUIDs']"
Usability,"// Program is loading user32.dll, in the applications we are testing,; // this only happens if an assert has fired. By now the message has; // already been printed, so simply close the program.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp:168,simpl,simply,168,interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp,1,['simpl'],['simply']
Usability,"// Program to check a TGeo geometry; // The first time you run this program, the geometry files will be taken; // from http://root.cern/files; //; // How the program works; // If the file <geom_name>_ref.root does not exist, it is generated. The file; // contains a TTree with Npoints (default=100000) obtained with the following; // algorithm:; // -a point is generated with a uniform distribution x,y,z in the master volume; // -a direction theta, phi is generated uniformly in -2pi<phi<2pi and 0<theta<pi; // -gGeoManager finds the geometry path for the point; // -the number of boundaries (nbound), total length (length), safety distance; // from the starting point (safe) and number of radiation lengths (rad) from x,y,z; // is calculated to the exit of the detector. The total number of crossings, detector; // weight and total number of radiation lengths for all tracks are stored as user info in the tree.; //; // Using the file <geom_name>_ref.root (generated typically with a previous version; // of the TGeo classes), the Npoints in the Tree are used to perform the; // same operation with the new version.; // In case of a disagreement, an error message is reported.; //; // The ReadRef case is also used as a benchmark; // The ROOTMARKS reported are relative to a Linux/P IV 2.8 GHz gcc3.2.3 machine; // normalized at 800 ROOTMARKS when running with CINT.; //; // To run this script, do; // stressGeometry; // or stressGeometry *; // or stressGeometry alice; // or from the ROOT command line; // root > .L stressGeometry.cxx or .L stressGeometry.cxx+; // root > stressGeometry(exp_name); // where exp_name is the geometry file name without .root; // OR simply: stressGeometry(); to run tests for a set of geometries; //; // Authors: Rene Brun, Andrei Gheata, 22 march 2005",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressGeometry.cxx:1666,simpl,simply,1666,test/stressGeometry.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressGeometry.cxx,1,['simpl'],['simply']
Usability,"// Progress bar",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TProofProgressDialog.cxx:3,Progress bar,Progress bar,3,gui/sessionviewer/src/TProofProgressDialog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TProofProgressDialog.cxx,1,['Progress bar'],['Progress bar']
Usability,// Promote from an unevaluated context to an unevaluated list context in; // C++11 list-initialization; we need to instantiate entities usable in; // constant expressions here in order to perform narrowing checks =(,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:136,usab,usable,136,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['usab'],['usable']
Usability,// Promotion aliases are used only in inline assembly. It's safe to; // simply skip unusual names. Subset of MCAsmInfo::isAcceptableChar(); // and MCAsmInfoXCOFF::isAcceptableChar().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:72,simpl,simply,72,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,1,['simpl'],['simply']
Usability,// Propagate FP flags from the original instructions.; // But clear poison-generating flags because those may not be valid now.; // TODO: There should be a helper function for copying only fast-math-flags.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:62,clear,clear,62,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,1,['clear'],['clear']
Usability,"// Propagate the reached registers up in the phi chain.; //; // The following type of situation needs careful handling:; //; // phi d1<R1:0> (1); // |; // ... d2<R1>; // |; // phi u3<R1:0> (2); // |; // ... u4<R1>; //; // The phi node (2) defines a register pair R1:0, and reaches a ""real""; // use u4 of just R1. The same phi node is also known to reach (upwards); // the phi node (1). However, the use u4 is not reached by phi (1),; // because of the intervening definition d2 of R1. The data flow between; // phis (1) and (2) is restricted to R1:0 minus R1, i.e. R0.; //; // When propagating uses up the phi chains, get the all reaching defs; // for a given phi use, and traverse the list until the propagated ref; // is covered, or until reaching the final phi. Only assume that the; // reference reaches the phi in the latter case.; // The operation ""clearIn"" can be expensive. For a given set of intervening; // defs, cache the result of subtracting these defs from a given register; // ref.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:855,clear,clearIn,855,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,1,['clear'],['clearIn']
Usability,"// Property metadata: name, attributes, isSynthesized, setter name, setter; // types, getter name, getter types.; // The isSynthesized value is always set to 0 in a protocol. It exists to; // simplify the runtime library by allowing it to use the same data; // structures for protocol metadata everywhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:192,simpl,simplify,192,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['simpl'],['simplify']
Usability,// Property names are always simple identifiers and therefore never; // require any interesting additional storage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:29,simpl,simple,29,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['simpl'],['simple']
Usability,"// Prorated callsite count, which will be used to guide inlining. For example,; // if a callsite is duplicated in LTO prelink, then in LTO postlink the two; // copies will get their own distribution factors and their prorated counts; // will be used to decide if they should be inlined independently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:50,guid,guide,50,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['guid'],['guide']
Usability,"// Provides predicate information for assumes. Since assumes are always true,; // we simply provide the assume instruction, so you can tell your relative; // position to it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h:85,simpl,simply,85,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h,1,['simpl'],['simply']
Usability,"// Prune! But don't simply write our lines - other processes might have; // added their own.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/History.cpp:20,simpl,simply,20,core/textinput/src/textinput/History.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/History.cpp,1,['simpl'],['simply']
Usability,// Public interface to the simplify instructions pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp:27,simpl,simplify,27,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,1,['simpl'],['simplify']
Usability,// Public so this can be used in `SimplifyDemandedUseBits`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:34,Simpl,SimplifyDemandedUseBits,34,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['Simpl'],['SimplifyDemandedUseBits']
Usability,"// Pure subset/simple reordering of the standard Macintosh; // glyph set. Deprecated as of OpenType Specification v1.3; //; // numberOfGlyphs, offset[numGlyphs]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/mathtext/src/fontembed.cxx:15,simpl,simple,15,graf2d/mathtext/src/fontembed.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/mathtext/src/fontembed.cxx,1,['simpl'],['simple']
Usability,// Push BSWAP into a vector insertion if at least one side then simplifies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:64,simpl,simplifies,64,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['simpl'],['simplifies']
Usability,// Push BSWAP into a vector shuffle if at least one side then simplifies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:62,simpl,simplifies,62,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['simpl'],['simplifies']
Usability,// Put the lowest index to SrcOpIdx1 to simplify the checks below.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:40,simpl,simplify,40,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['simpl'],['simplify']
Usability,// Put the token stream back and undo any annotations we performed; // after the comma. They may reflect a different parse than the one; // we will actually perform at the end of the class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:33,undo,undo,33,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,1,['undo'],['undo']
Usability,"// QueryAnalysis allowed to transform the IR source, one such example is; // Simplify CFG helps the static branch prediction heuristics!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp:77,Simpl,Simplify,77,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp,1,['Simpl'],['Simplify']
Usability,"// R->getValue() != &F is to prevent promoting a recursive call.; // If it is a recursive call, we do not inline it as it could bloat; // the code exponentially. There is way to better handle this, e.g.; // clone the caller first, and inline the cloned caller if it is; // recursive. As llvm does not inline recursive calls, we will; // simply ignore it instead of handling it explicitly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:337,simpl,simply,337,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['simpl'],['simply']
Usability,"// RAUW has replaced all original uses with references to the new value,; // including the debug uses. Since we are undoing the replacements,; // the original debug uses must also be reinstated to maintain the; // correctness and utility of debug value instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:116,undo,undoing,116,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['undo'],['undoing']
Usability,// RESUME: [opval],MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:3,RESUME,RESUME,3,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,2,['RESUME'],['RESUME']
Usability,// RLDICL generates sign-extended output if it clears at least; // 33 bits from the left (MSB).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:47,clear,clears,47,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['clear'],['clears']
Usability,"// Re-assemble i64 arguments split up in SelectionDAGBuilder's; // visitInlineAsm / GetRegistersForValue functions.; //; // Note: This function was copied from, and is essentially identical; // to ARMISelDAGToDAG::SelectInlineAsm. It is very unfortunate that; // such hacking-up is necessary; a rethink of how inline asm operands; // are handled may be in order to make doing this more sane.; //; // TODO: fix inline asm support so I can simply tell it that 'i64'; // inputs to asm need to be allocated to the IntPair register type,; // and have that work. Then, delete this function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp:438,simpl,simply,438,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelDAGToDAG.cpp,1,['simpl'],['simply']
Usability,"// Re-evaluate an SVal with top-level `State->assume`, this ignites; // a RECURSIVE algorithm that will reach a FIXPOINT.; //; // About performance and complexity: Let us assume that in a State we; // have N non-trivial equivalence classes and that all constraints and; // disequality info is related to non-trivial classes. In the worst case,; // we can simplify only one symbol of one class in each iteration. The; // number of symbols in one class cannot grow b/c we replace the old; // symbol with the simplified one. Also, the number of the equivalence; // classes can decrease only, b/c the algorithm does a merge operation; // optionally. We need N iterations in this case to reach the fixpoint.; // Thus, the steps needed to be done in the worst case is proportional to; // N*N.; //; // This worst case scenario can be extended to that case when we have; // trivial classes in the constraints and in the disequality map. This; // case can be reduced to the case with a State where there are only; // non-trivial classes. This is because a merge operation on two trivial; // classes results in one non-trivial class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:355,simpl,simplify,355,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,2,['simpl'],"['simplified', 'simplify']"
Usability,"// Re-initialize live-ins and live-outs, to clear the remains of previous; // variables live-ins / live-outs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:44,clear,clear,44,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['clear'],['clear']
Usability,// Re-usable checks,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:6,usab,usable,6,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,1,['usab'],['usable']
Usability,"// Re-use the trip count and steps expanded for the main loop, as; // skeleton creation needs it as a value that dominates both the scalar; // and vector epilogue loops; // TODO: This is a workaround needed for epilogue vectorization and it; // should be removed once induction resume value creation is done; // directly in VPlan.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:278,resume,resume,278,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['resume'],['resume']
Usability,// Re-visit the ands. It's possible we eliminated one of them and it could; // simplify the vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:79,simpl,simplify,79,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['simpl'],['simplify']
Usability,"// Re-visit the store if anything changed and the store hasn't been merged; // with another node (N is deleted) SimplifyDemandedBits will add Value's; // node back to the worklist if necessary, but we also need to re-visit; // the Store node itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:112,Simpl,SimplifyDemandedBits,112,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['Simpl'],['SimplifyDemandedBits']
Usability,"// Read TObject derived classes from a TBuffer. Need to provide; // custom version for non-TObject derived classes.; // This operator has to be a templated and/or automatically; // generated if we want to be able to check the type of the; // incoming object. I.e. a operator>>(TBuffer &buf, TObject *&); // would not be sufficient to pass the information 'which class do we want'; // since the pointer could be zero (so typeid(*obj) is not usable).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TBuffer.h:440,usab,usable,440,core/base/inc/TBuffer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TBuffer.h,1,['usab'],['usable']
Usability,"// Read a simple v6.20 (and before) TFoam; // This is the example from the TFoam documentation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/test/testTFoam.cxx:10,simpl,simple,10,math/foam/test/testTFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/test/testTFoam.cxx,1,['simpl'],['simple']
Usability,"// Read a simple v6.20 workspace to test proxy schema evolution",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testProxiesAndCategories.cxx:10,simpl,simple,10,roofit/roofitcore/test/testProxiesAndCategories.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testProxiesAndCategories.cxx,1,['simpl'],['simple']
Usability,// Read guid,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:8,guid,guid,8,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,1,['guid'],['guid']
Usability,"// Rebuild the simplified chain of InsertElements. e.g. (a, b, a, b) as (a, b)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:15,simpl,simplified,15,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['simpl'],['simplified']
Usability,"// Receive clear or anonymous pass",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:11,clear,clear,11,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['clear'],['clear']
Usability,"// Recognize loops where the code at the end of the loop matches the code; // before the entry of the loop, and the matching code is such that is can; // be simplified. This pass relies on the bit simplification above and only; // prepares code in a way that can be handled by the bit simplifcation.; //; // This is the motivating testcase (and explanation):; //; // {; // loop0(.LBB0_2, r1) // %for.body.preheader; // r5:4 = memd(r0++#8); // }; // {; // r3 = lsr(r4, #16); // r7:6 = combine(r5, r5); // }; // {; // r3 = insert(r5, #16, #16); // r7:6 = vlsrw(r7:6, #16); // }; // .LBB0_2:; // {; // memh(r2+#4) = r5; // memh(r2+#6) = r6 # R6 is really R5.H; // }; // {; // r2 = add(r2, #8); // memh(r2+#0) = r4; // memh(r2+#2) = r3 # R3 is really R4.H; // }; // {; // r5:4 = memd(r0++#8); // }; // { # ""Shuffling"" code that sets up R3 and R6; // r3 = lsr(r4, #16) # so that their halves can be stored in the; // r7:6 = combine(r5, r5) # next iteration. This could be folded into; // } # the stores if the code was at the beginning; // { # of the loop iteration. Since the same code; // r3 = insert(r5, #16, #16) # precedes the loop, it can actually be moved; // r7:6 = vlsrw(r7:6, #16) # there.; // }:endloop0; //; //; // The outcome:; //; // {; // loop0(.LBB0_2, r1); // r5:4 = memd(r0++#8); // }; // .LBB0_2:; // {; // memh(r2+#4) = r5; // memh(r2+#6) = r5.h; // }; // {; // r2 = add(r2, #8); // memh(r2+#0) = r4; // memh(r2+#2) = r4.h; // }; // {; // r5:4 = memd(r0++#8); // }:endloop0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:157,simpl,simplified,157,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,3,['simpl'],"['simplifcation', 'simplification', 'simplified']"
Usability,// Recognize patterns that can be simplified and replace them with the; // simpler forms.; // This is by no means complete,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:34,simpl,simplified,34,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,2,['simpl'],"['simpler', 'simplified']"
Usability,// Recognize the following pattern:; //; // AndVT = (and (sign_extend NarrowVT to AndVT) #bitmask); //; // where bitmask is a mask that clears the upper bits of AndVT. The; // number of bits in bitmask must be a power of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:136,clear,clears,136,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['clear'],['clears']
Usability,// Record GEPs with non-zero offsets as candidates for splitting in; // the event that the offset cannot fit into the r+i addressing mode.; // Simple and common case that only one GEP is used in calculating the; // address for the memory access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:143,Simpl,Simple,143,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['Simpl'],['Simple']
Usability,// Record the number of bindings first to simplify deserialization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:42,simpl,simplify,42,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,1,['simpl'],['simplify']
Usability,// Record the number of friend type template parameter lists here; // so as to simplify memory allocation during deserialization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:79,simpl,simplify,79,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,1,['simpl'],['simplify']
Usability,// Record/return the DebugLoc of the simple 'return' expression to be used; // later by the actual 'ret' instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:37,simpl,simple,37,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['simpl'],['simple']
Usability,// Recreate the landingpad's return value for the 'resume' instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:51,resume,resume,51,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,1,['resume'],['resume']
Usability,"// Recurse through a chain of 'and' operands. This requires an extra check; // vs. the 'or' matcher: we must find an ""and X, 1"" instruction somewhere; // in the chain to know that all of the high bits are cleared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:205,clear,cleared,205,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['clear'],['cleared']
Usability,"// Recursive corrections didn't work, wipe them away and don't add; // them to the TypoExprs set. Remove them from Sema's TypoExpr list; // since we don't want to clear them twice. Note: it's possible the; // TypoExprs were created recursively and thus won't be in our; // Sema's TypoExprs - they were created in our `RecursiveTransformLoop`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:163,clear,clear,163,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['clear'],['clear']
Usability,// Recursive helper to trim contexts and create metadata nodes.; // Caller should have pushed Node's loc to MIBCallStack. Doing this in the; // caller makes it simpler to handle the many early returns in this method.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:160,simpl,simpler,160,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,1,['simpl'],['simpler']
Usability,"// Recursively enable all features that this one depends on. This handles all; // of the simple cases, where the behaviour doesn't depend on the base; // architecture version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/AArch64TargetParser.cpp:89,simpl,simple,89,interpreter/llvm-project/llvm/lib/TargetParser/AArch64TargetParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/AArch64TargetParser.cpp,1,['simpl'],['simple']
Usability,"// Reduce the code after globalopt and ipsccp. Both can open up significant; // simplification opportunities, and both can propagate functions through; // function pointers. When this happens, we often have to resolve varargs; // calls, etc, so let instcombine do this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:80,simpl,simplification,80,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['simpl'],['simplification']
Usability,"// Reduce the shift amount and add zeros to the LSBs so it will match; // LUI, then shift left with SLLI.UW to clear the upper 32 set bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:111,clear,clear,111,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,1,['clear'],['clear']
Usability,// Reduce v2i64 to v4i32 if we don't need the upper bits or are known zero.; // TODO: Move to DAGCombine/SimplifyDemandedBits?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:105,Simpl,SimplifyDemandedBits,105,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,"// Reduced tiny cores don't support load/store with displacement. However,; // they do support postincrement. So we'll simply adjust the pointer before; // and after and use postincrement to load multiple registers.; // Add offset. The offset can be 0 when expanding this instruction from the; // more specific LDWRdPtr instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:119,simpl,simply,119,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,1,['simpl'],['simply']
Usability,"// Reg is free of assignment, a simple assignment will make the; // register bank to match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:32,simpl,simple,32,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['simpl'],['simple']
Usability,// Regalloc scoring for ML-driven eviction - noop except when learning a new; // eviction policy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:62,learn,learning,62,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,1,['learn'],['learning']
Usability,// Reject constants that would be truncated if they were converted to; // the floating point type. Test by simple to/from conversion.; // FIXME: Ideally the conversion to an APFloat and from an APFloat; // could be avoided if there was a convertFromAPInt method; // which could signal back if implicit truncation occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:107,simpl,simple,107,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['simpl'],['simple']
Usability,// Reject empty ranges to simplify bookkeeping by ensuring that we can get; // the end of the last block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:26,simpl,simplify,26,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,1,['simpl'],['simplify']
Usability,"// RelDir should use /, but unescaped \ is possible on windows!; // Our completions will normalize to / for simplicity, this case is rare.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:108,simpl,simplicity,108,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['simpl'],['simplicity']
Usability,// Release function-specific state. SDB and CurDAG are already cleared; // at this point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:63,clear,cleared,63,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['clear'],['cleared']
Usability,"// Remainder is straightforward. Remainder is always exact, so the; // type of OpI doesn't enter into things at all. We simply evaluate; // in whichever source type is larger, then convert to the; // destination type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:120,simpl,simply,120,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['simpl'],['simply']
Usability,"// Remember that this was the last unordered store we saw for DSE. We; // don't yet handle DSE on ordered or volatile stores since we don't; // have a good way to model the ordering requirement for following; // passes once the store is removed. We could insert a fence, but; // since fences are slightly stronger than stores in their ordering,; // it's not clear this is a profitable transform. Another option would; // be to merge the ordering with that of the post dominating store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:358,clear,clear,358,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['clear'],['clear']
Usability,"// Remember the expanded value for this SCEV at this location.; //; // This is independent of PostIncLoops. The mapped value simply materializes; // the expression at this insertion point. If the mapped value happened to be; // a postinc expansion, it could be reused by a non-postinc user, but only if; // its insertion point was already at the head of the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:125,simpl,simply,125,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['simpl'],['simply']
Usability,"// Remember the phi nodes originally in the header of FC0 in order to rewire; // them later. However, this is only necessary if the new loop carried; // values might not dominate the exiting branch. While we do not generally; // test if this is the case but simply insert intermediate phi nodes, we; // need to make sure these intermediate phi nodes have different; // predecessors. To this end, we filter the special case where the exiting; // block is the latch block of the first loop. Nothing needs to be done; // anyway as all loop carried values dominate the latch and thereby also the; // exiting branch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:258,simpl,simply,258,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['simpl'],['simply']
Usability,"// Remember the phi nodes originally in the header of FC0 in order to rewire; // them later. However, this is only necessary if the new loop carried; // values might not dominate the exiting branch. While we do not generally; // test if this is the case but simply insert intermediate phi nodes, we; // need to make sure these intermediate phi nodes have different; // predecessors. To this end, we filter the special case where the exiting; // block is the latch block of the first loop. Nothing needs to be done; // anyway as all loop carried values dominate the latch and thereby also the; // exiting branch.; // KB: This is no longer necessary because FC0.ExitingBlock == FC0.Latch; // (because the loops are rotated. Thus, nothing will ever be added to; // OriginalFC0PHIs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:258,simpl,simply,258,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['simpl'],['simply']
Usability,// Remember to clear kill flags.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:15,clear,clear,15,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['clear'],['clear']
Usability,"// Remove all uses of stackified registers to bring the instruction format; // into its final stack form used thruout MC, and transition opcodes to; // their _S variant.; // We do this separate from the above code that still may need these; // registers for e.g. call_indirect signatures.; // See comments in lib/Target/WebAssembly/WebAssemblyInstrFormats.td for; // details.; // TODO: the code above creates new registers which are then removed here.; // That code could be slightly simplified by not doing that, though maybe; // it is simpler conceptually to keep the code above in ""register mode""; // until this transition point.; // FIXME: we are not processing inline assembly, which contains register; // operands, because it is used by later target generic code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMCInstLower.cpp:484,simpl,simplified,484,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMCInstLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMCInstLower.cpp,2,['simpl'],"['simpler', 'simplified']"
Usability,"// Remove any copies from the loop, to ensure the phi that remains is both; // simpler and contains no extra uses. Because t2LoopEndDec is a terminator; // that cannot spill, we need to be careful what remains in the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:79,simpl,simpler,79,interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,1,['simpl'],['simpler']
Usability,"// Remove debug intrinsics which describe the value contained within the; // alloca. In addition to removing dbg.{declare,addr} which simply point to; // the alloca, remove dbg.value(<alloca>, ..., DW_OP_deref)'s as well, e.g.:; //; // ```; // define void @foo(i32 %0) {; // %a = alloca i32 ; Deleted.; // store i32 %0, i32* %a; // dbg.value(i32 %0, ""arg0"") ; Not deleted.; // dbg.value(i32* %a, ""arg0"", DW_OP_deref) ; Deleted.; // call void @trivially_inlinable_no_op(i32* %a); // ret void; // }; // ```; //; // This may not be required if we stop describing the contents of allocas; // using dbg.value(<alloca>, ..., DW_OP_deref), but we currently do this in; // the LowerDbgDeclare utility.; //; // If there is a dead store to `%a` in @trivially_inlinable_no_op, the; // ""arg0"" dbg.value may be stale after the call. However, failing to remove; // the DW_OP_deref dbg.value causes large gaps in location coverage.; //; // FIXME: the Assignment Tracking project has now likely made this; // redundant (and it's sometimes harmful).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:134,simpl,simply,134,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simply']
Usability,"// Remove default from cases.; // If TI's block is the default block from Pred's comparison, potentially; // simplify TI based on this knowledge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:109,simpl,simplify,109,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['simpl'],['simplify']
Usability,// Remove early-clobber and exec dependency from simple SGPR copies.; // This allows some to be eliminated during/post RA.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:49,simpl,simple,49,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['simpl'],['simple']
Usability,"// Remove insertelement, if we don't use the inserted element.; // extractelement (bitcast (insertelement (Vec, b)), a) ->; // extractelement (bitcast (Vec), a); // FIXME: this should be removed to SimplifyDemandedVectorElts,; // once scale vectors are supported.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:198,Simpl,SimplifyDemandedVectorElts,198,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['Simpl'],['SimplifyDemandedVectorElts']
Usability,"// Remove ranges of all clobbered registers. Register masks don't usually; // list SP as preserved. Assume that call instructions never clobber SP,; // because some backends (e.g., AArch64) never list SP in the regmask.; // While the debug info may be off for an instruction or two around; // callee-cleanup calls, transferring the DEBUG_VALUE across the call is; // still a better user experience.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:382,user experience,user experience,382,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,1,['user experience'],['user experience']
Usability,// Remove suspend points that are simplified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:34,simpl,simplified,34,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['simpl'],['simplified']
Usability,// Remove the temporary PHI node SCEV that has been inserted while intending; // to create an AddRecExpr for this PHI node. We can not keep this temporary; // as it will prevent later (possibly simpler) SCEV expressions to be added; // to the ValueExprMap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:194,simpl,simpler,194,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['simpl'],['simpler']
Usability,// Remove usable registers clobbered by this mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:10,usab,usable,10,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,1,['usab'],['usable']
Usability,"// Removes a definition from the context, but keeps the variable name; // as a valid variable. The index 0 is a placeholder for cleared definitions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:128,clear,cleared,128,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,1,['clear'],['cleared']
Usability,"// Rename all nodes already in the workspace to 'clear the way' for the imported nodes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx:49,clear,clear,49,roofit/roofitcore/src/RooWorkspace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx,1,['clear'],['clear']
Usability,// Repeated simplify BB as long as resimplification is requested.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:12,simpl,simplify,12,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['simpl'],['simplify']
Usability,"// Replace G with a simple tail call to bitcast(F). Also (unless; // MergeFunctionsPDI holds) replace direct uses of G with bitcast(F),; // delete G. Under MergeFunctionsPDI, we use G itself for creating; // the thunk as we preserve the debug info (and associated instructions); // from G's entry block pertaining to G's incoming arguments which are; // passed on as corresponding arguments in the call that G makes to F.; // For better debugability, under MergeFunctionsPDI, we do not modify G's; // call sites to point to F even when within the same translation unit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:20,simpl,simple,20,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,1,['simpl'],['simple']
Usability,// Replace a direct call to coro.resume or coro.destroy with an indirect call to; // an address returned by coro.subfn.addr intrinsic. This is done so that; // CGPassManager recognizes devirtualization when CoroElide pass replaces a call; // to coro.subfn.addr with an appropriate function address.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp:33,resume,resume,33,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp,1,['resume'],['resume']
Usability,// Replace a read barrier with a simple load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:33,simpl,simple,33,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,1,['simpl'],['simple']
Usability,// Replace a write barrier with a simple store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:34,simpl,simple,34,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,1,['simpl'],['simple']
Usability,// Replace all alloca and SSA values that are accessed across suspend points; // with GetElementPointer from coroutine frame + loads and stores. Create an; // AllocaSpillBB that will become the new entry block for the resume parts of; // the coroutine:; //; // %hdl = coro.begin(...); // whatever; //; // becomes:; //; // %hdl = coro.begin(...); // br label %AllocaSpillBB; //; // AllocaSpillBB:; // ; geps corresponding to allocas that were moved to coroutine frame; // br label PostSpill; //; // PostSpill:; // whatever; //; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:218,resume,resume,218,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['resume'],['resume']
Usability,"// Replace all uses of gc.relocate and delete the gc.relocate; // There maybe unncessary bitcasts back to the OrigPtr type, an instcombine; // pass would clear this up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp:154,clear,clear,154,interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp,1,['clear'],['clear']
Usability,// Replace it.; // Replacing one register with another won't touch the kill flags.; // We need to conservatively clear the kill flags as a kill on the old; // register might dominate existing uses of the new register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:113,clear,clear,113,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['clear'],['clear']
Usability,// Replace llvm.coro.suspend with the value that results in resumption over; // the resume or cleanup path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:84,resume,resume,84,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['resume'],['resume']
Usability,// Replace the instruction with its simplified value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:36,simpl,simplified,36,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,4,['simpl'],['simplified']
Usability,// Replace the lvm.coro.async.resume intrisic call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:30,resume,resume,30,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['resume'],['resume']
Usability,// Replace with NewReg and clear kill flags which may be wrong now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:27,clear,clear,27,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['clear'],['clear']
Usability,"// Replacements from \p Replaces must be conflict-free already, so we can; // simply consume the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:78,simpl,simply,78,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,1,['simpl'],['simply']
Usability,// Replacing the inner FMul could cause the outer FMA to be simplified; // away.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:60,simpl,simplified,60,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simplified']
Usability,// Replacing with the preheader value will often allow IV users to simplify; // (especially if the preheader value is a constant).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:67,simpl,simplify,67,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['simpl'],['simplify']
Usability,"// Replaying that is paused",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/inc/TRecorder.h:21,pause,paused,21,gui/recorder/inc/TRecorder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/inc/TRecorder.h,1,['pause'],['paused']
Usability,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:116,clear,clear,116,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,3,['clear'],"['clear', 'clearing']"
Usability,"// Represents state of TRecorder when paused",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/inc/TRecorder.h:38,pause,paused,38,gui/recorder/inc/TRecorder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/inc/TRecorder.h,1,['pause'],['paused']
Usability,"// Request the set of PHIs we should insert for this variable. If there's; // only one value definition, things are very simple.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:121,simpl,simple,121,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['simpl'],['simple']
Usability,// Require either the replacement or the simplification result to be a; // constant to avoid infinite loops.; // FIXME: Make this check more precise.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:41,simpl,simplification,41,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['simpl'],['simplification']
Usability,"// Require that PredBB end with a conditional Branch. If PredBB ends with an; // unconditional branch, we should be merging PredBB and BB instead. For; // simplicity, we don't deal with a switch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:155,simpl,simplicity,155,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['simpl'],['simplicity']
Usability,// Require that src be an alloca. This simplifies the reasoning considerably.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:39,simpl,simplifies,39,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['simpl'],['simplifies']
Usability,"// Requires `CmpValDefInstr` and `VregDefInstr` are from the same MBB; // to simplify the subsequent analysis.; //; // FIXME: If `VregDefInstr->getParent()` is the only predecessor of; // `CmpValDefInstr.getParent()`, this could be handled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:77,simpl,simplify,77,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['simpl'],['simplify']
Usability,// Reset GUIDToFuncNameMap for of each function as they're no; // longer valid at this point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:9,GUID,GUIDToFuncNameMap,9,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['GUID'],['GUIDToFuncNameMap']
Usability,"// Reset progress bar",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TProofProgressDialog.cxx:9,progress bar,progress bar,9,gui/sessionviewer/src/TProofProgressDialog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TProofProgressDialog.cxx,1,['progress bar'],['progress bar']
Usability,"// Reset the debug location to that of the simple 'return' expression, if any; // rather than that of the end of the function's scope '}'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:43,simpl,simple,43,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['simpl'],['simple']
Usability,"// Reset the status flag and clear the messages in the list, if any",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:29,clear,clear,29,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['clear'],['clear']
Usability,// Resize the modified and used register unit trackers. We do this once; // per function and then clear the register units each time we determine; // correct return value for the POP.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:98,clear,clear,98,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,1,['clear'],['clear']
Usability,// Resize the modified and used register unit trackers. We do this once; // per function and then clear the register units each time we optimize a load; // or store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp:98,clear,clear,98,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,1,['clear'],['clear']
Usability,// Resize the modified and used register unit trackers. We do this once; // per function and then clear the register units each time we optimize a; // move.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp:98,clear,clear,98,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp,1,['clear'],['clear']
Usability,"// Restart learning",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:11,learn,learning,11,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['learn'],['learning']
Usability,"// Result type for the comparison, e.g. bool for simple equality,; // or int for lexigraphic comparison (-1, 0, 1). Must have one value which; // denotes ""true"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h:49,simpl,simple,49,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h,2,['simpl'],['simple']
Usability,// Result value will be used in a same basic block. Don't export it or; // perform any explicit register copies. The gc_result will simply grab; // this value. ,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:132,simpl,simply,132,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,1,['simpl'],['simply']
Usability,// Resume forceFlushDeletedBB() to erase DomTree or PostDomTree nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:3,Resume,Resume,3,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,1,['Resume'],['Resume']
Usability,"// Resume the existing benchmark",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBenchmark.cxx:3,Resume,Resume,3,core/base/src/TBenchmark.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBenchmark.cxx,1,['Resume'],['Resume']
Usability,// ResumeFnAddr is the first pointer sized element of the coroutine frame.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp:3,Resume,ResumeFnAddr,3,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp,1,['Resume'],['ResumeFnAddr']
Usability,// Resumed after being auto-suspended before generator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:3,Resume,Resumed,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['Resume'],['Resumed']
Usability,"// Resumes paused replaying",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/inc/TRecorder.h:3,Resume,Resumes,3,gui/recorder/inc/TRecorder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/inc/TRecorder.h,2,"['Resume', 'pause']","['Resumes', 'paused']"
Usability,"// Resumes replaying",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/src/TRecorder.cxx:3,Resume,Resumes,3,gui/recorder/src/TRecorder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/src/TRecorder.cxx,1,['Resume'],['Resumes']
Usability,// Retain the profile name and clear the full context for each function; // profile.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h:31,clear,clear,31,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,1,['clear'],['clear']
Usability,"// Retrieve the index of the next lambda appearing in this context, which is; // used for deduplicating lambdas across modules. Note that this is a simple; // sequence number and is not ABI-dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/MangleNumberingContext.h:148,simpl,simple,148,interpreter/llvm-project/clang/include/clang/AST/MangleNumberingContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/MangleNumberingContext.h,1,['simpl'],['simple']
Usability,"// Return & clear status",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TRegexp.h:12,clear,clear,12,core/base/inc/TRegexp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TRegexp.h,1,['clear'],['clear']
Usability,"// Return (ivar-type) objc_getProperty((id) self, _cmd, offset, true).; // FIXME: Can't this be simpler? This might even be worse than the; // corresponding gcc code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:96,simpl,simpler,96,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['simpl'],['simpler']
Usability,// Return GUID to caller.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFileBuilder.cpp:10,GUID,GUID,10,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFileBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFileBuilder.cpp,1,['GUID'],['GUID']
Usability,// Return MaxPressure and clear it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRegPressure.h:26,clear,clear,26,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRegPressure.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRegPressure.h,1,['clear'],['clear']
Usability,// Return a SimpleRemoteEPC instance connected to our end of the pipes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:12,Simpl,SimpleRemoteEPC,12,interpreter/llvm-project/llvm/tools/lli/lli.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp,1,['Simpl'],['SimpleRemoteEPC']
Usability,"// Return a nul-terminated string even for an empty Slice. This is; // safe because all existing SimplifyLibcalls callers require string; // arguments and the behavior of the functions they fold is undefined; // otherwise. Folding the calls this way is preferable to making; // the undefined library calls, even though it prevents sanitizers; // from reporting such calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:97,Simpl,SimplifyLibcalls,97,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['Simpl'],['SimplifyLibcalls']
Usability,"// Return an empty Slice for undersized constants to let callers; // transform even undefined library calls into simpler, well-defined; // expressions. This is preferable to making the calls although it; // prevents sanitizers from detecting such calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:113,simpl,simpler,113,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['simpl'],['simpler']
Usability,"// Return false for unknwon values - this implements a non-strict mode where; // unhandled IR constructs are simply considered to never produce poison. At; // some point in the future, we probably want a ""strict mode"" for testing if; // nothing else.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:109,simpl,simply,109,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,1,['simpl'],['simply']
Usability,"// Return list of non-usable files",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDSet.cxx:22,usab,usable,22,proof/proof/src/TDSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDSet.cxx,1,['usab'],['usable']
Usability,"// Return true if MI is a potential candidate for reuse/removal and if so; // also the register it defines in DefedReg. A candidate is a simple; // instruction that does not touch memory, has only one register definition; // and the only reg it may use is FrameReg. Typically this is an immediate; // load or a load-address instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:137,simpl,simple,137,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,1,['simpl'],['simple']
Usability,// Return true if MI is a simple load or store with a 12-bit displacement; // and no index. Flag is SimpleBDXLoad for loads and SimpleBDXStore for stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:26,simpl,simple,26,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,3,"['Simpl', 'simpl']","['SimpleBDXLoad', 'SimpleBDXStore', 'simple']"
Usability,"// Return true if all users of this SDNode* only consume the lower \p Bits.; // This can be used to form W instructions for add/sub/mul/shl even when the; // root isn't a sext_inreg. This can allow the ADDW/SUBW/MULW/SLLIW to CSE if; // SimplifyDemandedBits has made it so some users see a sext_inreg and some; // don't. The sext_inreg+add/sub/mul/shl will get selected, but still leave; // the add/sub/mul/shl to become non-W instructions. By checking the users we; // may be able to use a W instruction and CSE with the other instruction if; // this has happened. We could try to detect that the CSE opportunity exists; // before doing this, but that would be more complicated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:237,Simpl,SimplifyDemandedBits,237,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,// Return true if this instruction simply renames a general register without; // modifying bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:35,simpl,simply,35,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,2,['simpl'],['simply']
Usability,// Return true if this instruction simply sets its single destination register; // to zero. This is equivalent to a register rename of the zero-register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:35,simpl,simply,35,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['simpl'],['simply']
Usability,"// Return true if this is a bundled retainRV/claimRV call, which is always; // redundant with the attachedcall in the bundle, and is going to be erased; // at the end of this pass. This avoids undoing objc-arc-expand and; // replacing uses of the retainRV/claimRV call's argument with its result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:193,undo,undoing,193,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,1,['undo'],['undoing']
Usability,"// Return true if this is an atomic which has an ordering stronger than; // unordered. Note that this is different than the predicate we use in; // Attributor. Here we chose to be conservative and consider monotonic; // operations potentially synchronizing. We generally don't do much with; // monotonic operations, so this is simply risk reduction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:327,simpl,simply,327,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['simpl'],['simply']
Usability,"// Return true if this node is a setcc, or is a select_cc; // that selects between the target values used for true and false, making it; // equivalent to a setcc. Also, set the incoming LHS, RHS, and CC references to; // the appropriate nodes based on the type of node we are checking. This; // simplifies life a bit for the callers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:295,simpl,simplifies,295,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simplifies']
Usability,"// Return true if we can prove that, whenever Neg and Pos are both in the; // range [0, EltSize), Neg == (Pos == 0 ? 0 : EltSize - Pos). This means that; // for two opposing shifts shift1 and shift2 and a value X with OpBits bits:; //; // (or (shift1 X, Neg), (shift2 X, Pos)); //; // reduces to a rotate in direction shift2 by Pos or (equivalently) a rotate; // in direction shift1 by Neg. The range [0, EltSize) means that we only need; // to consider shift amounts with defined behavior.; //; // The IsRotate flag should be set when the LHS of both shifts is the same.; // Otherwise if matching a general funnel shift, it should be clear.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:635,clear,clear,635,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['clear'],['clear']
Usability,"// Returning valid-but-null is how we indicate to the caller that; // the lookup result was filled in. If typo correction was attempted and; // failed, the lookup result will have been cleared--that combined with the; // valid-but-null ExprResult will trigger the appropriate diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:185,clear,cleared--that,185,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['clear'],['cleared--that']
Usability,// Returns a counter usable as a loop counter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:21,usab,usable,21,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,1,['usab'],['usable']
Usability,"// Returns the GUID for the function name after canonicalization. For; // memprof, we remove any .llvm suffix added by LTO. MemProfRecords are; // mapped to functions using this GUID.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h:15,GUID,GUID,15,interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,2,['GUID'],['GUID']
Usability,"// Returns the PGO object name. This function has some special handling; // when called in LTO optimization. The following only applies when calling in; // LTO passes (when \c InLTO is true): LTO's internalization privatizes many; // global linkage symbols. This happens after value profile annotation, but; // those internal linkage functions should not have a source prefix.; // Additionally, for ThinLTO mode, exported internal functions are promoted; // and renamed. We need to ensure that the original internal PGO name is; // used when computing the GUID that is compared against the profiled GUIDs.; // To differentiate compiler generated internal symbols from original ones,; // PGOFuncName meta data are created and attached to the original internal; // symbols in the value profile annotation step; // (PGOUseFunc::annotateIndirectCallSites). If a symbol does not have the meta; // data, its original linkage must be non-internal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp:556,GUID,GUID,556,interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,2,['GUID'],"['GUID', 'GUIDs']"
Usability,"// Returns true for TPResult::True or; // TPResult::Error.; // FIXME: Add statistics about the number of ambiguous statements encountered; // and how they were resolved (number of declarations+number of expressions).; // Ok, we have a simple-type-specifier/typename-specifier followed by a '('.; // We need tentative parsing...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:235,simpl,simple-type-specifier,235,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['simpl'],['simple-type-specifier']
Usability,// Returns true if C is already in a simplest form and not worth being; // rewritten.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:37,simpl,simplest,37,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,1,['simpl'],['simplest']
Usability,"// Returns true if by simply looking at the block, we can be sure that it; // results in a sink during analysis. This is useful to know when the analysis; // was interrupted, and we try to figure out if it would sink eventually.; // There may be many more reasons why a sink would appear during analysis; // (eg. checkers may generate sinks arbitrarily), but here we only consider; // sinks that would be obvious by looking at the CFG.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:22,simpl,simply,22,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['simpl'],['simply']
Usability,"// Returns true if these basic blocks belong to a presplit coroutine and the; // edge corresponds to the 'default' case in the switch statement in the; // pattern:; //; // %0 = call i8 @llvm.coro.suspend(token none, i1 false); // switch i8 %0, label %suspend [i8 0, label %resume; // i8 1, label %cleanup]; //; // i.e. the edge to the `%suspend` BB. This edge is special in that it will; // be elided by coroutine lowering (coro-split), and the `%suspend` BB needs; // to be kept as-is. It's not a real CFG edge - post-lowering, it will end; // up being a `ret`, and it must be thus lowerable to support symmetric; // transfer. For example:; // - this edge is not a loop exit edge if encountered in a loop (and should; // be ignored); // - must not be split for PGO instrumentation, for example.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:273,resume,resume,273,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,1,['resume'],['resume']
Usability,"// Returns whether an ancestor of \p Node matches \p Matcher.; //; // The order of matching (which can lead to different nodes being bound in; // case there are multiple matches) is breadth first search.; //; // To allow memoization in the very common case of having deeply nested; // expressions inside a template function, we first walk up the AST, memoizing; // the result of the match along the way, as long as there is only a single; // parent.; //; // Once there are multiple parents, the breadth first search order does not; // allow simple memoization on the ancestors. Thus, we only memoize as long; // as there is a single parent.; //; // We avoid a recursive implementation to prevent excessive stack use on; // very deep ASTs (similarly to RecursiveASTVisitor's data recursion).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:541,simpl,simple,541,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,1,['simpl'],['simple']
Usability,"// Review the constraints, looking for opportunities; // to simplify a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.; // Corresponds to Figure 5 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:60,simpl,simplify,60,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,3,['simpl'],"['simplification', 'simplify']"
Usability,"// Rewrite final suspend handling as it is not done via switch (allows to; // remove final case from the switch, since it is undefined behavior to; // resume the coroutine suspended at the final suspend point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:151,resume,resume,151,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['resume'],['resume']
Usability,"// Rewrite the problematic successors for every block that wants to reach; // the bad blocks. For simplicity, we just introduce a new block for every; // edge we need to rewrite. (Fancier things are possible.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:98,simpl,simplicity,98,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,1,['simpl'],['simplicity']
Usability,"// Right now, we use a simple heuristic. If MBB2 ends with a call, and; // MBB1 doesn't, we prefer to fall through into MBB1. This allows us to; // optimize branches that branch to either a return block or an assert block; // into a fallthrough to the return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:23,simpl,simple,23,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['simpl'],['simple']
Usability,"// Root URL for ROOT's reference guide for libs that are not in fLibURLs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/inc/THtml.h:33,guid,guide,33,html/inc/THtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/inc/THtml.h,1,['guid'],['guide']
Usability,// Root node has a GUID 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCPseudoProbe.h:19,GUID,GUID,19,interpreter/llvm-project/llvm/include/llvm/MC/MCPseudoProbe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCPseudoProbe.h,1,['GUID'],['GUID']
Usability,"// Rotate if either the loop latch does *not* exit the loop, or if the loop; // latch was just simplified. Or if we think it will be profitable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:95,simpl,simplified,95,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,1,['simpl'],['simplified']
Usability,// Rotate left by OnesOnLeft (so leading ones are now trailing ones) and clear; // on the left the bits that are already zeros in the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:73,clear,clear,73,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['clear'],['clear']
Usability,// Rotate loops to expose bit-simplification opportunities.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:30,simpl,simplification,30,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,1,['simpl'],['simplification']
Usability,"// Rule with clearance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/mathtext/src/mathrender.cxx:13,clear,clearance,13,graf2d/mathtext/src/mathrender.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/mathtext/src/mathrender.cxx,1,['clear'],['clearance']
Usability,// Run all loop passes on loop \p L. Loop-nest passes don't run either because; // \p L is not a top-level one or simply because there are no loop-nest passes; // in the pass manager at all.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:114,simpl,simply,114,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,1,['simpl'],['simply']
Usability,// Run constant folding to see if we can reduce the condition to a simple; // constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:67,simpl,simple,67,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['simpl'],['simple']
Usability,"// Run partial inlining pass to partially inline functions that have; // large bodies.; // FIXME: It isn't clear whether this is really the right place to run this; // in ThinLTO. Because there is another canonicalization and simplification; // phase that will run after the thin link, running this here ends up with; // less information than will be available later and it may grow functions in; // ways that aren't beneficial.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:107,clear,clear,107,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,2,"['clear', 'simpl']","['clear', 'simplification']"
Usability,// Run post-promotion simplifications.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:22,simpl,simplifications,22,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,1,['simpl'],['simplifications']
Usability,"// Run the AST-only checks using the order in which functions are defined.; // If inlining is not turned on, use the simplest function order for path; // sensitive analyzes as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:117,simpl,simplest,117,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,1,['simpl'],['simplest']
Usability,// Run this after loop unrolling but before; // SimplifyCFGPass(... .sinkCommonInsts(true)),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFTargetMachine.cpp:48,Simpl,SimplifyCFGPass,48,interpreter/llvm-project/llvm/lib/Target/BPF/BPFTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFTargetMachine.cpp,1,['Simpl'],['SimplifyCFGPass']
Usability,"// SLSR can complicate an instruction in two cases:; //; // 1. If we can fold I into an addressing mode, computing I is likely free or; // takes only one instruction.; //; // 2. I is already in a simplest form. For example, when; // X = B + 8 * S; // Y = B + S,; // rewriting Y to X - 7 * S is probably a bad idea.; //; // In the above cases, we still add I to the candidate list so that I can be; // the basis of other candidates, but we leave I's basis blank so that I; // won't be rewritten.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:196,simpl,simplest,196,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,1,['simpl'],['simplest']
Usability,// SLW and SRW always clear the higher-order bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:22,clear,clear,22,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['clear'],['clear']
Usability,// STATISTIC - A macro to make definition of statistics really simple. This; // automatically passes the DEBUG_TYPE of the file into the statistic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h:63,simpl,simple,63,interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h,1,['simpl'],['simple']
Usability,// STBRX can only handle simple types and it makes no sense to store less; // two bytes in byte-reversed order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,simpl,simple,25,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['simpl'],['simple']
Usability,"// Sa = select Sb, [ (c^d) | Sc | Sd ], [ b ? Sc : Sd ]; // If Sb (condition is poisoned), look for bits in c and d that are equal; // and both unpoisoned.; // If !Sb (condition is unpoisoned), simply pick one of Sc and Sd.; // Cast arguments to shadow-compatible type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:194,simpl,simply,194,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['simpl'],['simply']
Usability,"// Same as nsw case above - duplicated here to avoid a compile time; // issue. It's not clear that the order of checks does matter, but; // it's one of two issue possible causes for a change which was; // reverted. Be conservative for the moment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:88,clear,clear,88,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['clear'],['clear']
Usability,"// Same as nuw case above - duplicated here to avoid a compile time; // issue. It's not clear that the order of checks does matter, but; // it's one of two issue possible causes for a change which was; // reverted. Be conservative for the moment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:88,clear,clear,88,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['clear'],['clear']
Usability,"// Same mechanism to undo the parameter transformation as in the; // RooExponentialFactory (see comments in that class for more info).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/JSONFactories_RooFitCore.cxx:21,undo,undo,21,roofit/hs3/src/JSONFactories_RooFitCore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/JSONFactories_RooFitCore.cxx,1,['undo'],['undo']
Usability,"// Samples may not exist for replayed function, if so; // just add the direct GUID and move on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:78,GUID,GUID,78,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['GUID'],['GUID']
Usability,// Save and clear FP registers if present,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp:12,clear,clear,12,interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,1,['clear'],['clear']
Usability,// Save and clear the LR state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:12,clear,clear,12,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['clear'],['clear']
Usability,"// Save and restore the state of the Parser and lexer.; // Note: ROOT::Internal::ParsingStateRAII also save and restore the state of; // Sema, including pending instantiation for example. It is not clear; // whether we need to do so here too or whether we need to also see the; // ""on-going"" semantic information ... For now, we leave Sema untouched.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp:198,clear,clear,198,interpreter/cling/lib/Interpreter/LookupHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp,1,['clear'],['clear']
Usability,"// Save input SDKVersion to match, and clear SDKVersion for > comparsion",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/PlatformWin.cpp:39,clear,clear,39,interpreter/cling/lib/Utils/PlatformWin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/PlatformWin.cpp,1,['clear'],['clear']
Usability,// Save register clearances at end of MBB - used by enterBasicBlock().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp:17,clear,clearances,17,interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExecutionDomainFix.cpp,2,['clear'],['clearances']
Usability,// Save the currently-propagating exception before; // objc_exception_try_enter clears the exception slot.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:80,clear,clears,80,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['clear'],['clears']
Usability,"// Save the deduced template argument for the parameter pack expanded; // by this pack expansion, then clear out the deduction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:103,clear,clear,103,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['clear'],['clear']
Usability,"// Save to clear this storage, as it used only to sort the intervals.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h:11,clear,clear,11,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalTree.h,1,['clear'],['clear']
Usability,// Saves the current floating-point pragma stack and clear it in this Sema.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:53,clear,clear,53,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['clear'],['clear']
Usability,"// Scan over the PHI nodes in the loop header. Since they now have only two; // incoming values (the loop is canonicalized), we may have simplified the PHI; // down to 'X = phi [X, Y]', which should be replaced with 'Y'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:137,simpl,simplified,137,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,1,['simpl'],['simplified']
Usability,// Scan the BBs and collect legal loads and stores.; // Returns false if non-simple loads/stores are found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:77,simpl,simple,77,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,1,['simpl'],['simple']
Usability,// Scan the body of the basic block for resumes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:40,resume,resumes,40,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,1,['resume'],['resumes']
Usability,"// Scan the call setup sequence for the pattern we're looking for.; // We only handle a simple case - a sequence of store instructions that; // push a sequence of stack-slot-aligned values onto the stack, with; // no gaps between them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:88,simpl,simple,88,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,1,['simpl'],['simple']
Usability,"// Scan the instruction, looking for input operations that can be folded away.; // If all input operands to the phi are the same instruction (e.g. a cast from; // the same type or ""+42"") we can pull the operation through the PHI, reducing; // code size and simplifying code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:257,simpl,simplifying,257,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,1,['simpl'],['simplifying']
Usability,"// Scan the operand lists looking for X and -X pairs. If we find any, we; // can simplify expressions like X+-X == 0 and X+~X ==-1. While we're at it,; // scan for any; // duplicates. We want to canonicalize Y+Y+Y+Z -> 3*Y+Z.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:81,simpl,simplify,81,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['simpl'],['simplify']
Usability,"// Scan the operand lists looking for X and ~X pairs, along with X,X pairs.; // If we find any, we can simplify the expression. X&~X == 0, X|~X == -1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:103,simpl,simplify,103,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['simpl'],['simplify']
Usability,// Scan through all the patterns and record the simple ones.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/FastISelEmitter.cpp:48,simpl,simple,48,interpreter/llvm-project/llvm/utils/TableGen/FastISelEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/FastISelEmitter.cpp,1,['simpl'],['simple']
Usability,// Search for a stronger dominating condition that can be used to simplify a; // conditional branch leaving BB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:66,simpl,simplify,66,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['simpl'],['simplify']
Usability,// Search towards the root for a usable subtree.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:33,usab,usable,33,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,1,['usab'],['usable']
Usability,// Search will resume after this instruction in a separate merge list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp:15,resume,resume,15,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,1,['resume'],['resume']
Usability,"// Second Step, fill new nodes by merged values and simplify if possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:52,simpl,simplify,52,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['simpl'],['simplify']
Usability,"// Second, we rewrite all of the split stores. At this point, we know that; // all loads from this alloca have been split already. For stores of such; // loads, we can simply look up the pre-existing split loads. For stores of; // other loads, we split those loads first and then write split stores of; // them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:168,simpl,simply,168,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['simpl'],['simply']
Usability,"// Sections in SecHdrTable is not necessarily in the same order as; // sections in the profile because section like FuncOffsetTable needs; // to be written after section LBRProfile but needs to be read before; // section LBRProfile, so we cannot simply use the last entry in; // SecHdrTable to calculate the file size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp:246,simpl,simply,246,interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,1,['simpl'],['simply']
Usability,"// Security: would the learning lead to non real numbers,; // the learning should stop now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMultiLayerPerceptron.cxx:23,learn,learning,23,math/mlp/src/TMultiLayerPerceptron.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMultiLayerPerceptron.cxx,2,['learn'],['learning']
Usability,"// See if ""V === X - Y"" simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:24,simpl,simplifies,24,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// See if ""V === X - Z"" simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:24,simpl,simplifies,24,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,['simpl'],['simplifies']
Usability,"// See if @llvm.abs argument is alays positive/negative, and simplify.; // Notably, INT_MIN can belong to either range, regardless of the NSW,; // because it is negation-invariant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:61,simpl,simplify,61,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,1,['simpl'],['simplify']
Usability,"// See if Sym is known to be within [min/4, max/4], where min and max; // are the bounds of the symbol's integral type. With such symbols,; // some manipulations can be performed without the risk of overflow.; // assume() doesn't cause infinite recursion because we should be dealing; // with simpler symbols on every recursive call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:293,simpl,simpler,293,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,1,['simpl'],['simpler']
Usability,// See if a clear mask is legal instead of going via; // XformToShuffleWithZero which loses UNDEF mask elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,clear,clear,12,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['clear'],['clear']
Usability,"// See if any memory operand specifies an address space that involves VMEM.; // Flat operations only supported FLAT, LOCAL (LDS), or address spaces; // involving VMEM such as GLOBAL, CONSTANT, PRIVATE (SCRATCH), etc. The REGION; // (GDS) address space is not supported by flat operations. Therefore, simply; // return true unless only the LDS address space is found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:300,simpl,simply,300,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['simpl'],['simply']
Usability,"// See if return type is coroutine-handle and if so, invoke builtin coro-resume; // on its address. This is to enable the support for coroutine-handle; // returning await_suspend that results in a guaranteed tail call to the target; // coroutine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:73,resume,resume,73,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,1,['resume'],['resume']
Usability,// See if the add simplifies away.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:18,simpl,simplifies,18,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,1,['simpl'],['simplifies']
Usability,"// See if the intrinsic is used in the following common pattern:; // br(llvm.type.test(...), thenbb, elsebb); // where nothing happens between the type test and the br.; // If so, create slightly simpler IR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:196,simpl,simpler,196,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,1,['simpl'],['simpler']
Usability,// See if the shuffle is a hidden identity shuffle - repeated args in HOPs; // etc. can be simplified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:91,simpl,simplified,91,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplified']
Usability,"// See if the transformation is safe. Specifically, see if there are any; // calls in between Save and CallInstr. They can potenitally resume the; // coroutine rendering this optimization unsafe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:135,resume,resume,135,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['resume'],['resume']
Usability,"// See if the user is one of our successors that has only one; // predecessor, so that we don't have to split the critical edge.; // Another option where we can sink is a block that ends with a; // terminator that does not pass control to other block (such as; // return or unreachable or resume). In this case:; // - I dominates the User (by SSA form);; // - the User will be executed at most once.; // So sinking I down to User is always profitable or neutral.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:289,resume,resume,289,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['resume'],['resume']
Usability,// See if this instruction simplifies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:27,simpl,simplifies,27,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,['simpl'],['simplifies']
Usability,"// See if this is a call that has been inlined and remapped, and not; // simplified away in the process.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:73,simpl,simplified,73,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['simpl'],['simplified']
Usability,"// See if this is a simple CONCAT_VECTORS with no UNDEF operands, and if one of; // the operands is a SHUFFLE_VECTOR, and all other operands are also operands; // to that SHUFFLE_VECTOR, create wider SHUFFLE_VECTOR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:20,simpl,simple,20,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simple']
Usability,"// See if we are defined by a previous store expression, it already has a; // value, and it's the same value as our current store. FIXME: Right now, we; // only do this for simple stores, we should expand to cover memcpys, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:173,simpl,simple,173,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['simpl'],['simple']
Usability,"// See if we can avoid creating the buffer, for now we just look for; // simple indentifier, constructor and destructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp:73,simpl,simple,73,interpreter/cling/lib/Interpreter/LookupHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp,1,['simpl'],['simple']
Usability,// See if we can avoid the phi by simplifying it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:34,simpl,simplifying,34,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['simpl'],['simplifying']
Usability,"// See if we can combine a single input shuffle with zeros to a bit-mask,; // which is much simpler than any shuffle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:92,simpl,simpler,92,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simpler']
Usability,"// See if we can peek through to a vector with a wider element type, if the; // signbits extend down to all the sub-elements as well.; // Calling MOVMSK with the wider type, avoiding the bitcast, helps expose; // potential SimplifyDemandedBits/Elts cases.; // If we looked through a truncate that discard bits, we can't do this; // transform.; // FIXME: We could do this transform for truncates that discarded bits by; // inserting an AND mask between the new MOVMSK and the CMP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:223,Simpl,SimplifyDemandedBits,223,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,// See if we can simplify any instructions used by the input whose sole; // purpose is to compute bits we don't care about.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:17,simpl,simplify,17,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['simpl'],['simplify']
Usability,// See if we can simplify any instructions used by the instruction whose sole; // purpose is to compute bits we don't care about.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:17,simpl,simplify,17,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,3,['simpl'],['simplify']
Usability,// See if we can simplify either shuffle operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:17,simpl,simplify,17,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['simpl'],['simplify']
Usability,// See if we can simplify either vselect operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:17,simpl,simplify,17,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['simpl'],['simplify']
Usability,"// See if we can simplify the operation with SimplifyDemandedBits, which; // only works if the value has a single use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,simpl,simplify,17,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,"['Simpl', 'simpl']","['SimplifyDemandedBits', 'simplify']"
Usability,"// See if we can simplify the operation with; // SimplifyDemandedBits, which only works if the value has a single use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,simpl,simplify,17,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,"['Simpl', 'simpl']","['SimplifyDemandedBits', 'simplify']"
Usability,"// See note at the bottom of this function to learn why we can only set; // the operation mode to ""always clean"" if there are no other value; // clients.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:46,learn,learn,46,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['learn'],['learn']
Usability,"// Seed our PRNG with simple additive sum of ModuleID. We're looking to; // simply avoid always having the same function names, and we need to; // remain deterministic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp:22,simpl,simple,22,interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp,2,['simpl'],"['simple', 'simply']"
Usability,// Select the opcode for simple extensions (that translate to a single SXT/UXT; // instruction). Extension operations more complicated than that should not; // invoke this. Returns the original opcode if it doesn't know how to select a; // better one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMInstructionSelector.cpp:25,simpl,simple,25,interpreter/llvm-project/llvm/lib/Target/ARM/ARMInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMInstructionSelector.cpp,2,"['UX', 'simpl']","['UXT', 'simple']"
Usability,// Select the opcode for simple loads and stores. Returns the original opcode; // if it doesn't know how to select a better one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMInstructionSelector.cpp:25,simpl,simple,25,interpreter/llvm-project/llvm/lib/Target/ARM/ARMInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMInstructionSelector.cpp,1,['simpl'],['simple']
Usability,"// Selects a new architecture by updating the FeatureBits with the necessary; // info including implied dependencies.; // Internally, it clears all the feature bits related to *any* architecture; // and selects the new one using the ToggleFeature functionality of the; // MCSubtargetInfo object that handles implied dependencies. The reason we; // clear all the arch related bits manually is because ToggleFeature only; // clears the features that imply the feature being cleared and not the; // features implied by the feature being cleared. This is easier to see; // with an example:; // --------------------------------------------------; // | Feature | Implies |; // | -------------------------------------------------|; // | FeatureMips1 | None |; // | FeatureMips2 | FeatureMips1 |; // | FeatureMips3 | FeatureMips2 | FeatureMipsGP64 |; // | FeatureMips4 | FeatureMips3 |; // | ... | |; // --------------------------------------------------; //; // Setting Mips3 is equivalent to set: (FeatureMips3 | FeatureMips2 |; // FeatureMipsGP64 | FeatureMips1); // Clearing Mips3 is equivalent to clear (FeatureMips3 | FeatureMips4).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:137,clear,clears,137,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,7,"['Clear', 'clear']","['Clearing', 'clear', 'cleared', 'clears']"
Usability,"// Semantically skip last iter is ""subtract 1, do not bother about unsigned; // wrap"". getLoopInvariantExitCondDuringFirstIterations knows how to deal; // with umin in a smart way, but umin(a, b) - 1 will likely not simplify.; // So we manually construct umin(a - 1, b - 1).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:216,simpl,simplify,216,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['simpl'],['simplify']
Usability,// Sequence of consecutive defs ended. Clear map for the next one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:39,Clear,Clear,39,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['Clear'],['Clear']
Usability,// Sequence with consecutive dbg.value instrs ended. Clear the map to; // restart identifying redundant instructions if case we find another; // dbg.value sequence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:53,Clear,Clear,53,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,2,['Clear'],['Clear']
Usability,// Set JD to closed state. Clear remaining data structures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:27,Clear,Clear,27,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['Clear'],['Clear']
Usability,"// Set bit, clear bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h:12,clear,clear,12,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,1,['clear'],['clear']
Usability,"// Set new learning rate at specific epochs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/inc/TMVA/MethodPyKeras.h:11,learn,learning,11,tmva/pymva/inc/TMVA/MethodPyKeras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/inc/TMVA/MethodPyKeras.h,2,['learn'],['learning']
Usability,"// Set of Control Flow Equivalent (CFE) Fusion Candidates, sorted in dominance; // order. Thus, if FC0 comes *before* FC1 in a FusionCandidateSet, then FC0; // dominates FC1 and FC1 post-dominates FC0.; // std::set was chosen because we want a sorted data structure with stable; // iterators. A subsequent patch to loop fusion will enable fusing non-adjacent; // loops by moving intervening code around. When this intervening code contains; // loops, those loops will be moved also. The corresponding FusionCandidates; // will also need to be moved accordingly. As this is done, having stable; // iterators will simplify the logic. Similarly, having an efficient insert that; // keeps the FusionCandidateSet sorted will also simplify the implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:612,simpl,simplify,612,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,2,['simpl'],['simplify']
Usability,// Set profile metadata (possibly annotated by LTO prelink) to zero or; // clear it for cold code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:75,clear,clear,75,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['clear'],['clear']
Usability,// Set shift operand (bit[6:4]).; // LSL - 000; // LSR - 010; // ASR - 100; // ROR - 110; // RRX - 110 and bit[11:8] clear.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:117,clear,clear,117,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,1,['clear'],['clear']
Usability,"// Set the LastFunctionBlockBit to point to the last function block.; // Later when parsing is resumed after function materialization,; // we can simply skip that last function block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:95,resume,resumed,95,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,2,"['resume', 'simpl']","['resumed', 'simply']"
Usability,// Set the proper type for the bounds given what we learned from the; // enclosed loops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:52,learn,learned,52,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['learn'],['learned']
Usability,"// Set to true if we do not import the type of the function as is. There are; // cases when the original type would result in an infinite recursion during; // the import. To avoid an infinite recursion when importing, we create the; // FunctionDecl with a simplified function type and update it only after the; // relevant AST nodes are already imported.; // The type is related to TypeSourceInfo (it references the type), so we must; // do the same with TypeSourceInfo.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:256,simpl,simplified,256,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['simpl'],['simplified']
Usability,// Set when the client has invoked this to simply drop all type test assume; // sequences.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:43,simpl,simply,43,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,1,['simpl'],['simply']
Usability,"// Set/clear verbose messaging",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsGenContext.h:7,clear,clear,7,roofit/roofitcore/inc/RooAbsGenContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsGenContext.h,1,['clear'],['clear']
Usability,"// Setup a python dictionary with the desired learning rate steps",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx:46,learn,learning,46,tmva/pymva/src/MethodPyKeras.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx,2,['learn'],['learning']
Usability,// Shader is simple does not need any state changes or any complex lowering,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:13,simpl,simple,13,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['simpl'],['simple']
Usability,"// Shader stage is only included in binaries for v1 and later, but we always; // include it since it simplifies parsing and file construction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/DXContainerYAML.cpp:101,simpl,simplifies,101,interpreter/llvm-project/llvm/lib/ObjectYAML/DXContainerYAML.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/DXContainerYAML.cpp,1,['simpl'],['simplifies']
Usability,"// Shift amount must be in {0, 8, 16, 24} (0 is undocumented extension); // normally, zero is represented in asm by omitting the rotate operand; // entirely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:48,undo,undocumented,48,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['undo'],['undocumented']
Usability,// Shift if the lower 16-bit is cleared.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp:32,clear,cleared,32,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.cpp,1,['clear'],['cleared']
Usability,// Shift the offset of the maximally aligned instruction (OffAtMax); // back by just enough multiples of the required alignment to cover the; // distance from Start to OffAtMax.; // Calculate the address adjustment amount based on the address with the; // maximum alignment. This is to allow a simple gep instruction instead; // of potential bitcasts to i8*.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:294,simpl,simple,294,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['simpl'],['simple']
Usability,"// Shortcut: Simplify ""$x + 0"" to ""$x"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:13,Simpl,Simplify,13,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,1,['Simpl'],['Simplify']
Usability,"// Should be called on updates in which if we're processing an instruction; // \p I that depends on a value \p V, one of the following has to happen:; // - If the value is assumed, then stop.; // - If the value is known but undef, then consider it UB.; // - Otherwise, do specific processing with the simplified value.; // We return std::nullopt in the first 2 cases to signify that an appropriate; // action was taken and the caller should stop.; // Otherwise, we return the simplified value that the caller should; // use for specific processing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:301,simpl,simplified,301,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,2,['simpl'],['simplified']
Usability,"// Show signatures of constructors as they are declared:; // vector(int n) rather than vector<string>(int n); // This is less noisy without being less clear, and avoids tricky cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:151,clear,clear,151,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['clear'],['clear']
Usability,"// Signal ending of learning phase",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx:20,learn,learning,20,proof/proofplayer/src/TEventIter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx,1,['learn'],['learning']
Usability,"// Signal repeat, simplifying any other constants.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:18,simpl,simplifying,18,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['simpl'],['simplifying']
Usability,"// Signed predicates aren't correct in some edge cases like for i2 types, as; // well since (ctpop x) is known [0, log2(BitWidth(x))] almost all signed; // comparisons against it are simplfied to unsigned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:183,simpl,simplfied,183,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplfied']
Usability,"// Similar to the logic for GCC above, if we are currently running Clang; // inside of the requested system root, add its parent library path to those; // searched.; // FIXME: It's not clear whether we should use the driver's installed; // directory ('Dir' below) or the ResourceDir.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp:185,clear,clear,185,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,1,['clear'],['clear']
Usability,"// Similar to the logic for GCC above, if we currently running Clang inside; // of the requested system root, add its parent library paths to; // those searched.; // FIXME: It's not clear whether we should use the driver's installed; // directory ('Dir' below) or the ResourceDir.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp:182,clear,clear,182,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,1,['clear'],['clear']
Usability,"// Simple (split, no rejoin):; // EBB; // | \_; // | |; // | TBB---> exit; // |; // FBB",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,1,['Simpl'],['Simple']
Usability,"// Simple 1st degree polynomial",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TProofBench.h:3,Simpl,Simple,3,proof/proofbench/inc/TProofBench.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TProofBench.h,1,['Simpl'],['Simple']
Usability,"// Simple 2nd degree polynomial",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TProofBench.h:3,Simpl,Simple,3,proof/proofbench/inc/TProofBench.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TProofBench.h,1,['Simpl'],['Simple']
Usability,"// Simple CR -> LF conversion",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/mathtext/src/fontembedps.cxx:3,Simpl,Simple,3,graf2d/mathtext/src/fontembedps.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/mathtext/src/fontembedps.cxx,1,['Simpl'],['Simple']
Usability,// Simple Integer,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,2,['Simpl'],['Simple']
Usability,// Simple Integer or Relocatable Constant,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,3,['Simpl'],['Simple']
Usability,// Simple RAII helper for defining ifdef-undef-endif scopes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DirectiveEmitter.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/utils/TableGen/DirectiveEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DirectiveEmitter.cpp,1,['Simpl'],['Simple']
Usability,// Simple Set for storing all the VarLoc Indices at a Location bucket.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,1,['Simpl'],['Simple']
Usability,"// Simple assignments just pass through the RHS, which will have; // been coerced to the LHS type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Simpl,Simple,3,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['Simpl'],['Simple']
Usability,"// Simple branch support.; // If we can, avoid recomputing the compare - redoing it could lead to wonky; // behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,1,['Simpl'],['Simple']
Usability,"// Simple branch: if([!]Pn) jump ...; // i.e. Op0 = predicate, Op1 = branch target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,2,['Simpl'],['Simple']
Usability,// Simple builder class to easily profile properties about MIs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:3,Simpl,Simple,3,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,1,['Simpl'],['Simple']
Usability,"// Simple call to create destroy a 'named' canvas",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofDraw.cxx:3,Simpl,Simple,3,proof/proofplayer/src/TProofDraw.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofDraw.cxx,1,['Simpl'],['Simple']
Usability,"// Simple call to draw a canvas on the fly from applications loading; // this plug-in dynamically",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofDraw.cxx:3,Simpl,Simple,3,proof/proofplayer/src/TProofDraw.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofDraw.cxx,1,['Simpl'],['Simple']
Usability,"// Simple call to parse arguments on the fly from applications loading; // this plug-in dynamically",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofDraw.cxx:3,Simpl,Simple,3,proof/proofplayer/src/TProofDraw.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofDraw.cxx,1,['Simpl'],['Simple']
Usability,// Simple case (most common),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp,1,['Simpl'],['Simple']
Usability,// Simple case just extract using vmv.x.s and truncate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['Simpl'],['Simple']
Usability,// Simple case no variable type tags.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:3,Simpl,Simple,3,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['Simpl'],['Simple']
Usability,// Simple case of a shuffle with zeroinitializer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['Simpl'],['Simple']
Usability,"// Simple case varName = branchName",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx:3,Simpl,Simple,3,roofit/roofitcore/src/RooTreeDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx,1,['Simpl'],['Simple']
Usability,// Simple case when we put subvector in the upper part,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['Simple']
Usability,// Simple case where 'CurrentVec' is UNDEF.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Simpl'],['Simple']
Usability,"// Simple case, LLA.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['Simpl'],['Simple']
Usability,"// Simple case, just copy the virtual register to RBX.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['Simple']
Usability,"// Simple case, just do a coerced store of the argument into the alloca.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:3,Simpl,Simple,3,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['Simpl'],['Simple']
Usability,"// Simple case, m(m(X,Y), X) => m(X, Y); // m(m(X,Y), Y) => m(X, Y); // For minimum/maximum, X is NaN => m(NaN, Y) == NaN and m(NaN, NaN) == NaN.; // For minimum/maximum, Y is NaN => m(X, NaN) == NaN and m(NaN, NaN) == NaN.; // For minnum/maxnum, X is NaN => m(NaN, Y) == Y and m(Y, Y) == Y.; // For minnum/maxnum, Y is NaN => m(X, NaN) == X and m(X, NaN) == X.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['Simpl'],['Simple']
Usability,"// Simple case, move on to the next base class specifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingBaseClassInfo.cxx:3,Simpl,Simple,3,core/metacling/src/TClingBaseClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingBaseClassInfo.cxx,1,['Simpl'],['Simple']
Usability,"// Simple case, we only need one comparison and we're done.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMInstructionSelector.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMInstructionSelector.cpp,1,['Simpl'],['Simple']
Usability,"// Simple case. Single use, just push its operands to the worklist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PartialReduction.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Target/X86/X86PartialReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PartialReduction.cpp,1,['Simpl'],['Simple']
Usability,// Simple case: Direct non-truncating forwarding,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Simpl'],['Simple']
Usability,"// Simple case: If GV is not private, it is not important to find out if; // private labels are legal in this case or not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/TargetMachine.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Target/TargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/TargetMachine.cpp,1,['Simpl'],['Simple']
Usability,// Simple case: compare the parameter and argument types at this point.; // Make sure we have an argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Simpl,Simple,3,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['Simpl'],['Simple']
Usability,"// Simple case: contiguous memory. get address of first, then jump.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TGenCollectionStreamer.cxx:3,Simpl,Simple,3,io/io/src/TGenCollectionStreamer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TGenCollectionStreamer.cxx,3,['Simpl'],['Simple']
Usability,"// Simple case: if the end BB has a single predecessor, the fact that it; // dominates the use block implies that the edge also does.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/IR/Dominators.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Dominators.cpp,1,['Simpl'],['Simple']
Usability,"// Simple case: integral over full range or single limited range",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:3,Simpl,Simple,3,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['Simpl'],['Simple']
Usability,// Simple case: matching a function parameter to a function argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:3,Simpl,Simple,3,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['Simpl'],['Simple']
Usability,"// Simple case: normal parameter, or a parameter pack that's; // instantiated to a (still-dependent) parameter pack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:3,Simpl,Simple,3,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['Simpl'],['Simple']
Usability,// Simple case: not a parameter pack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:3,Simpl,Simple,3,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['Simpl'],['Simple']
Usability,// Simple case: substitution into a parameter that is not a parameter pack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:3,Simpl,Simple,3,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['Simpl'],['Simple']
Usability,// Simple case: the destination can store all values of the source type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp:3,Simpl,Simple,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ConversionChecker.cpp,1,['Simpl'],['Simple']
Usability,"// Simple case: we need to generate a single handler call, either; // fatal, or non-fatal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:3,Simpl,Simple,3,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['Simpl'],['Simple']
Usability,// Simple check if not a strided access - clear order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,"['Simpl', 'clear']","['Simple', 'clear']"
Usability,"// Simple checks, just to check that the dataset was filled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testActionHelpers.cxx:3,Simpl,Simple,3,roofit/roofitcore/test/testActionHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testActionHelpers.cxx,1,['Simpl'],['Simple']
Usability,"// Simple conversion from a 'From' on disk to a 'To' in memory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:3,Simpl,Simple,3,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,1,['Simpl'],['Simple']
Usability,"// Simple conversion from a 'From' on disk to a 'To' in memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:3,Simpl,Simple,3,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,15,['Simpl'],['Simple']
Usability,// Simple copy of the option value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h:3,Simpl,Simple,3,interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,1,['Simpl'],['Simple']
Usability,"// Simple cross-check that TH1::SmoothArray() is not doing anything if input; // array is already smooth.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH1.cxx:3,Simpl,Simple,3,hist/hist/test/test_TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH1.cxx,1,['Simpl'],['Simple']
Usability,// Simple debug printing of StoredDiagnostic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:3,Simpl,Simple,3,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['Simpl'],['Simple']
Usability,// Simple detection of a call through a block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp:3,Simpl,Simple,3,interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp,1,['Simpl'],['Simple']
Usability,"// Simple event analysis",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:3,Simpl,Simple,3,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,1,['Simpl'],['Simple']
Usability,"// Simple filter callback that, for keywords, only accepts the C++ *_cast",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Simpl,Simple,3,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['Simpl'],['Simple']
Usability,"// Simple form of widening. If a range is extended multiple times, go to; // overdefined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h:3,Simpl,Simple,3,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h,1,['Simpl'],['Simple']
Usability,"// Simple function name mangler.; // This function simply takes LLVM's string representation of parameter types; // and concatenate them with '_'. There are non-alphanumeric characters but llc; // is ok with it, and we need to postprocess these names after the lowering; // phase anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,2,"['Simpl', 'simpl']","['Simple', 'simply']"
Usability,// Simple getSymbolOffset helper for the non-variable case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp,1,['Simpl'],['Simple']
Usability,"// Simple global addresses are supported, do not allow dllimport or; // thread-local globals.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,1,['Simpl'],['Simple']
Usability,"// Simple greedy algorithm.; // If this is replaced with something smarter, it must preserve the property; // that the first object is always at the offset 0 in the stack frame (for; // StackProtectorSlot), or handle stack protector in some other way.; // Sort objects by size (largest first) to reduce fragmentation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.cpp,1,['Simpl'],['Simple']
Usability,// Simple helper to check an expression can be used as a bool-valued template; // argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:3,Simpl,Simple,3,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,1,['Simpl'],['Simple']
Usability,// Simple helper to save temporary files for debug.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,1,['Simpl'],['Simple']
Usability,// Simple heuristic for what to reflow: content should contain at least two; // characters and either the first or second character must be; // non-punctuation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:3,Simpl,Simple,3,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,1,['Simpl'],['Simple']
Usability,// Simple heuristic so that we don't allocate a very large; // initializer with many empty entries at the end.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:3,Simpl,Simple,3,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['Simpl'],['Simple']
Usability,"// Simple histogram generation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:3,Simpl,Simple,3,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,1,['Simpl'],['Simple']
Usability,"// Simple histogram generation by TSelector object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:3,Simpl,Simple,3,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,1,['Simpl'],['Simple']
Usability,// Simple i8 add case,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['Simple']
Usability,// Simple information about a single control type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptStmt.h:3,Simpl,Simple,3,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptStmt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptStmt.h,1,['Simpl'],['Simple']
Usability,"// Simple input dialog",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/inc/TAdvancedGraphicsDialog.h:3,Simpl,Simple,3,gui/fitpanel/inc/TAdvancedGraphicsDialog.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/inc/TAdvancedGraphicsDialog.h,3,['Simpl'],['Simple']
Usability,"// Simple integer, undef, constant aggregate zero, etc are all supported.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,1,['Simpl'],['Simple']
Usability,"// Simple line",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManagerFile.cxx:3,Simpl,Simple,3,proof/proof/src/TDataSetManagerFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManagerFile.cxx,1,['Simpl'],['Simple']
Usability,// Simple linear scan through the sorted constant candidate vector for viable; // merge candidates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,1,['Simpl'],['Simple']
Usability,// Simple match: the operands of the multiply are identical.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['Simpl'],['Simple']
Usability,// Simple name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp:3,Simpl,Simple,3,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,2,['Simpl'],['Simple']
Usability,"// Simple object addition - buffer represents a unique single positioned object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TVirtualViewer3D.h:3,Simpl,Simple,3,core/base/inc/TVirtualViewer3D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TVirtualViewer3D.h,1,['Simpl'],['Simple']
Usability,"// Simple open",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:3,Simpl,Simple,3,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,1,['Simpl'],['Simple']
Usability,"// Simple operators arithmetic - complex",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/TComplex.h:3,Simpl,Simple,3,math/mathcore/inc/TComplex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/TComplex.h,1,['Simpl'],['Simple']
Usability,"// Simple operators complex - arithmetic",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/TComplex.h:3,Simpl,Simple,3,math/mathcore/inc/TComplex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/TComplex.h,1,['Simpl'],['Simple']
Usability,"// Simple operators complex - complex",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/TComplex.h:3,Simpl,Simple,3,math/mathcore/inc/TComplex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/TComplex.h,1,['Simpl'],['Simple']
Usability,// Simple optimization when Cond is a constant to avoid generating; // M68kISD::CMOV if possible.; // TODO: Generalize this to use SelectionDAG::computeKnownBits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,1,['Simpl'],['Simple']
Usability,"// Simple or multi?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerMulti.cxx:3,Simpl,Simple,3,proof/proofplayer/src/TPacketizerMulti.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerMulti.cxx,1,['Simpl'],['Simple']
Usability,// Simple pointer-to-member with no conversion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:3,Simpl,Simple,3,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['Simpl'],['Simple']
Usability,// Simple predicates for single condition-register bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.cpp,1,['Simpl'],['Simple']
Usability,"// Simple printable string, just return it now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/UTF8.cpp:3,Simpl,Simple,3,interpreter/cling/lib/Utils/UTF8.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/UTF8.cpp,1,['Simpl'],['Simple']
Usability,"// Simple progress bar",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:3,Simpl,Simple,3,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,6,"['Simpl', 'progress bar']","['Simple', 'progress bar']"
Usability,// Simple pseudo-instructions have their lowering (with expansion to real; // instructions) auto-generated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp,5,['Simpl'],['Simple']
Usability,// Simple recursive-descent JSON parser.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Support/JSON.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp,1,['Simpl'],['Simple']
Usability,// Simple requirement; // C++ [expr.prim.req.simple]; // simple-requirement:; // expression ';',MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Simpl,Simple,3,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,3,"['Simpl', 'simpl']","['Simple', 'simple', 'simple-requirement']"
Usability,"// Simple sanity check to make sure weights are respected.; // Simple in the sense it only uses 4 non-random datapoints.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx:3,Simpl,Simple,3,tmva/tmva/test/ROC/testRocWeights.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx,2,['Simpl'],['Simple']
Usability,"// Simple set of parameters that just return their index in the parameter; // list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testParamHistFunc.cxx:3,Simpl,Simple,3,roofit/histfactory/test/testParamHistFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testParamHistFunc.cxx,1,['Simpl'],['Simple']
Usability,"// Simple shift if we generate all observables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx:3,Simpl,Simple,3,roofit/roofitcore/src/RooMultiVarGaussian.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx,1,['Simpl'],['Simple']
Usability,"// Simple socket",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSocket.cxx:3,Simpl,Simple,3,net/net/src/TSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSocket.cxx,1,['Simpl'],['Simple']
Usability,// Simple struct to hold relevant .dynamic entries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/InterfaceStub/ELFObjHandler.cpp,1,['Simpl'],['Simple']
Usability,// Simple template that decides whether a type T has neither a member-function; // nor format_provider based implementation that it can use. Mostly used so; // that the compiler spits out a nice diagnostic when a type with no format; // implementation can be located.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadicDetails.h:3,Simpl,Simple,3,interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadicDetails.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadicDetails.h,1,['Simpl'],['Simple']
Usability,"// Simple template that decides whether a type T should use the format_provider; // based format() invocation. The member function takes priority, so this test; // will only be true if there is not ALSO a format member.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadicDetails.h:3,Simpl,Simple,3,interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadicDetails.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadicDetails.h,1,['Simpl'],['Simple']
Usability,// Simple template that decides whether a type T should use the member-function; // based format() invocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadicDetails.h:3,Simpl,Simple,3,interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadicDetails.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadicDetails.h,1,['Simpl'],['Simple']
Usability,// Simple template that decides whether a type T should use the operator<<; // based format() invocation. This takes last priority.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadicDetails.h:3,Simpl,Simple,3,interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadicDetails.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormatVariadicDetails.h,1,['Simpl'],['Simple']
Usability,"// Simple term",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdGenContext.cxx:3,Simpl,Simple,3,roofit/roofitcore/src/RooProdGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdGenContext.cxx,1,['Simpl'],['Simple']
Usability,"// Simple test case: calculate x^2 + b, where x is a vector. This case does; // both a simple calculation (squaring the input vector x) and represents; // handling of state updates in b.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Job.cxx:3,Simpl,Simple,3,roofit/multiprocess/test/test_Job.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Job.cxx,6,"['Simpl', 'simpl']","['Simple', 'simple']"
Usability,"// Simple text editor using TGTextEdit widget",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGTextEditor.h:3,Simpl,Simple,3,gui/gui/inc/TGTextEditor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGTextEditor.h,1,['Simpl'],['Simple']
Usability,// Simple types are always ABI compatible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['Simpl'],['Simple']
Usability,// Simple types are unchanged.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp,1,['Simpl'],['Simple']
Usability,// Simple types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticPrinter.h:3,Simpl,Simple,3,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticPrinter.h,2,['Simpl'],['Simple']
Usability,"// Simple uncorrelated multi-dimensional p.d.f.s; //; // pdf = gauss(x,mx,sx) * gauss(y,my,sy)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:3,Simpl,Simple,3,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['Simpl'],['Simple']
Usability,// Simple upper registers,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AVR.h:3,Simpl,Simple,3,interpreter/llvm-project/clang/lib/Basic/Targets/AVR.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AVR.h,2,['Simpl'],['Simple']
Usability,// Simple upper registers r16..r23.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,1,['Simpl'],['Simple']
Usability,// Simple value types that aren't explicitly part of this enumeration; // are considered extended value types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:3,Simpl,Simple,3,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,1,['Simpl'],['Simple']
Usability,// Simple variable ref.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,18,['Simpl'],['Simple']
Usability,"// Simple void foo(), where the incoming T is the result type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Simpl,Simple,3,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['Simpl'],['Simple']
Usability,"// Simple wrapper class to abstract away from the details of memory management.; // SExprs are allocated in pools, and deallocated all at once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyUtil.h:3,Simpl,Simple,3,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyUtil.h,1,['Simpl'],['Simple']
Usability,// Simple wrapper to add the name of a variable or (if no variable is; // available) a DeclarationName into a diagnostic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Simpl,Simple,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Simpl'],['Simple']
Usability,"// Simple wrapper to separate, time-wise, the call to the; // TROOT destructor and the actual free-ing of the memory.; //; // Since the interpreter implementation (currently TCling) is; // loaded via dlopen by libCore, the destruction of its global; // variable (i.e. in particular clang's) is scheduled before; // those in libCore so we need to schedule the call to the TROOT; // destructor before that *but* we want to make sure the memory; // stay around until libCore itself is unloaded so that code; // using gROOT can 'properly' check for validity.; //; // The order of loading for is:; // libCore.so; // libRint.so; // ... anything other library hard linked to the executable ...; // ... for example libEvent; // libCling.so; // ... other libraries like libTree for example ....; // and the destruction order is (of course) the reverse.; // By default the unloading of the dictionary, does use; // the service of the interpreter ... which of course; // fails if libCling is already unloaded by that information; // has not been registered per se.; //; // To solve this problem, we now schedule the destruction; // of the TROOT object to happen _just_ before the; // unloading/destruction of libCling so that we can; // maximize the amount of clean-up we can do correctly; // and we can still allocate the TROOT object's memory; // statically.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:3,Simpl,Simple,3,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['Simpl'],['Simple']
Usability,"// Simple: fixed address, class offset, stack offset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp:3,Simpl,Simple,3,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp,1,['Simpl'],['Simple']
Usability,"// SimpleSValBuilder.cpp - A basic SValBuilder -----------------------*- C++ -*-; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines SimpleSValBuilder, a basic implementation of SValBuilder.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:3,Simpl,SimpleSValBuilder,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,2,['Simpl'],['SimpleSValBuilder']
Usability,// Simplest case is that the operand needs to be promoted to XLenVT.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Simpl,Simplest,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['Simpl'],['Simplest']
Usability,// Simplest case: an exact overlap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp:3,Simpl,Simplest,3,interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,1,['Simpl'],['Simplest']
Usability,"// Simplest case: top-level of component is a RooRealSumPdf",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFitImplHelpers.cxx:3,Simpl,Simplest,3,roofit/roofitcore/src/RooFitImplHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFitImplHelpers.cxx,1,['Simpl'],['Simplest']
Usability,"// Simplest case: top-level of pdf is a RRSP",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/buildLikelihood.cxx:3,Simpl,Simplest,3,roofit/roofitcore/src/TestStatistics/buildLikelihood.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/buildLikelihood.cxx,1,['Simpl'],['Simplest']
Usability,"// Simplest scenario, full-range integration over all dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHistPdf.cxx:3,Simpl,Simplest,3,roofit/roofitcore/src/RooHistPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHistPdf.cxx,1,['Simpl'],['Simplest']
Usability,"// Simplest scenario, integrate over all dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooParamHistFunc.cxx:3,Simpl,Simplest,3,roofit/roofit/src/RooParamHistFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooParamHistFunc.cxx,1,['Simpl'],['Simplest']
Usability,"// Simplification can cause a special instruction to become not special.; // For example, devirtualization to a willreturn function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:3,Simpl,Simplification,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['Simpl'],['Simplification']
Usability,"// Simplification is much more costly than computing complexity.; // For high complexity, it may be not worth it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:3,Simpl,Simplification,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,1,['Simpl'],['Simplification']
Usability,"// Simplification made the clause empty, which is equivalent to `false`.; // We already know that this formula is unsatisfiable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:3,Simpl,Simplification,3,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,1,['Simpl'],['Simplification']
Usability,"// Simplification: translate an assume of a constraint of the form; // ""(exp comparison_op expr) != 0"" to true into an assume of; // ""exp comparison_op expr"" to true. (And similarly, an assume of the form; // ""(exp comparison_op expr) == 0"" to true into an assume of; // ""exp comparison_op expr"" to false.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp:3,Simpl,Simplification,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,1,['Simpl'],['Simplification']
Usability,// Simplified addends are placed <SimpVect>.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:3,Simpl,Simplified,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['Simpl'],['Simplified']
Usability,// Simplified check for a compile-time constant value of ExtIdxR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp:3,Simpl,Simplified,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,1,['Simpl'],['Simplified']
Usability,// Simplified from Generic_GCC::GCCInstallationDetector::ScanLibDirForGCCTriple.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp:3,Simpl,Simplified,3,interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp,1,['Simpl'],['Simplified']
Usability,"// Simplified from memoryobject, as we're always dealing with C arrays.; // start with full copy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/LowLevelViews.cxx:3,Simpl,Simplified,3,bindings/pyroot/cppyy/CPyCppyy/src/LowLevelViews.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/LowLevelViews.cxx,1,['Simpl'],['Simplified']
Usability,// Simplified segment directives,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/COFFMasmParser.cpp:3,Simpl,Simplified,3,interpreter/llvm-project/llvm/lib/MC/MCParser/COFFMasmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/COFFMasmParser.cpp,1,['Simpl'],['Simplified']
Usability,// Simplifies ICMP to trivial true or false by turning it into '0 == 0' or; // '0 != 0'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Simpl,Simplifies,3,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Simpl'],['Simplifies']
Usability,// Simplifies IntToPtr/PtrToInt RoundTrip Cast.; // inttoptr ( ptrtoint (x) ) --> x,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Simpl,Simplifies,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['Simpl'],['Simplifies']
Usability,"// Simplifies X % C0 + (( X / C0 ) % C1) * C0 to X % (C0 * C1), where (C0 * C1); // does not overflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:3,Simpl,Simplifies,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['Simpl'],['Simplifies']
Usability,// Simplifies a terminator by replacing it with a branch to TrueBB if Cond is; // true or to FalseBB if Cond is false.; // Takes care of updating the successors and removing the old terminator.; // Also makes sure not to introduce new successors by assuming that edges to; // non-successor TrueBBs and FalseBBs aren't reachable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Simpl,Simplifies,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['Simpl'],['Simplifies']
Usability,"// Simplify ""(LSym + LInt) Op (RSym + RInt)"" assuming all values are of the; // same signed integral type and no overflows occur (which should be checked; // by the caller).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify 'fcmp pred X, X'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify 'shl' inequality test into 'and' equality test.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify (X+Y) == (X+Z) --> Y == Z,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify (build_vec (ext )) to (bitcast (build_vec )),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify (build_vec (trunc $1); // (trunc (srl $1 half-width)); // (trunc (srl $1 (2 * half-width)))); // to (bitcast $1),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify (fcmp cc0 x, y) & (fcmp cc1 x, y).; // Suppose the relation between x and y is R, where R is one of; // U(1000), L(0100), G(0010) or E(0001), and CC0 and CC1 are the bitmasks for; // testing the desired relations.; //; // Since (R & CC0) and (R & CC1) are either R or 0, we actually have this:; // bool(R & CC0) && bool(R & CC1); // = bool((R & CC0) & (R & CC1)); // = bool(R & (CC0 & CC1)) <= by re-association, commutation, and idempotency; //; // Since (R & CC0) and (R & CC1) are either R or 0, we actually have this:; // bool(R & CC0) || bool(R & CC1); // = bool((R & CC0) | (R & CC1)); // = bool(R & (CC0 | CC1)) <= by reversed distribution (contribution? ;)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify BinOps with their identity values first. They are no-ops and we; // can always return the other value, including undef or poison values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify FMUL recurrences starting with 0.0 to 0.0 if nnan and nsz are set.; // Given a phi node with entry value as 0 and it used in fmul operation,; // we can replace fmul with 0 safely and eleminate loop operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify Mask based on demanded element.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify PERMPD/PERMQ to extract_subvector.; // TODO: This should be done in shuffle combining.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify PMULDQ and PMULUDQ operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify Q -> V -> Q conversion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify TF.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify V:v2NiB --(bitcast)--> vNi2B --(truncate)--> vNiB; // to extract-subvector (shuffle V, pick even, pick odd)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify VPERM2F128/VPERM2I128 to extract_subvector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify VPMADDUBSW/VPMADDWD operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify X & Y == Y to X & Y != 0 if Y has exactly one bit set.; // Note that where Y is variable and is known to have at most one bit set; // (for example, if it is Z & 1) we cannot do this; the expressions are not; // equivalent when Y == 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify any new induction variables in the partially unrolled loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify code with refs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLBoundingBox.cxx:3,Simpl,Simplify,3,graf3d/gl/src/TGLBoundingBox.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLBoundingBox.cxx,1,['Simpl'],['Simplify']
Usability,"// Simplify comparisons of related pointers using a powerful, recursive; // GEP-walk when we have target data available..",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify conditional branches and switches with a constant operand. We try; // to prune these out when cloning, but if the simplification required; // looking through PHI nodes, those are only available after forming the full; // basic block. That may leave some here, and we still want to prune the dead; // code as early as possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,2,"['Simpl', 'simpl']","['Simplify', 'simplification']"
Usability,// Simplify each loop nest in the function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify icmp eq (or (ptrtoint P), (ptrtoint Q)), 0; // -> and (icmp eq P, null), (icmp eq Q, null).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify icmp eq (trunc x to i8), 42 -> icmp eq x, 42|highbits if all; // of the high bits truncated out of x are known.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify if all shift amounts are constant/undef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify if count is constant vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify is skipped while building the counters above: it can get really; // slow on top of switches with thousands of cases. Instead, trigger; // simplification by adding zero to the last counter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,2,"['Simpl', 'simpl']","['Simplify', 'simplification']"
Usability,// Simplify loop values after breaking the backedge,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify loops for which we might've broken loop-simplify form.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,2,"['Simpl', 'simpl']","['Simplify', 'simplify']"
Usability,// Simplify mask if we have an undemanded element that is not undef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify mask using undef elements from LHS/RHS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify mul instructions with a constant RHS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify multiplies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,2,['Simpl'],['Simplify']
Usability,// Simplify operations where predicate has all inactive lanes or try to replace; // with _u form when all lanes are active,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify reciprocal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify resume that is only used by a single (non-phi) landing pad.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,2,"['Simpl', 'resume']","['Simplify', 'resume']"
Usability,// Simplify resume that is shared by several landing pads (phi of landing pad).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,2,"['Simpl', 'resume']","['Simplify', 'resume']"
Usability,"// Simplify scalar inserts into an undef vector:; // insert_subvector undef, (splat X), N2 -> splat X",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify selects that test the returned flag of cmpxchg instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify source operands based on insertion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify source operands based on shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify source operands based on shuffle mask.; // TODO - merge this into combineX86ShufflesRecursively.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify the 1-into-3 and 3-into-1 cases with a single pshufd. For all; // such inputs we can swap two of the dwords across the half mark and end up; // with <=2 inputs to each half in each half. Once there, we can fall through; // to the generic code below. For example:; //; // Input: [a, b, c, d, e, f, g, h] -PSHUFD[0,2,1,3]-> [a, b, e, f, c, d, g, h]; // Mask: [0, 1, 2, 7, 4, 5, 6, 3] -----------------> [0, 1, 4, 7, 2, 3, 6, 5]; //; // However in some very rare cases we have a 1-into-3 or 3-into-1 on one half; // and an existing 2-into-2 on the other half. In this case we may have to; // pre-shuffle the 2-into-2 half to avoid turning it into a 3-into-1 or; // 1-into-3 which could cause us to cycle endlessly fixing each side in turn.; // Fortunately, we don't have to handle anything but a 2-into-2 pattern; // because any other situation (including a 3-into-1 or 1-into-3 in the other; // half than the one we target for fixing) will be fixed when we re-enter this; // path. We will also combine away any sequence of PSHUFD instructions that; // result into a single instruction. Here is an example of the tricky case:; //; // Input: [a, b, c, d, e, f, g, h] -PSHUFD[0,2,1,3]-> [a, b, e, f, c, d, g, h]; // Mask: [3, 7, 1, 0, 2, 7, 3, 5] -THIS-IS-BAD!!!!-> [5, 7, 1, 0, 4, 7, 5, 3]; //; // This now has a 1-into-3 in the high half! Instead, we do two shuffles:; //; // Input: [a, b, c, d, e, f, g, h] PSHUFHW[0,2,1,3]-> [a, b, c, d, e, g, f, h]; // Mask: [3, 7, 1, 0, 2, 7, 3, 5] -----------------> [3, 7, 1, 0, 2, 7, 3, 6]; //; // Input: [a, b, c, d, e, g, f, h] -PSHUFD[0,2,1,3]-> [a, b, e, g, c, d, f, h]; // Mask: [3, 7, 1, 0, 2, 7, 3, 6] -----------------> [5, 7, 1, 0, 4, 7, 5, 6]; //; // The result is fine to be handled by the generic logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify the GEP to handle 'gep x, 0' -> x etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify the argument operand explicitly and check if the result is; // valid in the current scope. This avoids refering to simplified values; // in other functions, e.g., we don't want to say a an argument in a; // static function is actually an argument in a different function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,2,"['Simpl', 'simpl']","['Simplify', 'simplified']"
Usability,"// Simplify the control flow graph (deleting unreachable blocks, etc).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/Chapter4/toy.cpp,10,['Simpl'],['Simplify']
Usability,"// Simplify the control flow graph (deleting unreachable; // blocks, etc).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify the display file path, and wrap it in a link if requested.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify the expression using non-local knowledge.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify the following patterns:; // if (cond); // / \; // ... ...; // \ /; // phi [true] [false]; // and; // switch (cond); // case v1: / \ case v2:; // ... ...; // \ /; // phi [v1] [v2]; // Make sure all inputs are constants.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify the initializer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify the input constraint.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify the input, using demanded bit information, and compute the known; // zero/one bits live out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify the input, using demanded bit information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify the inputs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['Simpl'],['Simplify']
Usability,"// Simplify the list of clauses, eg by removing repeated catch clauses; // (these are often created by inlining).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify the loop body. We do this initially to clean up after other loop; // passes run, either when iterating on a loop or on inner loops with; // implications on the outer loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,2,['Simpl'],['Simplify']
Usability,// Simplify the loop latch before attempting to rotate the header; // upward. Rotation may not be needed if the loop tail can be folded into the; // loop exit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify the operand first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,2,['Simpl'],['Simplify']
Usability,// Simplify the operands before analyzing them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify the operands first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,3,['Simpl'],['Simplify']
Usability,// Simplify the operands using demanded-bits information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,5,['Simpl'],['Simplify']
Usability,// Simplify the operands using demanded-bits information.; // We don't have demanded bits support for MULHU so this just enables constant; // folding based on known bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify the output constraint.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify this down to something we can handle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,4,['Simpl'],['Simplify']
Usability,// Simplify to target-generic binary op.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify to target-generic cast op.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify to target-generic intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify unnecessary loops away.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,2,['Simpl'],['Simplify']
Usability,// Simplify variable target shuffle masks based on the demanded elements.; // TODO: Handle DemandedBits in mask indices as well?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify xor/and/or (bitcast(A), bitcast(B)) -> bitcast(op (A,B)); // Only perform this optimization up until type legalization, before; // LegalizeVectorOprs. LegalizeVectorOprs promotes vector operations by; // adding bitcasts. For example (xor v4i32) is promoted to (v2i64), and; // we don't want to undo this promotion.; // We also handle SCALAR_TO_VECTOR because xor/or/and operations are cheaper; // on scalars.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,"['Simpl', 'undo']","['Simplify', 'undo']"
Usability,"// Simplify, based on bits shifted out of N0/N1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify, based on bits shifted out of the LHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify: (and (op x...), (op y...)) -> (op (and x, y))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify: (or (op x...), (op y...)) -> (op (or x, y))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify: xor (op x...), (op y...) -> (op (xor x, y))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify:; // BasePtr = Ptr; // Index = (X + splat(Offset)) << splat(Shift); // ->; // BasePtr = Ptr + (Offset << Shift) * scale); // Index = X << splat(shift),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Simpl'],['Simplify']
Usability,// Simplify:; // BasePtr = Ptr; // Index = X + splat(Offset); // ->; // BasePtr = Ptr + Offset * scale.; // Index = X,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Simpl'],['Simplify']
Usability,"// Simplify; // mov r1, r0; // cmp r1, x; // mov r0, y; // moveq r0, x; // to; // cmp r0, x; // movne r0, y; //; // mov r1, r0; // cmp r1, x; // mov r0, x; // movne r0, y; // to; // cmp r0, x; // movne r0, y; /// FIXME: Turn this into a target neutral optimization?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Simpl,Simplify,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Simpl'],['Simplify']
Usability,// SimplifyAction is a poor-man's variant (plus an additional flag) that; // represents how to replace an NVVM intrinsic with target-generic LLVM IR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:3,Simpl,SimplifyAction,3,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,1,['Simpl'],['SimplifyAction']
Usability,"// SimplifyDemandedBits has the annoying habit of turning useful zero_extends; // in the source into any_extends if the result of the mul is truncated. Since; // we can assume the high bits are whatever we want, use the underlying value; // to avoid the unknown high bits from interfering.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:3,Simpl,SimplifyDemandedBits,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,2,['Simpl'],['SimplifyDemandedBits']
Usability,// SimplifyDemandedBits may have optimized the mask so try restoring any; // bits that are known zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp:3,Simpl,SimplifyDemandedBits,3,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelDAGToDAG.cpp,3,['Simpl'],['SimplifyDemandedBits']
Usability,// SimplifyLibCalls is set only in the absence of -fno-builtin and; // -ffreestanding. We'll consider that when generating them.; // NoBuiltinFuncs are generated by LangOptions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:3,Simpl,SimplifyLibCalls,3,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['Simpl'],['SimplifyLibCalls']
Usability,// SimplifySetCC uses this function to determine whether or not it should; // create setcc with i1 operands. We don't have instructions for i1 setcc.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:3,Simpl,SimplifySetCC,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Simpl'],['SimplifySetCC']
Usability,"// SimplifySuspendPoint needs to check that there is no calls between; // coro_save and coro_suspend, since any of the calls may potentially resume; // the coroutine and if that is the case we cannot eliminate the suspend point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:3,Simpl,SimplifySuspendPoint,3,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,2,"['Simpl', 'resume']","['SimplifySuspendPoint', 'resume']"
Usability,"// Simplist check is to compare against a new tree. This will also; // usefully print the old and new trees, if they are different.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h:3,Simpl,Simplist,3,interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,1,['Simpl'],['Simplist']
Usability,// Simply append the trace if we have not yet hit our reservoir size limit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp:3,Simpl,Simply,3,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,1,['Simpl'],['Simply']
Usability,// Simply bail if this instruction has no user.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:3,Simpl,Simply,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,1,['Simpl'],['Simply']
Usability,"// Simply check addressIsReturn, as ret is always reliable, both for; // regular call and tail call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h:3,Simpl,Simply,3,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h,1,['Simpl'],['Simply']
Usability,"// Simply consider every block pointed by seh frame block as parants.; // This adds some unnecessary keep-alive edges to unwind info blocks,; // (xdata) but these blocks are usually dead by default, so they wouldn't; // count for the fate of seh frame block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/SEHFrameSupport.h:3,Simpl,Simply,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/SEHFrameSupport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/SEHFrameSupport.h,1,['Simpl'],['Simply']
Usability,// Simply copy the metadata if the type did not change.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Simpl,Simply,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['Simpl'],['Simply']
Usability,"// Simply discard ADJCALLSTACKDOWN, ADJCALLSTACKUP instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:3,Simpl,Simply,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['Simpl'],['Simply']
Usability,"// Simply discard ADJCALLSTACKDOWN,; // ADJCALLSTACKUP instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXFrameLowering.cpp:3,Simpl,Simply,3,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXFrameLowering.cpp,1,['Simpl'],['Simply']
Usability,// Simply discard the function level map,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:3,Simpl,Simply,3,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,1,['Simpl'],['Simply']
Usability,// Simply gathers the contents of the various rules into a single rule. The; // actual work to combine these into an ordered choice is deferred to matcher; // registration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:3,Simpl,Simply,3,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,1,['Simpl'],['Simply']
Usability,// Simply look at the actual default argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:3,Simpl,Simply,3,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,1,['Simpl'],['Simply']
Usability,"// Simply loop over bins,; // get the height, and; // multiply by the bind width",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/ParamHistFunc.cxx:3,Simpl,Simply,3,roofit/histfactory/src/ParamHistFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/ParamHistFunc.cxx,1,['Simpl'],['Simply']
Usability,"// Simply multiplying by the reciprocal estimate can leave us a few ulps; // too low, so we add 2 ulps (exhaustive testing shows that this is enough,; // and that it will never cause us to return an answer too large).; // float4 result = as_float4(as_int4(xf*recip) + 2);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:3,Simpl,Simply,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Simpl'],['Simply']
Usability,// Simply remove the dead def at OldIdx.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:3,Simpl,Simply,3,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,1,['Simpl'],['Simply']
Usability,"// Simply return integral",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:3,Simpl,Simply,3,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['Simpl'],['Simply']
Usability,"// Simply skip the CXXDependentScopeMemberExpr and only use its content.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp:3,Simpl,Simply,3,interpreter/cling/lib/Interpreter/DynamicLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp,1,['Simpl'],['Simply']
Usability,// Simply skip until then. This range only contains a value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:3,Simpl,Simply,3,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['Simpl'],['Simply']
Usability,// Simply strip out debugging intrinsics,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp:3,Simpl,Simply,3,interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp,1,['Simpl'],['Simply']
Usability,// Simply strip out pcmarker on unsupported architectures,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp:3,Simpl,Simply,3,interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp,1,['Simpl'],['Simply']
Usability,// Simply strip out prefetches on unsupported architectures,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp:3,Simpl,Simply,3,interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp,1,['Simpl'],['Simply']
Usability,// Simply use 'id' for all qualified types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:3,Simpl,Simply,3,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,4,['Simpl'],['Simply']
Usability,"// Simply wait for all, this works even if recursive (the running task; // is already removed from the queue).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ThreadPool.cpp:3,Simpl,Simply,3,interpreter/llvm-project/llvm/lib/Support/ThreadPool.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ThreadPool.cpp,1,['Simpl'],['Simply']
Usability,"// Simulate execution of each iteration of the loop counting instructions,; // which would be simplified.; // Since the same load will take different values on different iterations,; // we literally have to go through all loop's iterations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:94,simpl,simplified,94,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['simpl'],['simplified']
Usability,"// Since SCEVs are immutable, ScalarEvolution allocates operand; // arrays with its SCEVAllocator, so this class just needs a simple; // pointer rather than a more elaborate vector-like data structure.; // This also avoids the need for a non-trivial destructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:126,simpl,simple,126,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,1,['simpl'],['simple']
Usability,"// Since SETCC_CARRY gives output based on R = CF ? ~0 : 0, it's unsafe to; // simplify it if the result of SETCC_CARRY is not canonicalized to 0 or 1,; // i.e. it's a comparison against true but the result of SETCC_CARRY is not; // truncated to i1 using 'and'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:79,simpl,simplify,79,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplify']
Usability,"// Since both OMPC_DEPEND_outallmemory and OMPC_DEPEND_inoutallmemory are; // equivalent to the runtime, always use OMPC_DEPEND_outallmemory to; // simplify.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:148,simpl,simplify,148,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['simpl'],['simplify']
Usability,"// Since data is always emitted into a DataFragment, our check strategy is; // simple here.; // - If the fragment is a DataFragment; // - If it's not the fragment where the previous instruction is,; // returns true.; // - If it's the fragment holding the previous instruction but its; // size changed since the previous instruction was emitted into; // it, returns true.; // - Otherwise returns false.; // - If the fragment is not a DataFragment, returns false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:79,simpl,simple,79,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,1,['simpl'],['simple']
Usability,"// Since our optimizations should never increase the number of operations, the; // new expression can usually be written reusing the existing binary operators; // from the original expression tree, without creating any new instructions,; // though the rewritten expression may have a completely different topology.; // We take care to not change anything if the new expression will be the same; // as the original. If more than trivial changes (like commuting operands); // were made then we are obliged to clear out any optional subclass data like; // nsw flags.; /// NodesToRewrite - Nodes from the original expression available for writing; /// the new expression into.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:507,clear,clear,507,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['clear'],['clear']
Usability,"// Since some of the friends of this chain might simple trees; // (i.e., not really chains at all), we need to execute this; // before calling LoadTree(entry) on the friends (so that; // they use the correct read entry number).; // Change the new current tree to the new entry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:49,simpl,simple,49,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['simpl'],['simple']
Usability,"// Since the GUID from probe desc and inline stack are computed seperately, we; // need to make sure their names are consistent, so here also use the name; // from debug info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp:13,GUID,GUID,13,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfileProbe.cpp,1,['GUID'],['GUID']
Usability,"// Since the call site is now direct, we must clear metadata that; // is only appropriate for indirect calls. This includes !prof and; // !callees metadata.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:46,clear,clear,46,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['clear'],['clear']
Usability,"// Since the call site will no longer be direct, we must clear metadata that; // is only appropriate for indirect calls. This includes !prof and !callees; // metadata.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp:57,clear,clear,57,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,1,['clear'],['clear']
Usability,"// Since the callers side has left justified the aggregate in the; // register, we can simply store the entire register into the stack; // slot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:87,simpl,simply,87,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['simpl'],['simply']
Usability,"// Since the invented template parameters generated from 'auto' parameters; // are either appended to the end of the explicit template parameter list or; // form a new template parameter list, we can simply observe the last; // parameter to determine if such a thing happened.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h:200,simpl,simply,200,interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,1,['simpl'],['simply']
Usability,"// Since the new call site is direct, we must clear metadata that; // is only appropriate for indirect calls. This includes !prof and; // !callees metadata.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:46,clear,clear,46,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['clear'],['clear']
Usability,"// Since the shift amount is not a constant, we need to clear; // the upper bits with a separate RLWINM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:56,clear,clear,56,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['clear'],['clear']
Usability,"// Since we bail out, the ""Cache"" set won't contain all of the; // results for the query. This is ok (we can still use it to accelerate; // specific block queries) but we can't do the fastpath ""return all; // results from the set"". Clear out the indicator for this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:232,Clear,Clear,232,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['Clear'],['Clear']
Usability,"// Since we can possibly extend register lifetime, clear kill flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp:51,clear,clear,51,interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,2,['clear'],['clear']
Usability,"// Since we did phi translation, the ""Cache"" set won't contain all of the; // results for the query. This is ok (we can still use it to accelerate; // specific block queries) but we can't do the fastpath ""return all; // results from the set"" Clear out the indicator for this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:242,Clear,Clear,242,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['Clear'],['Clear']
Usability,"// Since we do not allow splitting EH-block with BlockColors in; // canSplitPredecessors(), we can simply assign predecessor's color to; // the new block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:99,simpl,simply,99,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['simpl'],['simply']
Usability,"// Since we failed phi translation, the ""Cache"" set won't contain all of the; // results for the query. This is ok (we can still use it to accelerate; // specific block queries) but we can't do the fastpath ""return all; // results from the set"". Clear out the indicator for this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:246,Clear,Clear,246,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['Clear'],['Clear']
Usability,"// Since we may not have visited the input blocks of the phis, we can't; // use our normal hash approach for phis. Instead, simply look for; // obvious duplicates. The first pass of GVN will tend to create; // identical phis, and the second or later passes can eliminate them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:124,simpl,simply,124,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['simpl'],['simply']
Usability,"// Since we're extended the lifetime of RegPair.Reg, clear the; // kill flags to account for that and make RegPair.Reg reaches; // the new PHI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:53,clear,clear,53,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['clear'],['clear']
Usability,"// Single selection with zero element --> clear selection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveSelection.cxx:42,clear,clear,42,graf3d/eve7/src/REveSelection.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveSelection.cxx,1,['clear'],['clear']
Usability,"// Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs:58,simpl,simplices,58,js/modules/three_addons.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs,1,['simpl'],['simplices']
Usability,// Skew the input space to determine which simplex cell we're in,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs:43,simpl,simplex,43,js/modules/three_addons.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs,2,['simpl'],['simplex']
Usability,"// Skip C++-style comment.; // We may just return true now, but let's skip to the line/buffer end; // to simplify the method specification.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp:105,simpl,simplify,105,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,1,['simpl'],['simplify']
Usability,// Skip X/sqrt(X) that has not been simplified to sqrt(X) yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,simpl,simplified,36,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simplified']
Usability,// Skip deduction guides.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ObjectFilePCHContainerOperations.cpp:18,guid,guides,18,interpreter/llvm-project/clang/lib/CodeGen/ObjectFilePCHContainerOperations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ObjectFilePCHContainerOperations.cpp,1,['guid'],['guides']
Usability,// Skip induction resume value creation here because they will be created in; // the second pass for the scalar loop. The induction resume values for the; // inductions in the epilogue loop are created before executing the plan for; // the epilogue loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:18,resume,resume,18,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,['resume'],['resume']
Usability,// Skip non-simple loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULateCodeGenPrepare.cpp:12,simpl,simple,12,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULateCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULateCodeGenPrepare.cpp,1,['simpl'],['simple']
Usability,// Skip read2 / write2 variants for simplicity.; // TODO: We should report true if the used offsets are adjacent (excluded; // st64 versions).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:36,simpl,simplicity,36,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['simpl'],['simplicity']
Usability,// Skip shifts of shift by constants. It undoes a combine in; // FoldShiftByConstant and is the extend in reg pattern.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:41,undo,undoes,41,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['undo'],['undoes']
Usability,"// Skip the clearance token, too",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/mathtext/src/mathrender.cxx:12,clear,clearance,12,graf2d/mathtext/src/mathrender.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/mathtext/src/mathrender.cxx,1,['clear'],['clearance']
Usability,"// Skip the code-completion char and all immediate identifier characters.; // This ensures we get consistent behavior when completing at any point in; // an identifier (i.e. at the start, in the middle, at the end). Note that; // only simple cases (i.e. [a-zA-Z0-9_]) are supported to keep the code; // simpler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:235,simpl,simple,235,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,2,['simpl'],"['simple', 'simpler']"
Usability,// Skip the invalid destructor. We cannot simply return because; // it would interrupt the analysis instead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:42,simpl,simply,42,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,1,['simpl'],['simply']
Usability,"// Some call descriptions aren't easily hashable (eg., the ones with qualified; // names in which some sections are omitted), so let's put them; // in a simple vector and use linear lookup.; // TODO: Implement an actual map for fast lookup for ""hashable"" call; // descriptions (eg., the ones for C functions that just match the name).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h:153,simpl,simple,153,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h,1,['simpl'],['simple']
Usability,"// Some checks may be represented as inversion of simpler check, for example; // ""inf|normal|subnormal|zero"" => !""nan"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:50,simpl,simpler,50,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['simpl'],['simpler']
Usability,"// Some intervals are suspicious! In some cases we find address; // calculations outside of the lifetime zone, but not actual memory; // read or write. Memory accesses outside of the lifetime zone are a clear; // violation, but address calculations are okay. This can happen when; // GEPs are hoisted outside of the lifetime zone.; // So, in here we only check instructions which can read or write memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:203,clear,clear,203,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,1,['clear'],['clear']
Usability,// Some kind of simplification occurred: check whether the operand of the; // salvaged debug expression can be encoded in this DAG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:16,simpl,simplification,16,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['simpl'],['simplification']
Usability,"// Some libraries (e.g., arm64rt.lib) from the Windows WDK; // (version 10.0.22000.0) contain this undocumented special member.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/Archive.cpp:99,undo,undocumented,99,interpreter/llvm-project/llvm/lib/Object/Archive.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/Archive.cpp,1,['undo'],['undocumented']
Usability,"// Some loops may have become dead by now. Try to delete them.; // FIXME: see discussion in https://reviews.llvm.org/D112851,; // this may need to be revisited once we run GVN before loop deletion; // in the simplification pipeline.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:208,simpl,simplification,208,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['simpl'],['simplification']
Usability,"// Some simple shape drawing utils",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h:8,simpl,simple,8,graf3d/gl/inc/TGLUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h,1,['simpl'],['simple']
Usability,// Some simple statistics,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:8,simpl,simple,8,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['simpl'],['simple']
Usability,"// Some versions of SUSE and Fedora on ppc64 put 32-bit libs; // in what would normally be GCCInstallPath and put the 64-bit; // libs in a subdirectory named 64. The simple logic we follow is that; // *if* there is a subdirectory of the right name with crtbegin.o in it,; // we use that. If not, and if not a biarch triple alias, we look for; // crtbegin.o without the subdirectory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:166,simpl,simple,166,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['simpl'],['simple']
Usability,"// Sometimes the line between taint sources and propagators is blurry.; // _IO_getc is choosen to be a source, but could also be a propagator.; // This way it is simpler, as modeling it as a propagator would require; // to model the possible sources of _IO_FILE * values, which the _IO_getc; // function takes as parameters.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:162,simpl,simpler,162,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,1,['simpl'],['simpler']
Usability,"// Sometimes, the amount of data that needs to be compared is smaller than; // the standard register size, but it cannot be loaded with just one load; // instruction. For example, if the size of the memory comparison is 6; // bytes, we can handle it more efficiently by loading all 6 bytes in a; // single block and generating an 8-byte number, instead of generating two; // separate blocks with conditional jumps for 4 and 2 byte loads. This; // approach simplifies the process and produces the comparison result as; // normal. This array lists the allowed sizes of memcmp tails that can be; // merged into one block",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:456,simpl,simplifies,456,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['simpl'],['simplifies']
Usability,"// Sort all the symbols, this allows us to use a simple binary search to find; // Multiple symbols can have the same address. Use a stable sort to stabilize; // the output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp:49,simpl,simple,49,interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,1,['simpl'],['simple']
Usability,// Sort the completed regions by end location. This makes it simple to; // emit closing segments in sorted order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp:61,simpl,simple,61,interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp,1,['simpl'],['simple']
Usability,// Sort the contexts before writing them out. This is to help fast load all; // context profiles for a function as well as their callee contexts which; // can help profile-guided importing for ThinLTO.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfWriter.cpp:172,guid,guided,172,interpreter/llvm-project/llvm/lib/ProfileData/SampleProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfWriter.cpp,1,['guid'],['guided']
Usability,"// Sort the edges, and then for each successor, find the best incoming; // predecessor. If the best incoming predecessors aren't the same,; // then that is clearly the best layout. If there is a conflict, one of the; // successors will have to fallthrough from the second best predecessor. We; // compare which combination is better overall.; // Sort for highest frequency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:156,clear,clearly,156,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['clear'],['clearly']
Usability,// Sort the export list elements GUIDs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:33,GUID,GUIDs,33,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['GUID'],['GUIDs']
Usability,// Sparse conditional constant propagation.; // FIXME: It isn't clear why we do this *after* loop passes rather than; // before...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:64,clear,clear,64,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,2,['clear'],['clear']
Usability,"// Sparse does not need to be cleared, see find().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h:30,clear,cleared,30,interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h,3,['clear'],['cleared']
Usability,"// Special case for div8, just use a move with zero extension to AX to; // clear the upper 8 bits (AH).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:75,clear,clear,75,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['clear'],['clear']
Usability,"// Special case where there is only one user defined region,; // and this LLVM-MCA-END directive doesn't provide a region name.; // In this case, we assume that the user simply wanted to just terminate; // the only active region.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/CodeRegion.cpp:170,simpl,simply,170,interpreter/llvm-project/llvm/tools/llvm-mca/CodeRegion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/CodeRegion.cpp,1,['simpl'],['simply']
Usability,"// Special case: 'omp target enter data', 'omp target exit data',; // 'omp target update' are stand-alone directives, but for implementation; // reasons they have empty synthetic structured block, to simplify codegen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtOpenMP.cpp:200,simpl,simplify,200,interpreter/llvm-project/clang/lib/AST/StmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtOpenMP.cpp,1,['simpl'],['simplify']
Usability,"// Special case: check for comparisons against literals that can be exactly; // represented by APFloat. In such cases, do not emit a warning. This; // is a heuristic: often comparison against such literals are used to; // detect if a value in a variable has not changed. This clearly can; // lead to false negatives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:276,clear,clearly,276,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['clear'],['clearly']
Usability,"// Special case: if memcmp result is used in a zero equality, result does not; // need to be calculated and can simply return 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:112,simpl,simply,112,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,1,['simpl'],['simply']
Usability,"// Special hackery is needed with PHI nodes that have inputs from more than; // one extracted block. For simplicity, just split the PHIs into a two-level; // sequence of PHIs, some of which will go in the extracted region, and some; // of which will go outside.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:105,simpl,simplicity,105,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,1,['simpl'],['simplicity']
Usability,// Special optimizations to the combination of ext and trunc.; // (ext ... (select ... (trunc ...))) is safe to avoid truncate here; // since this truncate instruction clears higher 32 bits which is filled; // by one of ext instructions later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:168,clear,clears,168,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,1,['clear'],['clears']
Usability,// Special support for PAUSE,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp:23,PAUSE,PAUSE,23,interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,1,['PAUSE'],['PAUSE']
Usability,"// Specially track simple redefs of m0 to the same value in a block, so we; // can erase the later ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp:19,simpl,simple,19,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,1,['simpl'],['simple']
Usability,// Speedup: We have a default if the set is simple.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:44,simpl,simple,44,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['simpl'],['simple']
Usability,"// Splat the simplified sequence, e.g. (f16 a, f16 b, f16 c, f16 d) as one i64; // value or (f16 a, f16 b) as one i32 value. This requires an InsertSubvector; // be bitcast to a type wide enough to fit the sequence, be splatted, and then; // be narrowed back to the original type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:13,simpl,simplified,13,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['simpl'],['simplified']
Usability,"// Splatting the first element of the result of a BinOp, where any of the; // BinOp's operands are the result of a first element splat can be simplified to; // splatting the first element of the result of the BinOp",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:142,simpl,simplified,142,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['simpl'],['simplified']
Usability,"// Split block before and after coro.suspend and add a jump from an entry; // switch:; //; // whateverBB:; // whatever; // %0 = call i8 @llvm.coro.suspend(token none, i1 false); // switch i8 %0, label %suspend[i8 0, label %resume; // i8 1, label %cleanup]; // becomes:; //; // whateverBB:; // whatever; // br label %resume.0.landing; //; // resume.0: ; <--- jump from the switch in the resume.entry; // %0 = tail call i8 @llvm.coro.suspend(token none, i1 false); // br label %resume.0.landing; //; // resume.0.landing:; // %1 = phi i8[-1, %whateverBB], [%0, %resume.0]; // switch i8 % 1, label %suspend [i8 0, label %resume; // i8 1, label %cleanup]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:223,resume,resume,223,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,8,['resume'],['resume']
Usability,"// Split the interval containing Index into up to two parts: one from; // [Start, Index-1] and another from [Index+1, Stop]. If Index is equal to; // either Start or Stop, we create one new interval. If Index is equal to; // both Start and Stop, we simply erase the existing interval.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:249,simpl,simply,249,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,1,['simpl'],['simply']
Usability,// Split the promoted operand. This will simplify when it is expanded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:41,simpl,simplify,41,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,3,['simpl'],['simplify']
Usability,"// SrcTy and DstTy are recursively ismorphic. We clear names of SrcTy; // and all its descendants to lower amount of renaming in LLVM context; // Renaming occurs because we load all source modules to the same context; // and declaration with existing name gets renamed (i.e Foo -> Foo.42).; // As a result we may get several different types in the destination; // module, which are in fact the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:49,clear,clear,49,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,1,['clear'],['clear']
Usability,"// Stackmaps do not have arguments and do not preserve their calling; // convention. However, to simplify runtime support, they clobber the same; // scratch registers as AnyRegCC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp:97,simpl,simplify,97,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp,1,['simpl'],['simplify']
Usability,"// Start Recursion if the underlying type is a TypedefNameDecl; // Note: the simple cast w/o the getSingleStepDesugaredType call; // does not work in case the typedef is in a namespace.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:77,simpl,simple,77,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['simpl'],['simple']
Usability,"// Start a transaction at this point.; // The LHS may match but not the RHS.; // Therefore, we need a higher level restoration point to undo partially; // matched operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:136,undo,undo,136,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['undo'],['undo']
Usability,// Start address to Elf symbol GUID map,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.h:31,GUID,GUID,31,interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.h,1,['GUID'],['GUID']
Usability,"// Start assuming the prefix of elements is demanded, but possibly clear; // some other bits if there are trailing zeros (unused components at front); // and update offset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp:67,clear,clear,67,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,1,['clear'],['clear']
Usability,// Start new block - clear the list of reduction roots.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21,clear,clear,21,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['clear'],['clear']
Usability,// Start numbering the GUIDs after the module ids.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:23,GUID,GUIDs,23,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,1,['GUID'],['GUIDs']
Usability,// Start numbering the TypeIdCompatibleVtables after the GUIDs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:57,GUID,GUIDs,57,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,1,['GUID'],['GUIDs']
Usability,"// Start value must not be signmask for signed division, so simply being a; // power of two is not sufficient, and it has to be a constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:60,simpl,simply,60,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['simpl'],['simply']
Usability,"// Start with ""simple"" cases",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:15,simpl,simple,15,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,1,['simpl'],['simple']
Usability,// Start with the assumption that the buffer is invalid to simplify early; // return paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:59,simpl,simplify,59,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,1,['simpl'],['simplify']
Usability,// Stash away all the uses of the old instruction so we can check them for; // recursive simplifications after a RAUW. This is cheaper than checking all; // uses of To on the recursive step in most cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:89,simpl,simplifications,89,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,['simpl'],['simplifications']
Usability,"// Stash the old value. Also clear Old, so we don't clobber it later; // if we're post-incrementing a complex.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:29,clear,clear,29,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['clear'],['clear']
Usability,"// State gets destroyed here, so the Stk.clear() below doesn't accidentally; // remove values the State's destructor might access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp:41,clear,clear,41,interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp,1,['clear'],['clear']
Usability,"// Static methods to construct a ConstantExpr of different kinds. Note that; // these methods may return a object that is not an instance of the; // ConstantExpr class, because they will attempt to fold the constant; // expression into something simpler if possible.; /// getAlignOf constant expr - computes the alignment of a type in a target; /// independent way (Note: the return type is an i64).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h:246,simpl,simpler,246,interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,1,['simpl'],['simpler']
Usability,"// Step 3.1: Try simplifying ""CurrOpnd ^ ConstOpnd""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:17,simpl,simplifying,17,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['simpl'],['simplifying']
Usability,// Step over non-escapes simply.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:25,simpl,simply,25,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,1,['simpl'],['simply']
Usability,"// Still unresolved, so RAUW.; //; // First, clear out all operands to prevent any recursion (similar to; // dropAllReferences(), but we still need the use-list).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:45,clear,clear,45,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,1,['clear'],['clear']
Usability,// Stop trying when getting a non-simple element type.; // Note that vector elements may be greater than legal vector element; // types. Example: X86 XMM registers hold 64bit element on 32bit; // systems.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:34,simpl,simple,34,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['simpl'],['simple']
Usability,// Store addresses of Resume/Destroy/Cleanup functions in the coroutine frame.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:22,Resume,Resume,22,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['Resume'],['Resume']
Usability,// Store addresses resume/destroy/cleanup functions in the coroutine frame.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:19,resume,resume,19,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['resume'],['resume']
Usability,// Store an available register for FPSCR clearing,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp:41,clear,clearing,41,interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,1,['clear'],['clearing']
Usability,"// Storing the whole vector, simply store it on BE and reverse bytes and; // store on LE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:29,simpl,simply,29,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['simpl'],['simply']
Usability,"// Strictly speaking, we shouldn't be calling EmitLoadOfLValue, which; // transitively calls EmitCompoundLiteralLValue, here in C++ since compound; // literals aren't l-values in C++. We do so simply because that's the; // cleanest way to handle compound literals in C++.; // See the discussion here: https://reviews.llvm.org/D64464",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:193,simpl,simply,193,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['simpl'],['simply']
Usability,"// Strip off at most one level of pointer casts, looking for an alloca. This; // is good enough in practice and simpler than handling any number of casts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:112,simpl,simpler,112,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['simpl'],['simpler']
Usability,"// Substituting can cause recursive simplifications, which can invalidate; // our iterator. Use a WeakTrackingVH to hold onto it in case this; // happens.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:36,simpl,simplifications,36,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['simpl'],['simplifications']
Usability,"// Successfully parsed all the characters up to the ending NULL, so svalue; // was a simple number.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/src/TGDMLParse.cxx:85,simpl,simple,85,geom/gdml/src/TGDMLParse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/src/TGDMLParse.cxx,1,['simpl'],['simple']
Usability,"// Suspend parsing when we reach the function bodies. Subsequent; // materialization calls will resume it when necessary. If the bitcode; // file is old, the symbol table will be at the end instead and will not; // have been seen yet. In this case, just finish the parse now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:96,resume,resume,96,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['resume'],['resume']
Usability,"// Swap tags between the victim and the highest scoring pair.; // If SwapWith is still (-1, -1), that's fine, too - we'll simply take tag for; // the highest score slot without changing anything else.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StackTaggingPreRA.cpp:122,simpl,simply,122,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StackTaggingPreRA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StackTaggingPreRA.cpp,1,['simpl'],['simply']
Usability,"// Swap with a default-constructed std::vector, since std::vector<>::clear(); // does not actually clear heap storage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:69,clear,clear,69,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,2,['clear'],['clear']
Usability,"// THE SIMPLE XTRU",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/vecgeom/src/TGeoVGShape.cxx:7,SIMPL,SIMPLE,7,geom/vecgeom/src/TGeoVGShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/vecgeom/src/TGeoVGShape.cxx,1,['SIMPL'],['SIMPLE']
Usability,"// TM's OptLevel is used to build orc::SimpleCompiler passes for every Module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/BackendPasses.cpp:39,Simpl,SimpleCompiler,39,interpreter/cling/lib/Interpreter/BackendPasses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/BackendPasses.cpp,1,['Simpl'],['SimpleCompiler']
Usability,// TODO - Constant Folding.; // Simplify the inputs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:32,Simpl,Simplify,32,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['Simplify']
Usability,// TODO - add general PACKSS/PACKUS SimplifyDemandedBits support.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,Simpl,SimplifyDemandedBits,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,"// TODO Interrupt handlers; // M68k Interrupt handling function cannot assume anything about the; // direction flag (DF in CCR register). Clear this flag by creating ""cld""; // instruction in each prologue of interrupt handler function. The ""cld""; // instruction should only in these cases:; // 1. The interrupt handling function uses any of the ""rep"" instructions.; // 2. Interrupt handling function calls another function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:138,Clear,Clear,138,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,1,['Clear'],['Clear']
Usability,"// TODO We don't traverse all users. To make the algorithm simple, here we; // just traverse the first user. If we can find shape, then return the shape,; // otherwise just return nullptr and the optimization for undef/zero will be; // abandoned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp:59,simpl,simple,59,interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,1,['simpl'],['simple']
Usability,// TODO should we turn this into 'and' if shift is 0? Or 'shl' if we; // are only masking bits that a shift already cleared?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:116,clear,cleared,116,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['clear'],['cleared']
Usability,"// TODO support object files better; //; // Some object file formats (i.e. non-MachO) support COMDAT. ELF in; // particular does so by placing each function into a section. The DWARF data; // for the function at that point uses a section relative DW_FORM_addrp for; // the DW_AT_low_pc and a DW_FORM_data4 for the offset as the DW_AT_high_pc.; // In such a case, when the Die is the CU, the ranges will overlap, and we; // will flag valid conflicting ranges as invalid.; //; // For such targets, we should read the ranges from the CU and partition them; // by the section id. The ranges within a particular section should be; // disjoint, although the ranges across sections may overlap. We would map; // the child die to the entity that it references and the section with which; // it is associated. The child would then be checked against the range; // information for the associated section.; //; // For now, simply elide the range verification for the CU DIEs if we are; // processing an object file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp:912,simpl,simply,912,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,1,['simpl'],['simply']
Usability,"// TODO(courbet): Right now we abort the whole chain. We could be; // merging only the blocks that don't do other work and resume the; // chain from there. For example:; // if (a[0] == b[0]) { // bb1; // if (a[1] == b[1]) { // bb2; // some_value = 3; //bb3; // if (a[2] == b[2]) { //bb3; // do a ton of stuff //bb4; // }; // }; // }; //; // This is:; //; // bb1 --eq--> bb2 --eq--> bb3* -eq--> bb4 --+; // \ \ \ \; // ne ne ne \; // \ \ \ v; // +------------+-----------+----------> bb_phi; //; // We can only merge the first two comparisons, because bb3* does; // ""other work"" (setting some_value to 3).; // We could still merge bb1 and bb2 though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:123,resume,resume,123,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,1,['resume'],['resume']
Usability,"// TODO(deanm): Figure out this clearing vs code growth logic better. I; // have an feeling that it should just happen somewhere else, for now it; // is awkward between when we grow past the max and then hit a clear code.; // For now just check if we hit the max 12-bits (then a clear code should; // follow, also of course encoded in 12-bits).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:32,clear,clearing,32,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,6,['clear'],"['clear', 'clearing']"
Usability,"// TODO(deanm): Maybe should check that the first code was a clear code,; // at least this is what you're supposed to do. But actually our encoder; // now doesn't emit a clear code first anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:61,clear,clear,61,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['clear'],['clear']
Usability,"// TODO(gparolini): when we get serious about huge file support (>~ 100GB) we might want to check here; // the size of the running page list and commit a cluster group when it exceeds some threshold,; // which would prevent the page list from getting too large.; // However, as of today, we aren't really handling such huge files, and even relatively big ones; // such as the CMS dataset have a page list size of about only 2 MB.; // So currently we simply merge all cluster groups into one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:450,simpl,simply,450,tree/ntuple/v7/src/RNTupleMerger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx,1,['simpl'],['simply']
Usability,"// TODO-PERF: reuse the original liveness, then simply run the dataflow; // again. The old values are still live and will help it stabilize quickly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:48,simpl,simply,48,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['simpl'],['simply']
Usability,// TODO: 25% of our time is spent in simplifyCmpInst with pointer operands,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:37,simpl,simplifyCmpInst,37,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['simpl'],['simplifyCmpInst']
Usability,// TODO: Add support for parameters that have a pre-existing debug expressions; // (e.g. fragments).; // A simple deref expression is equivalent to an indirect debug value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:107,simpl,simple,107,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,1,['simpl'],['simple']
Usability,"// TODO: After performing the sink-and-fold, the original instruction is; // deleted. Its value is still available (in a hard register), so if there; // are debug instructions which refer to the (now deleted) virtual; // register they could be updated to refer to the hard register, in; // principle. However, it's not clear how to do that, moreover in some; // cases the debug instructions may need to be replicated proportionally; // to the number of the COPY instructions replaced and in some extreme; // cases we can end up with quadratic increase in the number of debug; // instructions.; // Sink a copy of the instruction, replacing a COPY instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:319,clear,clear,319,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['clear'],['clear']
Usability,"// TODO: At the moment ComputeReductionResult also drives creation of the; // bc.merge.rdx phi nodes, hence it needs to be created unconditionally here; // even for in-loop reductions, until the reduction resume value handling is; // also modeled in VPlan.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:205,resume,resume,205,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['resume'],['resume']
Usability,// TODO: Avoid clearing the high bits if we know workitem id y/z are always; // 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:15,clear,clearing,15,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['clear'],['clearing']
Usability,"// TODO: Bring all mouse handling into camera classes - would simplify interface and; // remove these non-generic cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLPerspectiveCamera.cxx:62,simpl,simplify,62,graf3d/gl/src/TGLPerspectiveCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLPerspectiveCamera.cxx,1,['simpl'],['simplify']
Usability,"// TODO: Build `SimpleTemplateNameSpecifier` children and implement; // accessors to them.; // Be aware, we cannot do that simply by calling `TraverseTypeLoc`,; // some `TypeLoc`s have inside them the previous name specifier and; // we want to treat them independently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:16,Simpl,SimpleTemplateNameSpecifier,16,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,2,"['Simpl', 'simpl']","['SimpleTemplateNameSpecifier', 'simply']"
Usability,// TODO: Check if it is possible to instead only added the min/max facts; // when simplifying uses of the min/max intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:82,simpl,simplifying,82,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,1,['simpl'],['simplifying']
Usability,"// TODO: Conservatively intersecting FMF. If Res == C2, the transform; // was a simplification (so Arg0 and its original flags could; // propagate?)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:80,simpl,simplification,80,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['simpl'],['simplification']
Usability,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:87,guid,guides,87,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,"['guid', 'simpl']","['guides', 'simply']"
Usability,// TODO: Even if the callee is not known now we might be able to simplify; // the call/callee.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:65,simpl,simplify,65,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['simpl'],['simplify']
Usability,// TODO: Fix base implementation which could simplify things a bit here; // (seems to miss on differentiating on scalar/vector types).; // Only 64 bit vector conversions are natively supported before z15.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:45,simpl,simplify,45,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,1,['simpl'],['simplify']
Usability,// TODO: For now just pretend it cannot be simplified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:43,simpl,simplified,43,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simplified']
Usability,// TODO: Further simplifications are possible; // 1. Replace inductions with constants.; // 2. Replace vector loop region with VPBasicBlock.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:17,simpl,simplifications,17,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,1,['simpl'],['simplifications']
Usability,// TODO: Ideally we should share Inliner's InlineCost Analysis code.; // For now use a simplified version. The returned 'InlineCost' will be used; // to esimate the size cost as well as runtime cost of the BB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:87,simpl,simplified,87,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,1,['simpl'],['simplified']
Usability,"// TODO: If OrICmp is true, then the definition of xor simplifies to !(X&Y).; // TODO: If OrICmp is false, the whole thing is false (InstSimplify?).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:55,simpl,simplifies,55,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['simpl'],['simplifies']
Usability,"// TODO: Improve estimate of operations needed for transposes. Currently we; // just count the insertelement/extractelement instructions, but do not; // account for later simplifications/combines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:171,simpl,simplifications,171,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['simpl'],['simplifications']
Usability,"// TODO: Is it not clear what situation we are checking for by checking if; // the unique_ptr class has any data members.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/rootpcm/src/rootclingIO.cxx:19,clear,clear,19,io/rootpcm/src/rootclingIO.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/rootpcm/src/rootclingIO.cxx,1,['clear'],['clear']
Usability,"// TODO: Is this true? kill flag appears to work OK below; // Register kill flags have been cleared by the time we get to this; // pass, but it is safe to assume that all uses of this register; // occur in the same basic block as its definition, because; // it is illegal for the scheduler to schedule them in; // different blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600EmitClauseMarkers.cpp:92,clear,cleared,92,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600EmitClauseMarkers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600EmitClauseMarkers.cpp,1,['clear'],['cleared']
Usability,// TODO: It is not clear whether comparing parameters is necessary (i.e.; // different functions with same params). Consider removing this (as no test; // fail w/o it).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:19,clear,clear,19,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['clear'],['clear']
Usability,"// TODO: It may be possible to actually avoid the copy.; // If we repair something where the source is defined by a copy; // and the source of that copy is on the right bank, we can reuse; // it for free.; // E.g.,; // RegToRepair<BankA> = copy AlternativeSrc<BankB>; // = op RegToRepair<BankA>; // We can simply propagate AlternativeSrc instead of copying RegToRepair; // into a new virtual register.; // We would also need to propagate this information in the; // repairing placement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:306,simpl,simply,306,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['simpl'],['simply']
Usability,"// TODO: Lots more we could do here:; // If V is a phi node, we can call this on each of its operands.; // ""select cond, X, 0"" can simplify to ""X"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:131,simpl,simplify,131,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['simpl'],['simplify']
Usability,"// TODO: Make this interface user-friendly.; // The interface here is bad, and we'll want to change this in the future. We; // probably will want to build out these mask vectors as vectors of bools and; // have this utility object convert them to the bit masks. I don't want to; // over-engineer this API now since we don't know what the data coming in to; // feed it will look like, so I kept it extremely simple for the immediate use; // case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/DXContainerPSVInfo.h:29,user-friendly,user-friendly,29,interpreter/llvm-project/llvm/include/llvm/MC/DXContainerPSVInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/DXContainerPSVInfo.h,2,"['simpl', 'user-friendly']","['simple', 'user-friendly']"
Usability,// TODO: Maybe simplify generation of the type of the fields.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:15,simpl,simplify,15,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,1,['simpl'],['simplify']
Usability,// TODO: More simplifications are possible here.; // Recursively simplify until we either hit a recursion limit or nothing; // changes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:14,simpl,simplifications,14,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,2,['simpl'],"['simplifications', 'simplify']"
Usability,// TODO: Move setting of resume values to prepareToExecute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:25,resume,resume,25,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['resume'],['resume']
Usability,"// TODO: Pass in a guid-to-name map in order for; // ContextTracker.getFuncNameFor to work, if `Profiles` can have md5 codes; // as their profile context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/CSPreInliner.cpp:19,guid,guid-to-name,19,interpreter/llvm-project/llvm/tools/llvm-profgen/CSPreInliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/CSPreInliner.cpp,1,['guid'],['guid-to-name']
Usability,// TODO: Should this clear flags individually?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceInstructionFlagsMIR.cpp:21,clear,clear,21,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceInstructionFlagsMIR.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceInstructionFlagsMIR.cpp,1,['clear'],['clear']
Usability,// TODO: Should this try to use a scalar add pseudo if the base address; // is uniform and saddr is usable?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp:100,usab,usable,100,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,1,['usab'],['usable']
Usability,"// TODO: Should use maximum with source; // If a node is guaranteed to be aligned, set low zero bits accordingly as; // well as clearing one bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:128,clear,clearing,128,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,2,['clear'],['clearing']
Usability,"// TODO: Should we clear the kDeleteObject bit before writing?; // If we did we would have to remember the old value and; // put it back, we wouldn't want to forget that we owned; // something just because we got written to disk.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:19,clear,clear,19,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['clear'],['clear']
Usability,// TODO: Simple permutation looks like it could be almost as common as; // mutation due to commutative operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp:9,Simpl,Simple,9,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp,1,['Simpl'],['Simple']
Usability,// TODO: Simplify,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp:9,Simpl,Simplify,9,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp,1,['Simpl'],['Simplify']
Usability,// TODO: Simplify demanded bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPostLegalizerCombiner.cpp:9,Simpl,Simplify,9,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPostLegalizerCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPostLegalizerCombiner.cpp,1,['Simpl'],['Simplify']
Usability,// TODO: Simplify preds to not branch here if possible!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:9,Simpl,Simplify,9,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['Simpl'],['Simplify']
Usability,// TODO: That potentially might be compile-time expensive. We should try; // to fix the loop-simplified form incrementally.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:93,simpl,simplified,93,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,1,['simpl'],['simplified']
Usability,"// TODO: The ordering of the following SelectXXX is relatively...arbitrary,; // right now we simply sort them by descending complexity. Maybe we should; // adjust this by code model and/or relocation mode in the future.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp:93,simpl,simply,93,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,1,['simpl'],['simply']
Usability,"// TODO: The simple type check probably belongs in the default hook; // implementation and/or target-specific overrides (because; // non-simple types likely require masking when legalized), but; // that restriction may conflict with other transforms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:13,simpl,simple,13,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['simpl'],['simple']
Usability,"// TODO: The standard is not clear how to resolve two thread limit clauses,; // let's pick the teams one if it's present, otherwise the target one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:29,clear,clear,29,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['clear'],['clear']
Usability,"// TODO: There is also f64 rcp instruction, but the documentation is less; // clear on its precision.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:78,clear,clear,78,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['clear'],['clear']
Usability,"// TODO: There is also f64 rsq instruction, but the documentation is less; // clear on its precision.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:78,clear,clear,78,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['clear'],['clear']
Usability,// TODO: This can be generalized in two important ways:; // 1) We can allow phi nodes in IfFalseBB and simply reuse all the input; // values from the PBI edge.; // 2) We can sink side effecting instructions into BI's fallthrough; // successor provided they doesn't contribute to computation of; // BI's condition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:103,simpl,simply,103,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['simpl'],['simply']
Usability,"// TODO: This code is very similar to findAffectedValues() in; // AssumptionCache, but currently specialized to just the patterns that; // computeKnownBits() supports, and without the notion of result elem indices; // that are AC specific. Deduplicate this code once we have a clearer picture; // of how much they can be shared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomConditionCache.cpp:277,clear,clearer,277,interpreter/llvm-project/llvm/lib/Analysis/DomConditionCache.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomConditionCache.cpp,1,['clear'],['clearer']
Usability,"// TODO: This is a poor/cheap way to determine dominance. Should we use a; // dominator tree (eg, from a SimplifyQuery) instead?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:105,Simpl,SimplifyQuery,105,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['Simpl'],['SimplifyQuery']
Usability,"// TODO: This is a specific form of a much more general pattern.; // We could detect a select with any binop identity constant, or we; // could use SimplifyBinOp to see if either arm of the select reduces.; // But that needs to be done carefully and/or while removing potential; // reverse canonicalizations as in InstCombiner::foldSelectIntoOp().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:148,Simpl,SimplifyBinOp,148,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['Simpl'],['SimplifyBinOp']
Usability,// TODO: This performs reassociative folds for FP ops. Some fraction of the; // functionality has been subsumed by simple pattern matching here and in; // InstSimplify. We should let a dedicated reassociation pass handle more; // complex pattern matching and remove this from InstCombine.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:115,simpl,simple,115,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['simpl'],['simple']
Usability,// TODO: This routine may be simplified if MD_prof used an enum instead of a; // string to differentiate the types of MD_prof nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ProfDataUtils.cpp:29,simpl,simplified,29,interpreter/llvm-project/llvm/lib/IR/ProfDataUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ProfDataUtils.cpp,1,['simpl'],['simplified']
Usability,// TODO: This seems really ugly. Simplify this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp:33,Simpl,Simplify,33,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp,1,['Simpl'],['Simplify']
Usability,// TODO: This should simplify VSELECT with non-zero constant condition using; // something like this (but check boolean contents to be complete?):,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:21,simpl,simplify,21,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['simpl'],['simplify']
Usability,// TODO: To support simple redirecting of the end of the body code that has; // multiple; introduce another auxiliary basic block like preheader and after.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:20,simpl,simple,20,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['simpl'],['simple']
Usability,// TODO: Track these as `FileEntryRef` to simplify the equality check below.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:42,simpl,simplify,42,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,1,['simpl'],['simplify']
Usability,// TODO: Use isNullOrNullSplat() to distinguish constants with undefs?; // TODO: Can we assert that both operands are not zeros (because that should; // get simplified at node creation time)?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:157,simpl,simplified,157,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplified']
Usability,"// TODO: We can do better for PHI nodes. In cases like this:; // ptr = phi(relocated_pointer, not_relocated_pointer); // statepoint(ptr); // We will return that stack slot for ptr is unknown. And later we might; // assign different stack slots for ptr and relocated_pointer. This limits; // llvm's ability to remove redundant stores.; // Unfortunately it's hard to accomplish in current infrastructure.; // We use this function to eliminate spill store completely, while; // in example we still need to emit store, but instead of any location; // we need to use special ""preferred"" location.; // TODO: handle simple updates. If a value is modified and the original; // value is no longer live, it would be nice to put the modified value in the; // same slot. This allows folding of the memory accesses for some; // instructions types (like an increment).; // statepoint (i); // i1 = i+1; // statepoint (i1); // However we need to be careful for cases like this:; // statepoint(i); // i1 = i+1; // statepoint(i, i1); // Here we want to reserve spill slot for 'i', but not for 'i+1'. If we just; // put handling of simple modifications in this function like it's done; // for bitcasts we might end up reserving i's slot for 'i+1' because order in; // which we visit values is unspecified.; // Don't know any information about this instruction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:609,simpl,simple,609,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,2,['simpl'],['simple']
Usability,// TODO: We can't mangle the result of a failed substitution. It's not clear; // whether we should be mangling the original form prior to any substitution; // instead. See https://lists.isocpp.org/core/2023/04/14118.php,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:71,clear,clear,71,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['clear'],['clear']
Usability,// TODO: We could enable the following two according to [0] but we haven't; // done an evaluation wrt. the performance implications.; // [0]; // https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#dynamic-global-memory-allocation-and-operations; //; // TLI.setAvailable(llvm::LibFunc_memcpy);; // TLI.setAvailable(llvm::LibFunc_memset);,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:193,guid,guide,193,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,1,['guid'],['guide']
Usability,// TODO: We could possibly avoid a 64-bit shift and use a simpler table if we; // knew only one mode was demanded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:58,simpl,simpler,58,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['simpl'],['simpler']
Usability,"// TODO: We could use simplifyInstruction here to fold PHINodes and; // SelectInsts. However, doing so requires to change the current; // dead-operand-tracking mechanism. For instance, suppose neither loading; // from %U nor %other traps. Then ""load (select undef, %U, %other)"" does not; // trap either. However, if we simply replace %U with undef using the; // current dead-operand-tracking mechanism, ""load (select undef, undef,; // %other)"" may trap because the select may return the first operand; // ""undef"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:22,simpl,simplifyInstruction,22,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,2,['simpl'],"['simplifyInstruction', 'simply']"
Usability,"// TODO: We might have proved that we can skip the last iteration for; // this check. In this case, we only want to check the condition on the; // pre-last iteration (MaxBECount - 1). However, there is a nasty; // corner case:; //; // for (i = len; i != 0; i--) { ... check (i ult X) ... }; //; // If we could not prove that len != 0, then we also could not prove that; // (len - 1) is not a UINT_MAX. If we simply query (len - 1), then; // OptimizeCond will likely not prove anything for it, even if it could; // prove the same fact for len.; //; // As a temporary solution, we query both last and pre-last iterations in; // hope that we will be able to prove triviality for at least one of; // them. We can stop querying MaxBECount for this case once SCEV; // understands that (MaxBECount - 1) will not overflow here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:408,simpl,simply,408,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['simpl'],['simply']
Usability,// TODO: We should avoid simplification duplication to begin with.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:25,simpl,simplification,25,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['simpl'],['simplification']
Usability,"// TODO: We should use an AA to create an (optimistic and callback; // call-aware) call graph. For now we stick to simple patterns that; // are less powerful, basically the worst fixpoint.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:115,simpl,simple,115,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['simpl'],['simple']
Usability,"// TODO: Would be nicer to use a lock upgrade strategy a-la TVirtualRWMutex; // but that is unfortunately not usable outside the already available ROOT mutexes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx:110,usab,usable,110,tree/dataframe/src/RDFUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFUtils.cxx,1,['usab'],['usable']
Usability,// TODO: clear line by line rather than all at once,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceModuleData.cpp:9,clear,clear,9,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceModuleData.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceModuleData.cpp,1,['clear'],['clear']
Usability,"// TODO: for now only allow consecutive strides of 1. We could support; // other strides as long as it is uniform, but let's keep it simple; // for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:133,simpl,simple,133,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,1,['simpl'],['simple']
Usability,"// TODO: handle e.g. store to alloca here - only worth doing if we extend; // to allow reload along used path as described below. Otherwise, this; // is simply a store to a dead allocation which will be removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:153,simpl,simply,153,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simply']
Usability,// TODO: handle not simple cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/GISel/X86CallLowering.cpp:20,simpl,simple,20,interpreter/llvm-project/llvm/lib/Target/X86/GISel/X86CallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/GISel/X86CallLowering.cpp,2,['simpl'],['simple']
Usability,"// TODO: handle slicing. This should be simpler than the memoryview; // case as there is no Python object holding the buffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/LowLevelViews.cxx:40,simpl,simpler,40,bindings/pyroot/cppyy/CPyCppyy/src/LowLevelViews.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/LowLevelViews.cxx,1,['simpl'],['simpler']
Usability,"// TODO: https://github.com/root-project/root/pull/12328 meenemen!; /// Fit a simple linear function, that starts in the negative. Triggers RooNaNPacker error handling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/TestStatistics/testLikelihoodGradientJob.cxx:78,simpl,simple,78,roofit/roofitcore/test/TestStatistics/testLikelihoodGradientJob.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/TestStatistics/testLikelihoodGradientJob.cxx,1,['simpl'],['simple']
Usability,// TODO: if selected member is simple data type - no need to make other checks - just break here,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:31,simpl,simple,31,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,"// TODO: m_QueriedLibraries.clear ?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:28,clear,clear,28,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,1,['clear'],['clear']
Usability,"// TODO: once the constraint manager is smart enough to handle non simplified; // symbolic expressions remove this function. Note that this can not be used in; // the constraint manager as is, since this does not handle overflows. It is; // safe to assume, however, that memory offsets will not overflow.; // NOTE: callers of this function need to be aware of the effects of overflows; // and signed<->unsigned conversions!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp:67,simpl,simplified,67,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,1,['simpl'],['simplified']
Usability,// TODO: see also imagemagick's C++ interface for RColor operations!; // https://www.imagemagick.org/api/magick++-classes.php; /** \class RColor; \ingroup GpadROOT7; \brief The color class; \author Axel Naumann <axel@cern.ch>; \author Sergey Linev <S.Linev@gsi.de>; \date 2017-09-26; \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome!; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RColor.hxx:392,Feedback,Feedback,392,graf2d/gpadv7/inc/ROOT/RColor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RColor.hxx,1,['Feedback'],['Feedback']
Usability,// TODO: simplify this once the macro is available in all OS levels.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp:9,simpl,simplify,9,interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,1,['simpl'],['simplify']
Usability,// TODO: simplify.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/HipStdPar/HipStdPar.cpp:9,simpl,simplify,9,interpreter/llvm-project/llvm/lib/Transforms/HipStdPar/HipStdPar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/HipStdPar/HipStdPar.cpp,1,['simpl'],['simplify']
Usability,"// TODO: something like PyMethod_Fini to clear up the free_list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx:41,clear,clear,41,bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,1,['clear'],['clear']
Usability,"// TODO: this simplification may be extended to any speculatable instruction,; // not just binops, and would possibly be handled better in FoldOpIntoSelect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:14,simpl,simplification,14,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplification']
Usability,// TODO: we could widen the smaller range and have this work; but for now we; // bail out to keep things simple.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:105,simpl,simple,105,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,2,['simpl'],['simple']
Usability,"// TODO:; // Implement similar hooks that can be used at other points during; // disassembly. Something along the following lines:; // - onBeforeInstructionDecode(); // - onAfterInstructionDecode(); // - onSymbolEnd(); // It should help move much of the target specific code from llvm-objdump to; // respective target disassemblers.; /// Suggest a distance to skip in a buffer of data to find the next; /// place to look for the start of an instruction. For example, if; /// all instructions have a fixed alignment, this might advance to; /// the next multiple of that alignment.; ///; /// If not overridden, the default is 1.; ///; /// \param Address - The address, in the memory space of region, of the; /// starting point (typically the first byte of something; /// that did not decode as a valid instruction at all).; /// \param Bytes - A reference to the actual bytes at Address. May be; /// needed in order to determine the width of an; /// unrecognized instruction (e.g. in Thumb this is a simple; /// consistent criterion that doesn't require knowing the; /// specific instruction). The caller can pass as much data; /// as they have available, and the function is required to; /// make a reasonable default choice if not enough data is; /// available to make a better one.; /// \return - A number of bytes to skip. Must always be greater than; /// zero. May be greater than the size of Bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCDisassembler/MCDisassembler.h:997,simpl,simple,997,interpreter/llvm-project/llvm/include/llvm/MC/MCDisassembler/MCDisassembler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCDisassembler/MCDisassembler.h,1,['simpl'],['simple']
Usability,// TODO; // This helps avoid infinite loop with SimplifyCondBranchToCondBranch which; // may undo the transform done here.; // TODO: There might be a more fine-grained solution to this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:48,Simpl,SimplifyCondBranchToCondBranch,48,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,2,"['Simpl', 'undo']","['SimplifyCondBranchToCondBranch', 'undo']"
Usability,"// TObject *select = gPad->GetSelected();; // if(!select) return;; // if (!select->InheritsFrom(TGraph::Class())) {gPad->SetUniqueID(0); return;}; // gPad->GetCanvas()->FeedbackMode(true);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode_interactive.cxx:169,Feedback,FeedbackMode,169,roofit/xroofit/src/xRooNode_interactive.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode_interactive.cxx,1,['Feedback'],['FeedbackMode']
Usability,// Tags can be simple keys.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp:15,simpl,simple,15,interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,1,['simpl'],['simple']
Usability,// Taint property gets lost if the variable is passed as a; // non-const pointer or reference to a function which is; // not inlined. For matching rules we want to preserve the taintedness.; // TODO: We should traverse all reachable memory regions via the; // escaping parameter. Instead of doing that we simply mark only the; // referred memory region as tainted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:305,simpl,simply,305,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,1,['simpl'],['simply']
Usability,"// Take a Value returned by simplification of Expression E/Instruction; // I, and see if it resulted in a simpler expression. If so, return; // that expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:28,simpl,simplification,28,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,2,['simpl'],"['simpler', 'simplification']"
Usability,// Target is accessible at EC when named in its declaring class.; // We can now hill-climb and simply check whether the declaring; // class is accessible as a base of the naming class. This is; // equivalent to checking the access of a notional public; // member with no instance context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:95,simpl,simply,95,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['simpl'],['simply']
Usability,"// Tarjan's SCC finding algorithm with Nuutila's improvements; // SCCIterator is actually fairly complex for the simple thing we want.; // It also wants to hand us SCC's that are unrelated to the phi node we ask; // about, and have us process them there or risk redoing work.; // Graph traits over a filter iterator also doesn't work that well here.; // This SCC finder is specialized to walk use-def chains, and only follows; // instructions,; // not generic values (arguments, etc).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:113,simpl,simple,113,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['simpl'],['simple']
Usability,"// Technical note:; //; // Most of these functions are identical, converting to Quaternions; // and then taking the simple distance between two Quaternions. This; // makes it tempting to use a template function (which could appear in; // each individual rotation header).; //; // However, then we would have to include Quaternion.h in this header,; // and by induction, each rotation class would depend on Quaternion, which; // would be undesirable.; // ----------------------------------------------------------------------; // Distance from Rotation3D",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/3DDistances.h:116,simpl,simple,116,math/genvector/inc/Math/GenVector/3DDistances.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/3DDistances.h,1,['simpl'],['simple']
Usability,"// Technically, we don't need to sort the dependency list to get determinism.; // Leaving these be will simply preserve the import order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:104,simpl,simply,104,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,1,['simpl'],['simply']
Usability,// Temporary map while building StackIds list. Clear when index is completely; // built via releaseTemporaryMemory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:47,Clear,Clear,47,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['Clear'],['Clear']
Usability,// Terminate the table with a final blank line to clearly delineate it from; // later dumps.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp:50,clear,clearly,50,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugLine.cpp,2,['clear'],['clearly']
Usability,"// Test if a bit is clear/set using a shifted-one mask:; // zext (icmp eq (and X, (1 << ShAmt)), 0) --> and (lshr (not X), ShAmt), 1; // zext (icmp ne (and X, (1 << ShAmt)), 0) --> and (lshr X, ShAmt), 1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:20,clear,clear,20,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['clear'],['clear']
Usability,"// Test if the trunc is the user of a select which is part of a; // minimum or maximum operation. If so, don't do any more simplification.; // Even simplifying demanded bits can break the canonical form of a; // min/max.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:123,simpl,simplification,123,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,2,['simpl'],"['simplification', 'simplifying']"
Usability,"// Test simple suppression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/test/testLogger.cxx:8,simpl,simple,8,core/foundation/test/testLogger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/test/testLogger.cxx,1,['simpl'],['simple']
Usability,"// Test src1 first, since we canonicalize simpler expressions to the RHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp:42,simpl,simpler,42,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/GISelKnownBits.cpp,2,['simpl'],['simpler']
Usability,// Test whether the high bit of the byte is clear.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:44,clear,clear,44,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['clear'],['clear']
Usability,"// Tests the merge method for 1D Histograms; // simple merge with histogram with same limits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx:48,simpl,simple,48,test/stressHistogram.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx,1,['simpl'],['simple']
Usability,"// Tests the merge method with differently labelled 2D Histograms; // This tests verify to perforl a merge using labels for the X axis and; // a numeric merge for the Y axis.; // Note: in case of underflow/overflow in x axis not clear how merge should proceed; // when merging with labels underflow/overflow will not be considered",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx:229,clear,clear,229,test/stressHistogram.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx,1,['clear'],['clear']
Usability,// That can fail in the somewhat crazy situation that we're; // type-checking a message send within the @interface declaration; // that declared the @property. But it's not clear that that's; // valuable to support.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:173,clear,clear,173,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,1,['clear'],['clear']
Usability,"// The ""CVTTP2SI"" instruction conveniently sets the sign bit if; // and only if the value was out of range. So we can use that; // as our indicator that we rather use ""Big"" instead of ""Small"".; //; // Use ""Small"" if ""IsOverflown"" has all bits cleared; // and ""0x80000000 | Big"" if all bits in ""IsOverflown"" are set.; // AVX1 can't use the signsplat masking for 256-bit vectors - we have to; // use the slightly slower blendv select instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:243,clear,cleared,243,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['clear'],['cleared']
Usability,"// The ""CVTTS2SI"" instruction conveniently sets the sign bit if; // and only if the value was out of range. So we can use that; // as our indicator that we rather use ""Big"" instead of ""Small"".; //; // Use ""Small"" if ""IsOverflown"" has all bits cleared; // and ""0x80000000 | Big"" if all bits in ""IsOverflown"" are set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:243,clear,cleared,243,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['clear'],['cleared']
Usability,"// The ""PrevBB"" is not yet updated to reflect current code layout, so,; // o. it may fall-through to a block without explicit ""goto"" instruction; // before layout, and no longer fall-through it after layout; or; // o. just opposite.; //; // analyzeBranch() may return erroneous value for FBB when these two; // situations take place. For the first scenario FBB is mistakenly set NULL;; // for the 2nd scenario, the FBB, which is expected to be NULL, is; // mistakenly pointing to ""*BI"".; // Thus, if the future change needs to use FBB before the layout is set, it; // has to correct FBB first by using the code similar to the following:; //; // if (!Cond.empty() && (!FBB || FBB == ChainBB)) {; // PrevBB->updateTerminator();; // Cond.clear();; // TBB = FBB = nullptr;; // if (TII->analyzeBranch(*PrevBB, TBB, FBB, Cond)) {; // // FIXME: This should never take place.; // TBB = FBB = nullptr;; // }; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:735,clear,clear,735,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['clear'],['clear']
Usability,"// The ""simple"" format is designed to be parsed by the; // layout-override testing code. There shouldn't be any external; // uses of this format --- when LLDB overrides a layout, it sets up; // the data structures directly --- so feel free to adjust this as; // you like as long as you also update the rudimentary parser for it; // in libFrontend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:8,simpl,simple,8,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['simpl'],['simple']
Usability,"// The 'any-bits-set' ('or' chain) pattern is simpler to match because the; // final ""and X, 1"" instruction must be the final op in the sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:46,simpl,simpler,46,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['simpl'],['simpler']
Usability,// The -disable-simplify-libcalls flag actually disables all builtin optzns.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp:16,simpl,simplify-libcalls,16,interpreter/llvm-project/llvm/tools/llc/llc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llc/llc.cpp,2,['simpl'],['simplify-libcalls']
Usability,// The <simple-id> and on <operator-name> productions end in an optional; // <template-args>.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:8,simpl,simple-id,8,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['simpl'],['simple-id']
Usability,// The ASTMatchRefactorer is re-used between translation units.; // Clear the matchers so that each Replacement is only emitted once.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp:68,Clear,Clear,68,interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/RefactoringCallbacks.cpp,1,['Clear'],['Clear']
Usability,// The Align and Offset of Resume function and Destroy function are fixed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:27,Resume,Resume,27,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['Resume'],['Resume']
Usability,// The AnalyzeCallOperands in the base class is not usable since we must; // provide a means of accessing ArgListEntry::IsFixed. Delete them from this; // class. This doesn't stop them being used via the base class though.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h:52,usab,usable,52,interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h,1,['usab'],['usable']
Usability,"// The CFG Simplifier pass may delete one of the basic blocks we are; // interested in. If it does we need to take the block out of the list. Make; // a ""persistent mapping"" by turning basic blocks into <function, name> pairs.; // This won't work well if blocks are unnamed, but that is just the risk we; // have to take. FIXME: Can we just name the blocks?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:11,Simpl,Simplifier,11,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['Simpl'],['Simplifier']
Usability,"// The CPPInstance::kNoMemReg by-passes the memory regulator; the assumption here is; // that objects in vectors are simple and thus do not need to maintain object identity; // (or at least not during the loop anyway). This gains 2x in performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CustomPyTypes.cxx:117,simpl,simple,117,bindings/pyroot/cppyy/CPyCppyy/src/CustomPyTypes.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CustomPyTypes.cxx,1,['simpl'],['simple']
Usability,"// The CallArg seems to have desugared the type already, so for clearer; // diagnostics, replace it with the type in the FunctionDecl if possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:64,clear,clearer,64,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['clear'],['clearer']
Usability,// The DW_AT_data_member_location attribute is a simple member offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVLocation.h:49,simpl,simple,49,interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVLocation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVLocation.h,1,['simpl'],['simple']
Usability,// The DominatorTree needs to be rebuilt by any consumers after this; // transformation. We simply reset here rather than setting the ModifiedDT; // flag to avoid restarting the function walk in runOnFunction for each; // select optimized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:92,simpl,simply,92,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['simpl'],['simply']
Usability,"// The Evaluator can look through pointer casts as long as alias; // analysis holds because it's just a simple interpreter and doesn't; // skip memory accesses due to invariant group metadata, but we can't; // let users of Evaluator use a value that's been gleaned looking; // through stripping pointer casts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:104,simpl,simple,104,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,1,['simpl'],['simple']
Usability,"// The GCC C EH and Rust personality only exists to support cleanups, so; // it's not clear what the semantics of catch clauses are.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:86,clear,clear,86,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['clear'],['clear']
Usability,// The GEP is different by more than one input. While this could be; // extended to support GEPs that vary by more than one variable it; // doesn't make sense since it greatly increases the complexity and; // would result in an R+R+R addressing mode which no backend; // directly supports and would need to be broken into several; // simpler instructions anyway.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:334,simpl,simpler,334,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simpler']
Usability,"// The HtmlTrace_Table4 flag causes tables to be draw with borders; // of 2, cellPadding of 5 and cell spacing of 2. This makes the; // table clearly visible. Useful for debugging. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx:142,clear,clearly,142,gui/guihtml/src/TGHtmlTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlTable.cxx,1,['clear'],['clearly']
Usability,"// The I constraint applies only to simple ADD or SUB immediate operands:; // i.e. 0 to 4095 with optional shift by 12; // The J constraint applies only to ADD or SUB immediates that would be; // valid when negated, i.e. if [an add pattern] were to be output as a SUB; // instruction [or vice versa], in other words -1 to -4095 with optional; // left shift by 12.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:36,simpl,simple,36,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['simpl'],['simple']
Usability,// The MinNumElts is simplified from equation:; // NumElts / VScale =; // (EltSize * NumElts / (VScale * RVVBitsPerBlock)); // * (RVVBitsPerBlock / EltSize),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/RISCV.cpp:21,simpl,simplified,21,interpreter/llvm-project/clang/lib/CodeGen/Targets/RISCV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/RISCV.cpp,1,['simpl'],['simplified']
Usability,// The O1 pipeline has a separate pipeline creation function to simplify; // construction readability.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:64,simpl,simplify,64,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['simpl'],['simplify']
Usability,// The RHS is simpler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:14,simpl,simpler,14,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['simpl'],['simpler']
Usability,"// The RooDataHit can be analytically integrated with the RooDataHist::sum(); // member functions. This functionality is used in the analytical; // integration capabilities of RooHistPdf and RooHistFunc. Therefore, to; // test these two classes at the same time, this tests validated; // RooDataHist::sum() via the RooHistPdf and RooHistFunc interfaces.; // The histograms for this example are kept simple such that one can easily; // calculate the expected values with a calculator.; // We first create an easy non-uniform histogram for the x variable so we; // can know what we expect as test results analytically. The histogram will; // have the following bins with contents:; // - bin1 [0.0, 1.0]: 3 counts (bin volume x counts = 3); // - bin2 [1.0, 3.0]: 1 count (bin volume x counts = 2); // - bin3 [3.0, 3.5]: 8 counts (bin volume x counts = 4)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataHist.cxx:399,simpl,simple,399,roofit/roofitcore/test/testRooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataHist.cxx,1,['simpl'],['simple']
Usability,"// The SIMD&FP variant of CLAST[AB] is significantly faster than the scalar; // integer variant across a variety of micro-architectures. Replace scalar; // integer CLAST[AB] intrinsic with optimal SIMD&FP variant. A simple; // bitcast-to-fp + clast[ab] + bitcast-to-int will cost a cycle or two more; // depending on the micro-architecture, but has been observed as generally; // being faster, particularly when the CLAST[AB] op is a loop-carried; // dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:216,simpl,simple,216,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['simpl'],['simple']
Usability,"// The TGTextEntry widget is a simple line editor for inputting text",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGTextEntry.h:31,simpl,simple,31,gui/gui/inc/TGTextEntry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGTextEntry.h,1,['simpl'],['simple']
Usability,"// The VECREDUCE result size may be larger than the element size, so; // we can simply change the result type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:80,simpl,simply,80,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['simpl'],['simply']
Usability,"// The VP_REDUCE result size may be larger than the element size, so we can; // simply change the result type. However the start value and result must be; // the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:80,simpl,simply,80,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['simpl'],['simply']
Usability,// The ValueInfo corresponding to the candidate. We save an index hash; // table lookup for each GUID by stashing this here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionImport.h:97,GUID,GUID,97,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionImport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionImport.h,1,['GUID'],['GUID']
Usability,"// The aggregate ops. Aggregates can either be in the heap or on the; // stack, but in either case, this is simply a field load. As a result,; // this is a defining definition of the base just like a load is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:108,simpl,simply,108,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['simpl'],['simply']
Usability,"// The algorithm for updating NRVO candidate is as follows:; // 1. All previous candidates become invalid because a new NRVO candidate is; // obtained. Therefore, we need to clear return slots for other; // variables defined before the current return statement in the current; // scope and in outer scopes.; // 2. Store the new candidate if its return slot is available. Otherwise,; // there is no NRVO candidate so far.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:174,clear,clear,174,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp,1,['clear'],['clear']
Usability,"// The algorithm here is quite simple: we add 2^(p-1), where p is the; // precision of our format, and then subtract it back off again. The choice; // of rounding modes for the addition/subtraction determines the rounding mode; // for our integral rounding as well.; // NOTE: When the input value is negative, we do subtraction followed by; // addition instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:31,simpl,simple,31,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['simpl'],['simple']
Usability,"// The algorithm is simple. Start at instructions that convert from the; // float to the int domain: fptoui, fptosi and fcmp. Walk up the def-use; // graph, using an equivalence datastructure to unify graphs that interfere.; //; // Mappable instructions are those with an integer corrollary that, given; // integer domain inputs, produce an integer output; fadd, for example.; //; // If a non-mappable instruction is seen, this entire def-use graph is marked; // as non-transformable. If we see an instruction that converts from the; // integer domain to FP domain (uitofp,sitofp), we terminate our walk.; /// The largest integer type worth dealing with.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp:20,simpl,simple,20,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Float2Int.cpp,1,['simpl'],['simple']
Usability,// The ambiguity resides in a simple-type-specifier/typename-specifier; // followed by a '('. The '(' could either be the start of:; //; // direct-declarator:; // '(' declarator ')'; //; // direct-abstract-declarator:; // '(' parameter-declaration-clause ')' cv-qualifier-seq[opt]; // exception-specification[opt]; // '(' abstract-declarator ')'; //; // or part of a function-style cast expression:; //; // simple-type-specifier '(' expression-list[opt] ')'; //; // simple-type-specifier:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:30,simpl,simple-type-specifier,30,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,3,['simpl'],['simple-type-specifier']
Usability,"// The argument is an input, so we can simply replace it with the overall; // argument value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:39,simpl,simply,39,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,1,['simpl'],['simply']
Usability,// The asm in a naked function may reasonably expect the argument registers; // and the return address register (if present) to be live. An inserted; // function call will clobber these registers. Simply skip naked functions for; // all targets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/EntryExitInstrumenter.cpp:197,Simpl,Simply,197,interpreter/llvm-project/llvm/lib/Transforms/Utils/EntryExitInstrumenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/EntryExitInstrumenter.cpp,1,['Simpl'],['Simply']
Usability,// The base phi insertion logic (for any safepoint) may have inserted new; // instructions which are now live at some safepoint. The simplest such; // example is:; // loop:; // phi a <-- will be a new base_phi here; // safepoint 1 <-- that needs to be live here; // gep a + 1; // safepoint 2; // br loop; // We insert some dummy calls after each safepoint to definitely hold live; // the base pointers which were identified for that safepoint. We'll then; // ask liveness for _every_ base inserted to see what is now live. Then we; // remove the dummy calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:133,simpl,simplest,133,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['simpl'],['simplest']
Usability,// The below is simplified from; //; // APInt CarryKnownZero = ~(PossibleSumZero ^ LHS.Zero ^ RHS.Zero);; // APInt CarryKnownOne = PossibleSumOne ^ LHS.One ^ RHS.One;; // APInt CarryUnknown = ~(CarryKnownZero | CarryKnownOne);; //; // APInt NeededToMaintainCarry =; // (CarryKnownZero & NeededToMaintainCarryZero) |; // (CarryKnownOne & NeededToMaintainCarryOne) |; // CarryUnknown;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:16,simpl,simplified,16,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,1,['simpl'],['simplified']
Usability,"// The below routines verify the correctness of the dominator tree relative to; // the CFG it's coming from. A tree is a dominator tree iff it has two; // properties, called the parent property and the sibling property. Tarjan; // and Lengauer prove (but don't explicitly name) the properties as part of; // the proofs in their 1972 paper, but the proofs are mostly part of proving; // things about semidominators and idoms, and some of them are simply asserted; // based on even earlier papers (see, e.g., lemma 2). Some papers refer to; // these properties as ""valid"" and ""co-valid"". See, e.g., ""Dominators,; // directed bipolar orders, and independent spanning trees"" by Loukas; // Georgiadis and Robert E. Tarjan, as well as ""Dominator Tree Verification; // and Vertex-Disjoint Paths "" by the same authors.; // A very simple and direct explanation of these properties can be found in; // ""An Experimental Study of Dynamic Dominators"", found at; // https://arxiv.org/abs/1604.02711; // The easiest way to think of the parent property is that it's a requirement; // of being a dominator. Let's just take immediate dominators. For PARENT to; // be an immediate dominator of CHILD, all paths in the CFG must go through; // PARENT before they hit CHILD. This implies that if you were to cut PARENT; // out of the CFG, there should be no paths to CHILD that are reachable. If; // there are, then you now have a path from PARENT to CHILD that goes around; // PARENT and still reaches CHILD, which by definition, means PARENT can't be; // a dominator of CHILD (let alone an immediate one).; // The sibling property is similar. It says that for each pair of sibling; // nodes in the dominator tree (LEFT and RIGHT) , they must not dominate each; // other. If sibling LEFT dominated sibling RIGHT, it means there are no; // paths in the CFG from sibling LEFT to sibling RIGHT that do not go through; // LEFT, and thus, LEFT is really an ancestor (in the dominator tree) of; // RIGHT, not a sibling.; // It i",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h:446,simpl,simply,446,interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,2,['simpl'],"['simple', 'simply']"
Usability,"// The bits cleared with RLDICL are [0, MBSrc).; // The bits cleared with RLDICR are (MEMI, 63].; // After the sequence, the bits cleared are:; // [0, MBSrc-SHMI) and (MEMI, 63).; //; // The bits cleared with RLDIC are [0, NewMB) and (63-NewSH, 63].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:12,clear,cleared,12,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,4,['clear'],['cleared']
Usability,// The block has now been cleared of all instructions except for; // a comparison and a conditional branch. SimplifyCFG may be able; // to fold it now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:26,clear,cleared,26,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,2,"['Simpl', 'clear']","['SimplifyCFG', 'cleared']"
Usability,"// The branch found with the simplest search approach was successful.; // We reset the state, we continue",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx:29,simpl,simplest,29,tree/treeplayer/src/TTreeReaderValue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx,1,['simpl'],['simplest']
Usability,// The branch node at l+1 is usable,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:29,usab,usable,29,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,1,['usab'],['usable']
Usability,// The branch should get simplified. Don't bother simplifying this condition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:25,simpl,simplified,25,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,2,['simpl'],"['simplified', 'simplifying']"
Usability,"// The buffered page sink maintains a copy of the RNTupleModel for the inner sink; replicate the changes there; // TODO(jalopezg): we should be able, in general, to simplify the buffered sink.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:165,simpl,simplify,165,tree/ntuple/v7/src/RPageSinkBuf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx,1,['simpl'],['simplify']
Usability,// The cache is cleared (in the above line) so we will have lost; // information about blocks we have already visited. We therefore must; // assume that the cache information is incomplete.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:16,clear,cleared,16,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,2,['clear'],['cleared']
Usability,"// The call to visitNonBranch could propagate the changes until a branch; // is actually visited. This could result in adding CFG edges to the flow; // queue. Since the queue won't be processed, clear it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp:195,clear,clear,195,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.cpp,1,['clear'],['clear']
Usability,"// The callback is used to clear the autoparsing caches.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:27,clear,clear,27,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,2,['clear'],['clear']
Usability,// The callee here is a parenthesized UnresolvedLookupExpr with; // no qualifier and should always get mangled as a <simple-id>; // anyway.; // <expression> ::= cl <expression>* E,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:117,simpl,simple-id,117,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['simpl'],['simple-id']
Usability,// The caller is what called check -- we are simply calling; // the close for it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:45,simpl,simply,45,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['simpl'],['simply']
Usability,"// The cast can be invalid, because SimplifiedValues contains results of SCEV; // analysis, which operates on integers (and, e.g., might convert i8* null to; // i32 0).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:36,Simpl,SimplifiedValues,36,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,1,['Simpl'],['SimplifiedValues']
Usability,"// The character is not safe, at least simple quoting needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:39,simpl,simple,39,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,1,['simpl'],['simple']
Usability,"// The choice of TRotation is arbitrary; it is a simple, existing class that inherits from TObject; // and is supported by RNTuple",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/rfield_class.cxx:49,simpl,simple,49,tree/ntuple/v7/test/rfield_class.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/rfield_class.cxx,1,['simpl'],['simple']
Usability,"// The clear() operation invalidates all the iterators, except the past-end; // iterators of list-like containers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp:7,clear,clear,7,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ContainerModeling.cpp,1,['clear'],['clear']
Usability,// The client should always call clear() so recycled arrays can be returned; // to the allocator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h:33,clear,clear,33,interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h,1,['clear'],['clear']
Usability,"// The clone was simplified, it's no longer a MemoryDef, look up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:17,simpl,simplified,17,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['simpl'],['simplified']
Usability,"// The clustering problem has the following characteristics:; // (A) - Low dimension (dimensions are typically proc resource units,; // typically < 10).; // (B) - Number of points : ~thousands (points are measurements of an MCInst); // (C) - Number of clusters: ~tens.; // (D) - The number of clusters is not known /a priory/.; // (E) - The amount of noise is relatively small.; // The problem is rather small. In terms of algorithms, (D) disqualifies; // k-means and makes algorithms such as DBSCAN[1] or OPTICS[2] more applicable.; //; // We've used DBSCAN here because it's simple to implement. This is a pretty; // straightforward and inefficient implementation of the pseudocode in [2].; //; // [1] https://en.wikipedia.org/wiki/DBSCAN; // [2] https://en.wikipedia.org/wiki/OPTICS_algorithm; // Finds the points at distance less than sqrt(EpsilonSquared) of Q (not; // including Q).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:577,simpl,simple,577,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,1,['simpl'],['simple']
Usability,// The condition can be modified by removePredecessor's PHI simplification; // logic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:60,simpl,simplification,60,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,1,['simpl'],['simplification']
Usability,"// The conditions under which each of the output operands should be [un]set; // can certainly be written much more concisely with just 3 if statements or; // ternary expressions. However, this provides a much clearer overview to the; // reader as to what is set for each <CROp, BROp, OpUsed> combination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:209,clear,clearer,209,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,1,['clear'],['clearer']
Usability,"// The conformance tag must be emitted first when serialised into an; // object file. Specifically, the addenda to the ARM ABI states that; // (2.3.7.4):; //; // ""To simplify recognition by consumers in the common case of claiming; // conformity for the whole file, this tag should be emitted first in a; // file-scope sub-subsection of the first public subsection of the; // attributes section.""; //; // So it is special-cased in this comparison predicate when the; // attributes are sorted in finishAttributeSection().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp:166,simpl,simplify,166,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFStreamer.cpp,1,['simpl'],['simplify']
Usability,// The constant islands pass can only really deal with alignment requests; // <= 4 bytes and cannot pad constants itself. Therefore we cannot promote; // any type wanting greater alignment requirements than 4 bytes. We also; // can only promote constants that are multiples of 4 bytes in size or; // are paddable to a multiple of 4. Currently we only try and pad constants; // that are strings for simplicity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:398,simpl,simplicity,398,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['simpl'],['simplicity']
Usability,"// The constant should never be 0 here, becasue multiplication by zero; // is simplified by the engine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp:78,simpl,simplified,78,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,1,['simpl'],['simplified']
Usability,"// The cost tables include both specific, custom (non-legal) src/dst type; // conversions and generic, legalized types. We test for customs first, before; // falling back to legalization.; // FIXME: Need a better design of the cost table to handle non-simple types of; // potential massive combinations (elem_num x src_type x dst_type).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:252,simpl,simple,252,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['simpl'],['simple']
Usability,"// The current ElementType can be a modifier, in which case we need to; // get the type being modified.; // If TypeIndex is not a simple type, check if we have a qualified type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp:130,simpl,simple,130,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,1,['simpl'],['simple']
Usability,"// The current approach to inline asm is that ""r"" constraints are expressed; // as local indices, rather than values on the operand stack. This simplifies; // using ""r"" as it eliminates the need to push and pop the values in a; // particular order, however it also makes it impossible to have an ""m""; // constraint. So we don't support it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp:144,simpl,simplifies,144,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp,1,['simpl'],['simplifies']
Usability,"// The debug location for the ""common"" instruction is the merged locations; // of all the commoned instructions. We start with the original location; // of the ""common"" instruction and iteratively merge each location in the; // loop below.; // This is an N-way merge, which will be inefficient if I0 is a CallInst.; // However, as N-way merge for CallInst is rare, so we use simplified API; // instead of using complex API for N-way merge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:375,simpl,simplified,375,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['simpl'],['simplified']
Usability,"// The debug location is an integral part of a debug info intrinsic; // and can't be separated from it or replaced. Instead of attempting; // to merge locations, simply hoist both copies of the intrinsic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:162,simpl,simply,162,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['simpl'],['simply']
Usability,"// The decl was found outside the C++ class, so only ObjC access checks; // apply. Those do not rely on NamingClass and BaseType, so we clear them; // out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:136,clear,clear,136,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['clear'],['clear']
Usability,"// The decode table is cleared for each top level decoder function. The; // predicates and decoders themselves, however, are shared across all; // decoders to give more opportunities for uniqueing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp:23,clear,cleared,23,interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,1,['clear'],['cleared']
Usability,"// The destination buffer must be empty as an invariant of the conversion; // function; but this function is sometimes called in a loop that passes in; // the same buffer, however. Simply clear it out so we can overwrite it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp:181,Simpl,Simply,181,interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsDriver/MSVCPaths.cpp,2,"['Simpl', 'clear']","['Simply', 'clear']"
Usability,"// The destination buffer must be empty as an invariant of the conversion; // function; but this function is sometimes called in a loop that passes; // in the same buffer, however. Simply clear it out so we can overwrite it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/PlatformWin.cpp:181,Simpl,Simply,181,interpreter/cling/lib/Utils/PlatformWin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/PlatformWin.cpp,2,"['Simpl', 'clear']","['Simply', 'clear']"
Usability,// The dispatch block for the end of the scope chain is a block that; // just resumes unwinding.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:78,resume,resumes,78,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,1,['resume'],['resumes']
Usability,"// The element inserted overwrites whatever was there, so the input demanded; // set is simpler than the output set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:88,simpl,simpler,88,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['simpl'],['simpler']
Usability,// The estimated cost of the unrolled form of the loop. We try to estimate; // this by simplifying as much as we can while computing the estimate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:87,simpl,simplifying,87,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['simpl'],['simplifying']
Usability,"// The example uses a non-lazy JIT for simplicity. Thus, looking up the main; // function will materialize all reachable code. It also triggers debug; // registration in the remote target process.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp:39,simpl,simplicity,39,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp,1,['simpl'],['simplicity']
Usability,"// The existing declaration isn't relevant to us; we're in a; // new scope, so clear out the previous declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:79,clear,clear,79,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['clear'],['clear']
Usability,"// The existing declaration isn't relevant to us; we're in a; // new scope, so clear out the previous declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp:79,clear,clear,79,interpreter/cling/lib/Interpreter/DeclExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp,1,['clear'],['clear']
Usability,"// The exit code of the process on windows is not meaningful as a; // signal, so simply pass in -1 as the signal into the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:81,simpl,simply,81,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,1,['simpl'],['simply']
Usability,"// The exporter might have messed with the content of the node; // before failing. That's why we clear it and only reset the name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/RooJSONFactoryWSTool.cxx:97,clear,clear,97,roofit/hs3/src/RooJSONFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/RooJSONFactoryWSTool.cxx,1,['clear'],['clear']
Usability,"// The fAddress and fObject data members are not persistent,; // therefore we do not own anything.; // Also clear the bit possibly set by the schema evolution.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:108,clear,clear,108,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['clear'],['clear']
Usability,"// The first time through the loop, ToSimplify is empty and we try to; // simplify all instructions. On later iterations, ToSimplify is not; // empty and we only bother simplifying instructions that are in it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp:74,simpl,simplify,74,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InstSimplifyPass.cpp,2,['simpl'],"['simplify', 'simplifying']"
Usability,"// The first token of the instruction is the mnemonic, which must be a; // simple string, not a $foo variable or a singleton register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:75,simpl,simple,75,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,1,['simpl'],['simple']
Usability,"// The flag is the sign bit, which on ARM64 is defined to be clear; // for global pointers. This is very ARM64-specific.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:61,clear,clear,61,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['clear'],['clear']
Usability,// The free list for a given array size is a simple singly linked list.; // We can't use iplist or Recycler here since those classes can't be copied.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h:45,simpl,simple,45,interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h,1,['simpl'],['simple']
Usability,// The function getSimpleVT only handles simple value types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:41,simpl,simple,41,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['simpl'],['simple']
Usability,"// The given argument wasn't iterable: simply forward to regular constructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx:39,simpl,simply,39,bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,3,['simpl'],['simply']
Usability,"// The given type may be something like <17 x i32>, which is not MVT,; // but can be represented as (non-simple) EVT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:105,simpl,simple,105,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['simpl'],['simple']
Usability,"// The goal of this pass is to enable more efficient code generation for; // operations on narrow types (i.e. types with < 32-bits) and this is a; // motivating IR code example:; //; // define hidden i32 @cmp(i8 zeroext) {; // %2 = add i8 %0, -49; // %3 = icmp ult i8 %2, 3; // ..; // }; //; // The issue here is that i8 is type-legalized to i32 because i8 is not a; // legal type. Thus, arithmetic is done in integer-precision, but then the; // byte value is masked out as follows:; //; // t19: i32 = add t4, Constant:i32<-49>; // t24: i32 = and t19, Constant:i32<255>; //; // Consequently, we generate code like this:; //; // subs r0, #49; // uxtb r1, r0; // cmp r1, #3; //; // This shows that masking out the byte value results in generation of; // the UXTB instruction. This is not optimal as r0 already contains the byte; // value we need, and so instead we can just generate:; //; // sub.w r1, r0, #49; // cmp r1, #3; //; // We achieve this by type promoting the IR to i32 like so for this example:; //; // define i32 @cmp(i8 zeroext %c) {; // %0 = zext i8 %c to i32; // %c.off = add i32 %0, -49; // %1 = icmp ult i32 %c.off, 3; // ..; // }; //; // For this to be valid and legal, we need to prove that the i32 add is; // producing the same value as the i8 addition, and that e.g. no overflow; // happens.; //; // A brief sketch of the algorithm and some terminology.; // We pattern match interesting IR patterns:; // - which have ""sources"": instructions producing narrow values (i8, i16), and; // - they have ""sinks"": instructions consuming these narrow values.; //; // We collect all instruction connecting sources and sinks in a worklist, so; // that we can mutate these instruction and perform type promotion when it is; // legal to do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:645,ux,uxtb,645,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,2,"['UX', 'ux']","['UXTB', 'uxtb']"
Usability,// The hi masked load has zero storage size. We therefore simply set it to; // the low masked load and rely on subsequent removal from the chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:58,simpl,simply,58,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['simpl'],['simply']
Usability,// The hi vp_load has zero storage size. We therefore simply set it to; // the low vp_load and rely on subsequent removal from the chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:54,simpl,simply,54,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['simpl'],['simply']
Usability,// The high vp_strided_load has zero storage size. We therefore simply set; // it to the low vp_strided_load and rely on subsequent removal from the; // chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:64,simpl,simply,64,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['simpl'],['simply']
Usability,"// The iOS ABI diverges from the standard in some cases, so for now don't; // try to simplify those calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:85,simpl,simplify,85,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,1,['simpl'],['simplify']
Usability,// The implicit model is simple: everything else is in the lambda class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h:25,simpl,simple,25,interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h,1,['simpl'],['simple']
Usability,"// The input IR must be in loop-simplify form, ensuring a single predecessor; // for exit blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp:32,simpl,simplify,32,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanHCFGBuilder.cpp,1,['simpl'],['simplify']
Usability,// The input must be a constantexpr. See if we can simplify this based on; // the bytes we are demanding. Only do this if the source and dest are an; // even multiple of a byte.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:51,simpl,simplify,51,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['simpl'],['simplify']
Usability,// The input register to the PHI has a subregister or it can't be; // constrained to the proper register class or it is undef:; // insert a COPY instead of simply replacing the output; // with the input.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp:156,simpl,simply,156,interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp,1,['simpl'],['simply']
Usability,"// The insert list is a prefix of the extract list; // We can simply remove the common indices from the extract and make it; // operate on the inserted value instead of the insertvalue result.; // i.e., replace; // %I = insertvalue { i32, { i32 } } %A, { i32 } { i32 42 }, 1; // %E = extractvalue { i32, { i32 } } %I, 1, 0; // with; // %E extractvalue { i32 } { i32 42 }, 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:62,simpl,simply,62,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simply']
Usability,// The insertion point instruction may have been deleted; clear it out; // so that the rewriter doesn't trip over it later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:58,clear,clear,58,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,1,['clear'],['clear']
Usability,"// The instruction has the form ""(A op' B) op C"". See if expanding it out; // to ""(A op C) op' (B op C)"" results in simplifications.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:116,simpl,simplifications,116,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplifications']
Usability,"// The instruction has the form ""A op (B op' C)"". See if expanding it out; // to ""(A op B) op' (A op C)"" results in simplifications.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:116,simpl,simplifications,116,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplifications']
Usability,// The instructions for these intrinsics are speced to zero upper bits not; // pass them through like other scalar intrinsics. So we shouldn't just; // use Arg0 if DemandedElts[0] is clear like we do for other intrinsics.; // Instead we should return a zero vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:183,clear,clear,183,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['clear'],['clear']
Usability,"// The integer coefficient of an individual addend is either 1 or -1,; // and we try to simplify at most 4 addends from neighboring at most; // two instructions. So the range of <IntVal> falls in [-4, 4]. APInt; // is overkill of this end.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:88,simpl,simplify,88,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['simpl'],['simplify']
Usability,"// The intention here is to find diamonds or triangles (see below) where each; // conditional block contains a store to the same address. Both of these; // stores are conditional, so they can't be unconditionally sunk. But it may; // be profitable to speculatively sink the stores into one merged store at the; // end, and predicate the merged store on the union of the two conditions of; // PBI and QBI.; //; // This can reduce the number of stores executed if both of the conditions are; // true, and can allow the blocks to become small enough to be if-converted.; // This optimization will also chain, so that ladders of test-and-set; // sequences can be if-converted away.; //; // We only deal with simple diamonds or triangles:; //; // PBI or PBI or a combination of the two; // / \ | \; // PTB PFB | PFB; // \ / | /; // QBI QBI; // / \ | \; // QTB QFB | QFB; // \ / | /; // PostBB PostBB; //; // We model triangles as a type of diamond with a nullptr ""true"" block.; // Triangles are canonicalized so that the fallthrough edge is represented by; // a true condition, as in the diagram above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:704,simpl,simple,704,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['simpl'],['simple']
Usability,"// The intrinsics only read one or two bits, clear the rest.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:45,clear,clear,45,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,1,['clear'],['clear']
Usability,"// The kept copy is eligible for auto-hiding (hidden visibility) if all; // copies were (i.e. they were all linkonce_odr global unnamed addr).; // If any copy is not (e.g. it was originally weak_odr), then the symbol; // must remain externally available (e.g. a weak_odr from an explicitly; // instantiated template). Additionally, if it is in the; // GUIDPreservedSymbols set, that means that it is visibile outside; // the summary (e.g. in a native object or a bitcode file without; // summary), and in that case we cannot hide it as it isn't possible to; // check all copies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:352,GUID,GUIDPreservedSymbols,352,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['GUID'],['GUIDPreservedSymbols']
Usability,// The lack of 'framework' keyword in a module declaration it's a simple; // mistake we can diagnose when the header exists within the proper; // framework style path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:66,simpl,simple,66,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,1,['simpl'],['simple']
Usability,// The lambda capture in a lambda's conversion-to-block-pointer is; // special; we'll simply emit it directly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:86,simpl,simply,86,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,1,['simpl'],['simply']
Usability,// The lane mask is simply the union of all sub-indices.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:20,simpl,simply,20,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['simpl'],['simply']
Usability,"// The language fp contract option FPM_FastHonorPragmas has the same effect; // as FPM_Fast in frontend. For simplicity, use FPM_Fast uniformly in; // frontend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h:109,simpl,simplicity,109,interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h,1,['simpl'],['simplicity']
Usability,// The last skipped range isn't actually skipped yet if it's truncated; // by the end of the preamble; we'll resume parsing after the preamble.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:109,resume,resume,109,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['resume'],['resume']
Usability,"// The list contains fHClone, so let's clear it first to avoid; // accessing deleted memory later [we 'could' have just removed; // fHClone from the list]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.h:39,clear,clear,39,hist/hist/src/TH1Merger.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.h,1,['clear'],['clear']
Usability,// The load must be used exclusively to store into other pointers for; // us to be able to arbitrarily pre-split it. The stores must also be; // simple to avoid changing semantics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:145,simpl,simple,145,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['simpl'],['simple']
Usability,"// The logic for summing over the histogram is borrowed from RooHistPdf with some differences:; //; // - a lambda function is used to inject the parameters for bin scaling into the RooDataHist::sum method; //; // - for simplicity, there is no check for the possibility of full-range integration with another overload of; // RooDataHist::sum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooParamHistFunc.cxx:219,simpl,simplicity,219,roofit/roofit/src/RooParamHistFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooParamHistFunc.cxx,1,['simpl'],['simplicity']
Usability,"// The loop flattening pass requires loops to be; // in simplified form, and also needs LCSSA. Running; // this pass will simplify all loops that contain inner loops,; // regardless of whether anything ends up being flattened.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:56,simpl,simplified,56,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,2,['simpl'],"['simplified', 'simplify']"
Usability,"// The low bits require touching in 3 cases:; // * A non-immediate value will always require both instructions.; // * An effectively imm13 value needs only an 'or' instruction.; // * Otherwise, an immediate that is not effectively imm13 requires the; // 'or' only if bits remain after clearing the 22 bits that 'sethi' set.; // If the low bits are known zeros, there's nothing to do.; // In the second case, and only in that case, must we NOT clear; // bits of the immediate value via the %lo() assembler function.; // Note also, the 'or' instruction doesn't mind a large value in the case; // where the operand to 'set' was 0xFFFFFzzz - it does exactly what you mean.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp:285,clear,clearing,285,interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/AsmParser/SparcAsmParser.cpp,2,['clear'],"['clear', 'clearing']"
Usability,// The map should be valid after clearing (at least empty).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp:33,clear,clearing,33,interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,1,['clear'],['clearing']
Usability,"// The mapping from OriginalId to GUID may return a GUID; // that corresponds to a static variable. Filter it out here.; // This can happen when; // 1) There is a call to a library function which is not defined; // in the index.; // 2) There is a static variable with the OriginalGUID identical; // to the GUID of the library function in 1);; // When this happens the static variable in 2) will be found,; // which needs to be filtered out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:34,GUID,GUID,34,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,3,['GUID'],['GUID']
Usability,"// The mapping from a method to a function involves reshuffling of self back; // into the list of arguments. However, the pythonized methods will then have; // to undo that shuffling, which is inefficient. This method is the same as; // the one for the instancemethod object, except for the shuffling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CustomPyTypes.cxx:163,undo,undo,163,bindings/pyroot/cppyy/CPyCppyy/src/CustomPyTypes.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CustomPyTypes.cxx,1,['undo'],['undo']
Usability,// The model learns to pick one of the mask == 1 interferences. This is the; // name of the output tensor. The contract with the model is that the output; // will be guaranteed to be to a mask == 1 position. Using a macro here to; // avoid 'not used' warnings (and keep cond compilation to a minimum),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:13,learn,learns,13,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,1,['learn'],['learns']
Usability,// The module unit which is in the same module with the current module; // unit is usable.; //; // FIXME: Here we judge if they are in the same module by comparing the; // string. Is there any better solution?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:83,usab,usable,83,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['usab'],['usable']
Usability,// The most simple case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:12,simpl,simple,12,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['simpl'],['simple']
Usability,"// The mul instructions wreak havock on our zero_reg R1. We need to clear it; // after the result has been evacuated. This is probably not the best way to do; // it, but it works for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:68,clear,clear,68,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,1,['clear'],['clear']
Usability,"// The new opcode will clear the other half of the GR64 reg, so; // cancel if that is live.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp:23,clear,clear,23,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp,1,['clear'],['clear']
Usability,"// The next-to-last t is the multiplicative inverse. However, we are; // interested in a positive inverse. Calculate a positive one from a negative; // one if necessary. A simple addition of the modulo suffices because; // abs(t[i]) is known to be less than *this/2 (see the link above).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:172,simpl,simple,172,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['simpl'],['simple']
Usability,"// The null value for ValueRefT. For LLVM IR and MIR, this is simply the; // default constructed value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericSSAContext.h:62,simpl,simply,62,interpreter/llvm-project/llvm/include/llvm/ADT/GenericSSAContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericSSAContext.h,1,['simpl'],['simply']
Usability,"// The number 1 in the ""simplex"" array is at the second smallest coordinate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs:24,simpl,simplex,24,js/modules/three_addons.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs,1,['simpl'],['simplex']
Usability,"// The number 2 in the ""simplex"" array is at the second largest coordinate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs:24,simpl,simplex,24,js/modules/three_addons.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs,1,['simpl'],['simplex']
Usability,// The number of blocks which comprise the directory is a simple function of; // the number of bytes it contains.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/MSF/MSFCommon.cpp:58,simpl,simple,58,interpreter/llvm-project/llvm/lib/DebugInfo/MSF/MSFCommon.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/MSF/MSFCommon.cpp,1,['simpl'],['simple']
Usability,"// The number of uOps for load / store multiple are determined by the number; // registers.; //; // On Cortex-A8, each pair of register loads / stores can be scheduled on the; // same cycle. The scheduling for the first load / store must be done; // separately by assuming the address is not 64-bit aligned.; //; // On Cortex-A9, the formula is simply (#reg / 2) + (#reg % 2). If the address; // is not 64-bit aligned, then AGU would take an extra cycle. For VFP / NEON; // load / store multiple, the formula is (#reg / 2) + (#reg % 2) + 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:345,simpl,simply,345,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['simpl'],['simply']
Usability,"// The object is not usable in constant expressions, so we can't inspect; // its value to see if it's in-lifetime or what the active union members; // are. We can still check for a one-past-the-end lvalue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:21,usab,usable,21,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['usab'],['usable']
Usability,"// The obvious transform is to shift the switch condition right and emit a; // check that the condition actually cleanly divided by GCD, i.e.; // C & (1 << Shift - 1) == 0; // inserting a new CFG edge to handle the case where it didn't divide cleanly.; //; // A cheaper way of doing this is a simple ROTR(C, Shift). This performs the; // shift and puts the shifted-off bits in the uppermost bits. If any of these; // are nonzero then the switch condition will be very large and will hit the; // default case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:293,simpl,simple,293,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['simpl'],['simple']
Usability,"// The offset doesn't fit, but we may be able to put some of the offset into; // the ldr to simplify the generation of the rest of it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp:92,simpl,simplify,92,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,1,['simpl'],['simplify']
Usability,"// The old exiting block of the first loop (FC0) has to jump to the header; // of the second as we need to execute the code in the second header block; // regardless of the trip count. That is, if the trip count is 0, so the; // back edge is never taken, we still have to execute both loop headers,; // especially (but not only!) if the second is a do-while style loop.; // However, doing so might invalidate the phi nodes of the first loop as; // the new values do only need to dominate their latch and not the exiting; // predicate. To remedy this potential problem we always introduce phi; // nodes in the header of the second loop later that select the loop carried; // value, if the second header was reached through an old latch of the; // first, or undef otherwise. This is sound as exiting the first implies the; // second will exit too, __without__ taking the back-edge. [Their; // trip-counts are equal after all.; // KB: Would this sequence be simpler to just make FC0.ExitingBlock go; // to FC1.Header? I think this is basically what the three sequences are; // trying to accomplish; however, doing this directly in the CFG may mean; // the DT/PDT becomes invalid",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:955,simpl,simpler,955,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['simpl'],['simpler']
Usability,"// The only instances of MetadataInfo are the constants above, so a set of; // them may simply store pointers to them. To deterministically generate code,; // we need to use a set with stable iteration order, such as SetVector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:88,simpl,simply,88,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,1,['simpl'],['simply']
Usability,"// The only new-placement list we support is of the form (std::nothrow).; //; // FIXME: There is no restriction on this, but it's not clear that any; // other form makes any sense. We get here for cases such as:; //; // new (std::align_val_t{N}) X(int); //; // (which should presumably be valid only if N is a multiple of; // alignof(int), and in any case can't be deallocated unless N is; // alignof(X) and X has new-extended alignment).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:134,clear,clear,134,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['clear'],['clear']
Usability,// The only possible non-loop header predecessor is the preheader because; // we know we cloned the loop in simplified form.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:108,simpl,simplified,108,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['simpl'],['simplified']
Usability,// The only way LessRecordRegister can return equal is if they're the same; // string. Use simple equality instead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp:91,simpl,simple,91,interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/RegisterInfoEmitter.cpp,1,['simpl'],['simple']
Usability,"// The only way a segment should move is if a section was between two; // segments and that section was removed. If that section isn't in a segment; // then it's acceptable, but not ideal, to simply move it to after the; // segments. So we can simply layout segments one after the other accounting; // for alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp:192,simpl,simply,192,interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.cpp,2,['simpl'],['simply']
Usability,// The opcodes must be the same. Use a new name to make that clear.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:61,clear,clear,61,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['clear'],['clear']
Usability,"// The operand registers of the ""sunk"" instruction have their live range; // extended and their kill flags may no longer be correct. Conservatively; // clear the kill flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:152,clear,clear,152,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['clear'],['clear']
Usability,// The pattern we're looking for is where our only predecessor is a switch on; // 'V' and this block is the default case for the switch. In this case we can; // fold the compared value into the switch to simplify things.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:204,simpl,simplify,204,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['simpl'],['simplify']
Usability,"// The placement calculation is somewhat simple right now: it finds a; // single location for the def that dominates all refs. Since this may; // place the def far from the uses, producing several locations for; // defs that collectively dominate all refs could be better.; // For now only do the single one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:41,simpl,simple,41,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,1,['simpl'],['simple']
Usability,"// The po_iterator_storage template provides access to the set of already; // visited nodes during the po_iterator's depth-first traversal.; //; // The default implementation simply contains a set of visited nodes, while; // the External=true version uses a reference to an external set.; //; // It is possible to prune the depth-first traversal in several ways:; //; // - When providing an external set that already contains some graph nodes,; // those nodes won't be visited again. This is useful for restarting a; // post-order traversal on a graph with nodes that aren't dominated by a; // single node.; //; // - By providing a custom SetType class, unwanted graph nodes can be excluded; // by having the insert() function return false. This could for example; // confine a CFG traversal to blocks in a specific loop.; //; // - Finally, by specializing the po_iterator_storage template itself, graph; // edges can be pruned by returning false in the insertEdge() function. This; // could be used to remove loop back-edges from the CFG seen by po_iterator.; //; // A specialized po_iterator_storage class can observe both the pre-order and; // the post-order. The insertEdge() function is called in a pre-order, while; // the finishPostorder() function is called just before the po_iterator moves; // on to the next node.; /// Default po_iterator_storage implementation with an internal set object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PostOrderIterator.h:175,simpl,simply,175,interpreter/llvm-project/llvm/include/llvm/ADT/PostOrderIterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PostOrderIterator.h,1,['simpl'],['simply']
Usability,// The pointer loaded from the global can only be used in simple ways:; // we allow addressing of it and loading storing to it. We do *not* allow; // storing the loaded pointer somewhere else or passing to a function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:58,simpl,simple,58,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,1,['simpl'],['simple']
Usability,"// The postorder_ref_sccs range we are walking is lazily constructed, so; // we only push the first one onto the worklist. The worklist allows us; // to capture *new* RefSCCs created during transformations.; //; // We really want to form RefSCCs lazily because that makes them cheaper; // to update as the program is simplified and allows us to have greater; // cache locality as forming a RefSCC touches all the parts of all the; // functions within that RefSCC.; //; // We also eagerly increment the iterator to the next position because; // the CGSCC passes below may delete the current RefSCC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:317,simpl,simplified,317,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,1,['simpl'],['simplified']
Usability,"// The presence of the following lane-sensitive operations in a; // web will kill the optimization, at least for now. For these; // we do nothing, causing the optimization to fail.; // FIXME: Some of these could be permitted with special handling,; // and will be phased in as time permits.; // FIXME: There is no simple and maintainable way to express a set; // of opcodes having a common attribute in TableGen. Should this; // change, this is a prime candidate to use such a mechanism.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:314,simpl,simple,314,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,1,['simpl'],['simple']
Usability,// The previous token does not open a block. Nothing to do. We don't; // assert so that we can simply call this function for all tokens.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:95,simpl,simply,95,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,1,['simpl'],['simply']
Usability,"// The properties are stated in ""positive"" form; i.e. a pass could require; // that the property hold, but not that it does not hold.; // Property descriptions:; // IsSSA: True when the machine function is in SSA form and virtual registers; // have a single def.; // NoPHIs: The machine function does not contain any PHI instruction.; // TracksLiveness: True when tracking register liveness accurately.; // While this property is set, register liveness information in basic block; // live-in lists and machine instruction operands (e.g. implicit defs) is; // accurate, kill flags are conservatively accurate (kill flag correctly; // indicates the last use of a register, an operand without kill flag may or; // may not be the last use of a register). This means it can be used to; // change the code in ways that affect the values in registers, for example; // by the register scavenger.; // When this property is cleared at a very late time, liveness is no longer; // reliable.; // NoVRegs: The machine function does not use any virtual registers.; // Legalized: In GlobalISel: the MachineLegalizer ran and all pre-isel generic; // instructions have been legalized; i.e., all instructions are now one of:; // - generic and always legal (e.g., COPY); // - target-specific; // - legal pre-isel generic instructions.; // RegBankSelected: In GlobalISel: the RegBankSelect pass ran and all generic; // virtual registers have been assigned to a register bank.; // Selected: In GlobalISel: the InstructionSelect pass ran and all pre-isel; // generic instructions have been eliminated; i.e., all instructions are now; // target-specific or non-pre-isel generic instructions (e.g., COPY).; // Since only pre-isel generic instructions can have generic virtual register; // operands, this also means that all generic virtual registers have been; // constrained to virtual registers (assigned to register classes) and that; // all sizes attached to them have been eliminated.; // TiedOpsRewritten: The twoaddress",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:914,clear,cleared,914,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['clear'],['cleared']
Usability,"// The pseudo_probe_desc section has a format like:; // .section .pseudo_probe_desc,"""",@progbits; // .quad -5182264717993193164 // GUID; // .quad 4294967295 // Hash; // .uleb 3 // Name size; // .ascii ""foo"" // Name; // .quad -2624081020897602054; // .quad 174696971957; // .uleb 34; // .ascii ""main""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:131,GUID,GUID,131,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,1,['GUID'],['GUID']
Usability,"// The raw CompoundVal is essentially a symbolic InitListExpr: an (immutable); // list of other values. It appears pretty much only when there's an actual; // initializer list expression in the program, and the analyzer tries to; // unwrap it as soon as possible.; // This code is where such unwrap happens: when the compound value is put into; // the object that it was supposed to initialize (it's an *initializer* list,; // after all), instead of binding the whole value to the whole object, we bind; // sub-values to sub-objects. Sub-values may themselves be compound values,; // and in this case the procedure becomes recursive.; // FIXME: The annoying part about compound values is that they don't carry; // any sort of information about which value corresponds to which sub-object.; // It's simply a list of values in the middle of nowhere; we expect to match; // them to sub-objects, essentially, ""by index"": first value binds to; // the first field, second value binds to the second field, etc.; // It would have been much safer to organize non-lazy compound values as; // a mapping from fields/bases to values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:798,simpl,simply,798,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,1,['simpl'],['simply']
Usability,"// The re-extended constant changed, partly changed (in the case of a vector),; // or could not be determined to be equal (in the case of a constant; // expression), so the constant cannot be represented in the shorter type.; // All the cases that fold to true or false will have already been handled; // by simplifyICmpInst, so only deal with the tricky case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:308,simpl,simplifyICmpInst,308,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['simpl'],['simplifyICmpInst']
Usability,"// The reason why we can't simply use the histFunc as an ""indirect proxy"" is; // the way HistFactory is implemented. The same RooBinWidthFunction is used; // for all samples (e.g. signal and backgrounds), but uses the RooHistFunc; // of only one of the samples (this is okay because the binnings for all; // samples in the template histogram stack is the same). This entangling of; // the computation graph for the different samples messes up the component; // selection when plotting only some samples with; // `plotOn(..., RooFit::Components(...))`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinWidthFunction.cxx:27,simpl,simply,27,roofit/roofitcore/src/RooBinWidthFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinWidthFunction.cxx,1,['simpl'],['simply']
Usability,"// The recoloring attempt failed, undo the changes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:34,undo,undo,34,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,1,['undo'],['undo']
Usability,// The registers of the addressing mode may have their live range extended; // and their kill flags may no longer be correct. Conservatively clear the; // kill flags.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:141,clear,clear,141,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['clear'],['clear']
Usability,"// The relations we have to `Parent` do not apply to our template arguments,; // so clear them while visiting the args.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp:84,clear,clear,84,interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexTypeSourceInfo.cpp,1,['clear'],['clear']
Usability,// The renamer uses the Visited set to avoid infinite loops. Clear it now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:61,Clear,Clear,61,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['Clear'],['Clear']
Usability,// The resetState() method gets invoked at the beginning of each code region; // so that targets that override this function can clear any state that they; // have left from the previous code region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h:129,clear,clear,129,interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h,1,['clear'],['clear']
Usability,"// The resource id offset is computed as (<isa opaque base> + M0[21:16] +; // offset field) % 64. Some versions of the programming guide omit the m0; // part, or claim it's from offset 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp:131,guid,guide,131,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,1,['guid'],['guide']
Usability,// The rest are simple getters that hide the implementation.; // getDirection - Returns the direction associated with a particular level.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:16,simpl,simple,16,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['simpl'],['simple']
Usability,// The result may not be usable in case of previous compilation errors.; // In this case evaluation of the expression may result in crash so just; // don't do anything further with the result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,usab,usable,25,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['usab'],['usable']
Usability,"// The result value of the gc_result is simply the result of the actual; // call. We've already emitted this, so just grab the value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:40,simpl,simply,40,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,1,['simpl'],['simply']
Usability,// The resume must unwind the exception that caused control to branch here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:7,resume,resume,7,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['resume'],['resume']
Usability,// The return value is simply the value of the first parameter.; // We ignore the probability.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpBuiltin.cpp:23,simpl,simply,23,interpreter/llvm-project/clang/lib/AST/Interp/InterpBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpBuiltin.cpp,1,['simpl'],['simply']
Usability,"// The rules are:; // - If there are any pointer types in the chain, use an integer type.; // - Prefer an integer type if it appears in the chain.; // - Otherwise, use the first type in the chain.; //; // The rule about pointer types is a simplification when we merge e.g. a load; // of a ptr and a double. There's no direct conversion from a ptr to a; // double; it requires a ptrtoint followed by a bitcast.; //; // It's unclear to me if the other rules have any practical effect, but we do; // it to match this pass's previous behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:239,simpl,simplification,239,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['simpl'],['simplification']
Usability,"// The salient part of Clear is now 'duplicated in ExpandCreateFast (i.e. the; // setting to zero of the unused slots), so we no longer need to call Clear explicitly; // clones->Clear();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:23,Clear,Clear,23,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,3,['Clear'],['Clear']
Usability,"// The second and third condition can be potentially relaxed. Currently; // the conditions help to simplify the code and allow us to reuse existing; // code, developed for tryToUnfoldSelect(CmpInst *, BasicBlock *)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:99,simpl,simplify,99,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['simpl'],['simplify']
Usability,"// The set in which to record GUIDs exported from their module by; // devirtualization, used by client to ensure they are not internalized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:30,GUID,GUIDs,30,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['GUID'],['GUIDs']
Usability,// The shift constant is out-of-range? This code hasn't been simplified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:61,simpl,simplified,61,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['simpl'],['simplified']
Usability,"// The simple (Darwin, except on x86_64) way of dealing with this was to; // assume that any reference to a temporary symbol *must* be a temporary; // symbol in the same atom, unless the sections differ. Therefore, any PCrel; // relocation to a temporary symbol (in the same section) is fully; // resolved. This also works in conjunction with absolutized .set, which; // requires the compiler to use .set to absolutize the differences between; // symbols which the compiler knows to be assembly time constants, so we; // don't need to worry about considering symbol differences fully resolved.; //; // If the file isn't using sub-sections-via-symbols, we can make the; // same assumptions about any symbol that we normally make about; // assembler locals.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:7,simpl,simple,7,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,1,['simpl'],['simple']
Usability,// The simple and common case. This also includes constant expressions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:7,simpl,simple,7,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,1,['simpl'],['simple']
Usability,// The simple case:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:7,simpl,simple,7,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['simpl'],['simple']
Usability,// The simple case: deduce template arguments by matching Pi and Ai.; // Check whether we have enough arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:7,simpl,simple,7,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['simpl'],['simple']
Usability,// The simple nary expr will require one less op (or pair of ops); // than the number of it's terms.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:7,simpl,simple,7,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['simpl'],['simple']
Usability,"// The simple thing to do would be to just call getSCEV on both operands; // and call getAddExpr with the result. However if we're looking at a; // bunch of things all added together, this can be quite inefficient,; // because it leads to N-1 getAddExpr calls for N ultimate operands.; // Instead, gather up all the operands and make a single getAddExpr call.; // LLVM IR canonical form means we need only traverse the left operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:7,simpl,simple,7,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['simpl'],['simple']
Usability,"// The simplification queries below may return the original value. Consider:; // %div = udiv i32 %arg, %arg2; // %mul = mul nsw i32 %div, %arg2; // %cmp = icmp eq i32 %mul, %arg; // %sel = select i1 %cmp, i32 %div, i32 undef; // Replacing %arg by %mul, %div becomes ""udiv i32 %mul, %arg2"", which; // simplifies back to %arg. This can only happen because %mul does not; // dominate %div. To ensure a consistent return value contract, we make sure; // that this case returns nullptr as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:7,simpl,simplification,7,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,['simpl'],"['simplification', 'simplifies']"
Usability,"// The simplified symbol should be the member of the original Class,; // however, it might be in another existing class at the moment. We; // have to merge these classes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:7,simpl,simplified,7,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['simpl'],['simplified']
Usability,"// The source operand should be a <kill>. This is not strictly necessary,; // but it makes things a lot simpler. Otherwise, we would need to rename; // some registers, which would complicate the transformation considerably.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:104,simpl,simpler,104,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,1,['simpl'],['simpler']
Usability,"// The start of the instruction, usable with the reader",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86DisassemblerDecoder.h:33,usab,usable,33,interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86DisassemblerDecoder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86DisassemblerDecoder.h,1,['usab'],['usable']
Usability,"// The swapped GEPs are inbounds if both original GEPs are inbounds; // and the sign of the offsets is the same. For simplicity, only; // handle both offsets being non-negative.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:117,simpl,simplicity,117,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['simpl'],['simplicity']
Usability,"// The symmetry with Define is clear. We want to:; // - Create globally the alias and return this very node, unchanged; // - Make aliases accessible based on chains and not globally; // Helper to find out if a name is a column",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:31,clear,clear,31,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['clear'],['clear']
Usability,"// The syntax only allows a decomposition declarator as a simple-declaration,; // a for-range-declaration, or a condition in Clang, but we parse it in more; // cases than that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:58,simpl,simple-declaration,58,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['simpl'],['simple-declaration']
Usability,"// The target region is an outlined function launched by the runtime; // via calls to __tgt_target_kernel().; //; // Note that on the host and CPU targets, the runtime implementation of; // these calls simply call the outlined function without forking threads.; // The outlined functions themselves have runtime calls to; // __kmpc_fork_teams() and __kmpc_fork() for this purpose, codegen'd by; // the compiler in emitTeamsCall() and emitParallelCall().; //; // In contrast, on the NVPTX target, the implementation of; // __tgt_target_teams() launches a GPU kernel with the requested number; // of teams and threads so no additional calls to the runtime are required.; // Check the error code and execute the host version if required.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:202,simpl,simply,202,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['simpl'],['simply']
Usability,// The template-name in the simple-template-id refers to; // something other than a type template. Give an appropriate; // error message and skip to the ';'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:28,simpl,simple-template-id,28,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['simpl'],['simple-template-id']
Usability,"// The terminating null element shall not be part of the; // slice (main() behavior).; // This flag simply indicates that the program couldn't start, which isn't; // applicable here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Job.cpp:100,simpl,simply,100,interpreter/llvm-project/clang/lib/Driver/Job.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Job.cpp,1,['simpl'],['simply']
Usability,"// The thumb bit shouldn't be set in the 'other-half' bit of the; // relocation, but it will be set in FixedValue if the base symbol; // is a thumb function. Clear it out here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMachObjectWriter.cpp:158,Clear,Clear,158,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMachObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMachObjectWriter.cpp,1,['Clear'],['Clear']
Usability,"// The transform has determined that we should perform a simple; // transformation on the pack expansion, producing another pack; // expansion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:57,simpl,simple,57,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,4,['simpl'],['simple']
Usability,"// The transforms below here are expected to be handled more generally with; // simplifyAndOrOfICmpsWithLimitConst() or in InstCombine's; // foldAndOrOfICmpsWithConstEq(). If we are looking to trim optimizer overlap,; // these are candidates for removal.; // X < Y && Y != 0 --> X < Y; // X < Y || Y != 0 --> Y != 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:80,simpl,simplifyAndOrOfICmpsWithLimitConst,80,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifyAndOrOfICmpsWithLimitConst']
Usability,"// The type might not be legal for the target. This should only happen; // if the type is smaller than a legal type, as on PPC, so the right; // thing to do is generate a LoadExt/StoreTrunc pair. These simplify; // to Load/Store if NVT==VT.; // FIXME does the case above also need this?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:202,simpl,simplify,202,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['simpl'],['simplify']
Usability,"// The type we're converting from is a class type, enumerate its conversion; // functions.; // We can only enumerate the conversion functions for a complete type; if; // the type isn't complete, simply skip this step.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:195,simpl,simply,195,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['simpl'],['simply']
Usability,"// The unroller requires loops to be in simplified form, and also needs LCSSA.; // Since simplification may add new inner loops, it has to run before the; // legality and profitability checks. This means running the loop unroller; // will simplify all loops, regardless of whether anything end up being; // unrolled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:40,simpl,simplified,40,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,3,['simpl'],"['simplification', 'simplified', 'simplify']"
Usability,// The use may have been simplified to a constant already.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:25,simpl,simplified,25,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,1,['simpl'],['simplified']
Usability,"// The usual case is that tokens don't contain anything interesting. Skip; // over the uninteresting characters. If a token only consists of simple; // chars, this method is extremely fast.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:141,simpl,simple,141,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['simpl'],['simple']
Usability,"// The value that didn't simplify is ""UnsimplifiedLHS op UnsimplifiedRHS"".; // We already know that ""op"" is the same as for the simplified value. See; // if the operands match too. If so, return the simplified value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:25,simpl,simplify,25,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,3,['simpl'],"['simplified', 'simplify']"
Usability,// The values of weak variables are never usable in constant expressions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:42,usab,usable,42,interpreter/llvm-project/clang/lib/AST/Decl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp,1,['usab'],['usable']
Usability,"// The vector's size in bits is not a multiple of the target's byte size,; // so its layout is unspecified. For now, we'll simply treat these cases; // as unsupported (this should only be possible with OpenCL bool vectors; // whose element count isn't a multiple of the byte size).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:123,simpl,simply,123,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,2,['simpl'],['simply']
Usability,"// The vectorizer requires loops to be in simplified form.; // Since simplification may add new inner loops, it has to run before the; // legality and profitability checks. This means running the loop vectorizer; // will simplify all loops, regardless of whether anything end up being; // vectorized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:42,simpl,simplified,42,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,3,['simpl'],"['simplification', 'simplified', 'simplify']"
Usability,"// The version field isn't actually encoded in the file, but it is inferred by; // the size of data regions. We include it in the yaml because it simplifies; // the format.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjectYAML/DXContainerYAML.h:146,simpl,simplifies,146,interpreter/llvm-project/llvm/include/llvm/ObjectYAML/DXContainerYAML.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjectYAML/DXContainerYAML.h,1,['simpl'],['simplifies']
Usability,// The virtual inheritance model has a quirk: the virtual base table is always; // referenced when dereferencing a member pointer even if the member pointer; // is non-virtual. This is accounted for by adjusting the non-virtual offset; // to point backwards to the top of the MDC from the first VBase. Undo this; // adjustment to normalize the member pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:302,Undo,Undo,302,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['Undo'],['Undo']
Usability,// The visited state for the iteration is a simple set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BreadthFirstIterator.h:44,simpl,simple,44,interpreter/llvm-project/llvm/include/llvm/ADT/BreadthFirstIterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BreadthFirstIterator.h,1,['simpl'],['simple']
Usability,"// The visited stated for the iteration is a simple set augmented with; // one more method, completed, which is invoked when all children of a; // node have been processed. It is intended to distinguish of back and; // cross edges in the spanning tree but is not used in the common case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h:45,simpl,simple,45,interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h,1,['simpl'],['simple']
Usability,// The widening or narrowing is expected to be free.; // Counting widening or narrowing as a saved operation will result in; // preferring an R*SBG over a simple shift/logical instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:155,simpl,simple,155,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['simpl'],['simple']
Usability,// The worklist may have been cleared at this point. First; // check if it is empty before checking the last item.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:30,clear,cleared,30,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['clear'],['cleared']
Usability,"// Then, output the possibly-simplified expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:29,simpl,simplified,29,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['simpl'],['simplified']
Usability,"// There are 9 possible permutations of; // {S0IsUnsigned, S0IsSigned, S1IsUnsigned, S1IsSigned}; // In two permutations, the sign bits are known to be the same for both Ops,; // so simply return Signed / Unsigned corresponding to the MSB",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:182,simpl,simply,182,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['simpl'],['simply']
Usability,"// There are certain cases when normal C/C++ lookup (localUncachedLookup); // does not find AST nodes. E.g.:; // Example 1:; // template <class T>; // struct X {; // friend void foo(); // this is never found in the DC of the TU.; // };; // Example 2:; // // The fwd decl to Foo is not found in the lookupPtr of the DC of the; // // translation unit decl.; // // Here we could find the node by doing a traverse throught the list of; // // the Decls in the DC, but that would not scale.; // struct A { struct Foo *p; };; // This is a severe problem because the importer decides if it has to create a; // new Decl or not based on the lookup results.; // To overcome these cases we need an importer specific lookup table which; // holds every node and we are not interested in any C/C++ specific visibility; // considerations. Simply, we must know if there is an existing Decl in a; // given DC. Once we found it then we can handle any visibility related tasks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporterLookupTable.h:823,Simpl,Simply,823,interpreter/llvm-project/clang/include/clang/AST/ASTImporterLookupTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporterLookupTable.h,1,['Simpl'],['Simply']
Usability,"// There are many forms of this optimization we can handle, for now, just do; // the simple index into a single-dimensional array.; //; // Require: GEP GV, 0, i {{, constant indices}}",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:85,simpl,simple,85,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['simpl'],['simple']
Usability,"// There are multiple offsets at play in this function, so let's break it; // down. Starting with how variables may be stored in allocas:; //; // 1 Simplest case: variable is alloca sized and starts at offset 0.; // 2 Variable is larger than the alloca: the alloca holds just a part of it.; // 3 Variable is smaller than the alloca: the alloca may hold multiple; // variables.; //; // Imagine we have a store to the entire alloca. In case (3) the store; // affects bits outside of the bounds of each variable. In case (2), where; // the alloca holds the Xth bit to the Yth bit of a variable, the; // zero-offset store doesn't represent an assignment at offset zero to the; // variable. It is an assignment to offset X.; //; // # Example 1; // Obviously, not all stores are alloca-sized and have zero offset. Imagine; // the lower 32 bits of this store are dead and are going to be DSEd:; //; // store i64 %v, ptr %dest, !DIAssignID !1; // dbg.assign(..., !DIExpression(fragment, 128, 32), !1, %dest,; // !DIExpression(DW_OP_plus_uconst, 4)); //; // Goal: Given our dead bits at offset:0 size:32 for the store, determine the; // part of the variable, which fits in the fragment expressed by the; // dbg.assign, that has been killed, if any.; //; // calculateFragmentIntersect(..., SliceOffsetInBits=0,; // SliceSizeInBits=32, Dest=%dest, Assign=dbg.assign); //; // Drawing the store (s) in memory followed by the shortened version ($),; // then the dbg.assign (d), with the fragment information on a seperate scale; // underneath:; //; // Memory; // offset; // from; // dest 0 63; // | |; // s[######] - Original stores 64 bits to Dest.; // $----[##] - DSE says the lower 32 bits are dead, to be removed.; // d [##] - Assign's address-modifying expression adds 4 bytes to; // dest.; // Variable | |; // Fragment 128|; // Offsets 159; //; // The answer is achieved in a few steps:; // 1. Add the fragment offset to the store offset:; // SliceOffsetInBits:0 + VarFrag.OffsetInBits:128 = 128; //; // 2. Su",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:148,Simpl,Simplest,148,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,1,['Simpl'],['Simplest']
Usability,"// There are no tags for return type, the simplest case. Enter the function; // parameter scope before mangling the name, because a template using; // constrained `auto` can have references to its parameters within its; // template argument list:; //; // template<typename T> void f(T x, C<decltype(x)> auto); // ... is mangled as ...; // template<typename T, C<decltype(param 1)> U> void f(T, U)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:42,simpl,simplest,42,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['simpl'],['simplest']
Usability,"// There are only two legal forms of epilogue:; // - add SEHAllocationSize, %rsp; // - lea SEHAllocationSize(%FramePtr), %rsp; //; // 'mov %FramePtr, %rsp' will not be recognized as an epilogue sequence.; // However, we may use this sequence if we have a frame pointer because the; // effects of the prologue can safely be undone.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:323,undo,undone,323,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['undo'],['undone']
Usability,"// There are several ways we can dereference things, and several inputs; // to consider:; // * NRVO variables will appear with IsIndirect set, but should have; // nothing else in their DIExpressions,; // * Variables with DW_OP_stack_value in their expr already need an; // explicit dereference of the stack location,; // * Values that don't match the variable size need DW_OP_deref_size,; // * Everything else can just become a simple location expression.; // We need to use deref_size whenever there's a mismatch between the; // size of value and the size of variable portion being read.; // Additionally, we should use it whenever dealing with stack_value; // fragments, to avoid the consumer having to determine the deref size; // from DW_OP_piece.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:428,simpl,simple,428,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['simpl'],['simple']
Usability,"// There are some 32-bit instructions that always clear the high-order 32; // bits, there are also some instructions (like AND) that we can look; // through.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:50,clear,clear,50,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['clear'],['clear']
Usability,"// There are some cases where the user may set up a pointer in the (default); // constructor but not mark this pointer as transient. Sometime the value; // of this pointer is the address of one of the object with just created; // and the following delete would result in the deletion (possibly of the; // top level object we are goint to return!).; // Eventhough this is a user error, we could prevent the crash by simply; // adding:; // && !CheckObject(start[j],cl); // However this can increase the read time significantly (10% in the case; // of one TLine pointer in the test/Track and run ./Event 200 0 0 20 30000; //; // If ReadObjectAny returned the same value as we previous had, this means; // that when writing this object (start[j] had already been written and; // is indeed pointing to the same object as the object the user set up; // in the default constructor).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:415,simpl,simply,415,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,2,['simpl'],['simply']
Usability,"// There are three cases for the receiver:; // (1) it is definitely nil,; // (2) it is definitely non-nil, and; // (3) we don't know.; //; // If the receiver is definitely nil, we skip the pre/post callbacks and; // instead call the ObjCMessageNil callbacks and return.; //; // If the receiver is definitely non-nil, we call the pre- callbacks,; // evaluate the call, and call the post- callbacks.; //; // If we don't know, we drop the potential nil flow and instead; // continue from the assumed non-nil state as in (2). This approach; // intentionally drops coverage in order to prevent false alarms; // in the following scenario:; //; // id result = [o someMethod]; // if (result) {; // if (!o) {; // // <-- This program point should be unreachable because if o is nil; // // it must the case that result is nil as well.; // }; // }; //; // However, it also loses coverage of the nil path prematurely,; // leading to missed reports.; //; // It's possible to handle this by performing a state split on every call:; // explore the state where the receiver is non-nil, and independently; // explore the state where it's nil. But this is not only slow, but; // completely unwarranted. The mere presence of the message syntax in the code; // isn't sufficient evidence that nil is a realistic possibility.; //; // An ideal solution would be to add the following constraint that captures; // both possibilities without splitting the state:; //; // ($x == 0) => ($y == 0) (1); //; // where in our case '$x' is the receiver symbol, '$y' is the returned symbol,; // and '=>' is logical implication. But RangeConstraintManager can't handle; // such constraints yet, so for now we go with a simpler, more restrictive; // constraint: $x != 0, from which (1) follows as a vacuous truth.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp:1682,simpl,simpler,1682,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineObjC.cpp,1,['simpl'],['simpler']
Usability,"// There are two main parts to this algorithm:; // - identifying which spelled range covers the expanded tokens; // - validating that this range doesn't cover any extra tokens (First/Last); //; // We do these in order. However as we transform the expanded range into the; // spelled one, we adjust First/Last so the validation remains simple.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:335,simpl,simple,335,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,1,['simpl'],['simple']
Usability,"// There is a chance that we might need to update constraints for the; // classes that are known to be disequal to Class.; //; // In order for this to be even possible, the new constraint should; // be simply a constant because we can't reason about range disequalities.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:202,simpl,simply,202,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['simpl'],['simply']
Usability,"// There is a temptation to just call getAddExpr(this, getStepRecurrence(SE)),; // but in this case we cannot guarantee that the value returned will be an; // AddRec because SCEV does not have a fixed point where it stops; // simplification: it is legal to return ({rec1} + {rec2}). For example, it; // may happen if we reach arithmetic depth limit while simplifying. So we; // construct the returned value explicitly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:226,simpl,simplification,226,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,2,['simpl'],"['simplification', 'simplifying']"
Usability,"// There is no need to recompute _stateNames and _insertionOrder, as only defining new; // mappings has an effect on these. When the input category changes it shape, it is sufficient; // to clear the cached state mappings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMappedCategory.cxx:190,clear,clear,190,roofit/roofitcore/src/RooMappedCategory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMappedCategory.cxx,1,['clear'],['clear']
Usability,// There is no simple replacement for a saturating unsigned left shift that; // exceeds the scalar size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:15,simpl,simple,15,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['simpl'],['simple']
Usability,// There is nothing to simplify.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:23,simpl,simplify,23,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['simpl'],['simplify']
Usability,"// There might be more than two commutable operands, update BaseOp and; // continue scanning.; // FIXME: This assumes that the new instruction's operands are in the; // same positions and were simply swapped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:193,simpl,simply,193,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,1,['simpl'],['simply']
Usability,"// There's an undocumented extension that allows an integer to; // follow the name of the procedure which AFAICS is ignored by GAS.; // Example: .ent foo,2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:14,undo,undocumented,14,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['undo'],['undocumented']
Usability,"// There's no clear preference between forms 3. and 4., try both. Avoid; // forming getNotSCEV of pointer values as the resulting subtract is; // not legal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:14,clear,clear,14,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['clear'],['clear']
Usability,"// There's no way to express this expression in any of our supported; // languages, so just emit something terse and (hopefully) clear.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtPrinter.cpp:129,clear,clear,129,interpreter/llvm-project/clang/lib/AST/StmtPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtPrinter.cpp,1,['clear'],['clear']
Usability,// These API functions are known to NOT act as a CFRetain wrapper.; // They simply make a new object owned by the caller.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:76,simpl,simply,76,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,2,['simpl'],['simply']
Usability,"// These bitfields will only ever be set to something non-zero in operator=,; // when setting the -sve-tail-folding option. This option should always be of; // the form (default|simple|all|disable)[+(Flag1|Flag2|etc)], where here; // InitialBits is one of (disabled|all|simple). EnableBits represents; // additional flags we're enabling, and DisableBits for those flags we're; // disabling. The default flag is tracked in the variable NeedsDefault, since; // at the time of setting the option we may not know what the default value; // for the CPU is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:178,simpl,simple,178,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,2,['simpl'],['simple']
Usability,"// These calls return their argument verbatim, as a low-level; // optimization. However, this makes high-level optimizations; // harder. Undo any uses of this optimization that the front-end; // emitted here. We'll redo them in the contract pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:137,Undo,Undo,137,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,1,['Undo'],['Undo']
Usability,// These can all be promoted if neither operand has 'bits to clear'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:61,clear,clear,61,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['clear'],['clear']
Usability,"// These cases are generally not written to ignore the result of; // evaluating their sub-expressions, so we clear this now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:109,clear,clear,109,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['clear'],['clear']
Usability,// These helper functions return a SimplifyQuery structure that contains as; // many of the optional analysis we use as are currently valid. This is the; // strongly preferred way of constructing SimplifyQuery in passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:35,Simpl,SimplifyQuery,35,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,2,['Simpl'],['SimplifyQuery']
Usability,// These instructions clear the overflow flag just like TEST.; // FIXME: These are not the only instructions in this switch that clear the; // overflow flag.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:22,clear,clear,22,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,2,['clear'],['clear']
Usability,"// These intrinsics all take an i32 scalar operand which is narrowed to the; // size of a single lane of the vector type they return. So we don't need; // any bits of that operand above that point, which allows us to eliminate; // uxth/sxth.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:231,ux,uxth,231,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['ux'],['uxth']
Usability,"// These intrinsics only demand the 0th element of their input vectors. If; // we can simplify the input based on that, do so now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:86,simpl,simplify,86,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,2,['simpl'],['simplify']
Usability,"// These live sets may contain state Value pointers, since we replaced calls; // with operand bundles with calls wrapped in gc.statepoint, and some of; // those calls may have been def'ing live gc pointers. Clear these out to; // avoid accidentally using them.; //; // TODO: We should create a separate data structure that does not contain; // these live sets, and migrate to using that data structure from this point; // onward.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:207,Clear,Clear,207,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['Clear'],['Clear']
Usability,// These should be ordered in terms of increasing complexity to make the; // folders simpler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:85,simpl,simpler,85,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,1,['simpl'],['simpler']
Usability,// These simplifications apply to splat vectors as well.; // TODO: Handle more splat vector cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:9,simpl,simplifications,9,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['simpl'],['simplifications']
Usability,// These tables are sorted by their RegOp value allowing them to be binary; // searched at runtime without the need for additional storage. The enum values; // are currently emitted in X86GenInstrInfo.inc in alphabetical order. Which; // makes sorting these tables a simple matter of alphabetizing the table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp:267,simpl,simple,267,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp,1,['simpl'],['simple']
Usability,"// These tokens cannot come after the declarator-id in a; // simple-declaration, and are likely to come after a type-specifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:61,simpl,simple-declaration,61,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['simpl'],['simple-declaration']
Usability,"// These transforms have the potential to lose undef knowledge, so they are; // intentionally placed after SimplifyDemandedVectorElts().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:107,Simpl,SimplifyDemandedVectorElts,107,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['Simpl'],['SimplifyDemandedVectorElts']
Usability,"// These types are invariant across 32/64-bit ELF, so for simplicity just; // directly give them their exact sizes. We don't need to worry about; // endianness because these are just the types in the YAMLIO structures,; // and are appropriately converted to the necessary endianness when; // reading/generating binary object files.; // The naming of these types is intended to be ELF_PREFIX, where PREFIX is; // the common prefix of the respective constants. E.g. ELF_EM corresponds; // to the `e_machine` constants, like `EM_X86_64`.; // In the future, these would probably be better suited by C++11 enum; // class's with appropriate fixed underlying type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjectYAML/ELFYAML.h:58,simpl,simplicity,58,interpreter/llvm-project/llvm/include/llvm/ObjectYAML/ELFYAML.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjectYAML/ELFYAML.h,1,['simpl'],['simplicity']
Usability,"// Think all other usages may be an escaping candidate conservatively.; //; // Note that the major user of switch ABI coroutine (the C++) will store; // resume.fn, destroy.fn and the index to the coroutine frame immediately.; // So the parent of the coro.begin in C++ will be always escaping.; // Then we can't get any performance benefits for C++ by improving the; // precision of the method.; //; // The reason why we still judge it is we want to make LLVM Coroutine in; // switch ABIs to be self contained as much as possible instead of a; // by-product of C++20 Coroutines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp:153,resume,resume,153,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp,1,['resume'],['resume']
Usability,"// Third is Identity, because Second should rank us worse than any other; // conversion. This could also be ICK_Qualification, but it's simpler to just; // lump everything in with the second conversion, and we don't gain anything; // from making this ICK_Qualification.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:136,simpl,simpler,136,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['simpl'],['simpler']
Usability,// This PRNG is from the ISO C spec. It is intentionally simple and; // unsuitable for cryptographic use. We're just looking for enough; // variety to surprise and delight users.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp:57,simpl,simple,57,interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp,1,['simpl'],['simple']
Usability,// This SCEV does not seem to simplify: fail the division here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp:30,simpl,simplify,30,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp,1,['simpl'],['simplify']
Usability,"// This abstracts the logic for generating and updating S_WAIT* instructions; // away from the analysis that determines where they are needed. This was; // done because the set of counters and instructions for waiting on them; // underwent a major shift with gfx12, sufficiently so that having this; // abstraction allows the main analysis logic to be simpler than it would; // otherwise have had to become.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:352,simpl,simpler,352,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['simpl'],['simpler']
Usability,"// This causes the reference type flag to be cleared. Darwin 'as' was ""trying""; // to clear the weak reference and weak definition bits too, but the; // implementation was buggy. For now we just try to match 'as', for; // diffability.; //; // FIXME: Cleanup this code, these bits should be emitted based on semantic; // properties, not on the order of definition, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp:45,clear,cleared,45,interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp,2,['clear'],"['clear', 'cleared']"
Usability,// This change is needed for architectures with varying; // pointer widths. See the amdgcn opencl reproducer with; // this change as an example: solver-sym-simplification-ptr-bool.cl,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:156,simpl,simplification-ptr-bool,156,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,1,['simpl'],['simplification-ptr-bool']
Usability,"// This check is different to that in canSinkInstructions. There, we; // cared about the global view once simplifycfg (and instcombine) have; // completed - it takes into account PHIs that become trivially; // simplifiable. However here we need a more local view; if an operand; // differs we create a PHI and rely on instcombine to clean up the very; // small mess we may make.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:106,simpl,simplifycfg,106,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,2,['simpl'],"['simplifiable', 'simplifycfg']"
Usability,"// This check would be insufficient for operator overloads like; // ""operator>>"" - but for now Clang doesn't try to simplify them, so this; // is OK. Add more nuanced operator overload handling here if/when needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFTypePrinter.cpp:116,simpl,simplify,116,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFTypePrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFTypePrinter.cpp,1,['simpl'],['simplify']
Usability,"// This class is just a helper to be used in std::for_each to; // simplify the code later. It's just a definition of a method; // that will discern whether a Box is included into another one",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SparseData.cxx:66,simpl,simplify,66,math/mathcore/src/SparseData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/SparseData.cxx,1,['simpl'],['simplify']
Usability,// This class is used to build up a contiguous binary blob while keeping; // track of an offset in the output (which notionally begins at; // `InitialOffset`).; // The blob might be limited to an arbitrary size. All attempts to write data; // are ignored and the error condition is remembered once the limit is reached.; // Such an approach allows us to simplify the code by delaying error reporting; // and doing it at a convenient time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp:354,simpl,simplify,354,interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,1,['simpl'],['simplify']
Usability,"// This class is used to get an estimate of the optimization effects that we; // could get from complete loop unrolling. It comes from the fact that some; // loads might be replaced with concrete constant values and that could trigger; // a chain of instruction simplifications.; //; // E.g. we might have:; // int a[] = {0, 1, 0};; // v = 0;; // for (i = 0; i < 3; i ++); // v += b[i]*a[i];; // If we completely unroll the loop, we would get:; // v = b[0]*a[0] + b[1]*a[1] + b[2]*a[2]; // Which then will be simplified to:; // v = b[0]* 0 + b[1]* 1 + b[2]* 0; // And finally:; // v = b[1]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:262,simpl,simplifications,262,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,2,['simpl'],"['simplifications', 'simplified']"
Usability,"// This code lowers all pseudo-CMOV instructions. Generally it lowers these; // as described above, by inserting a MBB, and then making a PHI at the join; // point to select the true and false operands of the CMOV in the PHI.; //; // The code also handles two different cases of multiple CMOV opcodes; // in a row.; //; // Case 1:; // In this case, there are multiple CMOVs in a row, all which are based on; // the same condition setting (or the exact opposite condition setting).; // In this case we can lower all the CMOVs using a single inserted MBB, and; // then make a number of PHIs at the join point to model the CMOVs. The only; // trickiness here, is that in a case like:; //; // t2 = CMOV cond1 t1, f1; // t3 = CMOV cond1 t2, f2; //; // when rewriting this into PHIs, we have to perform some renaming on the; // temps since you cannot have a PHI operand refer to a PHI result earlier; // in the same block. The ""simple"" but wrong lowering would be:; //; // t2 = PHI t1(BB1), f1(BB2); // t3 = PHI t2(BB1), f2(BB2); //; // but clearly t2 is not defined in BB1, so that is incorrect. The proper; // renaming is to note that on the path through BB1, t2 is really just a; // copy of t1, and do that renaming, properly generating:; //; // t2 = PHI t1(BB1), f1(BB2); // t3 = PHI t1(BB1), f2(BB2); //; // Case 2, we lower cascaded CMOVs such as; //; // (CMOV (CMOV F, T, cc1), T, cc2); //; // to two successives branches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:922,simpl,simple,922,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,2,"['clear', 'simpl']","['clearly', 'simple']"
Usability,"// This combine needs to run after all reassociations/folds on pointer; // addressing have been done, specifically those that combine two G_PTR_ADDs; // with constant offsets into a single G_PTR_ADD with a combined offset.; // The goal of this optimization is to undo that combine in the case where; // doing so has prevented the formation of pair stores due to illegal; // addressing modes of STP. The reason that we do it here is because; // it's much easier to undo the transformation of a series consecutive; // mem ops, than it is to detect when doing it would be a bad idea looking; // at a single G_PTR_ADD in the reassociation/ptradd_immed_chain combine.; //; // An example:; // G_STORE %11:_(<2 x s64>), %base:_(p0) :: (store (<2 x s64>), align 1); // %off1:_(s64) = G_CONSTANT i64 4128; // %p1:_(p0) = G_PTR_ADD %0:_, %off1:_(s64); // G_STORE %11:_(<2 x s64>), %p1:_(p0) :: (store (<2 x s64>), align 1); // %off2:_(s64) = G_CONSTANT i64 4144; // %p2:_(p0) = G_PTR_ADD %0:_, %off2:_(s64); // G_STORE %11:_(<2 x s64>), %p2:_(p0) :: (store (<2 x s64>), align 1); // %off3:_(s64) = G_CONSTANT i64 4160; // %p3:_(p0) = G_PTR_ADD %0:_, %off3:_(s64); // G_STORE %11:_(<2 x s64>), %17:_(p0) :: (store (<2 x s64>), align 1)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp:263,undo,undo,263,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp,2,['undo'],['undo']
Usability,"// This could be something simple like ""int"" (in which case the declarator; // portion is empty), if an abstract-declarator is allowed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:27,simpl,simple,27,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['simpl'],['simple']
Usability,"// This doesn't work unless we're already learning; // Restore entry values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:42,learn,learning,42,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['learn'],['learning']
Usability,"// This effectively clears the undefined lazy bit, in Darwin 'as', although; // it isn't very consistent because it implements this as part of symbol; // lookup.; //; // FIXME: Cleanup this code, these bits should be emitted based on semantic; // properties, not on the order of definition, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp:20,clear,clears,20,interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCMachOStreamer.cpp,1,['clear'],['clears']
Usability,"// This expression tree simplified to something that isn't a tree,; // eliminate it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:24,simpl,simplified,24,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,2,['simpl'],['simplified']
Usability,"// This fake chunk is used by the other procedures so that they can; // pretend that there is a chunk with no chars in it, which makes; // the coding simpler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx:150,simpl,simpler,150,gui/gui/src/TGFont.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx,1,['simpl'],['simpler']
Usability,"// This fixes the case where type `T` is a parameter inside a function; // type (e.g. `std::function<void(T)>`) and the DeclContext of `T`; // becomes the translation unit. As a workaround, we simply use; // fully-qualified name here for all references whose `DeclContext` is; // the translation unit and ignore the possible existence of; // using-decls (in the global scope) that can shorten the replaced; // name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp:193,simpl,simply,193,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Rename/USRLocFinder.cpp,1,['simpl'],['simply']
Usability,"// This fixes what appears to be undocumented hardware behavior in SI where; // s_mov writing a descriptor and s_buffer_load_dword reading the descriptor; // needs some number of nops in between. We don't know how many we need, but; // let's use 4. This wasn't discovered before probably because the only; // case when this happens is when we expand a 64-bit pointer into a full; // descriptor and use s_buffer_load_dword instead of s_load_dword, which was; // probably never encountered in the closed-source land.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:33,undo,undocumented,33,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['undo'],['undocumented']
Usability,// This follows the naming guideline under riscv-c-api-doc to add the; // `__riscv_` suffix for all RVV intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:27,guid,guideline,27,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,1,['guid'],['guideline']
Usability,// This function canonicalizes the loop into Loop-Simplify and LCSSA forms.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:50,Simpl,Simplify,50,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,1,['Simpl'],['Simplify']
Usability,"// This function creates the IR intructions for loading and comparing using the; // given LoadSize. It loads the number of bytes specified by LoadSize from each; // source of the memcmp parameters. It then does a subtract to see if there was; // a difference in the loaded values. If a difference is found, it branches; // with an early exit to the ResultBlock for calculating which source was; // larger. Otherwise, it falls through to the either the next LoadCmpBlock or; // the EndBlock if this is the last LoadCmpBlock. Loading 1 byte is handled with; // a special case through emitLoadCompareByteBlock. The special handling can; // simply subtract the loaded values and add it to the result phi node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:637,simpl,simply,637,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,1,['simpl'],['simply']
Usability,"// This function decodes the contents of an SHT_RELR packed relocation; // section.; //; // Proposal for adding SHT_RELR sections to generic-abi is here:; // https://groups.google.com/forum/#!topic/generic-abi/bX460iggiKg; //; // The encoded sequence of Elf64_Relr entries in a SHT_RELR section looks; // like [ AAAAAAAA BBBBBBB1 BBBBBBB1 ... AAAAAAAA BBBBBB1 ... ]; //; // i.e. start with an address, followed by any number of bitmaps. The address; // entry encodes 1 relocation. The subsequent bitmap entries encode up to 63; // relocations each, at subsequent offsets following the last address entry.; //; // The bitmap entries must have 1 in the least significant bit. The assumption; // here is that an address cannot have 1 in lsb. Odd addresses are not; // supported.; //; // Excluding the least significant bit in the bitmap, each non-zero bit in; // the bitmap represents a relocation to be applied to a corresponding machine; // word that follows the base address word. The second least significant bit; // represents the machine word immediately following the initial address, and; // each bit that follows represents the next word, in linear order. As such,; // a single bitmap can encode up to 31 relocations in a 32-bit object, and; // 63 relocations in a 64-bit object.; //; // This encoding has a couple of interesting properties:; // 1. Looking at any entry, it is clear whether it's an address or a bitmap:; // even means address, odd means bitmap.; // 2. Just a simple list of addresses is a valid encoding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ELF.cpp:1383,clear,clear,1383,interpreter/llvm-project/llvm/lib/Object/ELF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ELF.cpp,2,"['clear', 'simpl']","['clear', 'simple']"
Usability,"// This function provides global ranking of operations so that we can place them; // in a canonical order. Note that rank alone is not necessarily enough for a; // complete ordering, as constants all have the same rank. However, generally,; // we will simplify an operation with all constants so that it doesn't matter; // what order they appear in.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:252,simpl,simplify,252,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['simpl'],['simplify']
Usability,"// This generates the new instruction that will replace the original Cmp; // Instruction. Instead of enumerating the various combinations when; // TrueWhenLessThan, TrueWhenEqual and TrueWhenGreaterThan are true versus; // false, we rely on chaining of ORs and future passes of InstCombine to; // simplify the OR further (i.e. a s< b || a == b becomes a s<= b).; // When none of the three constants satisfy the predicate for the RHS (C),; // the entire original Cmp can be simplified to a false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:297,simpl,simplify,297,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,2,['simpl'],"['simplified', 'simplify']"
Usability,"// This handles all of cast-expression, unary-expression, postfix-expression,; // and primary-expression. We handle them together like this for efficiency; // and to simplify handling of an expression starting with a '(' token: which; // may be one of a parenthesized expression, cast-expression, compound literal; // expression, or statement expression.; //; // If the parsed tokens consist of a primary-expression, the cases below; // break out of the switch; at the end we call ParsePostfixExpressionSuffix; // to handle the postfix expression suffixes. Cases that cannot be followed; // by postfix exprs should set AllowSuffix to false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:166,simpl,simplify,166,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['simpl'],['simplify']
Usability,"// This hoists/decomposes div/rem ops. It should run after other sink/hoist; // passes to avoid re-sinking, but before SimplifyCFG because it can allow; // flattening of blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:119,Simpl,SimplifyCFG,119,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,2,['Simpl'],['SimplifyCFG']
Usability,"// This index belongs to an existing fragment. Copy the elements of the; // old fragment into this one and clear the old fragment. We don't update; // the fragment map just yet, this ensures that any further references to; // indices from the old fragment in this fragment do not insert any more; // indices.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:107,clear,clear,107,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,1,['clear'],['clear']
Usability,"// This index stores the smallest object_id that contains the point; // only relevant if there are overlaps within the parallel world.; // We introduce this to make sure that the BVH traversal here, gives the same; // result as a simple loop iteration in increasing object_id order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:230,simpl,simple,230,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['simpl'],['simple']
Usability,// This instruction is not supported.; // Clear any other pending errors because they are no longer relevant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:42,Clear,Clear,42,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,1,['Clear'],['Clear']
Usability,// This instruction is not vectorized by simple widening.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:41,simpl,simple,41,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,1,['simpl'],['simple']
Usability,"// This is a bitvector because, on larger functions, we may have; // thousands of touched instructions at once (entire blocks,; // instructions with hundreds of uses, etc). Even with optimization; // for when we mark whole blocks as touched, when this was a; // SmallPtrSet or DenseSet, for some functions, we spent >20% of all; // the time in GVN just managing this list. The bitvector, on the; // other hand, efficiently supports test/set/clear of both; // individual and ranges, as well as ""find next element"" This; // enables us to use it as a worklist with essentially 0 cost.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:441,clear,clear,441,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['clear'],['clear']
Usability,// This is a hack around preserving template parameters for simplified; // template names - it should probably be replaced with a; // DICompositeType flag specifying whether template parameters are; // required on declarations of this type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:60,simpl,simplified,60,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,1,['simpl'],['simplified']
Usability,// This is a high-level transform that might change the constant arguments; // of the init and dinit calls. We need to tell the Attributor about this; // to avoid other parts using the current constant value for simpliication.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:212,simpl,simpliication,212,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['simpl'],['simpliication']
Usability,// This is a normal token with leading space. Clear the leading space; // marker on the first token to get proper expansion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:46,Clear,Clear,46,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['Clear'],['Clear']
Usability,"// This is a simple greedy algorithm for merging allocas. First, sort the; // slots, placing the largest slots first. Next, perform an n^2 scan and look; // for disjoint slots. When you find disjoint slots, merge the smaller one; // into the bigger one and update the live interval. Remove the small alloca; // and continue.; // Sort the slots according to their size. Place unused slots at the end.; // Use stable sort to guarantee deterministic code generation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:13,simpl,simple,13,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,1,['simpl'],['simple']
Usability,// This is a simple type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeIndex.cpp:13,simpl,simple,13,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeIndex.cpp,1,['simpl'],['simple']
Usability,"// This is a specialization of a fold in SimplifyDemandedVectorElts. We may; // not be able to handle it there if the insertelement has >1 use.; // If the shuffle has an insertelement operand but does not choose the; // inserted scalar element from that value, then we can replace that shuffle; // operand with the source vector of the insertelement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:41,Simpl,SimplifyDemandedVectorElts,41,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['Simpl'],['SimplifyDemandedVectorElts']
Usability,"// This is a variant of from generic_parser_base::printOptionInfo. Sadly,; // it's not easy to make it more usable. We could get it to print these as; // options if we were a cl::opt and registered them, but lists don't have; // options, nor does the parser for std::string. The other mechanisms for; // options are global and would pollute the global namespace with our; // counters. Rather than go that route, we have just overridden the; // printing, which only a few things call anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/DebugCounter.cpp:108,usab,usable,108,interpreter/llvm-project/llvm/lib/Support/DebugCounter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/DebugCounter.cpp,1,['usab'],['usable']
Usability,// This is an extending load from a sub-dword size. Widen the memory; // access size to 4 bytes and clear the extra high bits appropriately,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:100,clear,clear,100,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['clear'],['clear']
Usability,// This is basically just a port of takeLog2 from InstCombineMulDivRem.cpp; //; // Returns the node that represents `Log2(Op)`. This may create a new node. If; // we are unable to compute `Log2(Op)` its return `SDValue()`.; //; // All nodes will be created at `DL` and the output will be of type `VT`.; //; // This will only return `Log2(Op)` if we can prove `Op` is non-zero. Set; // `AssumeNonZero` if this function should simply assume (not require proving; // `Op` is non-zero).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:425,simpl,simply,425,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simply']
Usability,// This is intentionally placed after demanded elements simplification because; // it could eliminate knowledge of undef elements created by this shuffle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:56,simpl,simplification,56,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simplification']
Usability,"// This is meant for the learning phase",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:25,learn,learning,25,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['learn'],['learning']
Usability,"// This is not a simple type, use the template to simplify it...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h:17,simpl,simple,17,interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,2,['simpl'],"['simple', 'simplify']"
Usability,"// This is only used internally for now, to clear the MemWrites and MemReads; // list and setting Valid to false. I can't envision other uses of this right; // now, since once FusionCandidates are put into the FusionCandidateSet they; // are immutable. Thus, any time we need to change/update a FusionCandidate,; // we must create a new one and insert it into the FusionCandidateSet to; // ensure the FusionCandidateSet remains ordered correctly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:44,clear,clear,44,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['clear'],['clear']
Usability,"// This is still a valid proxy.; // All updates to preserve valid results are done below, so we don't need to; // invalidate this proxy.; //; // Note that in order to preserve this proxy, a module pass must ensure that; // the FAM has been completely updated to handle the deletion of functions.; // Specifically, any FAM-cached results for those functions need to have been; // forcibly cleared. When preserved, this proxy will only invalidate results; // cached on functions *still in the module* at the end of the module pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:388,clear,cleared,388,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,1,['clear'],['cleared']
Usability,"// This is still a valid proxy.; // If this proxy isn't marked as preserved, then even if the result remains; // valid, the key itself may no longer be valid, so we clear everything.; //; // Note that in order to preserve this proxy, a module pass must ensure that; // the FAM has been completely updated to handle the deletion of functions.; // Specifically, any FAM-cached results for those functions need to have been; // forcibly cleared. When preserved, this proxy will only invalidate results; // cached on functions *still in the module* at the end of the module pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassManager.cpp:165,clear,clear,165,interpreter/llvm-project/llvm/lib/IR/PassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PassManager.cpp,2,['clear'],"['clear', 'cleared']"
Usability,"// This is still a valid proxy.; // If this proxy or the call graph is going to be invalidated, we also need; // to clear all the keys coming from that analysis.; //; // We also directly invalidate the FAM's module proxy if necessary, and if; // that proxy isn't preserved we can't preserve this proxy either. We rely on; // it to handle module -> function analysis invalidation in the face of; // structural changes and so if it's unavailable we conservatively clear the; // entire SCC layer as well rather than trying to do invalidation ourselves.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:116,clear,clear,116,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,2,['clear'],['clear']
Usability,"// This is the ""size or nmemb is zero"" case.; // Just return 0, do nothing more (not clear the error flags).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:85,clear,clear,85,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,1,['clear'],['clear']
Usability,"// This is the common case, which also happens to be trivially simple.; // Special case it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:63,simpl,simple,63,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['simpl'],['simple']
Usability,"// This is the final component of a symbol name (i.e. the leftmost component; // of a mangled name. Since the only possible template instantiation that; // can appear in this context is a function template, and since those are; // not saved for the purposes of name backreferences, only backref simple; // names.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/MicrosoftDemangle.cpp:295,simpl,simple,295,interpreter/llvm-project/llvm/lib/Demangle/MicrosoftDemangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/MicrosoftDemangle.cpp,1,['simpl'],['simple']
Usability,// This is the first overlap. Initialize UsableRegs to all ones.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp:41,Usab,UsableRegs,41,interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveIntervals.cpp,1,['Usab'],['UsableRegs']
Usability,// This is the index of the first element of the VectorWidth-bit chunk; // we want. Since ElemsPerChunk is a power of 2 just need to clear bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:133,clear,clear,133,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,1,['clear'],['clear']
Usability,// This is the index of the first element of the vectorWidth-bit chunk; // we want. Since ElemsPerChunk is a power of 2 just need to clear bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:133,clear,clear,133,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['clear'],['clear']
Usability,"// This is the marker algorithm from ""Simple and Efficient Construction of; // Static Single Assignment Form""; // The simple, non-marker algorithm places phi nodes at any join; // Here, we place markers, and only place phi nodes if they end up necessary.; // They are only necessary if they break a cycle (IE we recursively visit; // ourselves again), or we discover, while getting the value of the operands,; // that there are two or more definitions needing to be merged.; // This still will leave non-minimal form in the case of irreducible control; // flow, where phi nodes may be in cycles with themselves, but unnecessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:38,Simpl,Simple,38,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,2,"['Simpl', 'simpl']","['Simple', 'simple']"
Usability,// This is the simple case where we are the outermost finally. All we; // have to do here is make sure we escape this and recover it in the; // outlined handler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:15,simpl,simple,15,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,1,['simpl'],['simple']
Usability,"// This is the simple case: binops without unsigned multiplication, and with; // widened operands. No overflow check is needed here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:15,simpl,simple,15,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['simpl'],['simple']
Usability,"// This is the simplest correct case: a class with no fields and one base; // class. Other cases are more complicated because of how the base classes; // & fields might interact, so we don't bother dealing with them.; // TODO: Support other combinations of base classes and fields.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp:15,simpl,simplest,15,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PaddingChecker.cpp,1,['simpl'],['simplest']
Usability,"// This is the simplest possible case, we just need to find a TEC that; // contains OpName. Look at all operands in equivalence class and try to; // find a suitable one. If `AllowSelf` is true, the operand itself is also; // considered suitable.; // Check for a def of a matched pattern. This is guaranteed to always; // be a register so we can blindly use that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp:15,simpl,simplest,15,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,1,['simpl'],['simplest']
Usability,"// This is well-defined for any case except where offset is strictly; // greater than the current length. If offset is equal to the current; // length, we can still grow. If offset is beyond the current length, we; // would have to decide how to deal with the intermediate uninitialized; // bytes. So we punt on that case for simplicity and just say it's an; // error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryByteStream.h:326,simpl,simplicity,326,interpreter/llvm-project/llvm/include/llvm/Support/BinaryByteStream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryByteStream.h,1,['simpl'],['simplicity']
Usability,"// This isn't respected by Nvidia, simply put here for clarity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp:35,simpl,simply,35,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp,1,['simpl'],['simply']
Usability,"// This isn't strictly necessary, but it simplifies things a bit since the; // current RedZone handling code assumes the SP is adjusted by the; // callee-save save/restore code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:41,simpl,simplifies,41,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['simpl'],['simplifies']
Usability,"// This isn't strictly true. If the user were to provide exactly the same; // matchers as the original operand then we could allow it. However, it's; // simpler to not permit the redundant specification.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp:153,simpl,simpler,153,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp,1,['simpl'],['simpler']
Usability,// This load (store) aliases with a preceding store (load). Delay; // it until the depenency is cleared.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/InOrderIssueStage.cpp:96,clear,cleared,96,interpreter/llvm-project/llvm/lib/MCA/Stages/InOrderIssueStage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/Stages/InOrderIssueStage.cpp,1,['clear'],['cleared']
Usability,"// This logic assumes that writes and reads are contributed by a register move; // or a register swap operation. In particular, it assumes a simple register; // move if there is only one write. It assumes a swap operation if there are; // exactly two writes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp:141,simpl,simple,141,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/RegisterFile.cpp,1,['simpl'],['simple']
Usability,"// This macro read all events generated by the test program Event; // provided in $ROOTSYS/test.; //; // NOTE: Before executing this macro, you must have executed the macro eventload.; //; // This small program simply counts the number of bytes read and dump; // the first 3 events.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/eventa.cxx:211,simpl,simply,211,test/eventa.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/eventa.cxx,1,['simpl'],['simply']
Usability,// This matches patterns corresponding to tests of the signbit as well as:; // (trunc X) u< C --> (X & -C) == 0 (are all masked-high-bits clear?); // (trunc X) u> C --> (X & ~C) != 0 (are any masked-high-bits set?),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:138,clear,clear,138,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['clear'],['clear']
Usability,// This matches the simplified 32-bit pointer code in the data layout; // computation.; // FIXME: Should use the data layout?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp:20,simpl,simplified,20,interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp,1,['simpl'],['simplified']
Usability,// This may happen for operands that are tied to a suboperand of a; // complex operand. Simply use a dummy value here; nobody should; // use this operand slot.; // FIXME: The long term goal is for the MCOperand list to not contain; // tied operands at all.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:88,Simpl,Simply,88,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,1,['Simpl'],['Simply']
Usability,// This may not be a real conflict if DefMI simply kills Other and defines; // VNI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:44,simpl,simply,44,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['simpl'],['simply']
Usability,"// This message resumes the session; should not come during processing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:16,resume,resumes,16,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['resume'],['resumes']
Usability,// This might be 'typename T::value_type;' (a type requirement) or; // 'typename T::value_type{};' (a simple requirement).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:102,simpl,simple,102,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['simpl'],['simple']
Usability,"// This might be an enum-base or part of some unrelated enclosing context.; //; // 'enum E : base' is permitted in two circumstances:; //; // 1) As a defining-type-specifier, when followed by '{'.; // 2) As the sole constituent of a complete declaration -- when DS is empty; // and the next token is ';'.; //; // The restriction to defining-type-specifiers is important to allow parsing; // a ? new enum E : int{}; // _Generic(a, enum E : int{}); // properly.; //; // One additional consideration applies:; //; // C++ [dcl.enum]p1:; // A ':' following ""enum nested-name-specifier[opt] identifier"" within; // the decl-specifier-seq of a member-declaration is parsed as part of; // an enum-base.; //; // Other language modes supporting enumerations with fixed underlying types; // do not have clear rules on this, so we disambiguate to determine whether; // the tokens form a bit-field width or an enum-base.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:791,clear,clear,791,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['clear'],['clear']
Usability,"// This might seem conter-intuitive at first glance, but the functions are; // closely related. Reasoning about destructors depends only on the type; // of the expression that initialized the memory region, which is the; // CXXConstructExpr. So to avoid code repetition, the work is delegated; // to the function that reasons about destructor inlining. Also note that; // if the constructors of the array elements are inlined, the destructors; // can also be inlined and if the destructors can be inline, it's safe to; // inline the constructors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:26,intuit,intuitive,26,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,1,['intuit'],['intuitive']
Usability,"// This might work out to be a current instantiation, in which; // case the canonical type needs to be the InjectedClassNameType.; //; // TODO: in theory this could be a simple hashtable lookup; most; // changes to CurContext don't change the set of current; // instantiations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:170,simpl,simple,170,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['simpl'],['simple']
Usability,// This must be a constant between -4095 and 4095. It is not clear; // what this constraint is intended for. Implemented for; // compatibility with GCC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:61,clear,clear,61,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['clear'],['clear']
Usability,"// This must be done after modified flag is cleared, as some; // viewers will invoke another paint by marking pad modified again",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx:44,clear,cleared,44,graf2d/gpad/src/TPad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx,1,['clear'],['cleared']
Usability,"// This node will go into the next RefSCC, clear out its DFS and low link; // as we scan.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:43,clear,clear,43,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,1,['clear'],['clear']
Usability,// This option is used in simplifying testing SampleFDO optimizations for; // profile loading.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:26,simpl,simplifying,26,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['simpl'],['simplifying']
Usability,"// This overload is chosen when the callable passed to Define or DefineSlot returns void.; // It simply fires a compile-time error. This is preferable to a static_assert in the main `Define` overload because; // this way compilation of `Define` has no way to continue after throwing the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:97,simpl,simply,97,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['simpl'],['simply']
Usability,"// This simple PRE (partial redundancy elimination) pass doesn't actually; // eliminate partial redundancy but transforms it to full redundancy,; // anticipating that the next CSE step will eliminate this created redundancy.; // If CSE doesn't eliminate this, than created instruction will remain dead; // and eliminated later by Remove Dead Machine Instructions pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:8,simpl,simple,8,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['simpl'],['simple']
Usability,// This simplification is only valid if the upper range is not negative.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:8,simpl,simplification,8,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['simpl'],['simplification']
Usability,"// This stuff is too complex for our simple use case!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/span.hxx:37,simpl,simple,37,core/foundation/inc/ROOT/span.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/span.hxx,1,['simpl'],['simple']
Usability,"// This table describes function formal argument type rules. The order of rules; // corresponds to the EFuncId enum at AMDGPULibFunc.h; //; // ""<func name>"", { <leads> }, { <param rules> }; // where:; // <leads> - list of integers that are one-based indexes of formal argument; // used to mangle a function name. Other argument types are derived from types; // of these 'leads'. The order of integers in this list correspond to the; // order in which these arguments are mangled in the EDG mangling scheme. The; // same order should be preserved for arguments in the AMDGPULibFunc structure; // when it is used for mangling. For example:; // { ""vstorea_half"", {3,1}, {E_ANY,EX_SIZET,E_ANY}},; // will be mangled in EDG scheme as vstorea_half_<3dparam>_<1stparam>; // When mangling from code use:; // AMDGPULibFunc insc;; // insc.param[0] = ... // describe 3rd parameter; // insc.param[1] = ... // describe 1rd parameter; //; // <param rules> - list of rules used to derive all of the function formal; // argument types. EX_ prefixed are simple types, other derived from the; // latest 'lead' argument type in the order of encoding from first to last.; // E_ANY - use prev lead type, E_CONSTPTR_ANY - make const pointer out of; // prev lead type, etc. see ParamIterator::getNextParam() for details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibFunc.cpp:1037,simpl,simple,1037,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibFunc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibFunc.cpp,1,['simpl'],['simple']
Usability,"// This takes a very simple approach since there are two lanes and a; // shuffle can have 2 inputs. So we reserve the first input for the first; // lane and the second input for the second lane. This may result in; // duplicate sources, but this can be dealt with in the backend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:21,simpl,simple,21,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['simpl'],['simple']
Usability,// This trivial case can show up in some degenerate cases where; // the incoming IR has not yet been fully simplified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:107,simpl,simplified,107,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['simpl'],['simplified']
Usability,"// This type is being defined, so clear the location to indicate this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:34,clear,clear,34,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,2,['clear'],['clear']
Usability,"// This unrolling functionality is target independent, but to provide some; // motivation for its intended use, for x86:; // According to the Intel 64 and IA-32 Architectures Optimization Reference; // Manual, Intel Core models and later have a loop stream detector (and; // associated uop queue) that can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have no more than 4 (8 for Nehalem and later) branches; // taken, and none of them may be calls.; // - The loop can have no more than 18 (28 for Nehalem and later) uops.; // According to the Software Optimization Guide for AMD Family 15h; // Processors, models 30h-4fh (Steamroller and later) have a loop predictor; // and loop buffer which can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have fewer than 16 branches; // - The loop must have less than 40 uops in all executed loop branches; // The number of taken branches in a loop is hard to estimate here, and; // benchmarking has revealed that it is better not to be conservative when; // estimating the branch count. As a result, we'll ignore the branch limits; // until someone finds a case where it matters in practice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:606,Guid,Guide,606,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,1,['Guid'],['Guide']
Usability,// This vector and the next vector are shuffled together (simply to; // append the one to the other).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:58,simpl,simply,58,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['simpl'],['simply']
Usability,// This version of AnalyzeCallOperands in the base class is not usable; // since we must provide a means of accessing ISD::OutputArg::IsFixed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:64,usab,usable,64,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,1,['usab'],['usable']
Usability,// This visitor will traverse a conditional statement and store all; // the evaluated decls into a vector. Simple is set to true if none; // of the excluded constructs are used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:107,Simpl,Simple,107,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['Simpl'],['Simple']
Usability,"// This was created for a call to an external or indirect target.; // A GUID with no summary came from a VALUE_GUID record, dummy GUID; // created for indirect calls with VP. A Name with no GUID came from; // an external definition. We pass ExternalLinkage since that is only; // used when the GUID must be computed from Name, and in that case; // the symbol must have external linkage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:72,GUID,GUID,72,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,4,['GUID'],['GUID']
Usability,"// This was originally permitted (and indeed the canonical way) to; // represent the {ILP32,LP64}D ABIs, but in Feb 2023 Loongson decided to; // drop the explicit suffix in favor of unmarked `-gnu` for the; // ""general-purpose"" ABIs, among other non-technical reasons.; //; // The spec change did not mention whether existing usages of ""gnuf64""; // shall remain valid or not, so we are going to continue recognizing it; // for some time, until it is clear that everyone else has migrated away; // from it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp:450,clear,clear,450,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp,1,['clear'],['clear']
Usability,"// This was the first time (RegIdx, ParentVNI) was mapped, and it is not; // forced. Keep it as a simple def without any liveness.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:98,simpl,simple,98,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,1,['simpl'],['simple']
Usability,// This will truncate the value to Val's input width. Simply check; // for overflow by comparing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:54,Simpl,Simply,54,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,1,['Simpl'],['Simply']
Usability,"// This would inject an emprt parameter pack, which is a good default.; // But for cases where instantiation fails, this hits bug in unloading; // of the failed instantiation, causing a missing symbol in subsequent; // transactions where a Decl instantiated by the failed instatiation; // is not re-emitted. So for now just give up default-instantiating; // templates with parameter packs, even if this is simply a work-around.; //defaultTemplateArgs.emplace_back(ArrayRef<TemplateArgument>{}); // empty pack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx:406,simpl,simply,406,core/metacling/src/TClingMethodInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx,1,['simpl'],['simply']
Usability,// This would need adjustment if we allow Inst to be a phi node -- the; // new use block won't simply be NewBB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:95,simpl,simply,95,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,1,['simpl'],['simply']
Usability,"// Threading Add over selects and phi nodes is pointless, so don't bother.; // Threading over the select in ""A + select(cond, B, C)"" means evaluating; // ""A+B"" and ""A+C"" and seeing if they are equal; but they are equal if and; // only if B and C are equal. If B and C are equal then (since we assume; // that operands have already been simplified) ""select(cond, B, C)"" should; // have been simplified to the common value of B and C already. Analysing; // ""A+B"" and ""A+C"" thus gains nothing, but costs compile time. Similarly; // for threading over phi nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:336,simpl,simplified,336,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,['simpl'],['simplified']
Usability,"// Threading Sub over selects and phi nodes is pointless, so don't bother.; // Threading over the select in ""A - select(cond, B, C)"" means evaluating; // ""A-B"" and ""A-C"" and seeing if they are equal; but they are equal if and; // only if B and C are equal. If B and C are equal then (since we assume; // that operands have already been simplified) ""select(cond, B, C)"" should; // have been simplified to the common value of B and C already. Analysing; // ""A-B"" and ""A-C"" thus gains nothing, but costs compile time. Similarly; // for threading over phi nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:336,simpl,simplified,336,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,['simpl'],['simplified']
Usability,"// Threading Xor over selects and phi nodes is pointless, so don't bother.; // Threading over the select in ""A ^ select(cond, B, C)"" means evaluating; // ""A^B"" and ""A^C"" and seeing if they are equal; but they are equal if and; // only if B and C are equal. If B and C are equal then (since we assume; // that operands have already been simplified) ""select(cond, B, C)"" should; // have been simplified to the common value of B and C already. Analysing; // ""A^B"" and ""A^C"" thus gains nothing, but costs compile time. Similarly; // for threading over phi nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:336,simpl,simplified,336,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,['simpl'],['simplified']
Usability,"// Three possibilities here:; //; // A) The fragment just happens to end at a bundle boundary, so we're good.; // B) The fragment ends before the current bundle boundary: pad it just; // enough to reach the boundary.; // C) The fragment ends after the current bundle boundary: pad it until it; // reaches the end of the next bundle boundary.; //; // Note: this code could be made shorter with some modulo trickery, but it's; // intentionally kept in its more explicit form for simplicity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp:477,simpl,simplicity,477,interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCFragment.cpp,1,['simpl'],['simplicity']
Usability,"// Throughout C++2a [class.compare]: if overload resolution does not; // result in a usable function, the candidate function is defined as; // deleted. This requires that we selected an accessible function.; //; // Note that this only considers the access of the function when named; // within the type of the subobject, and not the access path for any; // derived-to-base conversion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:85,usab,usable,85,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['usab'],['usable']
Usability,// Throw away the SymbolToDefinition map: it's not usable after we hand; // off the module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Layer.cpp:51,usab,usable,51,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Layer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Layer.cpp,1,['usab'],['usable']
Usability,"// Thumb reg+reg addressing is simple. Just two registers, a base and; // an offset. No shifts, negations or any other complicating factors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:31,simpl,simple,31,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['simpl'],['simple']
Usability,"// Thumb1 has very limited immediate modes, so turning an ""and"" into a; // shift can save multiple instructions.; //; // If we have (x & C1), and C1 is an appropriate mask, we can transform it; // into ""((x << n) >> n)"". But that isn't necessarily profitable on its; // own. If it's the operand to an unsigned comparison with an immediate,; // we can eliminate one of the shifts: we transform; // ""((x << n) >> n) == C2"" to ""(x << n) == (C2 << n)"".; //; // We avoid transforming cases which aren't profitable due to encoding; // details:; //; // 1. C2 fits into the immediate field of a cmp, and the transformed version; // would not; in that case, we're essentially trading one immediate load for; // another.; // 2. C1 is 255 or 65535, so we can use uxtb or uxth.; // 3. C2 is zero; we have other code for this special case.; //; // FIXME: Figure out profitability for Thumb2; we usually can't save an; // instruction, since the AND is always one instruction anyway, but we could; // use narrow instructions in some cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:752,ux,uxtb,752,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,['ux'],"['uxtb', 'uxth']"
Usability,// Tie breaker using GUID so we have stable/deterministic inlining order,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:21,GUID,GUID,21,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,2,['GUID'],['GUID']
Usability,"// Timur.Pocheptsov: it's not really clear, if I should really check this:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/MetaProcessor/Display.cpp:37,clear,clear,37,interpreter/cling/lib/MetaProcessor/Display.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/MetaProcessor/Display.cpp,1,['clear'],['clear']
Usability,"// To ""insert"" a SELECT_CC instruction, we actually have to insert the; // diamond control-flow pattern. The incoming instruction knows the; // destination vreg to set, the condition code register to branch on, the; // true/false values to select between and a branch opcode to use.; // ThisMBB:; // ...; // TrueVal = ...; // cmpTY ccX, r1, r2; // bCC copy1MBB; // fallthrough --> FalseMBB; // This code lowers all pseudo-CMOV instructions. Generally it lowers these; // as described above, by inserting a BB, and then making a PHI at the join; // point to select the true and false operands of the CMOV in the PHI.; //; // The code also handles two different cases of multiple CMOV opcodes; // in a row.; //; // Case 1:; // In this case, there are multiple CMOVs in a row, all which are based on; // the same condition setting (or the exact opposite condition setting).; // In this case we can lower all the CMOVs using a single inserted BB, and; // then make a number of PHIs at the join point to model the CMOVs. The only; // trickiness here, is that in a case like:; //; // t2 = CMOV cond1 t1, f1; // t3 = CMOV cond1 t2, f2; //; // when rewriting this into PHIs, we have to perform some renaming on the; // temps since you cannot have a PHI operand refer to a PHI result earlier; // in the same block. The ""simple"" but wrong lowering would be:; //; // t2 = PHI t1(BB1), f1(BB2); // t3 = PHI t2(BB1), f2(BB2); //; // but clearly t2 is not defined in BB1, so that is incorrect. The proper; // renaming is to note that on the path through BB1, t2 is really just a; // copy of t1, and do that renaming, properly generating:; //; // t2 = PHI t1(BB1), f1(BB2); // t3 = PHI t1(BB1), f2(BB2); //; // Case 2:; // CMOV ((CMOV F, T, cc1), T, cc2) is checked here and handled by a separate; // function - EmitLoweredCascadedSelect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:1311,simpl,simple,1311,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,"['clear', 'simpl']","['clearly', 'simple']"
Usability,"// To avoid changing the bits of the constant due to extension to a larger; // type and then using G_FPTRUNC, we simply convert to a G_CONSTANT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:113,simpl,simply,113,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['simpl'],['simply']
Usability,"// To avoid having these optimizations undone by constant folding,; // we convert to a pseudo that will be expanded later into one of; // the above forms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:39,undo,undone,39,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['undo'],['undone']
Usability,// To be clear: this happily visits unsupported builtins. Better name welcomed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:9,clear,clear,9,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['clear'],['clear']
Usability,// To compute the new parent of this hoisted loop we look at where we; // placed the preheader above. We can't lookup the header itself because we; // retained the mapping from the header to the hoisted loop. But the; // preheader and header should have the exact same new parent computed; // based on the set of exit blocks from the original loop as the preheader; // is a predecessor of the header and so reached in the reverse walk. And; // because the loops were all in simplified form the preheader of the; // hoisted loop can't be part of some *other* loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:474,simpl,simplified,474,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['simpl'],['simplified']
Usability,"// To consider a PHI profitable to break, we need to see some interesting; // incoming values. At least 2/3rd (rounded up) of all PHIs in the worklist; // must have one to consider all PHIs breakable.; //; // This threshold has been determined through performance testing.; //; // Note that the computation below is equivalent to; //; // (unsigned)ceil((K / 3.0) * 2); //; // It's simply written this way to avoid mixing integral/FP arithmetic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:381,simpl,simply,381,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,1,['simpl'],['simply']
Usability,"// To construct a syntax tree of the same shape for calls to built-in and; // user-defined operators, ignore the `DeclRefExpr` that refers to the; // operator and treat it as a simple token. Do that by traversing; // arguments instead of children.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:177,simpl,simple,177,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,1,['simpl'],['simple']
Usability,"// To control potential compile time explosion, we choose to be; // conserviate when we have more than one Phi input. It is important; // that we handle the single phi case as that lets us handle LCSSA; // phi nodes and (combined with the recursive phi handling) simple; // pointer induction variable patterns.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:263,simpl,simple,263,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['simpl'],['simple']
Usability,"// To do the 'conservative' version, we would need to do some; // intervention here. We would probably need to create a different; // ParamHistFunc for each sample in the channel. The would nominally; // use the same gamma's, so we haven't increased the number of parameters; // However, if a bin in the 'nominal' histogram is 0, we simply need to; // change the parameter in that bin in the ParamHistFunc for this sample.; // We also need to add a constraint term.; // Actually, we'd probably not use the ParamHistFunc...?; // we could remove the dependence in this ParamHistFunc on the ith gamma; // and then create the poisson term: Pois(tau | n_exp)Pois(data | n_exp); // Next, try to get the common ParamHistFunc (it may have been; // created by another sample in this channel); // or create it if it doesn't yet exist:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx:333,simpl,simply,333,roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,1,['simpl'],['simply']
Usability,"// To focus on basic collection protocol, this sample program uses; // simple classes inheriting from TObject. One class, TObjString, is a; // collectable string class (a TString wrapped in a TObject) provided; // by the ROOT system. The other class we define below, is an integer; // wrapped in a TObject, just like TObjString.; // TObjNum is a simple container for an integer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/tcollex.cxx:71,simpl,simple,71,test/tcollex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/tcollex.cxx,2,['simpl'],['simple']
Usability,// To get the default FP mode all control bits are cleared:; // FPSCR = FPSCR & (FPStatusBits | FPReservedBits),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:51,clear,cleared,51,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['clear'],['cleared']
Usability,// To get the live-outs we simply merge the live-ins of all successors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp:27,simpl,simply,27,interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LivePhysRegs.cpp,2,['simpl'],['simply']
Usability,"// To help keep the loop simple, temporarily append the last; // outgoing block to the list of guard blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:25,simpl,simple,25,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,1,['simpl'],['simple']
Usability,"// To help with overload selection, methods are given a priority based on the; // affinity of Python and C++ types. Priority only matters for methods that have; // an equal number of arguments and types that are possible substitutes (the; // normal selection mechanisms would simply distinguish them otherwise).; // The following types are ordered, in favor (variants implicit):; //; // bool >> long >> int >> short; // double >> long double >> float; // const char* >> char; //; // Further, all integer types are preferred over floating point b/c int to float; // is allowed implicitly, float to int is not.; //; // Special cases that are disliked include void* and unknown/incomplete types.; // Also, moves are preferred over references. std::initializer_list is not a nice; // conversion candidate either, but needs to be higher priority to mix well with; // implicit conversions.; // TODO: extend this to favour classes that are not bases.; // TODO: profile this method (it's expensive, but should be called too often)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx:276,simpl,simply,276,bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx,1,['simpl'],['simply']
Usability,"// To keep things simple for now, remove those where the load is potentially; // fed by multiple stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:18,simpl,simple,18,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,1,['simpl'],['simple']
Usability,"// To keep things simple have an empty preheader before we version or clone; // the loop. (Also split if this has no predecessor, i.e. entry, because we; // rely on PH having a predecessor.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:18,simpl,simple,18,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,1,['simpl'],['simple']
Usability,"// To keep things simple, only process loops with single latch. We; // canonicalize most loops to this form. We can support multi-latch if needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:18,simpl,simple,18,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,1,['simpl'],['simple']
Usability,// To make the enum usable as an array index.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:20,usab,usable,20,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,1,['usab'],['usable']
Usability,// To save some vertical space we print up to MaxChildrenPerLine APValues; // considered to be simple (by isSimpleAPValue) on a single line.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp:95,simpl,simple,95,interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp,1,['simpl'],['simple']
Usability,"// To simplify code, we cap the number of file infos we write out to fit; // easily in a 32-bit signed integer. This gives consistent behavior between; // 32-bit and 64-bit systems without requiring (potentially very slow) 64-bit; // operations on 32-bit systems. It also seems unreasonable to try to handle; // more than 2 billion files.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:6,simpl,simplify,6,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,1,['simpl'],['simplify']
Usability,"// To simplify the first loop iteration, pretend an empty request starting at the first page's fOffset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx:6,simpl,simplify,6,tree/ntuple/v7/src/RPageStorageFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx,1,['simpl'],['simplify']
Usability,"// To simplify the implementation, never keep around an empty stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:6,simpl,simplify,6,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,1,['simpl'],['simplify']
Usability,"// To simplify the sub-register handling, verify that we only need to; // consider physical registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:6,simpl,simplify,6,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,1,['simpl'],['simplify']
Usability,"// To simplify this code we canonicalize the relation so that the first; // operand is always the most ""complex"" of the two. We consider simple; // constants (like ConstantPointerNull) to be the simplest, followed by; // BlockAddress, GlobalValues, and ConstantExpr's (the most complex).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:6,simpl,simplify,6,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,3,['simpl'],"['simple', 'simplest', 'simplify']"
Usability,"// Tokenize the CommandLine to the command and the args to allow; // defining a full command line as the command instead of just the; // executed program. We cannot just pass the whole string after the command; // as a single argument because then the program sees only a single; // command line argument (with spaces in it: ""foo bar"" instead; // of ""foo"" and ""bar"").; //; // Spaces are used as a delimiter; however repeated, leading, and trailing; // whitespace are ignored. Simple escaping is allowed via the '\'; // character, as seen below:; //; // Two consecutive '\' evaluate to a single '\'.; // A space after a '\' evaluates to a space that is not interpreted as a; // delimiter.; // Any other instances of the '\' character are removed.; //; // Example:; // '\\' -> '\'; // '\ ' -> ' '; // 'exa\mple' -> 'example'; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:476,Simpl,Simple,476,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,1,['Simpl'],['Simple']
Usability,// Too hard to analyze.; // Analyze all uses of the allocation. If any of them are used in a; // non-simple way (e.g. stored to another global) bail out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:101,simpl,simple,101,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,1,['simpl'],['simple']
Usability,// Top bits are cleared for load2r (which is the same as lhbrx).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:16,clear,cleared,16,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['clear'],['cleared']
Usability,// Top bits of carry / borrow are clear.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/XCore/XCoreISelLowering.cpp:34,clear,clear,34,interpreter/llvm-project/llvm/lib/Target/XCore/XCoreISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/XCore/XCoreISelLowering.cpp,1,['clear'],['clear']
Usability,"// Trace the arguments of an incomplete Phi node to see if they have the same; // canonical definition. If so, mark the Phi node as redundant.; // getCanonicalVal() will recursively call simplifyIncompletePhi().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:187,simpl,simplifyIncompletePhi,187,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,1,['simpl'],['simplifyIncompletePhi']
Usability,"// Trace the sub-value needed by the return value as far back up the graph as; // possible, in the hope that it will intersect with the value produced by the; // call. In the simple case with no ""returned"" attribute, the hope is actually; // that we end up back at the tail call instruction itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:175,simpl,simple,175,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,1,['simpl'],['simple']
Usability,// Track a set vector of inlined callees so that we can augment the caller; // with all of their edges in the call graph before pruning out the ones that; // got simplified away.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:162,simpl,simplified,162,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,1,['simpl'],['simplified']
Usability,"// Track all instructions that may raise floating-point exceptions.; // These do not depend on one other (or normal loads or stores), but; // must not be rescheduled across global barriers. Note that we don't; // really need a ""map"" here since we don't track those MIs by value;; // using the same Value2SUsMap data type here is simply a matter of; // convenience.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:329,simpl,simply,329,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['simpl'],['simply']
Usability,// Track for simplification all factors which occur 2 or more times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:13,simpl,simplification,13,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['simpl'],['simplification']
Usability,// Track register writes that implicitly clear the upper portion of the; // underlying super-registers using an APInt.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp:41,clear,clear,41,interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,1,['clear'],['clear']
Usability,"// Track the largest value of features seen during this eviction session. We; // only normalize (some of) the float features, but it's just simpler to; // dimension 'Largest' to all the features, especially since we have the; // 'DoNotNormalize' list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:140,simpl,simpler,140,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,1,['simpl'],['simpler']
Usability,// Track the top most source sub-lane - by setting the remaining to; // UNDEF we can greatly simplify shuffle matching.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:93,simpl,simplify,93,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplify']
Usability,// Track whether the LHS or RHS is real at the type system level. When this is; // the case we can simplify our evaluation strategy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:99,simpl,simplify,99,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['simpl'],['simplify']
Usability,"// Tracks the simplification of newly created phi nodes. The reason we use; // this mapping is because we will add new created Phi nodes in AddrToBase.; // Simplification of Phi nodes is recursive, so some Phi node may; // be simplified after we added it to AddrToBase. In reality this; // simplification is possible only if original phi/selects were not; // simplified yet.; // Using this mapping we can find the current value in AddrToBase.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:14,simpl,simplification,14,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,5,"['Simpl', 'simpl']","['Simplification', 'simplification', 'simplified']"
Usability,// Traditional behaviour seems to special case this particular value. It's; // not clear why other masks are handled differently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:83,clear,clear,83,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['clear'],['clear']
Usability,"// Transfer memoperands. In the case of AArch64::LD64B, there won't be one,; // because it's too simple to have needed special treatment during lowering.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:97,simpl,simple,97,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['simpl'],['simple']
Usability,"// Transfer the simply mapped values, check if any are skipped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:16,simpl,simply,16,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,1,['simpl'],['simply']
Usability,"// Transform ""(X >> (8-C1)) & (0xff << C1)"" to ""((X >> 8) & 0xff) << C1"" if; // safe. This allows us to convert the shift and and into an h-register; // extract and a scaled index. Returns false if the simplification is; // performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:202,simpl,simplification,202,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['simpl'],['simplification']
Usability,"// Transform ""(X >> SHIFT) & (MASK << C1)"" to; // ""((X >> (SHIFT + C1)) & (MASK)) << C1"". Everything before the SHL will be; // matched to a BEXTR later. Returns false if the simplification is performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:175,simpl,simplification,175,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['simpl'],['simplification']
Usability,"// Transform (add X, (zext(setne Z, C))) -> (addze X, (addic (addi Z, -C), -1)); // Transform (add X, (zext(sete Z, C))) -> (addze X, (subfic (addi Z, -C), 0)); // When C is zero, the equation (addi Z, -C) can be simplified to Z; // Requirement: -C in [-32768, 32767], X and Z are MVT::i64 types",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:213,simpl,simplified,213,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['simpl'],['simplified']
Usability,"// Transform Mag value to integer, and clear the sign bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:39,clear,clear,39,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['clear'],['clear']
Usability,"// Transform value to integer, clear the sign bit and transform back.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:31,clear,clear,31,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['clear'],['clear']
Usability,"// Transform: ""(A op B) op C"" ==> ""(C op A) op B"" if ""C op A"" simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:62,simpl,simplifies,62,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplifies']
Usability,"// Transform: ""(A op B) op C"" ==> ""(C op A) op B"" if it simplifies completely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,simpl,simplifies,56,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// Transform: ""(A op B) op C"" ==> ""A op (B op C)"" if ""B op C"" simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:62,simpl,simplifies,62,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplifies']
Usability,"// Transform: ""(A op B) op C"" ==> ""A op (B op C)"" if it simplifies completely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,simpl,simplifies,56,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// Transform: ""A op (B op C)"" ==> ""(A op B) op C"" if ""A op B"" simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:62,simpl,simplifies,62,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplifies']
Usability,"// Transform: ""A op (B op C)"" ==> ""(A op B) op C"" if it simplifies completely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,simpl,simplifies,56,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// Transform: ""A op (B op C)"" ==> ""B op (C op A)"" if ""C op A"" simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:62,simpl,simplifies,62,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplifies']
Usability,"// Transform: ""A op (B op C)"" ==> ""B op (C op A)"" if it simplifies completely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,simpl,simplifies,56,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// Transform: (load ch (add x (and (srl y c) Mask))); // to: (load ch (add x (shl (srl y d) d-c))); // where; // Mask = 00..0 111..1 0.0; // | | +-- d-c 0s, and d-c is 0, 1 or 2.; // | +-------- 1s; // +-------------- at most c 0s; // Motivating example:; // DAG combiner optimizes (add x (shl (srl y 5) 2)); // to (add x (and (srl y 3) 1FFFFFFC)); // which results in a constant-extended and(##...,lsr). This transformation; // undoes this simplification for cases where the shl can be folded into; // an addressing mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:429,undo,undoes,429,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,4,"['simpl', 'undo']","['simplification', 'undoes']"
Usability,"// Translate arguments from AArch64 calling convention to x86 calling; // convention.; //; // For simple types, we don't need to do any translation: they're; // represented the same way. (Implicit sign extension is not part of; // either convention.); //; // The big thing we have to worry about is struct types... but; // fortunately AArch64 clang is pretty friendly here: the cases that need; // translation are always passed as a struct or array. (If we run into; // some cases where this doesn't work, we can teach clang to mark it up; // with an attribute.); //; // The first argument is the called function, stored in x9.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Arm64ECCallLowering.cpp:98,simpl,simple,98,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Arm64ECCallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Arm64ECCallLowering.cpp,1,['simpl'],['simple']
Usability,"// Traverse the CFG in topological order, so all predecessors of a block; // (excluding back-edges) are visited before the block itself. At; // each point in the code, we calculate a Context, which holds the set of; // variable definitions which are visible at that point in execution.; // Visible variables are mapped to their definitions using an array that; // contains all definitions.; //; // At join points in the CFG, the set is computed as the intersection of; // the incoming sets along each edge, E.g.; //; // { Context | VarDefinitions }; // int x = 0; { x -> x1 | x1 = 0 }; // int y = 0; { x -> x1, y -> y1 | y1 = 0, x1 = 0 }; // if (b) x = 1; { x -> x2, y -> y1 | x2 = 1, y1 = 0, ... }; // else x = 2; { x -> x3, y -> y1 | x3 = 2, x2 = 1, ... }; // ... { y -> y1 (x is unknown) | x3 = 2, x2 = 1, ... }; //; // This is essentially a simpler and more naive version of the standard SSA; // algorithm. Those definitions that remain in the intersection are from blocks; // that strictly dominate the current block. We do not bother to insert proper; // phi nodes, because they are not used in our analysis; instead, wherever; // a phi node would be required, we simply remove that definition from the; // context (E.g. x above).; //; // The initial traversal does not capture back-edges, so those need to be; // handled on a separate pass. Whenever the first pass encounters an; // incoming back edge, it duplicates the context, creating new definitions; // that refer back to the originals. (These correspond to places where SSA; // might have to insert a phi node.) On the second pass, these definitions are; // set to NULL if the variable has changed on the back-edge (i.e. a phi; // node was actually required.) E.g.; //; // { Context | VarDefinitions }; // int x = 0, y = 0; { x -> x1, y -> y1 | y1 = 0, x1 = 0 }; // while (b) { x -> x2, y -> y1 | [1st:] x2=x1; [2nd:] x2=NULL; }; // x = x+1; { x -> x3, y -> y1 | x3 = x2 + 1, ... }; // ... { y -> y1 | x3 = 2, x2 = 1, ... }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:845,simpl,simpler,845,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,2,['simpl'],"['simpler', 'simply']"
Usability,"// Traverse the DT with an rpo walk so we see defs before uses, allowing; // simplification to be done incrementally.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp:77,simpl,simplification,77,interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp,1,['simpl'],['simplification']
Usability,"// Treat constant and global as identical. SMRD loads are sometimes usable for; // global loads (ideally constant address space should be eliminated); // depending on the context. Legality cannot be context dependent, but; // RegBankSelect can split the load as necessary depending on the pointer; // register bank/uniformity and if the memory is invariant or not written in a; // kernel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:68,usab,usable,68,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['usab'],['usable']
Usability,"// Tries to turn a shuffle of two CONCAT_VECTORS into a single concat,; // or turn a shuffle of a single concat into simpler shuffle then concat.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:117,simpl,simpler,117,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simpler']
Usability,"// Triggered by the user, not the learning phase",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:34,learn,learning,34,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['learn'],['learning']
Usability,// Trivial Simplification. If Terminator is a conditional branch and; // condition becomes dead - erase it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:11,Simpl,Simplification,11,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['Simpl'],['Simplification']
Usability,"// Trivial equivalence classes (those that have only one symbol member) are; // not stored in the State. Thus, we must skim through the constraints as; // well. And we try to simplify symbols in the constraints.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:175,simpl,simplify,175,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['simpl'],['simplify']
Usability,// True if this write implicitly clears the upper portion of RegisterID's; // super-registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:33,clear,clears,33,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,1,['clear'],['clears']
Usability,// Truncate: Clearly undefined Bits on the MSB side are removed; // if there are any.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:13,Clear,Clearly,13,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,1,['Clear'],['Clearly']
Usability,// Truncated source must be a simple vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:30,simpl,simple,30,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simple']
Usability,"// Truncation simply means we keep position, but extract less bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,simpl,simply,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simply']
Usability,// Try a simple shift right with undef elements. Later we'll try with zeros.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:9,simpl,simple,9,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simple']
Usability,// Try a simple unquoted name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp:9,simpl,simple,9,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MILexer.cpp,1,['simpl'],['simple']
Usability,"// Try and vectorize the indices. We are currently only interested in; // gather-like cases of the form:; //; // ... = g[a[0] - b[0]] + g[a[1] - b[1]] + ...; //; // where the loads of ""a"", the loads of ""b"", and the subtractions can be; // performed in parallel. It's likely that detecting this pattern in a; // bottom-up phase will be simpler and less costly than building a; // full-blown top-down phase beginning at the consecutive loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:335,simpl,simpler,335,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['simpl'],['simpler']
Usability,"// Try calling SimplifyDemandedBits, converting demanded elts to the bits; // of the large element.; // TODO - bigendian once we have test coverage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:15,Simpl,SimplifyDemandedBits,15,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,// Try folding simple instructions into the csel.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:15,simpl,simple,15,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['simpl'],['simple']
Usability,// Try handling easy numbers of MIs with simpler mechanisms.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:41,simpl,simpler,41,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,1,['simpl'],['simpler']
Usability,// Try simple root leaf insert.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:7,simpl,simple,7,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,1,['simpl'],['simple']
Usability,// Try simplification again because we use this function to optimize; // BLENDV nodes that are not handled by the generic combiner.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:7,simpl,simplification,7,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplification']
Usability,"// Try simplify G_UADDO with 8 or 16 bit operands to wide G_ADD and TBNZ if; // result is only used in the no-overflow case. It is restricted to cases; // where we know that the high-bits of the operands are 0. If there's an; // overflow, then the 9th or 17th bit must be set, which can be checked; // using TBNZ.; //; // Change (for UADDOs on 8 and 16 bits):; //; // %z0 = G_ASSERT_ZEXT _; // %op0 = G_TRUNC %z0; // %z1 = G_ASSERT_ZEXT _; // %op1 = G_TRUNC %z1; // %val, %cond = G_UADDO %op0, %op1; // G_BRCOND %cond, %error.bb; //; // error.bb:; // (no successors and no uses of %val); //; // To:; //; // %z0 = G_ASSERT_ZEXT _; // %z1 = G_ASSERT_ZEXT _; // %add = G_ADD %z0, %z1; // %val = G_TRUNC %add; // %bit = G_AND %add, 1 << scalar-size-in-bits(%op1); // %cond = G_ICMP NE, %bit, 0; // G_BRCOND %cond, %error.bb",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PreLegalizerCombiner.cpp:7,simpl,simplify,7,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PreLegalizerCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PreLegalizerCombiner.cpp,1,['simpl'],['simplify']
Usability,"// Try sinking to another block. If that block is unreachable, then do; // not bother. SimplifyCFG should handle it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:87,Simpl,SimplifyCFG,87,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['Simpl'],['SimplifyCFG']
Usability,// Try some generic simplifications for associative operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:20,simpl,simplifications,20,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,5,['simpl'],['simplifications']
Usability,// Try to build a simple constant vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:18,simpl,simple,18,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['simpl'],['simple']
Usability,// Try to collapse single-value PHI nodes. This is necessary to undo; // unprofitable PRE transformations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:64,undo,undo,64,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['undo'],['undo']
Usability,// Try to convert a constant mask AND into a shuffle clear mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:53,clear,clear,53,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['clear'],['clear']
Usability,// Try to convert multiply of extended operand to narrow negate and shift; // for better analysis.; // This is valid if the shift amount (trailing zeros in the multiplier; // constant) clears more high bits than the bitwidth difference between; // source and destination types:; // ({z/s}ext X) * (-1<<C) --> (zext (-X)) << C,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:185,clear,clears,185,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['clear'],['clears']
Usability,"// Try to determine a join block through the help of the dominance tree. If no; // tree was provided, we perform simple pattern matching for one block; // conditionals only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:113,simpl,simple,113,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,1,['simpl'],['simple']
Usability,"// Try to determine a join block through the help of the post-dominance; // tree. If no tree was provided, we perform simple pattern matching for one; // block conditionals and one block loops only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:118,simpl,simple,118,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,1,['simpl'],['simple']
Usability,"// Try to determine the return value if we can. This is mainly here to; // simplify the writing of unit tests, but also helps to enable IPO by; // constant folding the return values of callees.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:75,simpl,simplify,75,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,1,['simpl'],['simplify']
Usability,"// Try to disprove equal directions.; // For example, given a subscript pair [3*i + 2*j] and [i' + 2*j' - 1],; // the code above can't disprove the dependence because the GCD = 1.; // So we consider what happen if i = i' and what happens if j = j'.; // If i = i', we can simplify the subscript to [2*i + 2*j] and [2*j' - 1],; // which is infeasible, so we can disallow the = direction for the i level.; // Setting j = j' doesn't help matters, so we end up with a direction vector; // of [<>, *]; //; // Given A[5*i + 10*j*M + 9*M*N] and A[15*i + 20*j*M - 21*N*M + 5],; // we need to remember that the constant part is 5 and the RunningGCD should; // be initialized to ExtraGCD = 30.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:271,simpl,simplify,271,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['simpl'],['simplify']
Usability,// Try to emit update expression as a simple atomic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:38,simpl,simple,38,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['simpl'],['simple']
Usability,"// Try to expand strrchr to the memrchr nonstandard extension if it's; // available, or simply fail otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:88,simpl,simply,88,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['simpl'],['simply']
Usability,"// Try to find an usable `errno` value.; // It can be an external variable called ""errno"" or a function that returns a; // pointer to the ""errno"" value. This function can have different names.; // The actual case is dependent on the C library implementation, we; // can only search for a match in one of these variations.; // We assume that exactly one of these cases might be true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp:18,usab,usable,18,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoModeling.cpp,1,['usab'],['usable']
Usability,// Try to fold an instruction into a simpler one,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp:37,simpl,simpler,37,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,1,['simpl'],['simpler']
Usability,// Try to generate a SimplifyAction describing how to replace our; // IntrinsicInstr with target-generic LLVM IR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:21,Simpl,SimplifyAction,21,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,1,['Simpl'],['SimplifyAction']
Usability,// Try to get the fneg to fold into the source modifier. This undoes generic; // DAG combines and folds them into the mad.; //; // Only do this if we are not trying to support denormals. v_mad_f32 does; // not support denormals ever.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:62,undo,undoes,62,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['undo'],['undoes']
Usability,// Try to handle some simple cases to avoid spilling and reloading every; // value inside a self looping block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:22,simpl,simple,22,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['simpl'],['simple']
Usability,// Try to iteratively fold parts of the index into the base pointer to; // simplify the index as much as possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:75,simpl,simplify,75,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['simpl'],['simplify']
Usability,"// Try to lower with the simpler initial blend/unpack/rotate strategies unless; // one of the input shuffles would be a no-op. We prefer to shuffle inputs as; // the shuffle may be able to fold with a load or other benefit. However, when; // we'll have to do 2x as many shuffles in order to achieve this, a 2-input; // pre-shuffle first is a better strategy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:25,simpl,simpler,25,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simpler']
Usability,// Try to match some simple smax or umax patterns.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:21,simpl,simple,21,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['simpl'],['simple']
Usability,// Try to parse the property accessor:; // https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:102,guid,guide,102,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['guid'],['guide']
Usability,"// Try to perform atomicrmw xchg, otherwise simple exchange.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:44,simpl,simple,44,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['simpl'],['simple']
Usability,"// Try to prove away overflow by looking at ""nearby"" add recurrences. A; // motivating example for this rule: if we know `{0,+,4}` is `ult` `-1` and it; // does not itself wrap then we can conclude that `{1,+,4}` is `nuw`.; //; // Formally:; //; // {S,+,X} == {S-T,+,X} + T; // => Ext({S,+,X}) == Ext({S-T,+,X} + T); //; // If ({S-T,+,X} + T) does not overflow ... (1); //; // RHS == Ext({S-T,+,X} + T) == Ext({S-T,+,X}) + Ext(T); //; // If {S-T,+,X} does not overflow ... (2); //; // RHS == Ext({S-T,+,X}) + Ext(T) == {Ext(S-T),+,Ext(X)} + Ext(T); // == {Ext(S-T)+Ext(T),+,Ext(X)}; //; // If (S-T)+T does not overflow ... (3); //; // RHS == {Ext(S-T)+Ext(T),+,Ext(X)} == {Ext(S-T+T),+,Ext(X)}; // == {Ext(S),+,Ext(X)} == LHS; //; // Thus, if (1), (2) and (3) are true for some T, then; // Ext({S,+,X}) == {Ext(S),+,Ext(X)}; //; // (3) is implied by (1) -- ""(S-T)+T does not overflow"" is simply ""({S-T,+,X}+T); // does not overflow"" restricted to the 0th iteration. Therefore we only need; // to check for (1) and (2).; //; // In the current context, S is `Start`, X is `Step`, Ext is `ExtendOpTy` and T; // is `Delta` (defined below).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:888,simpl,simply,888,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['simpl'],['simply']
Usability,"// Try to remove the previous instruction if it must lead to unreachable.; // This includes instructions like stores and ""llvm.assume"" that may not get; // removed by simple dead code elimination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:167,simpl,simple,167,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simple']
Usability,// Try to replace UseInst with a loop invariant before any other; // simplifications.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:69,simpl,simplifications,69,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,1,['simpl'],['simplifications']
Usability,"// Try to resolve ModuleName in the current header search context and; // verify that it is found in the same module map file as we saved. If the; // top-level AST file is a main file, skip this check because there is no; // usable header search context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:225,usab,usable,225,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['usab'],['usable']
Usability,"// Try to salvage DBG_VALUE instructions from an otherwise empty block. If such; // a basic block is removed we would lose the debug information unless we have; // copied the information to a predecessor/successor.; //; // TODO: This function only handles some simple cases. An alternative would be; // to run a heavier analysis, such as the LiveDebugValues pass, before we do; // branch folding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:261,simpl,simple,261,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['simpl'],['simple']
Usability,// Try to simplify (sext (load x)).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simplify']
Usability,// Try to simplify (sext (sextload x)).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simplify']
Usability,// Try to simplify (xxswap (vec-op (xxswap) (xxswap))) where vec-op is; // lane-insensitive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['simpl'],['simplify']
Usability,// Try to simplify (zext (load x)).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['simpl'],['simplify']
Usability,// Try to simplify (zext (zextload x)).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simplify']
Usability,"// Try to simplify a binop sandwiched between 2 selects with the same; // condition. This is not valid for div/rem because the select might be; // preventing a division-by-zero.; // TODO: A div/rem restriction is conservative; use something like; // isSafeToSpeculativelyExecute().; // select(C, binop(select(C, X, Y), W), Z) -> select(C, binop(X, W), Z)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['simpl'],['simplify']
Usability,// Try to simplify a vector extraction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['simpl'],['simplify']
Usability,// Try to simplify an EXTRACT_VECTOR_ELT from a vector of type VecVT; // producing a result of type ResVT. Op is a possibly bitcast version; // of the input vector and Index is the index (based on type VecVT) that; // should be extracted. Return the new extraction if a simplification; // was possible or if Force is true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,2,['simpl'],"['simplification', 'simplify']"
Usability,"// Try to simplify dupqlane patterns like dupqlane(f32 A, f32 B, f32 A, f32 B); // to dupqlane(f64(C)) where C is A concatenated with B",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['simpl'],['simplify']
Usability,// Try to simplify operations with a constant that may appear after instruction; // selection.; // TODO: See if a frame index with a fixed offset can fold.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,1,['simpl'],['simplify']
Usability,// Try to simplify our new udiv.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,1,['simpl'],['simplify']
Usability,// Try to simplify our new urem.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,1,['simpl'],['simplify']
Usability,// Try to simplify some other binary operator values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['simpl'],['simplify']
Usability,// Try to simplify the CCR and condition code operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,1,['simpl'],['simplify']
Usability,"// Try to simplify the CCR and condition code operands.; // Make sure to not keep references to operands, as combineSetCCCCR can; // RAUW them under us.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,1,['simpl'],['simplify']
Usability,// Try to simplify the EFLAGS and condition code operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplify']
Usability,"// Try to simplify the EFLAGS and condition code operands.; // Make sure to not keep references to operands, as combineSetCCEFLAGS can; // RAUW them under us.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplify']
Usability,// Try to simplify the EFLAGS and condition code operands.; // We can't always do this as FCMOV only supports a subset of X86 cond.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplify']
Usability,"// Try to simplify the branch condition if TC <= VF * UF when preparing to; // execute the plan for the main vector loop. We only do this if the; // terminator is:; // 1. BranchOnCount, or; // 2. BranchOnCond where the input is Not(ActiveLaneMask).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,1,['simpl'],['simplify']
Usability,// Try to simplify the underlying FMul.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['simpl'],['simplify']
Usability,// Try to simplify the underlying FMul. We can only apply simplifications; // that do not require rounding.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,2,['simpl'],"['simplifications', 'simplify']"
Usability,// Try to simplify this by merging 128-bit lanes to enable a lane-based; // shuffle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,5,['simpl'],['simplify']
Usability,"// Try to simplify this by merging 128-bit lanes to enable a lane-based; // shuffle. However, if we have AVX2 and either inputs are already in place,; // we will be able to shuffle even across lanes the other input in a single; // instruction so skip this pattern.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['simpl'],['simplify']
Usability,// Try to simplify to a constant range.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,1,['simpl'],['simplify']
Usability,// Try to simplify to a shift instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,1,['simpl'],['simplify']
Usability,"// Try to simplify:; // t1 = nxv8i16 add(X, 1 << (ShiftValue - 1)); // t2 = nxv8i16 srl(t1, ShiftValue); // to; // t1 = nxv8i16 rshrnb(X, shiftvalue).; // rshrnb will zero the top half bits of each element. Therefore, this combine; // should only be performed when a following instruction with the rshrnb; // as an operand does not care about the top half of each element. For example,; // a uzp1 or a truncating store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['simpl'],['simplify']
Usability,// Try to use constant folding to simplify the binary operator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:34,simpl,simplify,34,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['simpl'],['simplify']
Usability,"// Turn LLVM IR's floating point classes to that in RISC-V,; // by simply rotating the 10-bit immediate right by two bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVLegalizerInfo.cpp:67,simpl,simply,67,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVLegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVLegalizerInfo.cpp,1,['simpl'],['simply']
Usability,"// Turn this into an undef debug value list; right now, the simplest form; // of this is an expression with one arg, and an undef debug operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:60,simpl,simplest,60,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,1,['simpl'],['simplest']
Usability,"// Turn vperm(V1,V2,mask) -> shuffle(V1,V2,mask) if mask is a constant.; // Note that ppc_altivec_vperm has a big-endian bias, so when creating; // a vectorshuffle for little endian, we must undo the transformation; // performed on vec_perm in altivec.h. That is, we must complement; // the permutation mask with respect to 31 and reverse the order of; // V1 and V2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:191,undo,undo,191,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,1,['undo'],['undo']
Usability,// Two decl-specifiers in a row conclusively disambiguate this as being a; // simple-declaration. Don't bother calling isCXXDeclarationSpecifier in the; // overwhelmingly common case that the next token is a '('.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:78,simpl,simple-declaration,78,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['simpl'],['simple-declaration']
Usability,// Two identical types are clearly isomorphic. Remember this; // non-speculatively.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:27,clear,clearly,27,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,1,['clear'],['clearly']
Usability,// Two types with differing kinds are clearly not isomorphic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:38,clear,clearly,38,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,1,['clear'],['clearly']
Usability,"// Type-dependent expressions are always be value-dependent, so we simply drop; // type dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:67,simpl,simply,67,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,1,['simpl'],['simply']
Usability,"// UDivExpr is very likely a UDiv that ScalarEvolution's HowFarToZero or; // HowManyLessThans produced to compute a precise expression, rather than a; // UDiv from the user's code. If we can't find a UDiv in the code with some; // simple searching, we need to account for it's cost.; // At the beginning of this function we already tried to find existing; // value for plain 'S'. Now try to lookup 'S + 1' since it is common; // pattern involving division. This is just a simple search heuristic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:231,simpl,simple,231,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,2,['simpl'],['simple']
Usability,"// UX and UY are in [1, 2^n], where n is the number of digits.; // Check how the max allowed absolute value (2^n for negative, 2^(n-1) for; // positive) divided by an argument compares to the other.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h:3,UX,UX,3,interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h,1,['UX'],['UX']
Usability,// UXTB/UXTH,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:3,UX,UXTB,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,2,['UX'],"['UXTB', 'UXTH']"
Usability,"// Unassigned virtreg is probably in the priority queue.; // RegAllocBase will erase it after dequeueing.; // Nonetheless, clear the live-range so that the debug; // dump will show the right state for that VirtReg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:123,clear,clear,123,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,2,['clear'],['clear']
Usability,"// Unbias length.; // Handle the simple, do-nothing case: strcat(x, """") -> x",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:33,simpl,simple,33,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['simpl'],['simple']
Usability,// Unconditionally resume ZA.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:19,resume,resume,19,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['resume'],['resume']
Usability,"// Undef elements need to fold to 0. It's possible SimplifyDemandedBits; // created an undef input due to no input bits being demanded, but user; // still expects 0 in other bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:51,Simpl,SimplifyDemandedBits,51,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,// Undef operand with no poison min --> 0 (sign bit must be clear),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:60,clear,clear,60,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['clear'],['clear']
Usability,// Undo CRC-32 Init.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CRC.cpp:3,Undo,Undo,3,interpreter/llvm-project/llvm/lib/Support/CRC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CRC.cpp,1,['Undo'],['Undo']
Usability,// Undo CRC-32 XorOut.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CRC.cpp:3,Undo,Undo,3,interpreter/llvm-project/llvm/lib/Support/CRC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CRC.cpp,1,['Undo'],['Undo']
Usability,"// Undo InstCombine canonicalize X * (Y + 1) -> X * Y + X to enable mad; // matching.; // mul x, (add y, 1) -> add (mul x, y), x",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:3,Undo,Undo,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['Undo'],['Undo']
Usability,// Undo already-computed path if it is not unique.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/MissingFrameInferrer.cpp:3,Undo,Undo,3,interpreter/llvm-project/llvm/tools/llvm-profgen/MissingFrameInferrer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/MissingFrameInferrer.cpp,3,['Undo'],['Undo']
Usability,"// Undo compilation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:3,Undo,Undo,3,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,2,['Undo'],['Undo']
Usability,// Undo frame register modification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:3,Undo,Undo,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['Undo'],['Undo']
Usability,"// Undo phi node updates, because they will be added again by SelectionDAG.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp:3,Undo,Undo,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,1,['Undo'],['Undo']
Usability,"// Undo the LSB-preserving shift performed by QuantizeReals",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:3,Undo,Undo,3,tree/ntuple/v7/src/RColumnElement.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx,1,['Undo'],['Undo']
Usability,"// Undo the combine foldFreeOpFromSelect does if it helps us match the; // fmin/fmax.; //; // select (fcmp olt (lhs, K)), (fneg lhs), -K; // -> fneg (fmin_legacy lhs, K); //; // TODO: Use getNegatedExpression",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:3,Undo,Undo,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['Undo'],['Undo']
Usability,// Undo the opaque value mapping.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:3,Undo,Undo,3,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['Undo'],['Undo']
Usability,"// Undo these various manglings for Win32 extern ""C"" functions:; // cdecl - _foo; // stdcall - _foo@12; // fastcall - @foo@12; // vectorcall - foo@@12; // These are all different linkage names for 'foo'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/Symbolize.cpp:3,Undo,Undo,3,interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/Symbolize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/Symbolize.cpp,1,['Undo'],['Undo']
Usability,"// Undo-Button",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geombuilder/inc/TGeoBBoxEditor.h:3,Undo,Undo-Button,3,geom/geombuilder/inc/TGeoBBoxEditor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geombuilder/inc/TGeoBBoxEditor.h,13,['Undo'],['Undo-Button']
Usability,// Undocumented software feature.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Undo,Undocumented,3,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['Undo'],['Undocumented']
Usability,"// Unfortunately, the Instruction Set Architecture Reference Guide is; // misleading about how the inline operands work for (packed) 16-bit; // instructions. In a nutshell, the actual HW behavior is:; //; // - integer encodings (-16 .. 64) are always produced as sign-extended; // 32-bit values; // - float encodings are produced as:; // - for F16 instructions: corresponding half-precision float values in; // the LSBs, 0 in the MSBs; // - for UI16 instructions: corresponding single-precision float value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp:61,Guid,Guide,61,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp,1,['Guid'],['Guide']
Usability,"// Unique ""simple"" summaries -- those without ArgEffects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:11,simpl,simple,11,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,1,['simpl'],['simple']
Usability,// Unit clauses that were added later were not; // considered for the simplification of earlier clauses. Do a final; // pass to find more opportunities for simplification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:70,simpl,simplification,70,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,2,['simpl'],['simplification']
Usability,"// Unless a specific value is passed to invalidation, completely clear both; // caches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:65,clear,clear,65,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['clear'],['clear']
Usability,"// Unless the macro indicates that the intended type is clearly not; // a pointer type, we should avoid warning on comparing pointers; // to zero literals in non-pedantic mode.; // FIXME: Introduce an AST matcher to implement the macro-related logic?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:56,clear,clearly,56,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,1,['clear'],['clearly']
Usability,"// Unlike loads, we never try to eliminate stores, so we do not check if they; // are simple and avoid value numbering them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:86,simpl,simple,86,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['simpl'],['simple']
Usability,"// Unpack argument packs, which we translate them into separate; // arguments.; // FIXME: We could do much better if we could guarantee that the; // TemplateArgumentLocInfo for the pack expansion would be usable for; // all of the template arguments in the argument pack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:205,usab,usable,205,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['usab'],['usable']
Usability,"// UnparsedFiles has been processed now, so clear it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp:44,clear,clear,44,interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/VerifyDiagnosticConsumer.cpp,1,['clear'],['clear']
Usability,"// Unused constrained FP intrinsic calls may have declared side effect, which; // prevents it from being removed. In some cases however the side effect is; // actually absent. To detect this case, call SimplifyConstrainedFPCall. If it; // returns a replacement, the call may be removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:202,Simpl,SimplifyConstrainedFPCall,202,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['Simpl'],['SimplifyConstrainedFPCall']
Usability,// Unwind Resume Block,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:10,Resume,Resume,10,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,1,['Resume'],['Resume']
Usability,// Update Dominance from simplified New instruction operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:25,simpl,simplified,25,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['simpl'],['simplified']
Usability,// Update GUIDToFuncNameMap for each function including inlinees.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:10,GUID,GUIDToFuncNameMap,10,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['GUID'],['GUIDToFuncNameMap']
Usability,// Update flags after simplifying an operand based on the fact that some high; // order bits are not demanded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:22,simpl,simplifying,22,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['simpl'],['simplifying']
Usability,"// Update ids on the allocation nodes before calling the recursive; // update along caller edges, since this simplifies the logic during; // that traversal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:109,simpl,simplifies,109,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['simpl'],['simplifies']
Usability,// Update the cache of affected values for this assumption (we might be; // here because we just simplified the condition).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:97,simpl,simplified,97,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['simpl'],['simplified']
Usability,// Update the edge to point directly to the correct GUID.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:52,GUID,GUID,52,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['GUID'],['GUID']
Usability,"// Update the internal state of the advisor, and force invalidate feature; // analysis. Currently, we maintain minimal (and very simple) global state - the; // number of functions and the number of static calls. We also keep track of the; // total IR size in this module, to stop misbehaving policies at a certain bloat; // factor (SizeIncreaseThreshold)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:129,simpl,simple,129,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,1,['simpl'],['simple']
Usability,"// Update the linkage name to reflect the modified symbol name. It; // is necessary to update the linkage name in Swift, since the; // mangling changes for resume functions. It might also be the; // right thing to do in C++, but due to a limitation in LLVM's; // AsmPrinter we can only do this if the function doesn't have an; // abstract specification, since the DWARF backend expects the; // abstract specification to contain the linkage name and asserts; // that they are identical.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:156,resume,resume,156,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['resume'],['resume']
Usability,// Update the location type for simple ones.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp:32,simpl,simple,32,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp,1,['simpl'],['simple']
Usability,// Update the operand if we found a register with better clearance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:57,clear,clearance,57,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,1,['clear'],['clearance']
Usability,"// Update the ring buffer. Top byte of ThreadLong defines the size of the; // buffer in pages, it must be a power of two, and the start of the buffer; // must be aligned by twice that much. Therefore wrap around of the ring; // buffer is simply Addr &= ~((ThreadLong >> 56) << 12).; // The use of AShr instead of LShr is due to; // https://bugs.llvm.org/show_bug.cgi?id=39030; // Runtime library makes sure not to use the highest bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:238,simpl,simply,238,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,1,['simpl'],['simply']
Usability,"// Update the terminator of PredBB to jump to NewBB instead of BB. This; // eliminates predecessors from BB, which requires us to simplify any PHI; // nodes in BB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:130,simpl,simplify,130,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['simpl'],['simplify']
Usability,"// Update the terminator of PredPredBB to jump to NewBB instead of PredBB.; // This eliminates predecessors from PredPredBB, which requires us to simplify; // any PHI nodes in PredBB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:146,simpl,simplify,146,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['simpl'],['simplify']
Usability,"// Usable locations are valid with non-zero line numbers. A line number of zero; // corresponds to optimized code that doesn't have a distinct source location.; // In this case, we try to use the previous or next source location depending on; // the context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:3,Usab,Usable,3,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['Usab'],['Usable']
Usability,"// Usage of TBranch in ClearMustCleanupBits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:23,Clear,ClearMustCleanupBits,23,tree/tree/src/InternalTreeUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx,1,['Clear'],['ClearMustCleanupBits']
Usability,// Use BFI to guide register promotion,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation.h:14,guid,guide,14,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation.h,1,['guid'],['guide']
Usability,// Use FoldSetCC to simplify SETCC's.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:20,simpl,simplify,20,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['simpl'],['simplify']
Usability,"// Use LUI+ADDI or LUI to compose, then clear the upper 32 bits with; // SLLI_UW.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp:40,clear,clear,40,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVMatInt.cpp,1,['clear'],['clear']
Usability,"// Use SHUFPS for the permute so this will work on SSE2 targets,; // shuffle combining and domain handling will simplify this later on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:112,simpl,simplify,112,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplify']
Usability,// Use Scalar Evolution to compute the trip count. This allows more loops to; // be unrolled than relying on induction var simplification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:123,simpl,simplification,123,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,1,['simpl'],['simplification']
Usability,// Use a CopyFromReg WZR/XZR here to prevent; // DAGCombiner::MergeConsecutiveStores from undoing this transformation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:90,undo,undoing,90,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['undo'],['undoing']
Usability,"// Use a dedicated, simpler path for diagnostics without a valid location.; // This is important as if the location is missing, we may be emitting; // diagnostics in a context that lacks language options, a source manager, or; // other infrastructure necessary when emitting more rich diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp:20,simpl,simpler,20,interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnosticPrinter.cpp,2,['simpl'],['simpler']
Usability,"// Use a simple length-based heuristic to determine the minimum possible; // edit distance. If the minimum isn't good enough, bail out early.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:9,simpl,simple,9,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['simpl'],['simple']
Usability,// Use a simpler loop when values don't need destruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:9,simpl,simpler,9,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,1,['simpl'],['simpler']
Usability,"// Use a very simple parse step that dectect whether the name search (which; // is already supposed to be an unqualified name) is a simple identifier,; // a constructor name or a destructor name. In those 3 cases, we can easily; // create the UnqualifiedId object that would have resulted from the 'real'; // parse. By using this direct creation of the UnqualifiedId, we avoid the; // 'permanent' cost associated with creating a memory buffer and the; // associated FileID.; // If the name is a template or an operator, we revert to the regular parse; // (and its associated permanent cost).; // In the operator case, the additional work is in the case of a conversion; // operator where we would need to 'quickly' parse the type itself (if want; // to avoid the permanent cost).; // In the case with the template the problem gets a bit worse as we need to; // handle potentially arbitrary spaces and ordering; // ('const int' vs 'int const', etc.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp:14,simpl,simple,14,interpreter/cling/lib/Interpreter/LookupHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp,2,['simpl'],['simple']
Usability,"// Use a worklist to perform a depth-first search of OldSucc's successors.; // NOTE: We do not need a visited list since any blocks we have already; // visited will have had their overdefined markers cleared already, and we; // thus won't loop to their successors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:200,clear,cleared,200,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['clear'],['cleared']
Usability,"// Use bitfield extract on the lower 32-bit source, and then sign-extend; // or clear the upper 32-bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:80,clear,clear,80,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['clear'],['clear']
Usability,// Use masked off lanes to simplify operands via SimplifyDemandedVectorElts,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:27,simpl,simplify,27,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,4,"['Simpl', 'simpl']","['SimplifyDemandedVectorElts', 'simplify']"
Usability,// Use simple DJB2 hash,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h:7,simpl,simple,7,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h,1,['simpl'],['simple']
Usability,"// Use simplification to find potential callees, if !callees was present,; // fallback to that set if necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:7,simpl,simplification,7,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['simpl'],['simplification']
Usability,// Use the regular scalar folding to simplify this column.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:37,simpl,simplify,37,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['simpl'],['simplify']
Usability,// Use vpxord to clear the full ymm/zmm register.; // It wants to read and write the xmm sub-register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:17,clear,clear,17,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['clear'],['clear']
Usability,// Use vxorps to clear the full ymm register.; // It wants to read and write the xmm sub-register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:17,clear,clear,17,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['clear'],['clear']
Usability,// Use zeros for the widening if we already have some zeroes. This can; // allow SimplifyDemandedBits to remove scalar ANDs that may be down; // stream of this.; // FIXME: It might make sense to detect a concat_vectors with a mix of; // zeroes and undef and turn it into insert_subvector for i1 vectors as; // a separate combine. What we can't do is canonicalize the operands of; // such a concat or we'll get into a loop with SimplifyDemandedBits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:81,Simpl,SimplifyDemandedBits,81,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['Simpl'],['SimplifyDemandedBits']
Usability,"// Used to control the need to emit .generic() in the initializer of; // module scope variables.; // Although ptx supports the hybrid mode like the following,; // .global .u32 a;; // .global .u32 b;; // .global .u32 addr[] = {a, generic(b)}; // we have difficulty representing the difference in the NVVM IR.; //; // Since the address value should always be generic in CUDA C and always; // be specific in OpenCL, we use this simple control here.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h:425,simpl,simple,425,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.h,1,['simpl'],['simple']
Usability,// User intent isn't clear if they're mixing int literals with enum; // constants.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:21,clear,clear,21,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['clear'],['clear']
Usability,// User-defined CTAD guides.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SaveAndRestore.h:21,guid,guides,21,interpreter/llvm-project/llvm/include/llvm/Support/SaveAndRestore.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SaveAndRestore.h,1,['guid'],['guides']
Usability,// Userspace can simply do OR (tag << PointerTagShift);,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:17,simpl,simply,17,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,1,['simpl'],['simply']
Usability,"// Usually the return expression is evaluated before the cleanup; // code. If the function contains only a simple return statement,; // such as a constant, the location before the cleanup code becomes; // the last useful breakpoint in the function, because the simple; // return expression will be evaluated after the cleanup code. To be; // safe, set the debug location for cleanup code to the location of; // the return statement. Otherwise the cleanup code should be at the; // end of the function's lexical scope.; //; // If there are multiple branches to the return block, the branch; // instructions will get the location of the return statements and; // all will be fine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:107,simpl,simple,107,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,2,['simpl'],['simple']
Usability,"// Usually we can simply apply the ImplicitConversionSequence we formed; // earlier, but that's not guaranteed to work when initializing an object of; // class type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:18,simpl,simply,18,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['simpl'],['simply']
Usability,// V clear,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:5,clear,clear,5,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['clear'],['clear']
Usability,"// V is a predecessor of W. eval() returns V if V < W, otherwise the minimum; // of sdom(U), where U > W and there is a virtual forest path from U to V. The; // virtual forest consists of linked edges of processed vertices.; //; // We can follow Parent pointers (virtual forest edges) to determine the; // ancestor U with minimum sdom(U). But it is slow and thus we employ the path; // compression technique to speed up to O(m*log(n)). Theoretically the virtual; // forest can be organized as balanced trees to achieve almost linear; // O(m*alpha(m,n)) running time. But it requires two auxiliary arrays (Size; // and Child) and is unlikely to be faster than the simple implementation.; //; // For each vertex V, its Label points to the vertex with the minimal sdom(U); // (Semi) in its path from V (included) to NodeToInfo[V].Parent (excluded).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h:663,simpl,simple,663,interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,1,['simpl'],['simple']
Usability,// VECTOR LOAD (RIGHTMOST) WITH LENGTH with a length operand of 15; // or larger is simply a vector load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:84,simpl,simply,84,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['simpl'],['simply']
Usability,"// VLIWPacketizerList implements a simple VLIW packetizer using DFA. The; // packetizer works on machine basic blocks. For each instruction I in BB,; // the packetizer consults the DFA to see if machine resources are available; // to execute I. If so, the packetizer checks if I depends on any instruction; // in the current packet. If no dependency is found, I is added to current; // packet and the machine resource is marked as taken. If any dependency is; // found, a target API call is made to prune the dependence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:35,simpl,simple,35,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,1,['simpl'],['simple']
Usability,// Valid C# attribute targets:; // https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/#attribute-targets,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp:94,guid,guide,94,interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,1,['guid'],['guide']
Usability,// Validate GUID length.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:12,GUID,GUID,12,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['GUID'],['GUID']
Usability,"// ValueToValueMapTy is neither copy nor moveable, so we use a simple array; // here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp:63,simpl,simple,63,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CallSiteSplitting.cpp,1,['simpl'],['simple']
Usability,// Variables always have simple names.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp:25,simpl,simple,25,interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/USRGeneration.cpp,1,['simpl'],['simple']
Usability,"// Variadic arguments.; //; // Normally, for each argument, we declare a param scalar or a param; // byte array in the .param space, and store the argument value to that; // param scalar or array starting at offset 0.; //; // In the case of the first variadic argument, we declare a vararg byte array; // with size 0. The exact size of this array isn't known at this point, so; // it'll be patched later. All the variadic arguments will be stored to this; // array at a certain offset (which gets tracked by 'VAOffset'). The offset is; // initially set to 0, so it can be used for non-variadic arguments (which use; // 0 offset) to simplify the code.; //; // After all vararg is processed, 'VAOffset' holds the size of the; // vararg byte array.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:632,simpl,simplify,632,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['simpl'],['simplify']
Usability,"// Variants are ordered by layout-A/layout-B/satf, where 'row' has priority; // over 'col' for layout. The index of non-satf variants is expected to match; // the undocumented layout constants used by CUDA's mma.hpp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:163,undo,undocumented,163,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['undo'],['undocumented']
Usability,// Vector multiply by pow2 will be simplified to shifts.; // Vector multiply by -pow2 will be simplified to shifts/negates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:35,simpl,simplified,35,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,2,['simpl'],['simplified']
Usability,// Vector unsigned division/remainder will be simplified to shifts/masks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:46,simpl,simplified,46,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['simpl'],['simplified']
Usability,// Vectors are simple.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:15,simpl,simple,15,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['simpl'],['simple']
Usability,"// Verify stack map entry. It's better to communicate a problem to the; // runtime than crash in case of in-process compilation. Currently, we do; // simple overflow checks, but we may eventually communicate other; // compilation errors this way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp:150,simpl,simple,150,interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMaps.cpp,1,['simpl'],['simple']
Usability,"// Verify that any decl statements were handled as simple, they may be in; // scope of subsequent reachable statements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp:51,simpl,simple,51,interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,1,['simpl'],['simple']
Usability,"// Verify that the combination of GenTypes in a signature is supported.; // To simplify the logic for creating overloads in SemaLookup, only allow; // a signature to contain different GenTypes if these GenTypes represent; // the same number of actual scalar or vector types.; //; // Exit with a fatal error if an unsupported construct is encountered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:79,simpl,simplify,79,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,1,['simpl'],['simplify']
Usability,// Verify that the initializer is simple enough for us to handle. We are; // only allowed to optimize the initializer if it is unique.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp:34,simpl,simple,34,interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp,1,['simpl'],['simple']
Usability,"// Verify that we have a simple digit-sequence, and compute the value. This; // is always a simple digit string computed in decimal, so we do this manually; // here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:25,simpl,simple,25,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,2,['simpl'],['simple']
Usability,// Verify this is a simple bswap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp:20,simpl,simple,20,interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IntrinsicLowering.cpp,1,['simpl'],['simple']
Usability,"// Verify we have a legal type before going any further. Currently, we handle; // simple types that will directly fit in a register (i32/f32/i64/f64) or; // those that can be sign or zero-extended to a basic operation (i1/i8/i16).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:82,simpl,simple,82,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,2,['simpl'],['simple']
Usability,"// Version 17.6, with updated doxygen comments and bug-fixes in TUnfoldBinning; // Version 17.5, bug fix in TUnfold also corrects GetEmatrixSysUncorr(); // Version 17.4, in parallel to changes in TUnfoldBinning; // Version 17.3, in parallel to changes in TUnfoldBinning; // Version 17.2, with new options 'N' and 'c' for axis regularisation steering; // Version 17.1, add scan type RhoSquare, small bug fixes with useAxisBinning; // Version 17.0, support for density regularisation, complex binning schemes, tau scan; /** \class TUnfoldDensity; An algorithm to unfold distributions from detector to truth level. TUnfoldDensity is used to decompose a measurement y into several sources x,; given the measurement uncertainties, background b and a matrix of migrations A.; The method can be applied to a large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Beyond such a simple template fit,; TUnfoldDensity has an adjustable regularisation term and also supports an; optional constraint on the total number of events.; Background sources can be specified, with a normalisation constant and; normalisation uncertainty. In addition, variants of the response; matrix may be specified, these are taken to determine systematic; uncertainties. Complex, multidimensional arrangements of signal and; background bins are managed with the help of the class TUnfoldBinning. If you use this software, please consider the following citation; <br/>; <b>S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]</b>; <br/>; Detailed documentation and updates are available on; http://www.desy.de/~sschmitt. <h3>Brief recipy to use TUnfoldSys:</h3>; <ul>; <li>Set up binning schemes for the truth and measured; distributions. The binning schemes may be coded in the XML language,; for reading use TUnfoldBinningXML.</li>; <li>A matrix (truth,reconstructed) is given as a two-dimensional histogram; as argument to the constructor of TUnfold</li>; <li>A vector ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldDensity.cxx:1167,simpl,simple,1167,hist/unfold/src/TUnfoldDensity.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldDensity.cxx,1,['simpl'],['simple']
Usability,// Very nice and simple skew factor for 3D,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs:17,simpl,simple,17,js/modules/three_addons.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs,1,['simpl'],['simple']
Usability,"// Very nice and simple unskew factor, too",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs:17,simpl,simple,17,js/modules/three_addons.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs,1,['simpl'],['simple']
Usability,"// Visit all instructions in the given basic block and try to simplify; // it. We don't change the actual IR, just count optimization; // opportunities.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:62,simpl,simplify,62,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['simpl'],['simplify']
Usability,// Visit implicit @synthesize property implementations first as their; // location is reported at the name of the @implementation block. This; // serves no purpose other than to simplify the FileCheck-based tests.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp:178,simpl,simplify,178,interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Index/IndexDecl.cpp,1,['simpl'],['simplify']
Usability,// Visiting in a pre-order depth-first traversal causes us to simplify early; // blocks before querying later blocks (which require us to analyze early; // blocks). Eagerly simplifying shallow blocks means there is strictly less; // work to do for deep blocks. This also means we don't visit unreachable; // blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:62,simpl,simplify,62,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,2,['simpl'],"['simplify', 'simplifying']"
Usability,// WARNING: This reservoir size value is propagated to any input indexed; // profiles for simplicity. Changing this value between invocations could; // result in sample bias.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp:90,simpl,simplicity,90,interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,1,['simpl'],['simplicity']
Usability,// WARNING: keep in sync with SimplifyCFGOpt::simplifyUnreachable()!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:30,Simpl,SimplifyCFGOpt,30,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,2,"['Simpl', 'simpl']","['SimplifyCFGOpt', 'simplifyUnreachable']"
Usability,"// WARNING: no matter how worthwhile it may seem, we can not perform PHI CSE; // here, because the PHI we may succeed simplifying to was not; // def-reachable from the original PHI!; // If all of the PHI's incoming values are the same then replace the PHI node; // with the common value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:118,simpl,simplifying,118,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifying']
Usability,"// WVE - interim solution - fix proxies here; //_proxyList.Clear() ;; //registerProxy(_pdfObsList) ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHistPdf.cxx:59,Clear,Clear,59,roofit/roofitcore/src/RooHistPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHistPdf.cxx,1,['Clear'],['Clear']
Usability,// Wait for dispatcher to clear.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp:26,clear,clear,26,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/SimpleRemoteEPCServer.cpp,1,['clear'],['clear']
Usability,"// Walk the GUIDs that were referenced, and write the; // corresponding type id records.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:12,GUID,GUIDs,12,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,1,['GUID'],['GUIDs']
Usability,"// Walk the worklist from front to back, pushing newly found sub loops onto; // the back. This will let us process loops from back to front in depth-first; // order. We can use this simple process because loops form a tree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:182,simpl,simple,182,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,1,['simpl'],['simple']
Usability,"// Walk through the operands of a given User via worklist iteration and populate; // the set of GlobalValue references encountered. Invoked either on an; // Instruction or a GlobalVariable (which walks its initializer).; // Return true if any of the operands contains blockaddress. This is important; // to know when computing summary for global var, because if global variable; // references basic block address we can't import it separately from function; // containing that basic block. For simplicity we currently don't import such; // global vars at all. When importing function we aren't interested if any; // instruction in it takes an address of any basic block, because instruction; // can only take an address of basic block located in the same function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:494,simpl,simplicity,494,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,1,['simpl'],['simplicity']
Usability,"// Walk up the stack to determine whether we can capture the variable,; // performing the ""simple"" checks that don't depend on type. We stop when; // we've either hit the declared scope of the variable or find an existing; // capture of that variable. We start from the innermost capturing-entity; // (the DC) and ensure that all intervening capturing-entities; // (blocks/lambdas etc.) between the innermost capturer and the variable`s; // declcontext can either capture the variable or have already captured; // the variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:91,simpl,simple,91,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['simpl'],['simple']
Usability,"// Warn about Monte-Carlo event with zero distance; // this happens when this query event is also in learning sample",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodKNN.cxx:101,learn,learning,101,tmva/tmva/src/MethodKNN.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodKNN.cxx,1,['learn'],['learning']
Usability,"// Warn about retain cycles where a block captures the LHS, but; // not if the LHS is a simple variable into which the block is; // being stored...unless that variable can be captured by reference!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:88,simpl,simple,88,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['simpl'],['simple']
Usability,// Warn if CTAD was used on a type that does not have any user-defined; // deduction guides.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:85,guid,guides,85,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['guid'],['guides']
Usability,// Warn on any volatile-qualified simple-assignments that are not discarded-; // value expressions nor unevaluated operands (those cases get removed from; // this list by CheckUnusedVolatileAssignment).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:34,simpl,simple-assignments,34,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['simpl'],['simple-assignments']
Usability,"// WasmEHFuncInfo contains a map of <catchpad, its next unwind destination>,; // which means, if an exception is not caught by the catchpad, it should end; // up in the next unwind destination stored in this data structure. (It is; // written as catchswitch's 'unwind' destination in ll files.) The below is an; // intuitive example of their relationship in C++ code:; // try {; // try {; // } catch (int) { // catchpad; // ... // this catch (int) { ... } is grouped as an exception; // }; // } catch (...) { // next unwind destination; // }; // (The example is try-catches for illustration purpose, but the unwind; // destination can be also a cleanuppad generated by destructor calls.) So the; // unwind destination is in the outside of the catchpad's exception.; //; // We group exceptions in this analysis simply by including all BBs dominated; // by an EH pad. But in case the EH pad's unwind destination does not have any; // children outside of the exception, that unwind destination ends up also; // being dominated by the EH pad and included in the exception, which is not; // semantically correct, because it unwinds/rethrows into an inner scope.; //; // Here we extract those unwind destinations from their (incorrect) parent; // exception. Note that the unwind destinations may not be an immediate; // children of the parent exception, so we have to traverse the parent chain.; //; // We should traverse BBs in the preorder of the dominator tree, because; // otherwise the result can be incorrect. For example, when there are three; // exceptions A, B, and C and A > B > C (> is subexception relationship here),; // and A's unwind destination is B and B's is C. When we visit B before A, we; // end up extracting C only out of B but not out of A.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExceptionInfo.cpp:315,intuit,intuitive,315,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExceptionInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyExceptionInfo.cpp,2,"['intuit', 'simpl']","['intuitive', 'simply']"
Usability,// We actually see shuffles that are entirely re-arrangements of a set of; // zero inputs. This mostly happens while decomposing complex shuffles into; // simple ones. Directly lower these as a buildvector of zeros.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:155,simpl,simple,155,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simple']
Usability,"// We allow catchswitch unwind to caller to nest; // within an outer pad that unwinds somewhere else,; // because catchswitch doesn't have a nounwind variant.; // See e.g. SimplifyCFGOpt::SimplifyUnreachable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:172,Simpl,SimplifyCFGOpt,172,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,2,['Simpl'],"['SimplifyCFGOpt', 'SimplifyUnreachable']"
Usability,// We allow simple+cst.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:12,simpl,simple,12,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,1,['simpl'],['simple']
Usability,"// We already checked simple implication in InstSimplify, only handle complex; // cases here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:22,simpl,simple,22,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['simpl'],['simple']
Usability,// We also have to update the final source mask in this case because; // it may need to undo the above swap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:88,undo,undo,88,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['undo'],['undo']
Usability,// We also need to null out the inner AM so that when the object gets; // destroyed as invalid we don't try to clear the inner AM again. At that; // point we won't be able to reliably walk the loops for this function and; // only clear results associated with those loops the way we do here.; // FIXME: Making InnerAM null at this point isn't very nice. Most analyses; // try to remain valid during invalidation. Maybe we should add an; // `IsClean` flag?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp:111,clear,clear,111,interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAnalysisManager.cpp,2,['clear'],['clear']
Usability,// We also need to undo another guard that checks for libc++ 3.8+,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:19,undo,undo,19,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,1,['undo'],['undo']
Usability,"// We also track the estimated dynamic (that is, actually executed) cost in; // the rolled form. This helps identify cases when the savings from unrolling; // aren't just exposing dead control flows, but actual reduced dynamic; // instructions due to the simplifications which we expect to occur after; // unrolling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:255,simpl,simplifications,255,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['simpl'],['simplifications']
Usability,// We always have to clear the QNaN bit to make it an SNaN.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:21,clear,clear,21,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['clear'],['clear']
Usability,"// We are applying the transformation; // Invoke instructions are special in that their result value is not; // available along their unwind edge. The code below tests to see whether; // DomBB dominates the value, so adjust DomBB to the normal destination; // block, which is effectively where the value is first usable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:313,usab,usable,313,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,1,['usab'],['usable']
Usability,"// We are clearing high bits that were potentially set by sext+ashr:; // and (sext (ashr X, ShiftC)), C --> lshr (sext X), ShiftC",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:10,clear,clearing,10,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['clear'],['clearing']
Usability,// We are going to resume the execution of the scalar loop.; // Go over all of the induction variables that we found and fix the; // PHIs that are left in the scalar version of the loop.; // The starting values of PHI nodes depend on the counter of the last; // iteration in the vectorized loop.; // If we come from a bypass edge then we need to start from the original; // start value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,resume,resume,19,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['resume'],['resume']
Usability,"// We are going to spill SrcVNI immediately after its def, so clear out; // any later spills of the same value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:62,clear,clear,62,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['clear'],['clear']
Usability,// We are interested in instructions that copy values to ACC/UACC.; // The copy into UACC will be simply a COPY to a subreg so we; // want to allocate the corresponding physical subreg for the source.; // The copy into ACC will be a BUILD_UACC so we want to allocate; // the same number UACC for the source.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:98,simpl,simply,98,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,1,['simpl'],['simply']
Usability,"// We are looking for a i64 add of a VADDLVx. Due to these being i64's, this; // will look like:; // t1: i32,i32 = ARMISD::VADDLVs x; // t2: i64 = build_pair t1, t1:1; // t3: i64 = add t2, y; // Otherwise we try to push the add up above VADDLVAx, to potentially allow; // the add to be simplified seperately.; // We also need to check for sext / zext and commutitive adds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:286,simpl,simplified,286,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['simpl'],['simplified']
Usability,"// We are looking for loops that do something like this:; // int r = 0;; // for (int i = 0; i < n; i++) {; // if (src[i] > 3); // r = 3;; // }; // where the reduction value (r) only has two states, in this example 0 or 3.; // The generated LLVM IR for this type of loop will be like this:; // for.body:; // %r = phi i32 [ %spec.select, %for.body ], [ 0, %entry ]; // ...; // %cmp = icmp sgt i32 %5, 3; // %spec.select = select i1 %cmp, i32 3, i32 %r; // ...; // In general we can support vectorization of loops where 'r' flips between; // any two non-constants, provided they are loop invariant. The only thing; // we actually care about at the end of the loop is whether or not any lane; // in the selected vector is different from the start value. The final; // across-vector reduction after the loop simply involves choosing the start; // value if nothing changed (0 in the example above) or the other selected; // value (3 in the example above).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:803,simpl,simply,803,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,1,['simpl'],['simply']
Usability,"// We are now only returning a simple value, so just return the; // extracted value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:31,simpl,simple,31,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,1,['simpl'],['simple']
Usability,"// We are only setting the function proxy now that it's clear if it's a value; // server or not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:56,clear,clear,56,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['clear'],['clear']
Usability,"// We are storing the pointer into a memory location, potentially escaping.; // As an optimization, we try to detect simple cases where it doesn't; // actually escape, for example:; // %ptr = alloca ..; // %addr = alloca ..; // store %ptr, %addr; // %x = load %addr; // ..; // If %addr is only used by loading from it, we could simply treat %x as; // another alias of %ptr, and not considering %ptr being escaped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:117,simpl,simple,117,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,2,['simpl'],"['simple', 'simply']"
Usability,// We are trying to parse a simple-type-specifier but might not get such; // a token after error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:28,simpl,simple-type-specifier,28,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['simpl'],['simple-type-specifier']
Usability,// We assume VLENB is a multiple of 8. We manually choose the best shift; // here because SimplifyDemandedBits isn't always able to simplify it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:90,Simpl,SimplifyDemandedBits,90,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,"['Simpl', 'simpl']","['SimplifyDemandedBits', 'simplify']"
Usability,// We assume only one text segment in the main binary for simplicity and; // reduce the overhead of checking multiple ranges during symbolization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp:58,simpl,simplicity,58,interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,2,['simpl'],['simplicity']
Usability,"// We assume this is supposed to correspond to a C++0x-style; // sequentially-consistent fence (i.e. this is only usable for; // synchronization, not device I/O or anything like that). This intrinsic; // is really badly designed in the sense that in theory, there isn't; // any way to safely use it... but in practice, it mostly works; // to use it with non-atomic loads and stores to get acquire/release; // semantics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:114,usab,usable,114,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['usab'],['usable']
Usability,"// We calculate the interleave count using the following formula.; // Subtract the number of loop invariants from the number of available; // registers. These registers are used by all of the interleaved instances.; // Next, divide the remaining registers by the number of registers that is; // required by the loop, in order to estimate how many parallel instances; // fit without causing spills. All of this is rounded down if necessary to be; // a power of two. We want power of two interleave count to simplify any; // addressing operations or alignment considerations.; // We also want power of two interleave counts to ensure that the induction; // variable of the vector loop wraps to zero, when tail is folded by masking;; // this currently happens when OptForSize, in which case IC is set to 1 above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:506,simpl,simplify,506,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['simpl'],['simplify']
Usability,// We can choose any index value here and be correct because all elements; // are undefined. Return 0 for better potential for callers to simplify.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:138,simpl,simplify,138,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['simpl'],['simplify']
Usability,"// We can delta-update module-wide features. We know the inlining only changed; // the caller, and maybe the callee (by deleting the latter).; // Nodes are simple to update.; // For edges, we 'forget' the edges that the caller and callee used to have; // before inlining, and add back what they currently have together.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:156,simpl,simple,156,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,1,['simpl'],['simple']
Usability,// We can do this simplification if any comparisons fold to true or false.; // See if any do.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:18,simpl,simplification,18,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['simpl'],['simplification']
Usability,"// We can eliminate RLDICL (e.g. for zero-extension); // if all bits to clear are already zero in the input.; // This code assume following code sequence for zero-extension.; // %6 = COPY %5:sub_32; (optional); // %8 = IMPLICIT_DEF;; // %7<def,tied1> = INSERT_SUBREG %8<tied0>, %6, sub_32;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:72,clear,clear,72,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['clear'],['clear']
Usability,// We can eliminate RLDICL/RLDICR if it's used to clear bits and all; // bits cleared will be ANDed with 0 by ANDI_rec/ANDIS_rec.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:50,clear,clear,50,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,2,['clear'],"['clear', 'cleared']"
Usability,"// We can eliminate in favor of non-simple loads, but we won't be able to; // eliminate the loads themselves.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:36,simpl,simple,36,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['simpl'],['simple']
Usability,"// We can fold the conditional branch in the preheader, this makes things; // simpler. The first step is to remove the extra edge to the Exit block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:78,simpl,simpler,78,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,1,['simpl'],['simpler']
Usability,// We can form DeclRefExprs naming GUID declarations when reconstituting; // non-type template parameters into expressions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:35,GUID,GUID,35,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['GUID'],['GUID']
Usability,// We can handle fixed length vector bitcasts with a simple replacement; // in isel.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:53,simpl,simple,53,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['simpl'],['simple']
Usability,"// We can have more than one local with the same GUID, in the case of; // same-named locals in different but same-named source files that were; // compiled in their respective directories (so the source file name; // and resulting GUID is the same). Find the one in this module.; // Handle the case where there is no summary found in this module. That; // can happen in the distributed ThinLTO backend, because the index only; // contains summaries from the source modules if they are being imported.; // We might have a non-null VI and get here even in that case if the name; // matches one in this module (e.g. weak or appending linkage).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:49,GUID,GUID,49,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,2,['GUID'],['GUID']
Usability,"// We can merge the two given cases into a single SCEV statement,; // incase n = m, the mul expression will be 2^0, so it gets resolved to; // a simpler case. The following code handles the two cases:; //; // 1) For a two-shift sext-inreg, i.e. n = m,; // use sext(trunc(x)) as the SCEV expression.; //; // 2) When n > m, use sext(mul(trunc(x), 2^(n-m)))) as the SCEV; // expression. We already checked that ShlAmt < BitWidth, so; // the multiplier, 1 << (ShlAmt - AShrAmt), fits into TruncTy as; // ShlAmt - AShrAmt < Amt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:145,simpl,simpler,145,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['simpl'],['simpler']
Usability,// We can move record nodes across simple predicates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcher.cpp:35,simpl,simple,35,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcher.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcher.cpp,1,['simpl'],['simple']
Usability,// We can move simple predicates before record nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcher.cpp:15,simpl,simple,15,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcher.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcher.cpp,1,['simpl'],['simple']
Usability,"// We can not forward declared nested classes (well we might be able to do so for; // the one nested in a namespace but it is not clear yet if we can really reliably; // find this information)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProxyGenerator.cxx:130,clear,clear,130,tree/treeplayer/src/TTreeProxyGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProxyGenerator.cxx,1,['clear'],['clear']
Usability,"// We can only have 'explicit' on a constructor, conversion function, or; // deduction guide. The declarator of a deduction guide cannot be; // parenthesized, so we know this isn't a deduction guide. So the only; // thing we need to check for is some number of parens followed by either; // the current class name or 'operator'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:87,guid,guide,87,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,3,['guid'],['guide']
Usability,// We can only simplify expressions whose RHS is an integer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp:15,simpl,simplify,15,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,1,['simpl'],['simplify']
Usability,"// We can only simplify factors if the sum of the powers of our simplifiable; // factors is 4 or higher. When that is the case, we will *always* have; // a simplification. This is an important invariant to prevent cyclicly; // trying to simplify already minimal formations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:15,simpl,simplify,15,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,4,['simpl'],"['simplifiable', 'simplification', 'simplify']"
Usability,"// We can promote lshr(x, cst) if we can promote x. This requires the; // ultimate 'and' to clear out the high zero bits we're clearing out though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:92,clear,clear,92,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,2,['clear'],"['clear', 'clearing']"
Usability,"// We can simplify (X^Y) -> X or Y in the user's context if we know that; // only bits from X or Y are demanded.; // If all of the demanded bits are known zero on one side, return the other.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['simpl'],['simplify']
Usability,"// We can simplify (X|Y) -> X or Y in the user's context if we know that; // only bits from X or Y are demanded.; // If all of the demanded bits are known zero on one side, return the other.; // These bits cannot contribute to the result of the 'or' in this context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['simpl'],['simplify']
Usability,// We can simplify to a comparison of these larger parts of the integers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:10,simpl,simplify,10,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['simpl'],['simplify']
Usability,// We can simply check if it is AMX instruction by its def.; // But we should exclude old API which uses physical registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PreTileConfig.cpp:10,simpl,simply,10,interpreter/llvm-project/llvm/lib/Target/X86/X86PreTileConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PreTileConfig.cpp,1,['simpl'],['simply']
Usability,"// We can simply import the values mentioned in the combined index, since; // we should only invoke this using the individual indexes written out; // via a WriteIndexesThinBackend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:10,simpl,simply,10,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,2,['simpl'],['simply']
Usability,// We can skip constant expressions.; // We can skip expressions with trivial calls or simple expressions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:87,simpl,simple,87,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['simpl'],['simple']
Usability,// We can use a simple GEP for this because it can't have been; // moved yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:16,simpl,simple,16,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,1,['simpl'],['simple']
Usability,// We can use simple vreg locations for variadic dbg_values as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:14,simpl,simple,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['simpl'],['simple']
Usability,"// We can use the context instruction (generically the ultimate instruction; // the calling pass is trying to simplify) here, even though the result of; // this function is generally cached when called from the solve* functions; // (and that cached result might be used with queries using a different; // context instruction), because when this function is called from the solve*; // functions, the context instruction is not provided. When called from; // LazyValueInfoImpl::getValueOnEdge, the context instruction is provided,; // but then the result is not cached.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:110,simpl,simplify,110,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['simpl'],['simplify']
Usability,"// We can't extract the stride if the arithmetic is done at a different size; // than the pointer type. Adding the stride later may not wrap correctly.; // Technically we could handle wider indices, but I don't expect that in; // practice. Handle one special case here - constants. This simplifies; // writing test cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:287,simpl,simplifies,287,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,1,['simpl'],['simplifies']
Usability,// We can't guarantee that nsw/nuw hold after simplifying the operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:46,simpl,simplifying,46,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['simpl'],['simplifying']
Usability,"// We can't just clear implicit kills, so if we encounter one, stop; // looking further.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:17,clear,clear,17,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,1,['clear'],['clear']
Usability,"// We can't place the inputs into a single half with a simple i16 shuffle, so bail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:55,simpl,simple,55,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simple']
Usability,"// We can't push the freeze through an instruction which can itself create; // poison. If the only source of new poison is flags, we can simply; // strip them (since we know the only use is the freeze and nothing can; // benefit from them.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:137,simpl,simply,137,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simply']
Usability,"// We can't read the file even from RealFS, this is clearly an error,; // but we'll just leave the current VFS as is and let clang's code; // figure out what to do with missing PCH.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:52,clear,clearly,52,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,1,['clear'],['clearly']
Usability,"// We can't set a name on this value, but we need to clear V's name if; // it has one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:53,clear,clear,53,interpreter/llvm-project/llvm/lib/IR/Value.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp,1,['clear'],['clear']
Usability,// We can't simplify any invokes to nounwind functions if the personality; // function wants to catch asynch exceptions. The nounwind attribute only; // implies that the function does not throw synchronous exceptions.; // Cannot simplify CXX Personality under AsynchEH,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/EHPersonalities.cpp:12,simpl,simplify,12,interpreter/llvm-project/llvm/lib/IR/EHPersonalities.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/EHPersonalities.cpp,2,['simpl'],['simplify']
Usability,// We can't simplify infinite loops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:12,simpl,simplify,12,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['simpl'],['simplify']
Usability,// We can't simplify target constants.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:12,simpl,simplify,12,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['simpl'],['simplify']
Usability,"// We can't simply call Type::isUndeducedType here, because inside template; // auto can be deduced to a dependent type, which is not considered; // ""undeduced"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:12,simpl,simply,12,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['simpl'],['simply']
Usability,"// We can't simply save the live set from the original insertion. One of; // the live values might be the result of a call which needs a safepoint.; // That Value* no longer exists and we need to use the new gc_result.; // Thankfully, the live set is embedded in the statepoint (and updated), so; // we just grab that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:12,simpl,simply,12,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['simpl'],['simply']
Usability,"// We can't trust the high bits at this point, so clear them.; // TODO: Skip masking high bits if def is known boolean.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp:50,clear,clear,50,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,1,['clear'],['clear']
Usability,// We cannot accurately backward compute #VGPRs used from; // GRANULATED_WORKITEM_VGPR_COUNT. But we are concerned with getting the same; // value of GRANULATED_WORKITEM_VGPR_COUNT in the reassembled binary. So we; // simply calculate the inverse of what the assembler does.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp:218,simpl,simply,218,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,1,['simpl'],['simply']
Usability,"// We cannot clear the whole unloaded list. It is too much.; // fUnloaded->Clear();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TListOfEnums.cxx:13,clear,clear,13,core/meta/src/TListOfEnums.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TListOfEnums.cxx,2,"['Clear', 'clear']","['Clear', 'clear']"
Usability,// We cannot simply check the result type since comparison operations return; // an int.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:13,simpl,simply,13,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['simpl'],['simply']
Usability,"// We cannot simply map the sealed page as we don't know its life time. Specialized page sources; // may decide to implement to not use UnsealPage but to custom mapping / decompression code.; // Note that usually pages are compressed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx:13,simpl,simply,13,tree/ntuple/v7/src/RPageStorage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx,1,['simpl'],['simply']
Usability,"// We cannot simply zero-initialize the entire base sub-object if vbptrs are; // present, they are initialized by the most derived class before calling the; // constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp:13,simpl,simply,13,interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,1,['simpl'],['simply']
Usability,"// We check earlier that we are within the authorized range, but; // we might still be out of the (default) learning range and since; // this is called before any branch is added to the cache, this means; // that the user's first GetEntry is this one which is outside of the; // learning range ... so let's do something sensible-ish.; // Note: we probably should also fix the learning range but we may; // or may not have enough information to know if we can move it; // (for example fEntryMin (eminOld right now) might be the default or user provided)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:108,learn,learning,108,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,3,['learn'],['learning']
Usability,// We chose to emit the canonical immediate sequence rather than folding; // the offset into the using add under the theory that doing so doesn't; // save dynamic instruction count and some target may fuse the canonical; // 32 bit immediate sequence. We still need to clear the portion of the; // offset encoded in the immediate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp:268,clear,clear,268,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp,1,['clear'],['clear']
Usability,"// We clear the scopes which we may have carried from a previous iteration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:6,clear,clear,6,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['clear'],['clear']
Usability,"// We cleared the PendingMem list, so all these pointers are now invalid",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:6,clear,cleared,6,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,1,['clear'],['cleared']
Usability,"// We continue the authentication process in clear",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:45,clear,clear,45,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['clear'],['clear']
Usability,"// We could copy the data only if we need to apply a relocation to it. After; // testing, it seems there is no performance downside to doing the copy; // unconditionally, and it makes the code simpler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:193,simpl,simpler,193,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,2,['simpl'],['simpler']
Usability,"// We could erase instrs right after vectorizing them, but that can mess up; // our BB iterators, and also can make the equivalence class keys point to; // freed memory. This is fixable, but it's simpler just to wait until we're; // done with the BB and erase all at once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:196,simpl,simpler,196,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['simpl'],['simpler']
Usability,"// We could not derive a type for this function. In this case strip; // the isVarArg and make it a simple zero-arg function. This has more; // chance of being correct. The current signature of (...) is illegal in; // C since it doesn't have any arguments before the ""..."", we this at; // least makes it possible for this symbol to be resolved by the linker.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAddMissingPrototypes.cpp:99,simpl,simple,99,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAddMissingPrototypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAddMissingPrototypes.cpp,1,['simpl'],['simple']
Usability,"// We could not simplify the condition, assume both values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:16,simpl,simplify,16,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['simpl'],['simplify']
Usability,"// We could potentially update the cached values we have with the new value,; // but it's simpler to just treat the old value as invalidated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp:90,simpl,simpler,90,interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp,1,['simpl'],['simpler']
Usability,"// We could reset all the location values too; however either loadFromArray; // or setMPhis should be called before this object is re-used. Just; // clear Masks, they're definitely not needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:149,clear,clear,149,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,1,['clear'],['clear']
Usability,"// We could simplify extracts from other values. Note that nested extracts may; // already be simplified implicitly by the above: extract (extract (insert) ); // will be translated into extract ( insert ( extract ) ) first and then just; // the value inserted, if appropriate. Similarly for extracts from single-use; // loads: extract (extract (load)) will be translated to extract (load (gep)); // and if again single-use then via load (gep (gep)) to load (gep).; // However, double extracts from e.g. function arguments or return values; // aren't handled yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:12,simpl,simplify,12,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,2,['simpl'],"['simplified', 'simplify']"
Usability,"// We could use redeclaration lookup here, but we don't need to: the; // syntactic form of a deduction guide is enough to identify it even; // if we can't look up the template name at all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:103,guid,guide,103,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['guid'],['guide']
Usability,"// We create an access to represent ""live on entry"", for things like; // arguments or users of globals, where the memory they use is defined before; // the beginning of the function. We do not actually insert it into the IR.; // We do not define a live on exit for the immediate uses, and thus our; // semantics do *not* imply that something with no immediate uses can simply; // be removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:369,simpl,simply,369,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['simpl'],['simply']
Usability,"// We currently only support spilling VGPRs to EltSize boundaries, meaning; // we can simplify the adjustment of Offset here to just scale with; // WavefrontSize.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:86,simpl,simplify,86,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['simpl'],['simplify']
Usability,// We deferred clearing these lanes in case we needed to save them,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:15,clear,clearing,15,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['clear'],['clearing']
Usability,// We did not enter a callee so we simply return the previous instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:35,simpl,simply,35,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,1,['simpl'],['simply']
Usability,"// We did not manage to simplify this branch, try to see whether; // CondCmp depends on a known phi-select pattern.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:24,simpl,simplify,24,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['simpl'],['simplify']
Usability,"// We divide by two as a cheap and simple heuristic to reduce the; // critcal path length, which increases the priority of using the graph; // height/depth in the scheduler's cost computation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:35,simpl,simple,35,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,1,['simpl'],['simple']
Usability,// We do a simple search for mergeable stores prior to this one.; // Any potential alias hazard along the way terminates the search.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:11,simpl,simple,11,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,1,['simpl'],['simple']
Usability,"// We do not currently simplify intrinsics that give an approximate; // answer. These include:; //; // - nvvm_cos_approx_{f,ftz_f}; // - nvvm_ex2_approx_{d,f,ftz_f}; // - nvvm_lg2_approx_{d,f,ftz_f}; // - nvvm_sin_approx_{f,ftz_f}; // - nvvm_sqrt_approx_{f,ftz_f}; // - nvvm_rsqrt_approx_{d,f,ftz_f}; // - nvvm_div_approx_{ftz_d,ftz_f,f}; // - nvvm_rcp_approx_ftz_d; //; // Ideally we'd encode them as e.g. ""fast call @llvm.cos"", where ""fast""; // means that fastmath is enabled in the intrinsic. Unfortunately only; // binary operators (currently) have a fastmath bit in SelectionDAG, so; // this information gets lost and we can't select on it.; //; // TODO: div and rcp are lowered to a binary op, so these we could in; // theory lower them to ""fast fdiv"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp:23,simpl,simplify,23,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetTransformInfo.cpp,1,['simpl'],['simplify']
Usability,"// We don't actually have to clear the table. This could be a good idea; // for greater error checking, but we don't really do any anyway. We; // will just track it with next_code and overwrite old entries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:29,clear,clear,29,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clear']
Usability,"// We don't allow icmp's, and because we only look at single block loops,; // we simply count the icmps, i.e. there should only be 1 for the backedge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:81,simpl,simply,81,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,1,['simpl'],['simply']
Usability,"// We don't bother trying to simplify unless all of the operands; // were constant.; // TODO: There are a lot of Simplify*'s we could call here, if we; // wanted to. The original motivating case for this code was a; // zext i1 false to i8, which we don't have an interface to; // simplify (IE there is no SimplifyZExt).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:29,simpl,simplify,29,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,4,"['Simpl', 'simpl']","['Simplify', 'SimplifyZExt', 'simplify']"
Usability,"// We don't care the real value in reg, so set 64 bits or duplicate 64 bits; // for simplicity.; // TODO: update these if we need a accurate 128 values in registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp:84,simpl,simplicity,84,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp,1,['simpl'],['simplicity']
Usability,// We don't clear the ExternalContext.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp:12,clear,clear,12,interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineModuleInfo.cpp,1,['clear'],['clear']
Usability,"// We don't expect EH pads to ever be reached via an indirect branch. If; // this is desired for some reason, we could simply skip them here rather; // than asserting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:119,simpl,simply,119,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['simpl'],['simply']
Usability,"// We don't know for sure yet if we are importing this value (as either; // a reference or a def), since we are simply walking all values in the; // module. But by necessity if we end up importing it and it is local,; // it must be promoted, so unconditionally promote all values in the; // importing module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:112,simpl,simply,112,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,1,['simpl'],['simply']
Usability,"// We don't know the desired configuration for this module and don't; // necessarily even have a module map. Since ReadAST already produces; // diagnostics for these two cases, we simply error out here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:180,simpl,simply,180,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['simpl'],['simply']
Usability,"// We don't need to actually parse the unqualified-id in this case,; // because a simple-template-id cannot start with 'operator', but; // go ahead and parse it anyway for consistency with the case where; // we already annotated the template-id.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:82,simpl,simple-template-id,82,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['simpl'],['simple-template-id']
Usability,// We don't need to top frame probe since it should be extracted; // from the range.; // The outcome of the virtual unwinding with pseudo probes is a; // map from a context key to the address range being unwound.; // This means basically linear unwinding is not needed for pseudo; // probes. The range will be simply recorded here and will be; // converted to a list of pseudo probes to report in ProfileGenerator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp:310,simpl,simply,310,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,1,['simpl'],['simply']
Usability,"// We don't really care about the real address in snippets,; // So hardcode X1 for X-form Memory Operations for simplicity.; // TODO: materialize the offset into a reggister",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp:112,simpl,simplicity,112,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PowerPC/Target.cpp,1,['simpl'],['simplicity']
Usability,// We don't use EmitCXXTryStmt here. We need to store to ResumeEHVar that; // doesn't exist in the body.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:57,Resume,ResumeEHVar,57,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,1,['Resume'],['ResumeEHVar']
Usability,"// We don't want to deep dive into semantics of the check and; // figure out if that check was for null or something else.; // We simply trust the user that they know what they are doing.; //; // For this reason, in the following loop we look for the; // best-looking option.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:130,simpl,simply,130,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,1,['simpl'],['simply']
Usability,"// We don't want to track the block through assignments and so on, instead; // we simply see how the block used and if it's used directly in a call,; // we decide based on call to what it is.; //; // In order to do this, we go up the parents of the block looking for; // a call or a message expressions. These might not be immediate parents; // of the actual block expression due to casts and parens, so we skip them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:82,simpl,simply,82,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,1,['simpl'],['simply']
Usability,// We dump all sections first. It is simple and allows us to verify that all; // sections are valid and also to generalize the code. But we are not going to; // keep all of them in the final output (see comments for; // 'shouldPrintSection()'). Undesired chunks will be removed later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/obj2yaml/elf2yaml.cpp:37,simpl,simple,37,interpreter/llvm-project/llvm/tools/obj2yaml/elf2yaml.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/obj2yaml/elf2yaml.cpp,1,['simpl'],['simple']
Usability,"// We either found non-function declarations or a best viable function; // at class scope. A class-scope lookup result disables ADL. Don't; // look past this, but let the caller know that we found something that; // either is, or might be, usable in this class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:240,usab,usable,240,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['usab'],['usable']
Usability,"// We either have a simple type or a constructor name",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp:20,simpl,simple,20,interpreter/cling/lib/Interpreter/LookupHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp,1,['simpl'],['simple']
Usability,"// We eliminate comparisons here rather than earlier because some; // transformations can change the set of available CC values and we; // generally want those transformations to have priority. This is; // especially true in the commonest case where the result of the comparison; // is used by a single in-range branch instruction, since we will then; // be able to fuse the compare and the branch instead.; //; // For example, two-address NILF can sometimes be converted into; // three-address RISBLG. NILF produces a CC value that indicates whether; // the low word is zero, but RISBLG does not modify CC at all. On the; // other hand, 64-bit ANDs like NILL can sometimes be converted to RISBG.; // The CC value produced by NILL isn't useful for our purposes, but the; // value produced by RISBG can be used for any comparison with zero; // (not just equality). So there are some transformations that lose; // CC values (while still being worthwhile) and others that happen to make; // the CC result more useful than it was originally.; //; // Another reason is that we only want to use BRANCH ON COUNT in cases; // where we know that the count register is not going to be spilled.; //; // Doing it so late makes it more likely that a register will be reused; // between the comparison and the branch, but it isn't clear whether; // preventing that would be a win or not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp:1317,clear,clear,1317,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetMachine.cpp,1,['clear'],['clear']
Usability,"// We encountered an error in parsing 'decltype(...)' so lets annotate all; // the tokens in the backtracking cache - that we likely had to skip over; // to get to a token that allows us to resume parsing, such as a; // semi-colon.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:190,resume,resume,190,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['resume'],['resume']
Usability,"// We extended the lifetime of NewSrc.Reg, clear the kill flags to; // account for that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:43,clear,clear,43,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['clear'],['clear']
Usability,// We follow MSVC in mangling GUID declarations as if they were variables; // with a particular reserved name. Continue the pretense here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:30,GUID,GUID,30,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['GUID'],['GUID']
Usability,"// We found a __device__ function with the same name and signature as NewD; // (ignoring CUDA attrs). This is an error unless that function is defined; // in a system header, in which case we simply return without making NewD; // host+device.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:192,simpl,simply,192,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,1,['simpl'],['simply']
Usability,"// We found a candidate variable that can be put into a return slot.; // Clear the set, because other variables cannot occupy a return; // slot in the same scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp:73,Clear,Clear,73,interpreter/llvm-project/clang/lib/Sema/Scope.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Scope.cpp,1,['Clear'],['Clear']
Usability,// We found a usable declaration of the name in a dependent base of some; // enclosing class.; // FIXME: We should also explain why the candidates found by name lookup; // were not viable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:14,usab,usable,14,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['usab'],['usable']
Usability,"// We found the chain we want as an operand of this TokenFactor.; // Essentially, we reach the chain without side-effects if we could; // serialize the TokenFactor into a simple chain of operations with; // Dest as the last operation. This is automatically true if the; // chain has one use: there are no other ordering constraints.; // If the chain has more than one use, we give up: some other; // use of Dest might force a side-effect between Dest and the current; // node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:171,simpl,simple,171,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['simpl'],['simple']
Usability,"// We generally do not know how to divide Expr by Denominator. We initialize; // the division to a ""cannot divide"" state to simplify the rest of the code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp:124,simpl,simplify,124,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionDivision.cpp,1,['simpl'],['simplify']
Usability,"// We go ahead and implement the simple ones",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/LossFunction.h:33,simpl,simple,33,tmva/tmva/inc/TMVA/LossFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/LossFunction.h,3,['simpl'],['simple']
Usability,"// We got to the node we need to remove. If any of its children are; // missing, simply replace it with the other child.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp:81,simpl,simply,81,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstExtenders.cpp,1,['simpl'],['simply']
Usability,"// We had an error, the branch name had no ""."" or we simply did not find anything.; // We check if we had a branch found with the full name with a dot in it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx:53,simpl,simply,53,tree/treeplayer/src/TTreeReaderValue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx,1,['simpl'],['simply']
Usability,// We handle the simplest case for now. We can potentially do better by using; // the machine dominator tree.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:17,simpl,simplest,17,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,1,['simpl'],['simplest']
Usability,// We have a class message. Turn the simple-type-specifier or; // typename-specifier we parsed into a type and parse the; // remainder of the class message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:37,simpl,simple-type-specifier,37,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['simpl'],['simple-type-specifier']
Usability,// We have a clear winner,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:13,clear,clear,13,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,2,['clear'],['clear']
Usability,"// We have a non-trivially-coalescable copy with IntA being the source and; // IntB being the dest, thus this defines a value number in IntB. If the; // source value number (in IntA) is defined by a copy from B, see if we can; // merge these two pieces of B into a single value number, eliminating a copy.; // For example:; //; // A3 = B0; // ...; // B1 = A3 <- this copy; //; // In this case, B0 can be extended to where the B1 copy lives, allowing the; // B1 value number to be replaced with B0 (which simplifies the B; // liveinterval).; // BValNo is a value number in B that is defined by a copy from A. 'B1' in; // the example above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:504,simpl,simplifies,504,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['simpl'],['simplifies']
Usability,"// We have a simple asm expression like 'asm(""foo"")'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:13,simpl,simple,13,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,1,['simpl'],['simple']
Usability,// We have changed the object offset above but we do not want to change; // the actual offsets in the CFI instruction so we have to undo the; // offset change here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:132,undo,undo,132,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['undo'],['undo']
Usability,"// We have empty reaching kernels, therefore we cannot tell if the; // associated call site can be folded. At this moment, SimplifiedValue; // must be none.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:123,Simpl,SimplifiedValue,123,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['Simpl'],['SimplifiedValue']
Usability,"// We have found a preprocessing directive. Annotate the tokens; // appropriately.; //; // FIXME: Some simple tests here could identify macro definitions and; // #undefs, to provide specific cursor kinds for those.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:103,simpl,simple,103,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['simpl'],['simple']
Usability,"// We have four cases here:; // (1). no terminator, simple follow through.; // (2). jmp to another bb.; // (3). conditional jmp to another bb or follow through.; // (4). conditional jmp followed by an unconditional jmp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp:52,simpl,simple,52,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp,1,['simpl'],['simple']
Usability,"// We have just finished pushing the previous FP into the stack,; // so simply capture the SP value as the new Frame Pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:72,simpl,simply,72,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,1,['simpl'],['simply']
Usability,"// We have not even found the element .. this is strange :(; // fNewIDs.clear();; // fID = -3;; // SetBit(kDoNotProcess);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:72,clear,clear,72,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['clear'],['clear']
Usability,// We have parsed a template-name naming a deduction guide.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:53,guid,guide,53,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['guid'],['guide']
Usability,// We have some variations of rotate-and-mask instructions; // that clear higher 32-bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:68,clear,clear,68,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['clear'],['clear']
Usability,"// We have the simple pattern '*', it matches everything by definition!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/BaseSelectionRule.cxx:15,simpl,simple,15,core/dictgen/src/BaseSelectionRule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/BaseSelectionRule.cxx,1,['simpl'],['simple']
Usability,"// We have to be able to save if statements to execute later, and they have; // to live on the same stack as foreach loops. The simplest implementation; // technique is to convert each 'then' or 'else' clause *into* a foreach; // loop, over a list of length 0 or 1 depending on the condition, and with no; // iteration variable being assigned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:128,simpl,simplest,128,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['simpl'],['simplest']
Usability,"// We have to be careful that the succs of PredBB aren't both no-successor; // blocks. If neither have successors and if PredBB is the second from; // last block in the function, we'd just keep swapping the two blocks for; // last. Only do the swap if one is clearly better to fall through than; // the other.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:259,clear,clearly,259,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['clear'],['clearly']
Usability,// We have to clear the arguments top level loops as we've taken ownership.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericLoopInfo.h:14,clear,clear,14,interpreter/llvm-project/llvm/include/llvm/Support/GenericLoopInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericLoopInfo.h,1,['clear'],['clear']
Usability,// We have to null out the analysis manager in the moved-from state; // because we are taking ownership of the responsibilty to clear the; // analysis state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:128,clear,clear,128,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,4,['clear'],['clear']
Usability,"// We have; //; // template-id '::'; //; // So we need to check whether the template-id is a simple-template-id of; // the right kind (it should name a type or be dependent), and then; // convert it into a type within the nested-name-specifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:93,simpl,simple-template-id,93,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['simpl'],['simple-template-id']
Usability,// We hit the instantiation depth limit. Clear the exception specification; // so that our callers don't have to cope with EST_Uninstantiated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:41,Clear,Clear,41,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['Clear'],['Clear']
Usability,// We just support simple memory operands that have a single address; // operand and need no special handling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelDAGToDAG.cpp:19,simpl,simple,19,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYISelDAGToDAG.cpp,1,['simpl'],['simple']
Usability,// We just support simple memory operands that just have a single address; // operand and need no special handling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp:19,simpl,simple,19,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelDAGToDAG.cpp,1,['simpl'],['simple']
Usability,// We know how to negate certain expressions. Simplify them here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:46,Simpl,Simplify,46,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,1,['Simpl'],['Simplify']
Usability,"// We know that all PHIs in non-header blocks are converted into selects, so; // we don't have to worry about the insertion order and we can just use the; // builder. At this point we generate the predication tree. There may be; // duplications since this is a simple recursive scan, but future; // optimizations will clean it up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:261,simpl,simple,261,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['simpl'],['simple']
Usability,"// We know that all PHIs in non-header blocks are converted into; // selects, so we don't have to worry about the insertion order and we; // can just use the builder.; // At this point we generate the predication tree. There may be; // duplications since this is a simple recursive scan, but future; // optimizations will clean it up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:265,simpl,simple,265,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,1,['simpl'],['simple']
Usability,"// We learnt from a previous file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:6,learn,learnt,6,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['learn'],['learnt']
Usability,"// We limit this transform to power-of-2 types because we expect that the; // backend can convert the simplified IR patterns to identical nodes as the; // original IR.; // TODO: If we can verify the same behavior for arbitrary types, the; // power-of-2 checks can be removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:102,simpl,simplified,102,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['simpl'],['simplified']
Usability,// We made sure to clear analyses for deleted functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:19,clear,clear,19,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['clear'],['clear']
Usability,"// We make the reasonable assumption that a semicolon after 100 characters; // means that it is not the next token after our macro. If this assumption; // fails it is not critical, we will just fail to clear out, e.g., an empty; // 'if'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransEmptyStatementsAndDealloc.cpp:202,clear,clear,202,interpreter/llvm-project/clang/lib/ARCMigrate/TransEmptyStatementsAndDealloc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransEmptyStatementsAndDealloc.cpp,1,['clear'],['clear']
Usability,// We match the semantics of SimplifyPhiNode from InstructionSimplify here.; // See if all arguments are the same.; // We track if any were undef because they need special handling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:29,Simpl,SimplifyPhiNode,29,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['Simpl'],['SimplifyPhiNode']
Usability,"// We may be inside a template argument list. Grab up to the start of the; // next parenthesized initializer or braced-init-list. This *might* be the; // initializer, or it might be a subexpression in the template argument; // list.; // FIXME: Count angle brackets, and clear MightBeTemplateArgument; // if all angles are closed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:270,clear,clear,270,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,1,['clear'],['clear']
Usability,"// We may end up with a situation when section symbol is technically; // defined, but should not be. That happens because we explicitly; // pre-create few .debug_* sections to have accessors.; // And if these sections were not really defined in the code, but were; // referenced, we simply error out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp:283,simpl,simply,283,interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp,1,['simpl'],['simply']
Usability,// We may have simplified away the shuffle. We won't be able to do anything; // further with it here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:15,simpl,simplified,15,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['simpl'],['simplified']
Usability,"// We may have trivial equivalence classes in the disequality info as; // well, and we need to simplify them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:95,simpl,simplify,95,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['simpl'],['simplify']
Usability,// We may need to undo the effects of our pre-call check.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:18,undo,undo,18,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,1,['undo'],['undo']
Usability,"// We may need to widen to Top, but before we do so, check whether both; // values are implied to be either true or false in the current environment.; // In that case, we can simply return a literal instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:175,simpl,simply,175,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,1,['simpl'],['simply']
Usability,"// We may not have a defined value at this point, but still need to; // clear out any empty subranges tentatively created by; // updateRegDefUses. The original subrange def may have only undefed; // some lanes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:72,clear,clear,72,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['clear'],['clear']
Usability,"// We might extend the live range of Z, clear its kill flag to; // account for this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:40,clear,clear,40,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,2,['clear'],['clear']
Usability,"// We might have a vector load from an array. FIXME: for now we just bail; // out in this case, but we should be able to resolve and simplify such; // loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:133,simpl,simplify,133,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,1,['simpl'],['simplify']
Usability,"// We might have matched the amount of high bits to be cleared,; // but we want the amount of low bits to be kept, so negate it then.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:55,clear,cleared,55,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['clear'],['cleared']
Usability,"// We miss the opportunity to emit an RLDIC when lowering jump tables; // since ISEL sees only a single basic block. When selecting, the clear; // and shift left will be in different blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:137,clear,clear,137,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['clear'],['clear']
Usability,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:171,simpl,simple,171,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,3,"['intuit', 'simpl']","['intuition', 'simple']"
Usability,"// We must count the cost of every operand which is not free,; // recursively. If we reach a loop PHI node, simply add it to the set; // to be considered on the next iteration (backwards!).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:108,simpl,simply,108,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['simpl'],['simply']
Usability,"// We must do this walk rather than the simpler; // setValue(&I, getCopyFromRegs(CBR, CBR->getType()));; // otherwise we will end up with copies of virtregs only valid along direct; // edges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:40,simpl,simpler,40,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['simpl'],['simpler']
Usability,"// We must not add instrumentation to the BB representing the; // ""suspend"" path, else CoroSplit won't be able to lower; // llvm.coro.suspend to a tail call. We do want profiling info for; // the other branches (resume/destroy). So we do 2 things:; // 1. we prefer instrumenting those other edges by setting the weight; // of the ""suspend"" edge to max, and; // 2. we mark the edge as ""Removed"" to guarantee it is not considered; // for instrumentation. That could technically happen:; // (from test/Transforms/Coroutines/coro-split-musttail.ll); //; // %suspend = call i8 @llvm.coro.suspend(token %save, i1 false); // switch i8 %suspend, label %exit [; // i8 0, label %await.ready; // i8 1, label %exit; // ]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/CFGMST.h:212,resume,resume,212,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/CFGMST.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/CFGMST.h,1,['resume'],['resume']
Usability,// We need an 'add' and exactly 1 arm of the select to have been simplified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:65,simpl,simplified,65,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['simpl'],['simplified']
Usability,"// We need at least 3 pairs of copies for the transformation to apply,; // because the first outermost pair cannot be removed since we don't; // recolor outside of the chain and that we need at least one temporary; // spill slot to shorten the chain. If we only have a chain of two; // pairs, we already have the shortest sequence this code can handle:; // the outermost pair for the temporary spill slot, and the pair that; // use that temporary spill slot for the other end of the chain.; // TODO: We might be able to simplify to one spill-reload pair if collecting; // more infomation about the outermost COPY.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:520,simpl,simplify,520,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,1,['simpl'],['simplify']
Usability,"// We need the addDaughters flag returned from the viewer from paint; // so can't use the normal TObject::Paint(); // TGeoHMatrix *matrix = (TGeoHMatrix*)TGeoShape::GetTransform();; // if (viewer->PreferLocalFrame()) matrix->Clear();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoPainter.cxx:225,Clear,Clear,225,geom/geompainter/src/TGeoPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoPainter.cxx,1,['Clear'],['Clear']
Usability,// We need to clear R1. This is currently done (dirtily); // using a custom inserter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp:14,clear,clear,14,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,1,['clear'],['clear']
Usability,"// We need to clear kill flags since we may be extending the live range past; // a kill. If the mul had kill flags, we can preserve those since we know; // where the previous range stopped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:14,clear,clear,14,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,1,['clear'],['clear']
Usability,"// We need to clear linkage for specializations, too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp:14,clear,clear,14,interpreter/cling/lib/Interpreter/DeclExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp,1,['clear'],['clear']
Usability,// We need to clear the mutability bit in case we are; // destroying the node as part of a sweep in ImutAVLFactory::recoverNodes().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:14,clear,clear,14,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,1,['clear'],['clear']
Usability,"// We need to compute an access strategy for this bit-field. We are given the; // offset to the first byte in the bit-field, the sub-byte offset is taken; // from the original layout. We reuse the normal bit-field access strategy by; // treating this as an access to a struct where the bit-field is in byte 0,; // and adjust the containing type size as appropriate.; //; // FIXME: Note that currently we make a very conservative estimate of the; // alignment of the bit-field, because (a) it is not clear what guarantees the; // runtime makes us, and (b) we don't have a way to specify that the struct is; // at an alignment plus offset.; //; // Note, there is a subtle invariant here: we can only call this routine on; // non-synthesized ivars but we may be called for synthesized ivars. However,; // a synthesized ivar can never be a bit-field, so this is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.cpp:499,clear,clear,499,interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.cpp,1,['clear'],['clear']
Usability,"// We need to differentiate identifiers for a template deduction guide,; // variables, or function return types (the constraint expression has; // ended before that), and basically all other cases. But it's easier to; // check the other way around.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:65,guid,guide,65,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['guid'],['guide']
Usability,"// We need to do some work here if the operand types are < 16 bit and they; // are split across fpr/gpr banks. Since all types <32b on gpr; // end up being assigned gpr32 regclasses, we can end up with PHIs here; // which try to select between a gpr32 and an fpr16. Ideally RBS shouldn't; // be selecting heterogenous regbanks for operands if possible, but we; // still need to be able to deal with it here.; //; // To fix this, if we have a gpr-bank operand < 32b in size and at least; // one other operand is on the fpr bank, then we add cross-bank copies; // to homogenize the operand banks. For simplicity the bank that we choose; // to settle on is whatever bank the def operand has. For example:; //; // %endbb:; // %dst:gpr(s16) = G_PHI %in1:gpr(s16), %bb1, %in2:fpr(s16), %bb2; // =>; // %bb2:; // ...; // %in2_copy:gpr(s16) = COPY %in2:fpr(s16); // ...; // %endbb:; // %dst:gpr(s16) = G_PHI %in1:gpr(s16), %bb1, %in2_copy:gpr(s16), %bb2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:599,simpl,simplicity,599,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['simpl'],['simplicity']
Usability,// We need to emit an AND to clear the high bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:29,clear,clear,29,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['clear'],['clear']
Usability,// We need to find a vector index to simplify.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp:37,simpl,simplify,37,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVGatherScatterLowering.cpp,1,['simpl'],['simplify']
Usability,"// We need to have all the entries counted, for a TProfile values; // outside the range are simply ignored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/test/TMapFileTest.cxx:92,simpl,simply,92,io/io/test/TMapFileTest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/test/TMapFileTest.cxx,1,['simpl'],['simply']
Usability,// We need to resolve the symbols so the LTO backend knows which symbols need; // to be kept or can be internalized. This is a simplified symbol resolution; // scheme to approximate the full resolution a linker would do.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:127,simpl,simplified,127,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,1,['simpl'],['simplified']
Usability,"// We need to specifically handle i64 mul here to avoid unnecessary conversion; // instructions. If we only match on the legalized i64 mul expansion,; // SimplifyDemandedBits will be unable to remove them because there will be; // multiple uses due to the separate mul + mulh[su].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:154,Simpl,SimplifyDemandedBits,154,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,"// We never want to compare deduction guide names for templates from; // different scopes, so just compare the template-name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp:38,guid,guide,38,interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp,1,['guid'],['guide']
Usability,"// We normally expect IMPLICIT_DEF values to be live only until the end; // of their block. If the value is really live longer and gets pruned in; // another block, this flag is cleared again.; //; // Clearing the valid lanes is deferred until it is sure this can be; // erased.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:178,clear,cleared,178,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,2,"['Clear', 'clear']","['Clearing', 'cleared']"
Usability,"// We now have (dstParts * APINT_BITS_PER_WORD - shift) bits from SRC; // in DST. If this is less that srcBits, append the rest, else; // clear the high bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:138,clear,clear,138,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['clear'],['clear']
Usability,// We now need to clear out the completion info related to this translation; // unit; it'll be recreated if necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:18,clear,clear,18,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,1,['clear'],['clear']
Usability,"// We only compare a subset of features when comparing nodes between; // Top and Bottom boundary. Some properties are simply incomparable, in many; // other instances we should only override the other boundary if something; // is a clear good pick on one boundary. Skip heuristics that are more; // ""tie-breaking"" in nature.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:118,simpl,simply,118,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,4,"['clear', 'simpl']","['clear', 'simply']"
Usability,"// We only conservatively allow a few kinds of casts, because this code is; // inherently a simple solution that seeks to support the common case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:92,simpl,simple,92,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['simpl'],['simple']
Usability,"// We only decode broadcasts of same-sized vectors, peeking through to; // extracted subvectors is likely to cause hasOneUse issues with; // SimplifyDemandedBits etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:141,Simpl,SimplifyDemandedBits,141,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,// We only handle LHS as simple symbols or SymIntExprs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:25,simpl,simple,25,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,1,['simpl'],['simple']
Usability,// We only handle merging simple stores of 1-4 bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:26,simpl,simple,26,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,1,['simpl'],['simple']
Usability,// We only handle merging simple stores of 1-4 bytes.; // TODO: Allow unordered atomics when wider type is legal (see D66309),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,simpl,simple,26,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simple']
Usability,"// We only handle simple comparisons of the form ""$sym == constant""; // or ""($sym+constant1) == constant2"".; // The adjustment is ""constant1"" in the above expression. It's used to; // ""slide"" the solution range around for modular arithmetic. For example,; // x < 4 has the solution [0, 3]. x+2 < 4 has the solution [0-2, 3-2], which; // in modular arithmetic is [0, 1] U [UINT_MAX-1, UINT_MAX]. It's up to; // the subclasses of SimpleConstraintManager to handle the adjustment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp:18,simpl,simple,18,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangedConstraintManager.cpp,2,"['Simpl', 'simpl']","['SimpleConstraintManager', 'simple']"
Usability,// We only handle vectors here.; // TODO - investigate calling SimplifyDemandedBits/ComputeKnownBits?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:63,Simpl,SimplifyDemandedBits,63,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,"// We only have a post-order SCC traversal (because SCCs are inherently; // discovered in post-order), so we accumulate them in a vector and then walk; // it in reverse. This is simpler than using the RPO iterator infrastructure; // because we need to combine SCC detection and the PO walk of the call; // graph. We can also cheat egregiously because we're primarily interested in; // synthesizing norecurse and so we can only save the singular SCCs as SCCs; // with multiple functions in them will clearly be recursive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:178,simpl,simpler,178,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,2,"['clear', 'simpl']","['clearly', 'simpler']"
Usability,"// We only need to keep internal inlined edge information within; // a RefSCC, clear it to save on space and let the next time we visit; // any of these functions have a fresh start.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:79,clear,clear,79,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,1,['clear'],['clear']
Usability,// We only treat template-names that name type templates as valid deduction; // guide names.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:80,guid,guide,80,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['guid'],['guide']
Usability,// We only want simple or unordered-atomic stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:16,simpl,simple,16,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['simpl'],['simple']
Usability,"// We only want to perform this transformation if it will not lead to; // additional code. This is true if either both sides of the select; // fold to a constant (in which case the icmp is replaced with a select; // which will usually simplify) or this is the only user of the; // select (in which case we are trading a select+icmp for a simpler; // select+icmp) or all uses of the select can be replaced based on; // dominance information (""Global cases"").",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:235,simpl,simplify,235,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,2,['simpl'],"['simpler', 'simplify']"
Usability,// We padded the mask with undefs. But we now need to undo that.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:54,undo,undo,54,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['undo'],['undo']
Usability,// We previously decided to import this GUID definition if it was already; // inserted in the set of imports from the exporting module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:40,GUID,GUID,40,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['GUID'],['GUID']
Usability,// We queried AAValueSimplify for the returned values so they will be; // replaced if a simplified form was found. Nothing to do here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:88,simpl,simplified,88,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['simpl'],['simplified']
Usability,"// We search in the redecl context because of transparent contexts.; // E.g. a simple C language enum is a transparent context:; // enum E { A, B };; // Now if we had a global variable in the TU; // int A;; // then the enum constant 'A' and the variable 'A' violates ODR.; // We can diagnose this only if we search in the redecl context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:79,simpl,simple,79,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['simpl'],['simple']
Usability,"// We should attempts to set the address of the branch.; // something like:; //(TBranchElement*)branch->GetMother()->SetAddress(0); //plus a few more subtleties (see TBranchElement::GetEntry).; //but for now we go the simplest route:; //; // Note: This may result in the allocation of an object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:218,simpl,simplest,218,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['simpl'],['simplest']
Usability,// We should have cleared UnfilledBitsInLastUnit in every case; // where we changed storage units.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:18,clear,cleared,18,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['clear'],['cleared']
Usability,// We shouldn't have done anything to break loop simplify form or LCSSA.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:49,simpl,simplify,49,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,1,['simpl'],['simplify']
Usability,"// We signal the presence of a Swift extended frame to external tools by; // storing FP with 0b0001 in bits 63:60. In normal userland operation a simple; // ORR is sufficient, it is assumed a Swift kernel would initialize the TBI; // bits so that is still true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:146,simpl,simple,146,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['simpl'],['simple']
Usability,"// We simplified Src. If this node is not dead, visit it again so it is; // folded properly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:6,simpl,simplified,6,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['simpl'],['simplified']
Usability,"// We simplified the vector operand of this extract element. If this; // extract is not dead, visit it again so it is folded properly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:6,simpl,simplified,6,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['simpl'],['simplified']
Usability,"// We simply never allow init lists as the return value of void; // functions. This is compatible because this was never allowed before,; // so there's no legacy code to deal with.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:6,simpl,simply,6,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['simpl'],['simply']
Usability,// We simply return the type at index `Index`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:6,simpl,simply,6,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['simpl'],['simply']
Usability,// We simply select the FirstOffset as the first reusable offset between each; // chain element 1 and element 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:6,simpl,simply,6,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,1,['simpl'],['simply']
Usability,// We simulate the REX prefix for simplicity's sake,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp:34,simpl,simplicity,34,interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,4,['simpl'],['simplicity']
Usability,// We simulate the REX2 prefix for simplicity's sake,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp:35,simpl,simplicity,35,interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,1,['simpl'],['simplicity']
Usability,"// We still need to learn.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:20,learn,learn,20,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['learn'],['learn']
Usability,// We support these really simple operations even on types where all; // the actual arithmetic has to be broken down into simpler; // operations or turned into library calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:27,simpl,simple,27,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,['simpl'],"['simple', 'simpler']"
Usability,"// We tend to over estimate code size due to large alignment and; // inline assembly. Usually it causes larger computed branch offset.; // But sometimes it may also causes smaller computed branch offset; // than actual branch offset. If the offset is close to the limit of; // encoding, it may cause problem at run time.; // Following is a simplified example.; //; // actual estimated; // address address; // ...; // bne Far 100 10c; // .p2align 4; // Near: 110 110; // ...; // Far: 8108 8108; //; // Actual offset: 0x8108 - 0x100 = 0x8008; // Computed offset: 0x8108 - 0x10c = 0x7ffc; //; // This example also shows when we can get the largest gap between; // estimated offset and actual offset. If there is an aligned block; // ABB between branch and target, assume its alignment is <align>; // bits. Now consider the accumulated function size FSIZE till the end; // of previous block PBB. If the estimated FSIZE is multiple of; // 2^<align>, we don't need any padding for the estimated address of; // ABB. If actual FSIZE at the end of PBB is 4 bytes more than; // multiple of 2^<align>, then we need (2^<align> - 4) bytes of; // padding. It also means the actual branch offset is (2^<align> - 4); // larger than computed offset. Other actual FSIZE needs less padding; // bytes, so causes smaller gap between actual and computed offset.; //; // On the other hand, if the inline asm or large alignment occurs; // between the branch block and destination block, the estimated address; // can be <delta> larger than actual address. If padding bytes are; // needed for a later aligned block, the actual number of padding bytes; // is at most <delta> more than estimated padding bytes. So the actual; // aligned block address is less than or equal to the estimated aligned; // block address. So the actual branch offset is less than or equal to; // computed branch offset.; //; // The computed offset is at most ((1 << alignment) - 4) bytes smaller; // than actual offset. So we add this number to the o",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp:340,simpl,simplified,340,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchSelector.cpp,1,['simpl'],['simplified']
Usability,"// We track the simplification of each instruction in each iteration. We use; // this to recursively merge costs into the unrolled cost on-demand so that; // we don't count the cost of any dead code. This is essentially a map from; // <instruction, int> to <bool, bool>, but stored as a densely packed struct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:16,simpl,simplification,16,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['simpl'],['simplification']
Usability,"// We use a pointer union between a single `MachineMemOperand` pointer and; // a pointer to an array of `MachineMemOperand` pointers. This is null when; // the number of these is zero, the single pointer variant used when the; // number is one, and the array is used for larger numbers.; //; // The array is allocated via the `SelectionDAG`'s allocator and so will; // always live until the DAG is cleaned up and doesn't require ownership here.; //; // We can't use something simpler like `TinyPtrVector` here because `SDNode`; // subclasses aren't managed in a conforming C++ manner. See the comments on; // `SelectionDAG::MorphNodeTo` which details what all goes on, but the; // constraint here is that these don't manage memory with their constructor or; // destructor and can be initialized to a good state even if they start off; // uninitialized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:476,simpl,simpler,476,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['simpl'],['simpler']
Usability,"// We use a simple cost heuristic which determine skipping merging is; // profitable if the cost of skipping merging is less than the cost of; // merging : Cost(skipping merging) < Cost(merging BB), where the; // Cost(skipping merging) is Freq(BB) * (Cost(Copy) + Cost(Branch)), and; // the Cost(merging BB) is Freq(Pred) * Cost(Copy).; // Assuming Cost(Copy) == Cost(Branch), we could simplify it to :; // Freq(Pred) / Freq(BB) > 2.; // Note that if there are multiple empty blocks sharing the same incoming; // value for the PHIs in the DestBB, we consider them together. In such; // case, Cost(merging BB) will be the sum of their frequencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:12,simpl,simple,12,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,2,['simpl'],"['simple', 'simplify']"
Usability,"// We use a simple greedy algorithm.; // - Given a chain of length N, find all prefixes that; // (a) are not longer than the max register length, and; // (b) are a power of 2.; // - Starting from the longest prefix, try to create a vector of that length.; // - If one of them works, great. Repeat the algorithm on any remaining; // elements in the chain.; // - If none of them work, discard the first element and repeat on a chain; // of length N-1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:12,simpl,simple,12,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['simpl'],['simple']
Usability,"// We use llvm::SmallVector as the underlying container for the following; // reasons:; //; // * Range sets are usually very simple, 1 or 2 ranges.; // That's why llvm::ImmutableSet is not perfect.; //; // * Ranges in sets are NOT overlapping, so it is natural to keep them; // sorted for efficient operations and queries. For this reason,; // llvm::SmallSet doesn't fit the requirements, it is not sorted when it; // is a vector.; //; // * Range set operations usually a bit harder than add/remove a range.; // Complex operations might do many of those for just one range set.; // Formerly it used to be llvm::ImmutableSet, which is inefficient for our; // purposes as we want to make these operations BOTH immutable AND; // efficient.; //; // * Iteration over ranges is widespread and a more cache-friendly; // structure is preferred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h:125,simpl,simple,125,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h,1,['simpl'],['simple']
Usability,"// We use seven conditions to recognize a simplification case.; // For the clarity let `CastTy` be `C`, SE->getType() - `T`, root type -; // `R`, prefix `u` for unsigned, `s` for signed, no prefix - any sign: E.g.; // (char)(short)(uint x); // ( sC )( sT )( uR x); //; // C === R (the same type); // (char)(char x) -> (char x); // (long)(long x) -> (long x); // Note: Comparisons operators below are for bit width.; // C == T; // (short)(short)(int x) -> (short)(int x); // (int)(long)(char x) -> (int)(char x) (sizeof(long) == sizeof(int)); // (long)(ullong)(char x) -> (long)(char x) (sizeof(long) ==; // sizeof(ullong)); // C < T; // (short)(int)(char x) -> (short)(char x); // (char)(int)(short x) -> (char)(short x); // (short)(int)(short x) -> (short x); // C > T > uR; // (int)(short)(uchar x) -> (int)(uchar x); // (uint)(short)(uchar x) -> (uint)(uchar x); // (int)(ushort)(uchar x) -> (int)(uchar x); // C > sT > sR; // (int)(short)(char x) -> (int)(char x); // (uint)(short)(char x) -> (uint)(char x); // C > sT == sR; // (int)(char)(char x) -> (int)(char x); // (uint)(short)(short x) -> (uint)(short x); // C > uT == uR; // (int)(uchar)(uchar x) -> (int)(uchar x); // (uint)(ushort)(ushort x) -> (uint)(ushort x); // (llong)(ulong)(uint x) -> (llong)(uint x) (sizeof(ulong) ==; // sizeof(uint))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:42,simpl,simplification,42,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,1,['simpl'],['simplification']
Usability,"// We use the function guid which we expect to be a uint64_t. At; // this time, it is the lower 64 bits of the md5 of the canonical; // function name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/MemProf.cpp:23,guid,guid,23,interpreter/llvm-project/llvm/lib/ProfileData/MemProf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/MemProf.cpp,1,['guid'],['guid']
Usability,// We use the heuristic provided by AMD Accelerated Parallel Processing; // OpenCL Programming Guide :; // The approx. number of WF that allows TEX inst to hide ALU inst is :; // 500 (cycles for TEX) / (AluFetchRatio * 8 (cycles for ALU)),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineScheduler.cpp:95,Guid,Guide,95,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineScheduler.cpp,1,['Guid'],['Guide']
Usability,"// We use the simple binary decomposition method to generate the multiply; // sequence. There are more optimal ways to do this (for example,; // powi(x,15) generates one more multiply than it should), but this has; // the benefit of being both really simple and much better than a libcall.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:14,simpl,simple,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,2,['simpl'],['simple']
Usability,"// We want to add canonical declarations to the EC lists for; // simplicity of checking, but we need to walk up through the; // actual current DC chain. Otherwise, something like a local; // extern or friend which happens to be the canonical; // declaration will really mess us up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:65,simpl,simplicity,65,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['simpl'],['simplicity']
Usability,"// We want to consume the semicolon, make sure SimpleDeclaration does not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:47,Simpl,SimpleDeclaration,47,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,1,['Simpl'],['SimpleDeclaration']
Usability,"// We want to disallow code like this:; // file1.td:; // #define NAME; // #ifdef NAME; // include ""file2.td""; // EOF; // file2.td:; // #endif; // EOF; //; // To do this, we clear the preprocessing control stack on entry; // to each of the included file. PrepIncludeStack is used to store; // preprocessing control stacks for the current file and all its; // parent files. The back() element is the preprocessing control; // stack for the current file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h:173,clear,clear,173,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h,1,['clear'],['clear']
Usability,// We want to generally process call sites top-down in order for; // simplifications stemming from replacing the call with the returned value; // after inlining to be visible to subsequent inlining decisions.; // FIXME: Using instructions sequence is a really bad way to do this.; // Instead we should do an actual RPO walk of the function body.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:69,simpl,simplifications,69,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,1,['simpl'],['simplifications']
Usability,"// We want to print a simplified absolute path, i. e. without ""dots"".; //; // The hardest part here are the paths like ""<part1>/<link>/../<part2>"".; // On Unix-like systems, we cannot just collapse ""<link>/.."", because; // paths are resolved sequentially, and, thereby, the path; // ""<part1>/<part2>"" may point to a different location. That is why; // we use FileManager::getCanonicalName(), which expands all indirections; // with llvm::sys::fs::real_path() and caches the result.; //; // On the other hand, it would be better to preserve as much of the; // original path as possible, because that helps a user to recognize it.; // real_path() expands all links, which is sometimes too much. Luckily,; // on Windows we can just use llvm::sys::path::remove_dots(), because,; // on that system, both aforementioned paths point to the same place.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnostic.cpp:22,simpl,simplified,22,interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SARIFDiagnostic.cpp,1,['simpl'],['simplified']
Usability,"// We want to print a simplified absolute path, i. e. without ""dots"".; //; // The hardest part here are the paths like ""<part1>/<link>/../<part2>"".; // On Unix-like systems, we cannot just collapse ""<link>/.."", because; // paths are resolved sequentially, and, thereby, the path; // ""<part1>/<part2>"" may point to a different location. That is why; // we use FileManager::getCanonicalName(), which expands all indirections; // with llvm::sys::fs::real_path() and caches the result.; //; // On the other hand, it would be better to preserve as much of the; // original path as possible, because that helps a user to recognize it.; // real_path() expands all links, which sometimes too much. Luckily,; // on Windows we can just use llvm::sys::path::remove_dots(), because,; // on that system, both aforementioned paths point to the same place.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:22,simpl,simplified,22,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,1,['simpl'],['simplified']
Usability,"// We want to reliably handle any conditional branch terminators in the; // MBB, so we manually analyze the branch. We can handle all of the; // permutations here, including ones that analyze branch cannot.; //; // The approach is to walk backwards across the terminators, resetting at; // any unconditional non-indirect branch, and track all conditional edges; // to basic blocks as well as the fallthrough or unconditional successor; // edge. For each conditional edge, we track the target and the opposite; // condition code in order to inject a ""no-op"" cmov into that successor; // that will harden the predicate. For the fallthrough/unconditional; // edge, we inject a separate cmov for each conditional branch with; // matching condition codes. This effectively implements an ""and"" of the; // condition flags, even if there isn't a single condition flag that would; // directly implement that. We don't bother trying to optimize either of; // these cases because if such an optimization is possible, LLVM should; // have optimized the conditional *branches* in that way already to reduce; // instruction count. This late, we simply assume the minimal number of; // branch instructions is being emitted and use that to guide our cmov; // insertion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1131,simpl,simply,1131,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,2,"['guid', 'simpl']","['guide', 'simply']"
Usability,"// We will change CFG/DT during this traversal, so take precautions to; // avoid problems related to invalidated iterators. In fact, processing; // a child C of B cannot cause another child to be removed, but it can; // cause a new child to be added (which was a child of C before C itself; // was removed. This new child C, however, would have been processed; // prior to processing B, so there is no need to process it again.; // Simply keep a list of children of B, and traverse that list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:432,Simpl,Simply,432,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,1,['Simpl'],['Simply']
Usability,"// We will either select ds_read_b64/ds_write_b64 or ds_read2_b32/; // ds_write2_b32 depending on the alignment. In either case with either; // alignment there is no faster way of doing this.; // The numbers returned here and below are not additive, it is a 'speed; // rank'. They are just meant to be compared to decide if a certain way; // of lowering an operation is faster than another. For that purpose; // naturally aligned operation gets it bitsize to indicate that ""it; // operates with a speed comparable to N-bit wide load"". With the full; // alignment ds128 is slower than ds96 for example. If underaligned it; // is comparable to a speed of a single dword access, which would then; // mean 32 < 128 and it is faster to issue a wide load regardless.; // 1 is simply ""slow, don't do it"". I.e. comparing an aligned load to a; // wider load which will not be aligned anymore the latter is slower.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:770,simpl,simply,770,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['simpl'],['simply']
Usability,"// We will handle these bits from offset, clear them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:42,clear,clear,42,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,3,['clear'],['clear']
Usability,// We will insert coro.end to cut any of the destructors for objects that; // do not need to be destroyed once the coroutine is resumed.; // See llvm/docs/Coroutines.rst for more details about coro.end.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:128,resume,resumed,128,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,1,['resume'],['resumed']
Usability,"// We will only fill fragments for simple memory-describing dbg.value; // intrinsics. If the fragment offset is the same as the offset from the; // base pointer, do The Thing, otherwise fall back to normal dbg.value; // behaviour. AssignmentTrackingLowering has generated DIExpressions; // written in terms of the base pointer.; // TODO: Remove this condition since the fragment offset doesn't always; // equal the offset from base pointer (e.g. for a SROA-split variable).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:35,simpl,simple,35,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['simpl'],['simple']
Usability,// We won't bother with the InstSimplify interface if we didn't simplify any; // operand ourselves.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:64,simpl,simplify,64,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['simpl'],['simplify']
Usability,"// We'll still produce a fatal error downstream, but this diagnostic is more; // user-friendly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:81,user-friendly,user-friendly,81,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,1,['user-friendly'],['user-friendly']
Usability,"// We're ZExt i1 to i64. The ANDWri Wd, Ws, #1 implicitly clears the; // upper 32 bits. Emit a SUBREG_TO_REG to extend from Wd to Xd.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:58,clear,clears,58,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,1,['clear'],['clears']
Usability,"// We're about to hand off ownership of ourself to the continuation. Grab a; // pointer to the context so that we can call it to initiate the lookup.; //; // FIXME: Once MSVC implements c++17 order of evaluation rules for calls this; // can be simplified to:; //; // Ctx->lookup(std::move(UnresolvedExternals),; // [Self=std::move(Self)](Expected<AsyncLookupResult> Result) {; // Self->linkPhase3(std::move(Self), std::move(Result));; // });",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.cpp:244,simpl,simplified,244,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.cpp,1,['simpl'],['simplified']
Usability,// We're extracting from an overflow intrinsic. See if we're the only user.; // That allows us to simplify multiple result intrinsics to simpler things; // that just get one value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:98,simpl,simplify,98,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,2,['simpl'],"['simpler', 'simplify']"
Usability,"// We're generating a SELECT way after legalization, so keep the types; // simple.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:75,simpl,simple,75,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,1,['simpl'],['simple']
Usability,// We're looking for a simple add recurrence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:23,simpl,simple,23,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,1,['simpl'],['simple']
Usability,"// We're undoing ActOnTagStartDefinition here, not; // ActOnStartCXXMemberDeclarations, so we don't have to mess with; // the FieldCollector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:9,undo,undoing,9,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['undo'],['undoing']
Usability,"// We've actually done something - now clear misc accumulated junk (fabs,; // bitcast).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:39,clear,clear,39,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,1,['clear'],['clear']
Usability,// We've already marked the nodes internally with the RefSCC number so; // just clear them off the stack and continue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:80,clear,clear,80,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,1,['clear'],['clear']
Usability,"// We've changed the contents of this DIArgList, and the set storage may; // already contain a DIArgList with our new set of args; if it does, then we; // must RAUW this with the existing DIArgList, otherwise we simply insert this; // back into the set storage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp:212,simpl,simply,212,interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,1,['simpl'],['simply']
Usability,// We've cleared out analyses for deleted functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:9,clear,cleared,9,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,1,['clear'],['cleared']
Usability,"// WebGL clears buffers, therefore we should render scene and convert immediately",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:9,clear,clears,9,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['clear'],['clears']
Usability,"// Well.. if it's fast is actually another question all together, merely; // it's a quick and dirty simple kNN approach to the 1-Dim signal/backgr. MVA; // distributions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/QuickMVAProbEstimator.cxx:100,simpl,simple,100,tmva/tmva/src/QuickMVAProbEstimator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/QuickMVAProbEstimator.cxx,1,['simpl'],['simple']
Usability,"// When AA isn't available, but if the load and the store have the same; // base, constant offsets and non-overlapping access ranges, ignore the; // store. This is a simple form of alias analysis that is used by the; // inliner. FIXME: use BasicAA if possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:166,simpl,simple,166,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,1,['simpl'],['simple']
Usability,"// When ClearDSOLocalOnDeclarations is true, clear dso_local if GV is; // converted to a declaration, to disable direct access. Don't do this if GV; // is implicitly dso_local due to a non-default visibility.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:8,Clear,ClearDSOLocalOnDeclarations,8,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,2,"['Clear', 'clear']","['ClearDSOLocalOnDeclarations', 'clear']"
Usability,"// When From != SimplifiedType, we can simplify the type some more by using; // the simplify_type template.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h:16,Simpl,SimplifiedType,16,interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,2,"['Simpl', 'simpl']","['SimplifiedType', 'simplify']"
Usability,"// When From == SimpleType, we are as simple as we are going to get.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h:16,Simpl,SimpleType,16,interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,2,"['Simpl', 'simpl']","['SimpleType', 'simple']"
Usability,"// When a PHI is used only to be compared with zero, it is safe to replace; // an incoming value proved as known nonzero with any non-zero constant.; // For example, in the code below, the incoming value %v can be replaced; // with any non-zero constant based on the fact that the PHI is only used to; // be compared with zero and %v is a known non-zero value:; // %v = select %cond, 1, 2; // %p = phi [%v, BB] ...; // icmp eq, %p, 0; // FIXME: To be simple, handle only integer type for now.; // This handles a small number of uses to keep the complexity down, and an; // icmp(or(phi)) can equally be replaced with any non-zero constant as the; // ""or"" will only add bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:451,simpl,simple,451,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,1,['simpl'],['simple']
Usability,"// When a coroutine reaches final suspend point, it zeros out ResumeFnAddr in; // the coroutine frame (it is UB to resume from a final suspend point).; // The llvm.coro.done intrinsic is used to check whether a coroutine is; // suspended at the final suspend point or not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp:62,Resume,ResumeFnAddr,62,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp,2,"['Resume', 'resume']","['ResumeFnAddr', 'resume']"
Usability,"// When an edge in the graph has been threaded, values that we could not; // determine a value for before (i.e. were marked overdefined) may be; // possible to solve now. We do NOT try to proactively update these values.; // Instead, we clear their entries from the cache, and allow lazy updating to; // recompute them when needed.; // The updating process is fairly simple: we need to drop cached info; // for all values that were marked overdefined in OldSucc, and for those same; // values in any successor of OldSucc (except NewSucc) in which they were; // also marked overdefined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:237,clear,clear,237,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,2,"['clear', 'simpl']","['clear', 'simple']"
Usability,"// When are coming out of an unevaluated context, clear out any; // temporaries that we may have created as part of the evaluation of; // the expression in that context: they aren't relevant because they; // will never be constructed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:50,clear,clear,50,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['clear'],['clear']
Usability,// When at O3 add argument promotion to the pass pipeline.; // FIXME: It isn't at all clear why this should be limited to O3.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:86,clear,clear,86,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['clear'],['clear']
Usability,"// When building with per target runtime directories, various ways of naming; // the Arm architecture may have been normalised to simply ""arm"".; // For example ""armv8l"" (Armv8 AArch32 little endian) is replaced with ""arm"".; // Since an armv8l system can use libraries built for earlier architecture; // versions assuming endian and float ABI match.; //; // Original triple: armv8l-unknown-linux-gnueabihf; // Runtime triple: arm-unknown-linux-gnueabihf; //; // We do not do this for armeb (big endian) because doing so could make us; // select little endian libraries. In addition, all known armeb triples only; // use the ""armeb"" architecture name.; //; // M profile Arm is bare metal and we know they will not be using the per; // target runtime directory layout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp:130,simpl,simply,130,interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp,1,['simpl'],['simply']
Usability,"// When calling write on a different profile map, existing names should be; // cleared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfWriter.cpp:79,clear,cleared,79,interpreter/llvm-project/llvm/lib/ProfileData/SampleProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfWriter.cpp,1,['clear'],['cleared']
Usability,"// When calling write on a different profile map, existing states should be; // cleared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfWriter.cpp:80,clear,cleared,80,interpreter/llvm-project/llvm/lib/ProfileData/SampleProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfWriter.cpp,1,['clear'],['cleared']
Usability,"// When dealing with individual condition-register bits, we have simple set; // and unset predicates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h:65,simpl,simple,65,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h,1,['simpl'],['simple']
Usability,"// When directing calling an inline builtin, call it through it's mangled; // name to make it clear it's not the actual builtin.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:94,clear,clear,94,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['clear'],['clear']
Usability,"// When emitting the root class GCC emits ivar entries for the; // actual class structure. It is not clear if we need to follow this; // behavior; for now lets try and get away with not doing it. If so,; // the cleanest solution would be to make up an ObjCInterfaceDecl; // for the class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:101,clear,clear,101,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['clear'],['clear']
Usability,"// When exporting, consult the index. We can have more than one local; // with the same GUID, in the case of same-named locals in different but; // same-named source files that were compiled in their respective directories; // (so the source file name and resulting GUID is the same). Find the one; // in this module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:88,GUID,GUID,88,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,2,['GUID'],['GUID']
Usability,"// When fCache is set and has no previous and next node, it represents; // the node being cleared and/or deleted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TList.cxx:90,clear,cleared,90,core/cont/src/TList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TList.cxx,1,['clear'],['cleared']
Usability,"// When fully building the reflection info in TClass, a deserialization; // could be triggered, which may result in request for building the; // reflection info for the same TClass. This in turn will clear the caches; // for the TClass in-flight and cause null ptr derefs.; // FIXME: This is a quick fix, solving most of the issues. The actual; // question is: Shouldn't TClass provide a lock mechanism on update or lock; // itself until the update is done.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:200,clear,clear,200,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['clear'],['clear']
Usability,"// When given one NaN and one non-NaN input:; // - maxnum/minnum (C99 fmaxf()/fminf()) return the non-NaN input.; // - A simple C99 (a < b ? a : b) construction will return 'b' (as the; // ordered comparison fails), which could be NaN or non-NaN.; // so here we discover exactly what NaN behavior is required/accepted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:121,simpl,simple,121,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['simpl'],['simple']
Usability,"// When it comes here, the input look like:; // Probe: GUID of C, ...; // InlineStack: [88, A], [66, B]; // which means, Function A inlines function B at call site with a probe id of; // 88, and B inlines C at probe 66. The tri-tree expects a tree path like {[0,; // A], [88, B], [66, C]} to locate the tree node where the probe should be; // added. Note that the edge [0, A] means A is the top-level function we are; // emitting probes for.; // Make a [0, A] edge.; // An empty inline stack means the function that the probe originates from; // is a top-level function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:55,GUID,GUID,55,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,1,['GUID'],['GUID']
Usability,"// When merging declarations, it's common for supplemental information like; // attributes to only be present in one of the declarations, and we generally; // want type merging to preserve the union of information. So a merged; // function type should be noreturn if it was noreturn in *either* operand; // type.; //; // But for the conditional operator, this is backwards. The result of the; // operator could be either operand, and its type should conservatively; // reflect that. So a function type in a composite type is noreturn only; // if it's noreturn in *both* operand types.; //; // Arguably, noreturn is a kind of subtype, and the conditional operator; // ought to produce the most specific common supertype of its operand types.; // That would differ from this rule in contravariant positions. However,; // neither C nor C++ generally uses this kind of subtype reasoning. Also,; // as a practical matter, it would only affect C code that does abstraction of; // higher-order functions (taking noreturn callbacks!), which is uncommon to; // say the least. So we use the simpler rule.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:1081,simpl,simpler,1081,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['simpl'],['simpler']
Usability,"// When producing this diagnostic, we temporarily bypass ourselves,; // clear out any current diagnostic, and let the downstream client; // format the diagnostic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:72,clear,clear,72,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,1,['clear'],['clear']
Usability,"// When scalarizing PHI nodes we might try to examine/rewrite InsertElement; // nodes in predecessors. If those predecessors are unreachable from entry,; // then the IR in those blocks could have unexpected properties resulting in; // infinite loops in Scatterer::operator[]. By simply treating values; // originating from instructions in unreachable blocks as undef we do not; // need to analyse them further.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:279,simpl,simply,279,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,1,['simpl'],['simply']
Usability,"// When the input is extended (i.e. single vector becomes a pair),; // this is done by using an ""undef"" vector as the second input.; // However, then we get; // input 1: GOODBITS; // input 2: ........; // but we need; // input 1: ....BITS; // input 2: ....GOOD; // Then at the end, this needs to be undone. To accomplish this,; // artificially add ""LogLen-1"" at both ends of the sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:299,undo,undone,299,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['undo'],['undone']
Usability,"// When the object is moved with arrow or when the ShowGuideLines flag; // is off we do show guide lines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx:93,guid,guide,93,graf2d/gpad/src/TPad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx,1,['guid'],['guide']
Usability,"// When the simplified type and the from type are not the same, use the type; // simplifier to reduce the type, then reuse cast_retty_impl to get the; // resultant type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h:12,simpl,simplified,12,interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,2,['simpl'],"['simplified', 'simplifier']"
Usability,"// When the simplified type is equal to the from type, use it directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h:12,simpl,simplified,12,interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,1,['simpl'],['simplified']
Usability,"// When these options are used, the compiler is allowed to apply; // optimizations that may affect the final result. For example; // (x+y)+z is transformed to x+(y+z) but may not give the same; // final result; it's not value safe.; // Another example can be to simplify x/x to 1.0 but x could be 0.0, INF; // or NaN. Final result may then differ. An error is issued when the eval; // method is set with one of these options.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:262,simpl,simplify,262,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['simpl'],['simplify']
Usability,"// When they can, TPad::Paint() and TPad::PaintModified() simply; // call the following function:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TVirtualViewer3D.h:58,simpl,simply,58,core/base/inc/TVirtualViewer3D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TVirtualViewer3D.h,1,['simpl'],['simply']
Usability,"// When using C++ modules, we setup the callbacks now that we have them; // ready before we parse code for the first time. Without C++ modules; // we can't setup the calls now because the clang PCH currently just; // overwrites it in the Initialize method and we have no simple way to; // initialize them earlier. We handle the non-modules case below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:271,simpl,simple,271,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,1,['simpl'],['simple']
Usability,"// When using an external thunk for retpolines, we pick names that match the; // names GCC happens to use as well. This helps simplify the implementation; // of the thunks for kernels where they have no easy ability to create; // aliases and are doing non-trivial configuration of the thunk's body. For; // example, the Linux kernel will do boot-time hot patching of the thunk; // bodies and cannot easily export aliases of these to loaded modules.; //; // Note that at any point in the future, we may need to change the semantics; // of how we implement retpolines and at that time will likely change the; // name of the called thunk. Essentially, there is no hard guarantee that; // LLVM will generate calls to specific thunks, we merely make a best-effort; // attempt to help out kernels and other systems where duplicating the; // thunks is costly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:126,simpl,simplify,126,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simplify']
Usability,"// When we are going to clone an exit, we don't need to clone all the; // instructions in the exit block and we want to ensure we have an easy; // place to merge the CFG, so split the exit first. This is always safe to; // do because there cannot be any non-loop predecessors of a loop exit in; // loop simplified form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:303,simpl,simplified,303,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['simpl'],['simplified']
Usability,"// When we have a concrete function, first try to simplify it directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:50,simpl,simplify,50,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['simpl'],['simplify']
Usability,// When we leave this function this RAII will make sure the member; // KernelEnvC is updated properly depending on the state. That member is; // used for simplification of values and needs to be up to date at all; // times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:154,simpl,simplification,154,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['simpl'],['simplification']
Usability,"// When we see 'typedef A B', we add name 'B' to the set of names; // A's canonical type maps to. This is necessary for implementing; // isDerivedFrom(x) properly, where x can be the name of the base; // class or any of its aliases.; //; // In general, the is-alias-of (as defined by typedefs) relation; // is tree-shaped, as you can typedef a type more than once. For; // example,; //; // typedef A B;; // typedef A C;; // typedef C D;; // typedef C E;; //; // gives you; //; // A; // |- B; // `- C; // |- D; // `- E; //; // It is wrong to assume that the relation is a chain. A correct; // implementation of isDerivedFrom() needs to recognize that B and; // E are aliases, even though neither is a typedef of the other.; // Therefore, we cannot simply walk through one typedef chain to; // find out whether the type name matches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:747,simpl,simply,747,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,1,['simpl'],['simply']
Usability,"// When we zero-extend from i32 to i64, we use a pattern like this:; // def : Pat<(i64 (zext i32:$in)),; // (RLDICL (INSERT_SUBREG (i64 (IMPLICIT_DEF)), $in, sub_32),; // 0, 32)>;; // There are several 32-bit shift/rotate instructions, however, that will; // clear the higher-order bits of their output, rendering the RLDICL; // unnecessary. When that happens, we remove it here, and redefine the; // relevant 32-bit operation to be a 64-bit operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:259,clear,clear,259,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['clear'],['clear']
Usability,"// Where lowering the priority in predecessors is not possible, the; // block receiving control either was not part of a loop in the first; // place or the loop simplification/canonicalization pass should have; // already tried to split the edge and insert a preheader, and if for; // whatever reason it failed to do so, then this leaves us with the; // only option of lowering the priority within the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSetWavePriority.cpp:161,simpl,simplification,161,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSetWavePriority.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSetWavePriority.cpp,1,['simpl'],['simplification']
Usability,"// Whether cache is in learning phase",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TEventIter.h:23,learn,learning,23,proof/proofplayer/inc/TEventIter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TEventIter.h,1,['learn'],['learning']
Usability,// Whether this loop should be optimized for size based on profile guided size; // optimizatios.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:67,guid,guided,67,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['guid'],['guided']
Usability,// Whether to evaluate the C++20 constraints or simply substitute into them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Template.h:48,simpl,simply,48,interpreter/llvm-project/clang/include/clang/Sema/Template.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Template.h,2,['simpl'],['simply']
Usability,"// While processing the basic block, we kept `Def` relative to the start; // of the basic block for convenience. However, future use of this information; // only cares about the clearance from the end of the block, so adjust; // everything to be relative to the end of the basic block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp:178,clear,clearance,178,interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ReachingDefAnalysis.cpp,1,['clear'],['clearance']
Usability,// While simplifying we may discover dead code or cause code to become dead.; // Keep track of all such instructions and we will delete them at the end.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:9,simpl,simplifying,9,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,1,['simpl'],['simplifying']
Usability,"// While some warnings are attached to AST nodes (mostly path-sensitive; // checks), others are simply associated with a plain source location; // or range. Figuring out the node based on locations can be tricky,; // so instead, we traverse the whole body of the declaration and gather; // information on ALL suppressions. After that we can simply check if; // any of those suppressions affect the warning in question.; //; // Traversing AST of a function is not a heavy operation, but for; // large functions with a lot of bugs it can make a dent in performance.; // In order to avoid this scenario, we cache traversal results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:96,simpl,simply,96,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,2,['simpl'],['simply']
Usability,"// Wipe away any newly created TypoExprs that we don't know about. Since we; // clear any invalid TypoExprs in `CheckForRecursiveTypos`, this is only; // possible if a `TypoExpr` is created during a transformation but then; // fails before we can discover it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:80,clear,clear,80,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['clear'],['clear']
Usability,"// Wire up the FunctionProtoTypeLocs with the call operator's parameters.; // These parameter's are essentially used to transform the name and; // the type of the conversion operator. By using the same parameters; // as the call operator's we don't have to fix any back references that; // the trailing return type of the call operator's uses (such as; // decltype(some_type<decltype(a)>::type{} + decltype(a){}) etc.); // - we can simply use the return type of the call operator, and; // everything should work.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:432,simpl,simply,432,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,1,['simpl'],['simply']
Usability,"// With C++17 copy elision the InitExpr can be anything, so instead of; // pattern matching all cases, we simple check if the current field is; // under construction or not, regardless what it's InitExpr is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:106,simpl,simple,106,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,1,['simpl'],['simple']
Usability,"// With Cocoa XOR is fake, so no need in erasing the old box, it's; // done by clearing the backing store and repainting inside a special; // window.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx:79,clear,clearing,79,gui/fitpanel/src/TFitEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx,1,['clear'],['clearing']
Usability,"// With a name, the ValueType simply provides the type of the named; // variable.; //; // (sext_inreg i32:$src, i16); // ~~~~~~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:30,simpl,simply,30,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['simpl'],['simply']
Usability,"// With all other options exhausted, loop until the system is simple; // enough to handle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:62,simpl,simple,62,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['simpl'],['simple']
Usability,"// With one `simplifySValOnce` call, a compound symbols might collapse to; // simpler symbol tree that is still possible to further simplify. Thus, we; // do the simplification on a new symbol tree until we reach the simplest; // form, i.e. the fixpoint.; // Consider the following symbol `(b * b) * b * b` which has this tree:; // *; // / \; // * b; // / \; // / b; // (b * b); // Now, if the `b * b == 1` new constraint is added then during the first; // iteration we have the following transformations:; // * *; // / \ / \; // * b --> b b; // / \; // / b; // 1; // We need another iteration to reach the final result `1`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:13,simpl,simplifySValOnce,13,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,5,['simpl'],"['simpler', 'simplest', 'simplification', 'simplify', 'simplifySValOnce']"
Usability,"// With the operands remapped, see if the instruction constant folds or is; // otherwise simplifyable. This commonly occurs because the entry from PHI; // nodes allows icmps and other instructions to fold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:89,simpl,simplifyable,89,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,1,['simpl'],['simplifyable']
Usability,"// Within C++20 modules, we may have multiple same constructors in; // multiple same RecordDecls. And it doesn't make sense to create; // duplicated deduction guides for the duplicated constructors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:159,guid,guides,159,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['guid'],['guides']
Usability,// Work out the hashed gradient indices of the five simplex corners,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs:52,simpl,simplex,52,js/modules/three_addons.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs,1,['simpl'],['simplex']
Usability,// Work out the hashed gradient indices of the four simplex corners,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs:52,simpl,simplex,52,js/modules/three_addons.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs,1,['simpl'],['simplex']
Usability,// Work out the hashed gradient indices of the three simplex corners,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs:53,simpl,simplex,53,js/modules/three_addons.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs,1,['simpl'],['simplex']
Usability,// Workaround a hardware bug on SI where the condition output from div_scale; // is not usable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:88,usab,usable,88,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,2,['usab'],['usable']
Usability,"// Wrapper for TGeoShape with absolute positioning and color attributes allowing display of extracted TGeoShape's (without an active TGeoManager) and simplified geometries (needed for NLT projections).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveGeoShape.h:150,simpl,simplified,150,graf3d/eve/inc/TEveGeoShape.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveGeoShape.h,1,['simpl'],['simplified']
Usability,// Write out new DBG_VALUE instructions.; // We only do this if ClearVirtRegs is specified since this should be the; // final run of the pass and we don't want to emit them multiple times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:64,Clear,ClearVirtRegs,64,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,1,['Clear'],['ClearVirtRegs']
Usability,// Write the MemProf profile data if we have it. This includes a simple schema; // with the format described below followed by the hashtable:; // uint64_t RecordTableOffset = RecordTableGenerator.Emit; // uint64_t FramePayloadOffset = Stream offset before emitting the frame table; // uint64_t FrameTableOffset = FrameTableGenerator.Emit; // uint64_t Num schema entries; // uint64_t Schema entry 0; // uint64_t Schema entry 1; // ....; // uint64_t Schema entry N - 1; // OnDiskChainedHashTable MemProfRecordData; // OnDiskChainedHashTable MemProfFrameData,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp:65,simpl,simple,65,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,1,['simpl'],['simple']
Usability,"// Wt = momentum * Wt-1 + (learningRate * currentBiasGradients) / (sqrt(Vt + epsilon))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RMSProp.h:27,learn,learningRate,27,tmva/tmva/inc/TMVA/DNN/RMSProp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RMSProp.h,1,['learn'],['learningRate']
Usability,"// Wt = momentum * Wt-1 + (learningRate * currentWeightGradients) / (sqrt(Vt + epsilon))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RMSProp.h:27,learn,learningRate,27,tmva/tmva/inc/TMVA/DNN/RMSProp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RMSProp.h,1,['learn'],['learningRate']
Usability,"// X % 1.0 (doesn't simplify, but it is safe)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h:20,simpl,simplify,20,interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,1,['simpl'],['simplify']
Usability,"// X - (X % ?); // The remainder of a value can't have greater magnitude than itself,; // so the subtraction can't overflow.; // X - (X -nsw ?); // In the minimal case, this would simplify to ""?"", so there's no subtract; // at all. But if this analysis is used to peek through casts, for example,; // then determining no-overflow may allow other transforms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:180,simpl,simplify,180,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['simpl'],['simplify']
Usability,"// X - (X % ?); // The remainder of a value can't have greater magnitude than itself,; // so the subtraction can't overflow.; // X - (X -nuw ?); // In the minimal case, this would simplify to ""?"", so there's no subtract; // at all. But if this analysis is used to peek through casts, for example,; // then determining no-overflow may allow other transforms.; // TODO: There are other patterns like this.; // See simplifyICmpWithBinOpOnLHS() for candidates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:180,simpl,simplify,180,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,2,['simpl'],"['simplify', 'simplifyICmpWithBinOpOnLHS']"
Usability,"// X - (Y + Z) -> (X - Y) - Z or (X - Z) - Y if everything simplifies.; // For example, X - (X + 1) -> -1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,simpl,simplifies,59,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// X - (Y + Z); // See if ""V === X - Y"" simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:40,simpl,simplifies,40,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// X - Y == 0 --> X == Y.; // X - Y != 0 --> X != Y.; // TODO: We allow this with multiple uses as long as the other uses are not; // in phis. The phi use check is guarding against a codegen regression; // for a loop test. If the backend could undo this (and possibly; // subsequent transforms), we would not need this hack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:244,undo,undo,244,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['undo'],['undo']
Usability,"// X / 0 -> poison; // X % 0 -> poison; // If the divisor is known to be zero, just return poison. This can happen in; // some cases where its provable indirectly the denominator is zero but it's; // not trivially simplifiable (i.e known zero through a phi node).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:214,simpl,simplifiable,214,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifiable']
Usability,"// X86 Interrupt handling function cannot assume anything about the direction; // flag (DF in EFLAGS register). Clear this flag by creating ""cld"" instruction; // in each prologue of interrupt handler function.; //; // FIXME: Create ""cld"" instruction only in these cases:; // 1. The interrupt handling function uses any of the ""rep"" instructions.; // 2. Interrupt handling function calls another function.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:112,Clear,Clear,112,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['Clear'],['Clear']
Usability,// XLo = X & HalfMask; // YLo = Y & HalfMask; // TODO: Refactor with SimplifyDemandedBits or KnownBits known leading zeros; // to enhance robustness,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:69,Simpl,SimplifyDemandedBits,69,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['Simpl'],['SimplifyDemandedBits']
Usability,"// XXXX Fix this. It seems we could have flat shading with usage of simple shaders.; // XXXX Also, we could do edge detect on the server for outlines.; // XXXX a) 3d objects - angle between triangles >= 85 degrees (or something);; // XXXX b) 2d objects - segment only has one triangle.; // XXXX Somewhat orthogonal - when we do tesselation, conversion from quads to; // XXXX triangles is trivial, we could do it before invoking the big guns (if they are even needed).; // XXXX Oh, and once triangulated, we really don't need to store 3 as number of verts in a poly each time.; // XXXX Or do we? We might need it for projection stuff.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveElements.js:68,simpl,simple,68,ui5/eve7/lib/EveElements.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveElements.js,2,['simpl'],['simple']
Usability,"// XXXX This should be element added. Also, should be different for; // ""full (re)construction"". Scenes should manage that and have; // state like: none - constructing - clearing - nominal - updating.; // I recon this means an element should have a ptr to its scene.; //; // ElementChanged();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveElement.cxx:170,clear,clearing,170,graf3d/eve7/src/REveElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveElement.cxx,1,['clear'],['clearing']
Usability,"// Xor/and/or are indifferent to the swizzle operation (shuffle of one value).; // Simplify xor/and/or (shuff(A), shuff(B)) -> shuff(op (A,B)); // If both shuffles use the same mask, and both shuffle within a single; // vector, then it is worthwhile to move the swizzle after the operation.; // The type-legalizer generates this pattern when loading illegal; // vector types from memory. In many cases this allows additional shuffle; // optimizations.; // There are other cases where moving the shuffle after the xor/and/or; // is profitable even if shuffles don't perform a swizzle.; // If both shuffles use the same mask, and both shuffles have the same first; // or second operand, then it might still be profitable to move the shuffle; // after the xor/and/or operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:83,Simpl,Simplify,83,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Simpl'],['Simplify']
Usability,"// Yep, clear it and print it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp:8,clear,clear,8,interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSectionMachO.cpp,1,['clear'],['clear']
Usability,"// You might think that it would be ok to set DebugInfoKind outside of; // the guard for source type, however there is a test which asserts; // that some assembler invocation receives no -debug-info-kind,; // and it's not clear whether that test is just overly restrictive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:222,clear,clear,222,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['clear'],['clear']
Usability,"// Z - (X - Y) -> (Z - X) + Y if everything simplifies.; // For example, X - (X - Y) -> Y.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:44,simpl,simplifies,44,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,"// Z - (X - Y); // See if ""V === Z - X"" simplifies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:40,simpl,simplifies,40,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,// Z clear,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:5,clear,clear,5,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['clear'],['clear']
Usability,// Z clear and C set,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:5,clear,clear,5,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['clear'],['clear']
Usability,"// Z clear, N and V the same",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:5,clear,clear,5,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['clear'],['clear']
Usability,// Z set or C clear,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:14,clear,clear,14,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['clear'],['clear']
Usability,"// Zero-initialize. (Strictly speaking, we only need to initialize; // the padding at the end, but this is simpler.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp:107,simpl,simpler,107,interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,1,['simpl'],['simpler']
Usability,// [ and { may begin a simple key.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp:23,simpl,simple,23,interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,1,['simpl'],['simple']
Usability,// [GNU] simple-asm-expr[opt] attributes[opt],MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:9,simpl,simple-asm-expr,9,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['simpl'],['simple-asm-expr']
Usability,"// [SimpleLoopUnswitch] If BB is a dead block, about to be deleted, its; // DT is invalidated. Return LoE as its last def. This will be added to; // MemoryPhi node, and later deleted when the block is deleted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:4,Simpl,SimpleLoopUnswitch,4,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['Simpl'],['SimpleLoopUnswitch']
Usability,"// [basic.def.odr]/13:; // There can be more than one definition of a; // ...; // default template argument; // ...; // in a program provided that each definition appears in a different; // translation unit and the definitions satisfy the [same-meaning; // criteria of the ODR].; //; // Simply, the design of modules allows the definition of template default; // argument to be repeated across translation unit. Note that the ODR is; // checked elsewhere. But it is still not allowed to repeat template default; // argument in the same translation unit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:287,Simpl,Simply,287,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['Simpl'],['Simply']
Usability,// [dcl.meaning]p1: An unqualified-id occurring in a declarator-id shall be a; // simple identifier except [...irrelevant cases...].,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:82,simpl,simple,82,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['simpl'],['simple']
Usability,// [module.global.frag]p2; // A global-module-fragment specifies the contents of the global module; // fragment for a module unit. The global module fragment can be used to; // provide declarations that are attached to the global module and usable; // within the module unit.; //; // So the declations in the global module shouldn't be visible by default.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:241,usab,usable,241,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,1,['usab'],['usable']
Usability,"// [module.interface]p7:; // A declaration is attached to a module as follows:; // - If the declaration is a non-dependent friend declaration that nominates a; // function with a declarator-id that is a qualified-id or template-id or that; // nominates a class other than with an elaborated-type-specifier with neither; // a nested-name-specifier nor a simple-template-id, it is attached to the; // module to which the friend is attached ([basic.link]).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:353,simpl,simple-template-id,353,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['simpl'],['simple-template-id']
Usability,// __COUNTER__ expands to a simple numeric value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:28,simpl,simple,28,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['simpl'],['simple']
Usability,// __FLT_EVAL_METHOD__ expands to a simple numeric value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:36,simpl,simple,36,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['simpl'],['simple']
Usability,// __INCLUDE_LEVEL__ expands to a simple numeric value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:34,simpl,simple,34,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['simpl'],['simple']
Usability,// __LINE__ expands to a simple numeric value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:25,simpl,simple,25,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['simpl'],['simple']
Usability,"// __llvm_retpoline_r11:; // callq .Lr11_call_target; // .Lr11_capture_spec:; // pause; // lfence; // jmp .Lr11_capture_spec; // .align 16; // .Lr11_call_target:; // movq %r11, (%rsp); // retq",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp:81,pause,pause,81,interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp,1,['pause'],['pause']
Usability,"// __shared__ variables are odd. Shadows do get created, but; // they are not registered with the CUDA runtime, so they; // can't really be used to access their device-side; // counterparts. It's not clear yet whether it's nvcc's bug or; // a feature, but we've got to do the same for compatibility.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:200,clear,clear,200,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,1,['clear'],['clear']
Usability,"// __unknown_anytype(...) is a special case used by the debugger when; // it has no idea what a function's signature is.; //; // We want to build this call essentially under the K&R; // unprototyped rules, but making a FunctionNoProtoType in C++; // would foul up all sorts of assumptions. However, we cannot; // simply pass all arguments as variadic arguments, nor can we; // portably just call the function under a non-variadic type; see; // the comment on IR-gen's TargetInfo::isNoProtoCallVariadic.; // However, it turns out that in practice it is generally safe to; // call a function declared as ""A foo(B,C,D);"" under the prototype; // ""A foo(B,C,D,...);"". The only known exception is with the; // Windows ABI, where any variadic function is implicitly cdecl; // regardless of its normal CC. Therefore we change the parameter; // types to match the types of the arguments.; //; // This is a hack, but it is far superior to moving the; // corresponding target-specific code from IR-gen to Sema/AST.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:313,simpl,simply,313,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['simpl'],['simply']
Usability,"// `ReturnVal` might not always get set -- for example if we have a return; // statement of the form `return some_other_func()` and we decide not to; // analyze `some_other_func()`.; // In this case, we can't say anything about the joined return value -- we; // don't simply want to propagate the return value that we do have, because; // it might not be the correct one.; // This occurs for example in the test `ContextSensitiveMutualRecursion`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:268,simpl,simply,268,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,1,['simpl'],['simply']
Usability,"// a simple geometry checker",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/inc/TGeoChecker.h:5,simpl,simple,5,geom/geompainter/inc/TGeoChecker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/inc/TGeoChecker.h,1,['simpl'],['simple']
Usability,"// a simple structure to encode voxel indices, to address; // individual voxels in the 3D grid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoVoxelGrid.h:5,simpl,simple,5,geom/geom/inc/TGeoVoxelGrid.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoVoxelGrid.h,1,['simpl'],['simple']
Usability,// abs (sext X) --> zext (abs X*); // Clear the IsIntMin (nsw) bit on the abs to allow narrowing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:38,Clear,Clear,38,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['Clear'],['Clear']
Usability,"// add 1, not 0, because there is no implicit clearing; // of the high bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXCopy.cpp:46,clear,clearing,46,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXCopy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXCopy.cpp,1,['clear'],['clearing']
Usability,// add clear function for item,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/http/httptextlog.mjs:7,clear,clear,7,tutorials/http/httptextlog.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/http/httptextlog.mjs,1,['clear'],['clear']
Usability,"// add nsw/nuw (xor Y, signmask), signmask --> Y; // The no-wrapping add guarantees that the top bit will be set by the add.; // Therefore, the xor must be clearing the already set sign bit of Y.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:156,clear,clearing,156,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['clear'],['clearing']
Usability,"// aka uxtw; // Check for the 32 -> 64 bit extension case, these instructions can do; // much more.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:7,ux,uxtw,7,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['ux'],['uxtw']
Usability,"// alpha = learningRate * sqrt(1 - beta2^t) / (1-beta1^t)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adam.h:11,learn,learningRate,11,tmva/tmva/inc/TMVA/DNN/Adam.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adam.h,2,['learn'],['learningRate']
Usability,// also clear data which could be associated with item,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:8,clear,clear,8,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clear']
Usability,// always use black clear color except in tone map,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/GlViewerRCore.js:20,clear,clear,20,ui5/eve7/lib/GlViewerRCore.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/GlViewerRCore.js,1,['clear'],['clear']
Usability,"// and (icmp eq a, b), x implies (a==b) inside x.; // or (icmp ne a, b), x implies (a==b) inside x.; // If x simplifies to true/false, we can simplify the and/or.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:109,simpl,simplifies,109,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,['simpl'],"['simplifies', 'simplify']"
Usability,"// and(x, -x) is common idioms that will clear all but lowest set; // bit. If we have a single known bit in x, we can clear all bits; // above it.; // TODO: instcombine often reassociates independent `and` which can hide; // this pattern. Try to match and(x, and(-x, y)) / and(and(x, y), -x).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:41,clear,clear,41,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,2,['clear'],['clear']
Usability,"// and(x, add (x, -1)) is a common idiom that always clears the low bit;; // xor/or(x, add (x, -1)) is an idiom that will always set the low bit.; // here we handle the more general case of adding any odd number by; // matching the form and/xor/or(x, add(x, y)) where y is odd.; // TODO: This could be generalized to clearing any bit set in y where the; // following bit is known to be unset in y.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:53,clear,clears,53,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,2,['clear'],"['clearing', 'clears']"
Usability,// any message from server clear all warnings,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/browser/controller/Browser.controller.js:27,clear,clear,27,ui5/browser/controller/Browser.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/browser/controller/Browser.controller.js,1,['clear'],['clear']
Usability,// any single contingous sequence of 1s anywhere in the mask simply; // describes a subset of the input bits shifted to the appropriate; // position. Replace with the straight forward IR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp:61,simpl,simply,61,interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstCombineIntrinsic.cpp,2,['simpl'],['simply']
Usability,"// as I learned multiplications are much faster than division, and later I need one per bin. Well, not that it would really matter here I guess :)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Tools.cxx:8,learn,learned,8,tmva/tmva/src/Tools.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Tools.cxx,1,['learn'],['learned']
Usability,"// as soon as we know how to get event weights, get that here; // note: the normalization of event weights will affect the choice; // of learning rate, one will have to experiment to get the right value.; // in general, if the ""average"" event weight is 1, the learning rate; // should be good if set around 0.02 (a good value if all event weights are 1)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx:137,learn,learning,137,tmva/tmva/src/MethodMLP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx,2,['learn'],['learning']
Usability,"// avoid warning; // normally this method would be complex, but here it is simple for debugging",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/DebuggingSampler.h:75,simpl,simple,75,roofit/roostats/inc/RooStats/DebuggingSampler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/DebuggingSampler.h,1,['simpl'],['simple']
Usability,// base-clause can have simple-template-id; 'template' can't be there,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:24,simpl,simple-template-id,24,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['simpl'],['simple-template-id']
Usability,"// before creating, clear away caches if any if pdf is in ws",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNLLVar.cxx:20,clear,clear,20,roofit/xroofit/src/xRooNLLVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNLLVar.cxx,1,['clear'],['clear']
Usability,"// before getting into regexps, try simple matches; // and overwrite the input",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:36,simpl,simple,36,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['simpl'],['simple']
Usability,"// before saving, clear the eocache of all owned nodes; // because causes memory leak when read back in (workspace streamer immediately overwrites the caches); // fixed in: https://github.com/root-project/root/pull/12024",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:18,clear,clear,18,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['clear'],['clear']
Usability,"// bool GSLMultiRootFinder::AddFunction( const ROOT::Math::IMultiGenFunction & func) {; // // clone and add function to the list; // // If using a derivative algorithm the function is checked if it implements; // // the gradient interface. If this is not the case the type is set to non-derivatibe algo; // ROOT::Math::IGenMultiFunction * f = func.Clone();; // if (f != 0) return false;; // if (fUseDerivAlgo) {; // bool gradFunc = (dynamic_cast<ROOT::Math::IMultiGradFunction *> (f) != 0 );; // if (!gradFunc) {; // MATH_ERROR_MSG(""GSLMultiRootFinder::AddFunction"",""Function does not provide gradient interface"");; // MATH_WARN_MSG(""GSLMultiRootFinder::AddFunction"",""clear the function list"");; // ClearFunctions();; // return false;; // }; // }; // fFunctions.push_back(f);; // return true;; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiRootFinder.cxx:668,clear,clear,668,math/mathmore/src/GSLMultiRootFinder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiRootFinder.cxx,2,"['Clear', 'clear']","['ClearFunctions', 'clear']"
Usability,"// boundary case CL -> 0; // 6-10 TEST PLC CONFINT SIMPLE POISSON : Observed value range is [0,1000]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/stressRooStats.cxx:51,SIMPL,SIMPLE,51,roofit/roostats/test/stressRooStats.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/stressRooStats.cxx,1,['SIMPL'],['SIMPLE']
Usability,"// br(!x, t, f) -> br(x, f, t); // Avoid doing this optimization when instrumenting a condition for MC/DC.; // LNot is taken as part of the condition for simplicity, and changing its; // sense negatively impacts test vector tracking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:154,simpl,simplicity,154,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['simpl'],['simplicity']
Usability,"// browse list of feedback histos and check user's selected ones",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:18,feedback,feedback,18,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,5,['feedback'],['feedback']
Usability,// buffers might not be writable which is required to ensure a correct clear,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:71,clear,clear,71,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clear']
Usability,// build simple curve,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:9,simpl,simple,9,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,"// build_vector(N=ARMISD::VMOVRRD(X), N:1) -> bit_convert(X):; // VMOVRRD is introduced when legalizing i64 types. It forces the i64 value; // into a pair of GPRs, which is fine when the value is used as a scalar,; // but if the i64 value is converted to a vector, we need to undo the VMOVRRD.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:276,undo,undo,276,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['undo'],['undo']
Usability,"// bumpMBB simply decreases the stack pointer, since we know the current; // stacklet has enough space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:11,simpl,simply,11,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['simpl'],['simply']
Usability,"// calculate error matrix from error in regularisation parameter; // ematrix: output; // binMap: see method GetEmatrix(); // clearEmat: set kTRUE to clear the histogram prior to adding the errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx:125,clear,clearEmat,125,hist/unfold/src/TUnfoldSys.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx,2,['clear'],"['clear', 'clearEmat']"
Usability,"// callNumTrailingObjects simply calls numTrailingObjects on the; // provided Obj -- except when the type being queried is BaseTy; // itself. There is always only one of the base object, so that case; // is handled here. (An additional benefit of indirecting through; // this function is that consumers only say ""friend; // TrailingObjects"", and thus, only this class itself can call the; // numTrailingObjects function.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TrailingObjects.h:26,simpl,simply,26,interpreter/llvm-project/llvm/include/llvm/Support/TrailingObjects.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TrailingObjects.h,1,['simpl'],['simply']
Usability,"// can be handled via TWebPainter, simplify colors handling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx:35,simpl,simplify,35,gui/webgui6/src/TWebCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx,1,['simpl'],['simplify']
Usability,"// can only analyze simple loads and stores, i.e., no calls, invokes, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:20,simpl,simple,20,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['simpl'],['simple']
Usability,"// can use previously existing ws; // otherwise clear workspace (if existing)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMCIntegrator.cxx:48,clear,clear,48,math/mathmore/src/GSLMCIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMCIntegrator.cxx,1,['clear'],['clear']
Usability,// carry cleared,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h:9,clear,cleared,9,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h,2,['clear'],['cleared']
Usability,// carry cleared | unsigned less than,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h:9,clear,cleared,9,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h,1,['clear'],['cleared']
Usability,"// case TGraph is not sorted; // find neighbours simply looping all points; // and find also the 2 adjacent points: (low2 < low < x < up < up2 ); // needed in case x is outside the graph ascissa interval",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:49,simpl,simply,49,hist/hist/src/TGraph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx,1,['simpl'],['simply']
Usability,"// case current result is empty; // just make a simple copy of the other result",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverterResult.cxx:48,simpl,simple,48,roofit/roostats/src/HypoTestInverterResult.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverterResult.cxx,1,['simpl'],['simple']
Usability,"// case like: T.Draw(""y:x""); // h2 is a temporary histogram (htemp). This histogram; // will be automatically deleted by TPad::Clear",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorDraw.cxx:127,Clear,Clear,127,tree/treeplayer/src/TSelectorDraw.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorDraw.cxx,1,['Clear'],['Clear']
Usability,"// case like: T.Draw(""y:x""); // h3 is a temporary histogram (htemp). This histogram; // will be automatically deleted by TPad::Clear",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorDraw.cxx:127,Clear,Clear,127,tree/treeplayer/src/TSelectorDraw.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorDraw.cxx,1,['Clear'],['Clear']
Usability,"// case of combined (Migrad+ simplex)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx:29,simpl,simplex,29,math/minuit/src/TMinuitMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx,1,['simpl'],['simplex']
Usability,"// case of simple histogram addition",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:11,simpl,simple,11,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['simpl'],['simple']
Usability,"// case of simple vector, array already in the value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferJSON.cxx:11,simpl,simple,11,io/io/src/TBufferJSON.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferJSON.cxx,1,['simpl'],['simple']
Usability,"// change draw option to Simple Line (L)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TGraphEditor.cxx:25,Simpl,Simple,25,gui/ged/src/TGraphEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TGraphEditor.cxx,1,['Simpl'],['Simple']
Usability,"// check box for option ""clear view""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:25,clear,clear,25,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['clear'],['clear']
Usability,// check if simple reading can be performed and there are direct data in branch,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:12,simpl,simple,12,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,// check if we're trying to clear an integer target,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:28,clear,clear,28,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clear']
Usability,"// choose the initial simplex using single-parameter searches",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:22,simpl,simplex,22,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,1,['simpl'],['simplex']
Usability,"// clang-format off; /**; * \class ROOT::RDataFrame; * \ingroup dataframe; * \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; on their machines completely transparently.<br>; Skip to the [class reference](#reference) or keep reading for the user guide. In a nutshell:; ~~~{.cpp}; ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; myHisto->Draw(); // Event loop is run here, upon first access to a result; ~~~. Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; care of their execution. The implementation automatically puts in place several low level optimisations such as; multi-thread parallelization and caching. \htmlonly; <a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; alt=""DOI""></a>; \endhtmlonly. ## For the impatient user; You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python. ## Table of Contents; - [Cheat sheet](\ref cheatsheet); - [Introduction](\ref introduction); - [Crash course](\ref crash-course); - [Working with collections](\ref collections); - [Transformations: manipulating data](\ref transformations); - [Actions: getting results](\ref actions); - [Distributed execution in Python](\ref distrdf); - [Performance tips and parallel execution](\ref parallel-execution); - [More features](\ref more-features); - [Systematic variations](\ref systematics); - [RDataFrame objects as function arguments and return values](\ref rnode); - [Storing RDataFrame objects in",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:460,guid,guide,460,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['guid'],['guide']
Usability,"// clang-format off; /**; \class ROOT::Experimental::EColumnType; \ingroup NTuple; \brief The available trivial, native content types of a column. More complex types, such as classes, get translated into columns of such simple types by the RField.; When changed, remember to update; - RColumnElement::Generate(); - RColumnElement::GetTypeName(); - RColumnElement::GetValidBitRange(); - RColumnElement template specializations / packing & unpacking; - If necessary, endianess handling for the packing + unit test in ntuple_endian; - RNTupleSerializer::[Des|S]erializeColumnType; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx:220,simpl,simple,220,tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx,1,['simpl'],['simple']
Usability,"// clang-format off; /**; \class ROOT::Experimental::Internal::RColumn; \ingroup NTuple; \brief A column is a storage-backed array of a simple, fixed-size type, from which pages can be mapped into memory.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumn.hxx:136,simpl,simple,136,tree/ntuple/v7/inc/ROOT/RColumn.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumn.hxx,1,['simpl'],['simple']
Usability,"// clang-format off; /**; \class ROOT::Experimental::RNTupleDescriptor; \ingroup NTuple; \brief The on-storage meta-data of an ntuple. Represents the on-disk (on storage) information about an ntuple. The meta-data consists of a header and one or; several footers. The header carries the ntuple schema, i.e. the fields and the associated columns and their; relationships. The footer(s) carry information about one or several clusters. For every cluster, a footer stores; its location and size, and for every column the range of element indexes as well as a list of pages and page; locations. The descriptor provide machine-independent (de-)serialization of headers and footers, and it provides lookup routines; for ntuple objects (pages, clusters, ...). It is supposed to be usable by all RPageStorage implementations. The serialization does not use standard ROOT streamers in order to not let it depend on libCore. The serialization uses; the concept of frames: header, footer, and substructures have a preamble with version numbers and the size of the; writte struct. This allows for forward and backward compatibility when the meta-data evolves.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:774,usab,usable,774,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,1,['usab'],['usable']
Usability,"// clang-format off; /**; \class ROOT::Internal::RDF::GraphCreatorHelper; \ingroup dataframe; \brief Helper class that provides the operation graph nodes. This class is the single point from which graph nodes can be retrieved. Every time an object is created,; it clears the static members and starts again.; By asking this class to create a node, it will return an existing node if already created, otherwise a new one.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/GraphUtils.hxx:264,clear,clears,264,tree/dataframe/inc/ROOT/RDF/GraphUtils.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/GraphUtils.hxx,1,['clear'],['clears']
Usability,"// clang-format off; /**; \class ROOT::VecOps::RVec; \brief A ""std::vector""-like collection of values implementing handy operation to analyse them; \tparam T The type of the contained objects. A RVec is a container designed to make analysis of values' collections fast and easy.; Its storage is contiguous in memory and its interface is designed such to resemble to the one; of the stl vector. In addition the interface features methods and; [external functions](https://root.cern/doc/master/namespaceROOT_1_1VecOps.html) to ease the manipulation and analysis; of the data in the RVec. \note ROOT::VecOps::RVec can also be spelled simply ROOT::RVec. Shorthand aliases such as ROOT::RVecI or ROOT::RVecD; are also available as template instantiations of RVec of fundamental types. The full list of available aliases:; - RVecB (`bool`); - RVecC (`char`); - RVecD (`double`); - RVecF (`float`); - RVecI (`int`); - RVecL (`long`); - RVecLL (`long long`); - RVecU (`unsigned`); - RVecUL (`unsigned long`); - RVecULL (`unsigned long long`). \note RVec does not attempt to be exception safe. Exceptions thrown by element constructors during insertions, swaps or; other operations will be propagated potentially leaving the RVec object in an invalid state. \note RVec methods (e.g. `at` or `size`) follow the STL naming convention instead of the ROOT naming convention in order; to make RVec a drop-in replacement for `std::vector`. \htmlonly; <a href=""https://doi.org/10.5281/zenodo.1253756""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.1253756.svg"" alt=""DOI""></a>; \endhtmlonly. ## Table of Contents; - [Example](\ref example); - [Arithmetic operations, logical operations and mathematical functions](\ref operationsandfunctions); - [Owning and adopting memory](\ref owningandadoptingmemory); - [Sorting and manipulation of indices](\ref sorting); - [Usage in combination with RDataFrame](\ref usagetdataframe); - [Reference for the RVec class](\ref RVecdoxyref); - [Reference for RVec helper funct",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:631,simpl,simply,631,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['simpl'],['simply']
Usability,"// clang-format off; /**; \class TTreeReader; \ingroup treeplayer; \brief A simple, robust and fast interface to read values from ROOT columnar datasets such as TTree, TChain or TNtuple. TTreeReader is associated to TTreeReaderValue and TTreeReaderArray which are handles to concretely; access the information in the dataset. Example code can be found in; - tutorials/tree/hsimpleReader.C; - tutorials/tree/h1analysisTreeReader.C; - <a href=""https://github.com/root-project/roottest/tree/master/root/tree/reader"">This example</a>. You can generate a skeleton of `TTreeReaderValue<T>` and `TTreeReaderArray<T>` declarations; for all of a tree's branches using `TTree::MakeSelector()`. Roottest contains an; <a href=""https://github.com/root-project/roottest/tree/master/root/tree/reader"">example</a>; showing the full power. A simpler analysis example can be found below: it histograms a function of the px and py branches. ~~~{.cpp}; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C). #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"". void hsimpleReader() {; // Create a histogram for the values we read.; TH1F(""h1"", ""ntuple"", 100, -4, 4);. // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");. // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);. // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");. // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }. myHist->Draw();; }; ~~~. A more complete example including error handling and a few combinat",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx:76,simpl,simple,76,tree/treeplayer/src/TTreeReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx,3,['simpl'],"['simple', 'simpler']"
Usability,"// clang-format off; // FIXME: certain users need more information. E.g., SimplifyLibCalls needs to; // know which functions are nounwind, noalias, nocapture parameters, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:74,Simpl,SimplifyLibCalls,74,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,1,['Simpl'],['SimplifyLibCalls']
Usability,"// clang-format off; /// Thread-safe callback for RDataFrame.; /// It will record elapsed times and event statistics, and print a progress bar every n seconds (set by the fPrintInterval).; /// \param value Ignored.; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:130,progress bar,progress bar,130,tree/dataframe/inc/ROOT/RDFHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx,1,['progress bar'],['progress bar']
Usability,"// clang-format off; /// \brief Inform RDataSource of the number of processing slots (i.e. worker threads) used by the associated RDataFrame.; /// Slots numbers are used to simplify parallel execution: RDataFrame guarantees that different threads will always; /// pass different slot values when calling methods concurrently.; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx:173,simpl,simplify,173,tree/dataframe/inc/ROOT/RDataSource.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx,1,['simpl'],['simplify']
Usability,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column that is updated when the input sample changes.; /// \param[in] name The name of the defined column.; /// \param[in] expression A C++ callable that computes the new value of the defined column.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// The signature of the callable passed as second argument should be `T(unsigned int slot, const ROOT::RDF::RSampleInfo &id)`; /// where:; /// - `T` is the type of the defined column; /// - `slot` is a number in the range [0, nThreads) that is different for each processing thread. This can simplify; /// the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; /// - `id` is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is; /// being processed (see the class docs for more information).; ///; /// DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being; /// processed or to inject a callback into the event loop that is only called when the processing of a new sample; /// starts rather than at every entry.; ///; /// The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; /// df.DefinePerSample(""weightbysample"",; /// [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); /// { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; /// ~~~; // clang-format on; // TODO we could SFINAE on F's signature to provide friendlier compilation errors in case of signature mismatch",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:713,simpl,simplify,713,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['simpl'],['simplify']
Usability,// class DrawOptions; /** @summary Simple random generator with controlled seed; * @private */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:35,Simpl,Simple,35,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Simpl'],['Simple']
Usability,"// class RResultBase; // clang-format off; /**; \class ROOT::Experimental::RResult; \ingroup Base; \brief The class is used as a return type for operations that can fail; wraps a value of type T or an RError. The RResult<T> class and their related classes are used for call chains that can throw exceptions,; such as I/O code paths. Throwing of the exception is deferred to allow for `if (result)` style error; checking where it makes sense. If an RResult in error state leaves the scope unchecked, it will throw. A function returning an RResult might look like this:. ~~~ {.cpp}; RResult<int> MyIOFunc(); {; int rv = syscall(...);; if (rv == -1); return R__FAIL(""user-facing error message"");; if (rv == kShortcut); return 42;; return R__FORWARD_RESULT(FuncThatReturnsRResultOfInt());; }; ~~~. Code using MyIOFunc might look like this:. ~~~ {.cpp}; auto result = MyIOOperation();; if (!result) {; // custom error handling or result.Throw(); }; switch (result.Inspect()) {; ...; }; ~~~. Note that RResult<void> can be used for a function without return value, like this. ~~~ {.cpp}; RResult<void> DoSomething(); {; if (failure); return R__FAIL(""user-facing error messge"");; return RResult<void>::Success();; }; ~~~. RResult<T>::Unwrap() can be used as a short hand for; ""give me the wrapped value or, in case of an error, throw"". For instance:. ~~~ {.cpp}; int value = FuncThatReturnsRResultOfInt().Unwrap(); // may throw; ~~~. There is no implict operator that converts RResult<T> to T. This is intentional to make it clear in the calling code; where an exception may be thrown.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx:1518,clear,clear,1518,core/foundation/v7/inc/ROOT/RError.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx,1,['clear'],['clear']
Usability,// class coded as async function which returns class handle; // simple extract class and access class.draw method,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:64,simpl,simple,64,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,// clean up.; // FIXME: AbstractVariables.clear();,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:42,clear,clear,42,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,1,['clear'],['clear']
Usability,// cleanup jsroot fields to simplify browser cleanup job,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:28,simpl,simplify,28,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simplify']
Usability,// clear,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp:3,clear,clear,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,6,['clear'],['clear']
Usability,"// clear",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCalo2DGL.cxx:3,clear,clear,3,graf3d/eve/src/TEveCalo2DGL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCalo2DGL.cxx,4,['clear'],['clear']
Usability,// clear - Empties out the StringMap,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:3,clear,clear,3,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,1,['clear'],['clear']
Usability,// clear DwarfLocSeen saying the current .loc info is now used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:3,clear,clear,3,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,1,['clear'],['clear']
Usability,"// clear Python error, to allow full error handling C++ side",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/include/CPyCppyy/PyException.h:3,clear,clear,3,bindings/pyroot/cppyy/CPyCppyy/include/CPyCppyy/PyException.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/include/CPyCppyy/PyException.h,2,['clear'],['clear']
Usability,"// clear after minimization when setting params",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx:3,clear,clear,3,math/minuit/src/TMinuitMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx,4,['clear'],['clear']
Usability,"// clear all caches",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/jsoninterface/src/RYMLParser.cxx:3,clear,clear,3,roofit/jsoninterface/src/RYMLParser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/jsoninterface/src/RYMLParser.cxx,1,['clear'],['clear']
Usability,"// clear all cell dds",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCalo.cxx:3,clear,clear,3,graf3d/eve/src/TEveCalo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCalo.cxx,2,['clear'],['clear']
Usability,"// clear all data members which depend on the unfolding results",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx:3,clear,clear,3,hist/unfold/src/TUnfoldSys.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx,1,['clear'],['clear']
Usability,"// clear all elements, keep g element on its place",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,clear,clear,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clear']
Usability,"// clear all export keys",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/JSONIO.cxx:3,clear,clear,3,roofit/hs3/src/JSONIO.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/JSONIO.cxx,1,['clear'],['clear']
Usability,"// clear all factory expressions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/JSONIO.cxx:3,clear,clear,3,roofit/hs3/src/JSONIO.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/JSONIO.cxx,1,['clear'],['clear']
Usability,"// clear all packages button",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/inc/TSessionViewer.h:3,clear,clear,3,gui/sessionviewer/inc/TSessionViewer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/inc/TSessionViewer.h,1,['clear'],['clear']
Usability,"// clear all results",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfold.h:3,clear,clear,3,hist/unfold/inc/TUnfold.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfold.h,2,['clear'],['clear']
Usability,"// clear all selection rules",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/SelectionRules.h:3,clear,clear,3,core/dictgen/res/SelectionRules.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/SelectionRules.h,1,['clear'],['clear']
Usability,// clear all the kill flags of this new instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:3,clear,clear,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,1,['clear'],['clear']
Usability,// clear all_args property; // adjust font size (if there are normal text),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,clear,clear,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clear']
Usability,"// clear also the function minimum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/Minuit2Minimizer.cxx:3,clear,clear,3,math/minuit2/src/Minuit2Minimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/Minuit2Minimizer.cxx,1,['clear'],['clear']
Usability,"// clear and fill errorParams only with parameters that both in params and cloneParams",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:3,clear,clear,3,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,2,['clear'],['clear']
Usability,// clear any previous settings,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,clear,clear,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clear']
Usability,"// clear anything that has fTimes = 0 still",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:3,clear,clear,3,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['clear'],['clear']
Usability,"// clear array if existing or do nothing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h:3,clear,clear,3,hist/hist/src/TProfileHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h,1,['clear'],['clear']
Usability,"// clear board map",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/Tetris.cxx:3,clear,clear,3,test/Tetris.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/Tetris.cxx,1,['clear'],['clear']
Usability,"// clear browsing history",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TRootBrowserLite.cxx:3,clear,clear,3,gui/gui/src/TRootBrowserLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TRootBrowserLite.cxx,1,['clear'],['clear']
Usability,"// clear children for reload and update shared axis",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:3,clear,clear,3,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,2,['clear'],['clear']
Usability,"// clear coefficients",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleEnsemble.h:3,clear,clear,3,tmva/tmva/inc/TMVA/RuleEnsemble.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleEnsemble.h,1,['clear'],['clear']
Usability,"// clear collected errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx:3,clear,clear,3,bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,1,['clear'],['clear']
Usability,"// clear connections vector under mutex",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:3,clear,clear,3,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['clear'],['clear']
Usability,"// clear content if positions of subframes changed after layout",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGCanvas.cxx:3,clear,clear,3,gui/gui/src/TGCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGCanvas.cxx,1,['clear'],['clear']
Usability,"// clear directory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:3,clear,clear,3,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['clear'],['clear']
Usability,"// clear dirty flag as cache is up-to-date upon creation; // Introduce formal dependency of RooHistFunc on parameters so that const optimization code; // makes the correct decisions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedReal.cxx:3,clear,clear,3,roofit/roofitcore/src/RooAbsCachedReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedReal.cxx,1,['clear'],['clear']
Usability,"// clear dirty flag as cache is up-to-date upon creation; // Introduce formal dependency of RooHistPdf on parameters so that const optimization code; // makes the correct decisions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx:3,clear,clear,3,roofit/roofitcore/src/RooAbsCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx,1,['clear'],['clear']
Usability,// clear display property,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,clear,clear,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clear']
Usability,"// clear duplicates",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:3,clear,clear,3,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['clear'],['clear']
Usability,// clear element,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,clear,clear,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clear']
Usability,"// clear event count",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/ModulekNN.cxx:3,clear,clear,3,tmva/tmva/src/ModulekNN.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/ModulekNN.cxx,1,['clear'],['clear']
Usability,"// clear existing image if there is one",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TTF.cxx:3,clear,clear,3,graf2d/graf/src/TTF.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TTF.cxx,1,['clear'],['clear']
Usability,"// clear fClassIndex for anything we already sent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TParallelMergingFile.cxx:3,clear,clear,3,net/net/src/TParallelMergingFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TParallelMergingFile.cxx,1,['clear'],['clear']
Usability,"// clear fList",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TRootBrowserLite.cxx:3,clear,clear,3,gui/gui/src/TRootBrowserLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TRootBrowserLite.cxx,1,['clear'],['clear']
Usability,"// clear file map so files get send again to remote nodes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:3,clear,clear,3,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['clear'],['clear']
Usability,// clear html - most simple way,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,clear,clear,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,"['clear', 'simpl']","['clear', 'simple']"
Usability,"// clear if a formula was already existing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:3,clear,clear,3,hist/hist/src/TFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx,1,['clear'],['clear']
Usability,// clear indicator that animation running,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,clear,clear,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clear']
Usability,// clear it to speed up later scavengeStackSlot calls to; // StackBytesFree.none(),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp:3,clear,clear,3,interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PrologEpilogInserter.cpp,1,['clear'],['clear']
Usability,// clear leading 1 bit,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:3,clear,clear,3,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,1,['clear'],['clear']
Usability,"// clear list of functions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMultiRootFinder.h:3,clear,clear,3,math/mathmore/inc/Math/GSLMultiRootFinder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLMultiRootFinder.h,1,['clear'],['clear']
Usability,// clear list of hidden objects,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,clear,clear,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clear']
Usability,"// clear now to avoid concurrent destruction of output trees and input tree (which has them listed as fClones)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:3,clear,clear,3,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,1,['clear'],['clear']
Usability,// clear nsw flag if shl will produce poison value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:3,clear,clear,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['clear'],['clear']
Usability,"// clear old cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCalo.cxx:3,clear,clear,3,graf3d/eve/src/TEveCalo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCalo.cxx,4,['clear'],['clear']
Usability,"// clear old range [Xmin, Xmax] and prepare new range for reading",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDEFoam.cxx:3,clear,clear,3,tmva/tmva/src/MethodPDEFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDEFoam.cxx,1,['clear'],['clear']
Usability,"// clear our x-axis to re-evaluate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:3,clear,clear,3,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['clear'],['clear']
Usability,"// clear out any leading spaces",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/win/bindexplib/bindexplib.cxx:3,clear,clear,3,misc/win/bindexplib/bindexplib.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/win/bindexplib/bindexplib.cxx,1,['clear'],['clear']
Usability,// clear out for next method.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransZeroOutPropsInDealloc.cpp:3,clear,clear,3,interpreter/llvm-project/clang/lib/ARCMigrate/TransZeroOutPropsInDealloc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransZeroOutPropsInDealloc.cpp,1,['clear'],['clear']
Usability,// clear pad,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,clear,clear,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clear']
Usability,// clear pages,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,clear,clear,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clear']
Usability,"// clear pending exceptions so feenableexcept does not trigger them",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx:3,clear,clear,3,core/unix/src/TUnixSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx,1,['clear'],['clear']
Usability,// clear primitives produced by previous drawing to avoid flicking,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,clear,clear,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clear']
Usability,"// clear primitives, they just because of I/O",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,clear,clear,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clear']
Usability,"// clear resources (parameters) for consecutives minimizations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/Minuit2Minimizer.h:3,clear,clear,3,math/minuit2/inc/Minuit2/Minuit2Minimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/Minuit2Minimizer.h,1,['clear'],['clear']
Usability,"// clear row data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx:3,clear,clear,3,hist/unfold/src/TUnfold.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx,1,['clear'],['clear']
Usability,"// clear rule map",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleEnsemble.h:3,clear,clear,3,tmva/tmva/inc/TMVA/RuleEnsemble.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleEnsemble.h,1,['clear'],['clear']
Usability,"// clear selected cell ids",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCalo.cxx:3,clear,clear,3,graf3d/eve/src/TEveCalo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCalo.cxx,2,['clear'],['clear']
Usability,"// clear selection",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx:3,clear,clear,3,gui/guihtml/src/TGHtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx,1,['clear'],['clear']
Usability,// clear single touch handler,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,clear,clear,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clear']
Usability,"// clear subpads, but do not delete pads in case the canvas; // has been divided (note: option ""D"" is propagated so could cause; // conflicts for primitives using option ""D"" for something else)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TCanvas.cxx:3,clear,clear,3,graf2d/gpad/src/TCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TCanvas.cxx,1,['clear'],['clear']
Usability,"// clear table so no more lookups",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashList.cxx:3,clear,clear,3,core/cont/src/THashList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashList.cxx,1,['clear'],['clear']
Usability,"// clear table so not more lookups",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashList.cxx:3,clear,clear,3,core/cont/src/THashList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashList.cxx,1,['clear'],['clear']
Usability,"// clear temporary flags",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx:3,clear,clear,3,gui/webgui6/src/TWebCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx,1,['clear'],['clear']
Usability,"// clear text view after each command",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/inc/TSessionViewer.h:3,clear,clear,3,gui/sessionviewer/inc/TSessionViewer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/inc/TSessionViewer.h,1,['clear'],['clear']
Usability,"// clear the array if existing - do nothing otherwise",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3,clear,clear,3,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['clear'],['clear']
Usability,"// clear the function list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiRootFinder.cxx:3,clear,clear,3,math/mathmore/src/GSLMultiRootFinder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiRootFinder.cxx,1,['clear'],['clear']
Usability,"// clear the function list and the solver",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiRootFinder.cxx:3,clear,clear,3,math/mathmore/src/GSLMultiRootFinder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiRootFinder.cxx,1,['clear'],['clear']
Usability,"// clear the list of queries",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:3,clear,clear,3,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['clear'],['clear']
Usability,"// clear the results of the loop variables if they were vector observables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Detail/CodeSquashContext.cxx:3,clear,clear,3,roofit/roofitcore/src/RooFit/Detail/CodeSquashContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Detail/CodeSquashContext.cxx,1,['clear'],['clear']
Usability,"// clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DecisionTree.h:3,clear,clear,3,tmva/tmva/inc/TMVA/DecisionTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DecisionTree.h,1,['clear'],['clear']
Usability,"// clear the typedefs; we fill them later",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx:3,clear,clear,3,html/src/THtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx,1,['clear'],['clear']
Usability,"// clear underflow and overflow (in an alphanumeric situation they do not make sense); // NOTE: using AddBinContent instead of SetBinContent in order to not change; // the number of entries; //((TH1 *)fParent)->ClearUnderflowAndOverflow();; // L.M. 26.1.15 Keep underflow and overflows (see ROOT-7034)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TAxis.cxx:3,clear,clear,3,hist/hist/src/TAxis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TAxis.cxx,2,"['Clear', 'clear']","['ClearUnderflowAndOverflow', 'clear']"
Usability,"// clear vector contents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:3,clear,clear,3,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['clear'],['clear']
Usability,"// clear when connection to client closed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/v7/browser.cxx:3,clear,clear,3,tutorials/v7/browser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/v7/browser.cxx,1,['clear'],['clear']
Usability,"// clearValueDirty() ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:3,clear,clearValueDirty,3,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['clear'],['clearValueDirty']
Usability,// clearing,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,clear,clearing,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clearing']
Usability,"// co_await promise.final_suspend() could end up calling; // __builtin_coro_resume for symmetric transfer if await_suspend(); // returns a handle. In that case, even __builtin_coro_resume is not; // declared as noexcept and may throw, it does not throw _into_ the; // coroutine that just suspended, but rather throws back out from; // whoever called coroutine_handle::resume(), hence we claim that; // logically it does not throw.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:368,resume,resume,368,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,1,['resume'],['resume']
Usability,"// collect error message/trace (automatically clears exception, too)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx:46,clear,clears,46,bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,1,['clear'],['clears']
Usability,"// collection of feedback objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:17,feedback,feedback,17,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['feedback'],['feedback']
Usability,"// comment out this line and recompile if you want to gain additional; // performance (the gain is mainly for ""simple"" functions which are easy; // to calculate and vanishes quickly if going to cost-intensive functions); // the library is no longer thread save however",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/StackAllocator.h:111,simpl,simple,111,math/minuit2/inc/Minuit2/StackAllocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/StackAllocator.h,1,['simpl'],['simple']
Usability,"// common case of simple object assignment",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:18,simpl,simple,18,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,1,['simpl'],['simple']
Usability,"// compute progress bar position and update",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:11,progress bar,progress bar,11,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,2,['progress bar'],['progress bar']
Usability,"// computeBackedgeTakenCount may allocate memory for its result. Inserting it; // into the BackedgeTakenCounts map transfers ownership. Otherwise, the result; // must be cleared in this scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:170,clear,cleared,170,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['clear'],['cleared']
Usability,// computeDeadSymbolsAndUpdateIndirectCalls should have marked all; // copies live. Note that it is possible that there is a GUID collision; // between internal symbols with the same name in different files of the; // same name but not enough distinguishing path. Because; // computeDeadSymbolsAndUpdateIndirectCalls should conservatively mark; // all copies live we can assert here that all are dead if any copy is; // dead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp:125,GUID,GUID,125,interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ModuleSummaryIndex.cpp,1,['GUID'],['GUID']
Usability,"// connect feedback signal",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:11,feedback,feedback,11,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,2,['feedback'],['feedback']
Usability,"// connect to proof startup message (to update progress bar)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:47,progress bar,progress bar,47,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['progress bar'],['progress bar']
Usability,"// connection progress bar",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:14,progress bar,progress bar,14,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['progress bar'],['progress bar']
Usability,"// constructor from a char * for the algorithm type, used by the plug-in manager; // The names supported (case unsensitive) are:; // Migrad (default), Simplex, Minimize (for the combined Migrad+ Simplex) and Migrad_imp; // select type from the string",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx:151,Simpl,Simplex,151,math/minuit/src/TMinuitMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx,2,['Simpl'],['Simplex']
Usability,"// constructor inclusion; // convenience method to quickly clear/reset the queue (instead of having to pop one by one)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:59,clear,clear,59,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['clear'],['clear']
Usability,// continue with simpler points,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:17,simpl,simpler,17,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simpler']
Usability,"// could later be changed to be set via option string...; // but for now it's simpler like this",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/OptimizeConfigParameters.h:78,simpl,simpler,78,tmva/tmva/inc/TMVA/OptimizeConfigParameters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/OptimizeConfigParameters.h,1,['simpl'],['simpler']
Usability,"// cout << ""RooChangeTracker("" << this << "","" << GetName() << "") value of "" << real->GetName() << "" has changed from "" << _realRef[i] << "" to "" << real->getVal() << "" clearState = "" << (clearState?""T"":""F"") << endl ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooChangeTracker.cxx:167,clear,clearState,167,roofit/roofitcore/src/RooChangeTracker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooChangeTracker.cxx,2,['clear'],['clearState']
Usability,"// create Minimizer using the plug-in manager given the type of Minimizer (MINUIT, MINUIT2, FUMILI, etc..) and; // algorithm (MIGRAD, SIMPLEX, etc..)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Factory.cxx:134,SIMPL,SIMPLEX,134,math/mathcore/src/Factory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Factory.cxx,1,['SIMPL'],['SIMPLEX']
Usability,"// create name for position and clear rotation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/src/TGDMLWrite.cxx:32,clear,clear,32,geom/gdml/src/TGDMLWrite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/src/TGDMLWrite.cxx,2,['clear'],['clear']
Usability,"// create now the input and output matrices; //int n1 = batchHeight;; //int n2 = batchWidth;; // treat case where batchHeight is the batchSize in case of first Dense layers (then we need to set to fNet batch size); //if (fXInput.size() > 0) fXInput.clear();; //fXInput.emplace_back(MatrixImpl_t(n1,n2));",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx:249,clear,clear,249,tmva/tmva/src/MethodDL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx,1,['clear'],['clear']
Usability,"// create starting state for Simplex, which corresponds to the initial parameter values; // using the simple Initial gradient calculator (does not use any FCN function calls)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/SimplexSeedGenerator.cxx:29,Simpl,Simplex,29,math/minuit2/src/SimplexSeedGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/SimplexSeedGenerator.cxx,2,"['Simpl', 'simpl']","['Simplex', 'simple']"
Usability,"// current process progress bar",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/inc/TSessionViewer.h:19,progress bar,progress bar,19,gui/sessionviewer/inc/TSessionViewer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/inc/TSessionViewer.h,1,['progress bar'],['progress bar']
Usability,"// currently RVec does not go back to a small state after `clear()`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/test/vecops_rvec.cxx:59,clear,clear,59,math/vecops/test/vecops_rvec.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/test/vecops_rvec.cxx,1,['clear'],['clear']
Usability,"// cutting forward or wackward - change clears pastbuf",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/Editor.h:40,clear,clears,40,core/textinput/src/textinput/Editor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/Editor.h,1,['clear'],['clears']
Usability,"// dataset dir is in the user sandbox (simplified naming)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TDataSetManager.h:39,simpl,simplified,39,proof/proof/inc/TDataSetManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TDataSetManager.h,1,['simpl'],['simplified']
Usability,"// decay the learning rate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/TSynapse.h:13,learn,learning,13,tmva/tmva/inc/TMVA/TSynapse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/TSynapse.h,1,['learn'],['learning']
Usability,// deduction guides need this,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:13,guid,guides,13,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['guid'],['guides']
Usability,"// default is simple selection, we ignore the indx",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveElements.js:14,simpl,simple,14,ui5/eve7/lib/EveElements.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveElements.js,4,['simpl'],['simple']
Usability,"// delete command for undo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEdit.cxx:22,undo,undo,22,gui/gui/src/TGTextEdit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEdit.cxx,1,['undo'],['undo']
Usability,"// delete heap objects and clear list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/tcollex.cxx:27,clear,clear,27,test/tcollex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/tcollex.cxx,1,['clear'],['clear']
Usability,"// delete old results (if any); // this function is virtual, so derived classes may implement their own; // method to flag results as non-valid; // note: the inverse of the input covariance is not cleared; // because it does not change until the input is changed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx:197,clear,cleared,197,hist/unfold/src/TUnfold.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx,1,['clear'],['cleared']
Usability,"// delete only heap objects marked OK to clear",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TList.cxx:41,clear,clear,41,core/cont/src/TList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TList.cxx,1,['clear'],['clear']
Usability,"// descriptorGuard; // Clear the cache from clusters not the in the look-ahead or the look-back window",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:23,Clear,Clear,23,tree/ntuple/v7/src/RClusterPool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx,1,['Clear'],['Clear']
Usability,"// destructor. clears the cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/jsoninterface/src/RYMLParser.cxx:15,clear,clears,15,roofit/jsoninterface/src/RYMLParser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/jsoninterface/src/RYMLParser.cxx,1,['clear'],['clears']
Usability,"// display connection progress bar in first part of status bar",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:22,progress bar,progress bar,22,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['progress bar'],['progress bar']
Usability,"// divide stats canvas by number of selected feedback histos",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:45,feedback,feedback,45,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['feedback'],['feedback']
Usability,"// dmask 0 has special semantics, do not simplify.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp:41,simpl,simplify,41,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,1,['simpl'],['simplify']
Usability,"// do not redraw progress bar when neither time not ticks are different",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Timer.cxx:17,progress bar,progress bar,17,tmva/tmva/src/Timer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Timer.cxx,1,['progress bar'],['progress bar']
Usability,"// doesn't have binning, so clear binning attribute; // this can happen after Combine of models because binning don't get combined yet (should fix this)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:28,clear,clear,28,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['clear'],['clear']
Usability,"// draw a simple box",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TCandle.cxx:10,simpl,simple,10,graf2d/graf/src/TCandle.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TCandle.cxx,1,['simpl'],['simple']
Usability,"// draw progress bar (add convergence value)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx:8,progress bar,progress bar,8,tmva/tmva/src/MethodMLP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx,1,['progress bar'],['progress bar']
Usability,"// dummy for testing; // iret |= FitUsingNewFitter<DUMMY>(h1,f1);; // use simply TF1 wrapper; // ROOT::Math::WrappedMultiTF1 f2(*f1);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testFitPerf.cxx:74,simpl,simply,74,roofit/roofit/test/testFitPerf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testFitPerf.cxx,1,['simpl'],['simply']
Usability,"// eBPF at the moment only has 64-bit comparison. Any 32-bit comparison need; // to be promoted, however if the 32-bit comparison operands are destination; // registers then they are implicitly zero-extended already, there is no; // need of explicit zero-extend sequence for them.; //; // We simply do extension for all situations in this method, but we will; // try to remove those unnecessary in BPFMIPeephole pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:292,simpl,simply,292,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,1,['simpl'],['simply']
Usability,// each font has default encoding. Some have it clearly defined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:48,clear,clearly,48,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clearly']
Usability,// elaborated-type-specifier:; // class-key attribute-specifier-seq[opt]; // nested-name-specifier[opt] identifier; // class-key nested-name-specifier[opt] template[opt] simple-template-id; // enum nested-name-specifier[opt] identifier; //; // FIXME: We don't support class-specifiers nor enum-specifiers here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:170,simpl,simple-template-id,170,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['simpl'],['simple-template-id']
Usability,// emd of simple type-in colors; // array of color definition objects,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:10,simpl,simple,10,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,// empty means clear all diagnostics in the range.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp:15,clear,clear,15,interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp,1,['clear'],['clear']
Usability,"// empty string deactivates learning rate scheduler",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx:28,learn,learning,28,tmva/pymva/src/MethodPyKeras.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx,4,['learn'],['learning']
Usability,"// encapsulates the information for undo/redo a single action.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TQCommand.h:36,undo,undo,36,core/base/inc/TQCommand.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TQCommand.h,1,['undo'],['undo']
Usability,// end anonymous namespace; /* *** Helper Functions *** */; /// getConstantGEP() - Help routine to construct simple GEPs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:109,simpl,simple,109,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['simpl'],['simple']
Usability,// end anonymous namespace; /// Determine whether the token kind starts a simple-type-specifier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:74,simpl,simple-type-specifier,74,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['simpl'],['simple-type-specifier']
Usability,"// end anonymous namespace; /// EvaluateIntegerOrLValue - Evaluate an rvalue integral-typed expression, and; /// produce either the integer value or a pointer.; ///; /// GCC has a heinous extension which folds casts between pointer types and; /// pointer-sized integral types. We support this by allowing the evaluation of; /// an integer rvalue to produce a pointer (represented as an lvalue) instead.; /// Some simple arithmetic on such values is supported (they are treated much; /// like char*).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:413,simpl,simple,413,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['simpl'],['simple']
Usability,// end anonymous namespace; /// Get or create a target for the branch from ResumeInsts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:75,Resume,ResumeInsts,75,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['Resume'],['ResumeInsts']
Usability,// end anonymous namespace; /// Iteratively perform simplification on a worklist of IV users. Each; /// successive simplification may push more users which may themselves be; /// candidates for simplification.; ///; /// Sign/Zero extend elimination is interleaved with IV simplification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:52,simpl,simplification,52,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,4,['simpl'],['simplification']
Usability,// end anonymous namespace; /// cc—Carry clear GE—Greater than or equal; /// LS—Lower or same PL—Plus; /// CS—Carry set GT—Greater than; /// LT—Less than; /// EQ—Equal HI—Higher; /// MI—Minus VC—Overflow clear; /// LE—Less than or equal; /// NE—Not equal VS—Overflow set,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp:41,clear,clear,41,interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/MCTargetDesc/M68kAsmBackend.cpp,2,['clear'],['clear']
Usability,// end anonymous namespace; //===----------------------------------------------------------------------===//; // Parser; //===----------------------------------------------------------------------===//; /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current; /// token the parser is looking at. getNextToken reads another token from the; /// lexer and updates CurTok with its results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:239,simpl,simple,239,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,11,['simpl'],['simple']
Usability,// end namespace SimpleRemoteEPCDefaultBootstrapSymbolNames,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h:17,Simpl,SimpleRemoteEPCDefaultBootstrapSymbolNames,17,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h,2,['Simpl'],['SimpleRemoteEPCDefaultBootstrapSymbolNames']
Usability,"// end namespace detail; /// A class that does preorder or postorder; /// depth-first traversal on the entire Clang AST and visits each node.; ///; /// This class performs three distinct tasks:; /// 1. traverse the AST (i.e. go to each node);; /// 2. at a given node, walk up the class hierarchy, starting from; /// the node's dynamic type, until the top-most class (e.g. Stmt,; /// Decl, or Type) is reached.; /// 3. given a (node, class) combination, where 'class' is some base; /// class of the dynamic type of 'node', call a user-overridable; /// function to actually visit the node.; ///; /// These tasks are done by three groups of methods, respectively:; /// 1. TraverseDecl(Decl *x) does task #1. It is the entry point; /// for traversing an AST rooted at x. This method simply; /// dispatches (i.e. forwards) to TraverseFoo(Foo *x) where Foo; /// is the dynamic type of *x, which calls WalkUpFromFoo(x) and; /// then recursively visits the child nodes of x.; /// TraverseStmt(Stmt *x) and TraverseType(QualType x) work; /// similarly.; /// 2. WalkUpFromFoo(Foo *x) does task #2. It does not try to visit; /// any child node of x. Instead, it first calls WalkUpFromBar(x); /// where Bar is the direct parent class of Foo (unless Foo has; /// no parent), and then calls VisitFoo(x) (see the next list item).; /// 3. VisitFoo(Foo *x) does task #3.; ///; /// These three method groups are tiered (Traverse* > WalkUpFrom* >; /// Visit*). A method (e.g. Traverse*) may call methods from the same; /// tier (e.g. other Traverse*) or one tier lower (e.g. WalkUpFrom*).; /// It may not call methods from a higher tier.; ///; /// Note that since WalkUpFromFoo() calls WalkUpFromBar() (where Bar; /// is Foo's super class) before calling VisitFoo(), the result is; /// that the Visit*() methods for a given node are called in the; /// top-down order (e.g. for a node of type NamespaceDecl, the order will; /// be VisitDecl(), VisitNamedDecl(), and then VisitNamespaceDecl()).; ///; /// This scheme guara",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h:779,simpl,simply,779,interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h,1,['simpl'],['simply']
Usability,"// end namespace llvm; // Returns true if the function must be unreachable based on ValueInfo.; //; // In particular, identifies a function as unreachable in the following; // conditions; // 1) All summaries are live.; // 2) All function summaries indicate it's unreachable; // 3) There is no non-function with the same GUID (which is rare)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:320,GUID,GUID,320,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['GUID'],['GUID']
Usability,// end namespace llvm; // This is a simple lexicographical order that can be used to search for sets.; // It is not the same as the topological order provided by TopoOrderRC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:36,simpl,simple,36,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['simpl'],['simple']
Usability,"// end namespace sys; /// This class implements an extremely fast bulk output stream that can *only*; /// output to a stream. It does not support seeking, reopening, rewinding, line; /// buffered disciplines etc. It is a simple buffer that outputs; /// a chunk at a time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:221,simpl,simple,221,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,1,['simpl'],['simple']
Usability,"// entry is outside the learn range, need to stop the learning; // phase. Doing so may trigger a recursive call to FillBuffer in; // the process of filling both prefetching buffers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:24,learn,learn,24,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['learn'],"['learn', 'learning']"
Usability,"// estimate gradient numerically with simple 2 point rule; // should probably calculate gradient of log(pdf) is more stable numerically",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx:38,simpl,simple,38,math/mathcore/src/FitUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx,1,['simpl'],['simple']
Usability,// estimate quantiles... simple function... not so nice as GetQuantiles; // exclude points with negative y when log scale is specified,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:25,simpl,simple,25,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,"// exclude Simplex in tree; //noCompareInTree.push_back(algoType( ""Minuit2"", ""Simplex"", ""Q0"", CompareResult(0)));",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx:11,Simpl,Simplex,11,test/stressHistoFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx,2,['Simpl'],['Simplex']
Usability,"// execute undo action",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEdit.cxx:11,undo,undo,11,gui/gui/src/TGTextEdit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEdit.cxx,1,['undo'],['undo']
Usability,"// fCheckSum is an atomic variable. Also once it has; // transition from a zero Value it never changes. If two; // thread reach past this if statement and calculated the; // 'kLastestCheckSum', they will by definition obtain the; // same value, so technically we could simply have:; // if (fCheckSum && code == kCurrentCheckSum) return fCheckSum;; // However save a little bit of barrier time by calling load(); // only once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:269,simpl,simply,269,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['simpl'],['simply']
Usability,"// fStatus++ after Redo(), fStatus-- after Undo()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TQCommand.h:43,Undo,Undo,43,core/base/inc/TQCommand.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TQCommand.h,1,['Undo'],['Undo']
Usability,"// fadd X, -0 ==> X; // With strict/constrained FP, we have these possible edge cases that do; // not simplify to Op0:; // fadd SNaN, -0.0 --> QNaN; // fadd +0.0, -0.0 --> -0.0 (but only with round toward negative)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:102,simpl,simplify,102,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplify']
Usability,"// failure, clear sending flag",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:12,clear,clear,12,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['clear'],['clear']
Usability,"// feedback histos embedded canvas",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:3,feedback,feedback,3,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['feedback'],['feedback']
Usability,"// fetch self, verify, and put the arguments in usable order",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx:48,usab,usable,48,bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx,1,['usab'],['usable']
Usability,"// fetch self, verify, and put the arguments in usable order (if self is not handled; // first, arguments can not be reordered with sentinels in place)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPConstructor.cxx:48,usab,usable,48,bindings/pyroot/cppyy/CPyCppyy/src/CPPConstructor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPConstructor.cxx,1,['usab'],['usable']
Usability,"// fill error matrix; // if minimizer provides error provides also error matrix; // clear in case of re-filling an existing result",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitResult.cxx:84,clear,clear,84,math/mathcore/src/FitResult.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitResult.cxx,2,['clear'],['clear']
Usability,"// find minimum using combined method; // (Migrad then if fails try Simplex and then Migrad again)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/CombinedMinimumBuilder.cxx:68,Simpl,Simplex,68,math/minuit2/src/CombinedMinimumBuilder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/CombinedMinimumBuilder.cxx,1,['Simpl'],['Simplex']
Usability,"// find simplex direction (vector from big to smaller parameter points)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/SimplexParameters.cxx:8,simpl,simplex,8,math/minuit2/src/SimplexParameters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/SimplexParameters.cxx,1,['simpl'],['simplex']
Usability,"// find the minimum using the Simplex method of Nelder and Mead (does not use function gradient); // method to find initial simplex is slightly different than in the original Fortran; // Minuit since has not been proofed that one to be better; // synchronize print levels",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/SimplexBuilder.cxx:30,Simpl,Simplex,30,math/minuit2/src/SimplexBuilder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/SimplexBuilder.cxx,2,"['Simpl', 'simpl']","['Simplex', 'simplex']"
Usability,"// first, clear the lists",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DataSet.cxx:10,clear,clear,10,tmva/tmva/src/DataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DataSet.cxx,1,['clear'],['clear']
Usability,"// fold (and (any_ext V), c) -> (zero_ext V) if 'and' only clears top bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,clear,clears,59,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['clear'],['clears']
Usability,"// fold (sdiv X, pow2) -> simple ops after legalize; // FIXME: We check for the exact bit here because the generic lowering gives; // better results in that case. The target-specific lowering should learn how; // to handle exact sdivs efficiently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,simpl,simple,26,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,"['learn', 'simpl']","['learn', 'simple']"
Usability,// fold to a simpler setcc,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:13,simpl,simpler,13,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['simpl'],['simpler']
Usability,"// following is commented out while still considering, but idea is to include category in coords; /*if (auto s = _p->get<RooSimultaneous>(); s && s->indexCat().InheritsFrom(""RooCategory"") &&; !out.find(s->indexCat().GetName())) { auto cat = const_cast<RooCategory*>(dynamic_cast<const; RooCategory*>(&s->indexCat()));; // check if we have a pdf for every category ... if not then add to cut; cat->clearRange(""coordRange"",true);; bool hasMissing = false;; std::string includedStates;; for (auto state : *cat) {; if (!s->getPdf(state.first.c_str())) {; hasMissing = true;; } else {; if (!includedStates.empty()) {; includedStates += "","";; }; includedStates += state.first;; }; }; if (hasMissing) {; if(includedStates.find("","") != std::string::npos) {; cat->addToRange(""coordRange"",includedStates.c_str());; } else {; cat->setLabel(includedStates);; }; out.emplace_back(std::make_shared<xRooNode>(cat->GetName(),_p->getObject<RooAbsArg>(cat->GetName()),_p));; }; } else*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:397,clear,clearRange,397,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['clear'],['clearRange']
Usability,"// for local connection simple key can be used",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:24,simpl,simple,24,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['simpl'],['simple']
Usability,"// for now do simple linear interpolation.; // one day replace by splines...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooKeysPdf.cxx:14,simpl,simple,14,roofit/roofit/src/RooKeysPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooKeysPdf.cxx,1,['simpl'],['simple']
Usability,"// for ptr arithmetics; // Treat the case of std::complex in a special manner. We want to enforce; // the layout of a stl implementation independent class, which is the; // complex as implemented in ROOT5.; // A simple lambda to simplify the code",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:212,simpl,simple,212,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,2,['simpl'],"['simple', 'simplify']"
Usability,"// for simple inheritance testing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/advancedcpp.h:7,simpl,simple,7,bindings/pyroot/cppyy/cppyy/test/advancedcpp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/advancedcpp.h,1,['simpl'],['simple']
Usability,"// for simplicity of the example (avoiding getters/setters) we make data members public as well",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Job.cxx:7,simpl,simplicity,7,roofit/multiprocess/test/test_Job.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Job.cxx,1,['simpl'],['simplicity']
Usability,"// for simplicity the code assumes attributes are not shared across geometries, see #15811",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:7,simpl,simplicity,7,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simplicity']
Usability,"// for the enumerations defining the types; // constructors; /**; Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h:427,simpl,simple,427,math/mathcore/inc/Math/Integrator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Integrator.h,1,['simpl'],['simple']
Usability,"// for(const auto& selRule: fFunctionSelectionRules) {; // if (!selRule.GetMatchFound() && !GetHasFileNameRule()) {; // // Here the slow methods can be used; // std::string name;; // if (selRule.GetAttributeValue(""proto_pattern"", name)) {; // // keep it; // } else if (selRule.GetAttributeValue(""proto_name"", name)) {; // // keep it; // } else if (selRule.GetAttributeValue(""pattern"", name)) {; // // keep it; // } else if (selRule.GetAttributeValue(""name"", name)) {; // // keept it; // } else {; // name.clear();; // }; // // Make it soft, no error - just warnings; // std::cout<<""Warning - unused function rule: ""<<name<<std::endl;; // // if (IsSelectionXMLFile()){; // // std::cout<<""Warning - unused function rule: ""<<name<<std::endl;; // // }; // // else {; // // std::cout<<""Error - unused function rule: ""<<name<<std::endl;; // // }; // if (name.length() == 0) {; // selRule.PrintAttributes(std::cout,3);; // }; // }; //; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/SelectionRules.cxx:505,clear,clear,505,core/dictgen/src/SelectionRules.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/SelectionRules.cxx,1,['clear'],['clear']
Usability,"// frTree is not a chain but a simple TTree; // Get name of the tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:31,simpl,simple,31,tree/tree/src/InternalTreeUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx,1,['simpl'],['simple']
Usability,"// free page...; // Very simple algorithm: once we're done with a page, we send it back; // where it came from. If it's from our end, we put it on the free list, if; // it's from the other end, we send it back.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx:25,simpl,simple,25,roofit/roofitcore/src/BidirMMapPipe.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx,1,['simpl'],['simple']
Usability,"// from auto-folding operations, e.g.; // (i32 ext (i16 ext i8)) would be folded to (i32 ext i8).; // To simplify the type legalization, we want to keep these; // single steps separate during type legalization.; // TL_[EXTEND|TRUNCATE] Inp, i128 _, i32 Opc; // * Inp is the original input to extend/truncate,; // * _ is a dummy operand with an illegal type (can be undef),; // * Opc is the original opcode.; // The legalization process (in Hexagon lowering code) will; // first deal with the ""real"" types (i.e. Inp and the result),; // and once all of them are processed, the wrapper node will; // be replaced with the original ISD node. The dummy illegal; // operand is there to make sure that the legalization hooks; // are called again after everything else is legal, giving; // us the opportunity to undo the wrapping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:105,simpl,simplify,105,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,2,"['simpl', 'undo']","['simplify', 'undo']"
Usability,"// from the original LLVM implementation:; // FIXME: Consider assigning over existing elements, rather than clearing &; // re-initializing them - for all assign(...) variants.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:108,clear,clearing,108,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['clear'],['clearing']
Usability,// fshl is a rotate; // Avoid converting rotate into funnel shift.; // Only simplify if one operand is constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:76,simpl,simplify,76,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['simpl'],['simplify']
Usability,// fshl: (X << (Z % BW)) | (Y >> (BW - (Z % BW))); // fshr: (X << (BW - (Z % BW))) | (Y >> (Z % BW)); // This is simpler than TargetLowering::expandFunnelShift because we can rely; // on PowerPC shift by BW being well defined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:113,simpl,simpler,113,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['simpl'],['simpler']
Usability,"// function to retrieve additional layer parameters which are learned during training but they are not weights; // an example are the mean and std of batch normalization layer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/GeneralLayer.h:62,learn,learned,62,tmva/tmva/inc/TMVA/DNN/GeneralLayer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/GeneralLayer.h,1,['learn'],['learned']
Usability,"// gcc only allows for simple identifiers. Since we support more than gcc, we; // will warn the user.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:23,simpl,simple,23,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['simpl'],['simple']
Usability,"// gcroot is a special case, since it requires a constant argument which; // isn't also required to be a simple ConstantInt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:105,simpl,simple,105,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['simpl'],['simple']
Usability,"// generate the wrapper and JIT it; ignore wrapper generation errors (will simply; // result in a nullptr that is reported upstream if necessary; often, however,; // there is a different overload available that will do)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:75,simpl,simply,75,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['simpl'],['simply']
Usability,"// get the learning rate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/TSynapse.h:11,learn,learning,11,tmva/tmva/inc/TMVA/TSynapse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/TSynapse.h,1,['learn'],['learning']
Usability,"// getAddrOfVTable may return 0 if asked to get an address of a vtable which; // shouldn't be used in the given record type. We want to cache this result in; // VFTablesMap, thus a simple zero check is not sufficient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:181,simpl,simple,181,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['simpl'],['simple']
Usability,"// getBody() might return nullptr even though hasBody() is true for; // late template parsed functions. We simply don't do auto auto on; // those.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/AutoSynthesizer.cpp:107,simpl,simply,107,interpreter/cling/lib/Interpreter/AutoSynthesizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/AutoSynthesizer.cpp,1,['simpl'],['simply']
Usability,// gfx90a has an undocumented limitation:; // DS_GWS opcodes must use even aligned registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:17,undo,undocumented,17,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,1,['undo'],['undocumented']
Usability,// glc.clearHighlight();,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/GlViewerRCore.js:7,clear,clearHighlight,7,ui5/eve7/lib/GlViewerRCore.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/GlViewerRCore.js,1,['clear'],['clearHighlight']
Usability,// guides,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/GlViewerRCore.js:3,guid,guides,3,ui5/eve7/lib/GlViewerRCore.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/GlViewerRCore.js,1,['guid'],['guides']
Usability,// handle simple text drawing,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:10,simpl,simple,10,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,"// hasPrivateSymbols is the opposite of isStripped, but we expose; // hasPrivateSymbols as a more intuitive interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/DIA/DIARawSymbol.cpp:98,intuit,intuitive,98,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/DIA/DIARawSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/DIA/DIARawSymbol.cpp,1,['intuit'],['intuitive']
Usability,"// here clear ownership is required; // If it possible, TObject will be cloned by TObjectHolder",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/browsable/src/TObjectDraw7Provider.cxx:8,clear,clear,8,gui/browsable/src/TObjectDraw7Provider.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/browsable/src/TObjectDraw7Provider.cxx,1,['clear'],['clear']
Usability,"// hide connection progress bar from status bar",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:19,progress bar,progress bar,19,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,2,['progress bar'],['progress bar']
Usability,"// hitCount.print(""Clear"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/TBench.cxx:19,Clear,Clear,19,test/TBench.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/TBench.cxx,1,['Clear'],['Clear']
Usability,// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:61,guid,guid-uuid-in-javascript,61,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['guid'],['guid-uuid-in-javascript']
Usability,// https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-menuitemtemplate,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp:11,learn,learn,11,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp,1,['learn'],['learn']
Usability,// https://learn.microsoft.com/en-us/windows/win32/menurc/menuex-template-item,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp:11,learn,learn,11,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp,1,['learn'],['learn']
Usability,// i1 can be simplified in many cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:13,simpl,simplified,13,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['simpl'],['simplified']
Usability,"// icmp ne (call llvm.s390.tdc(...)), 0 -> simple TDC",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp:43,simpl,simple,43,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTDC.cpp,1,['simpl'],['simple']
Usability,"// if Proof sender match actual session one, update feedback histos",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:52,feedback,feedback,52,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['feedback'],['feedback']
Usability,"// if actual query has results, update feedback histos",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:39,feedback,feedback,39,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['feedback'],['feedback']
Usability,"// if check box ""clear view"" is checked, clear text view",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:17,clear,clear,17,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,4,['clear'],['clear']
Usability,"// if check box ""clear view"" is checked, open temp file in write mode; // (overwrite), in append mode otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:17,clear,clear,17,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['clear'],['clear']
Usability,"// if fAutomatic == true, pruneStrength will be the optimal pruning strength; // determined by the pruning algorithm; otherwise, it is simply the strength parameter; // set by the user",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx:135,simpl,simply,135,tmva/tmva/src/MethodBDT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx,1,['simpl'],['simply']
Usability,"// if fKeysPdf is still nullptr, then it means CreateKeysPdf failed; // so clear all the data members this function would normally determine; // and return",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/MCMCInterval.cxx:75,clear,clear,75,roofit/roostats/src/MCMCInterval.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/MCMCInterval.cxx,1,['clear'],['clear']
Usability,"// if feedback option not selected, clear Proof's feedback option",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:6,feedback,feedback,6,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,9,"['clear', 'feedback']","['clear', 'feedback']"
Usability,"// if feedback option selected",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:6,feedback,feedback,6,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['feedback'],['feedback']
Usability,"// if it's not a simple 'spectator' variable (0 or 1) that the categories are defined by; // (but rather some 'formula' (i.e. eta>0), then this formulas are stored in fCatTree and that; // one will be evaluated.. (the formulae return 'true' or 'false'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCategory.cxx:17,simpl,simple,17,tmva/tmva/src/MethodCategory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCategory.cxx,1,['simpl'],['simple']
Usability,"// if leaf is a simple type, i must be set to 0; // if leaf is an array, i is the array element number to be returned",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafD.h:16,simpl,simple,16,tree/tree/inc/TLeafD.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafD.h,6,['simpl'],['simple']
Usability,"// if mode == kOpaque its simple, we just draw the background",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:26,simpl,simple,26,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,2,['simpl'],['simple']
Usability,"// if no identifier, not a simple C function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/plugins/SampleAnalyzer/MainCallChecker.cpp:27,simpl,simple,27,interpreter/llvm-project/clang/lib/Analysis/plugins/SampleAnalyzer/MainCallChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/plugins/SampleAnalyzer/MainCallChecker.cpp,3,['simpl'],['simple']
Usability,"// if not valid, simply reset the hash function so as to not kill performance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx:17,simpl,simply,17,bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx,1,['simpl'],['simply']
Usability,"// if not, simply return, so no item will be added",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFileBrowser.cxx:11,simpl,simply,11,gui/gui/src/TGFileBrowser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFileBrowser.cxx,1,['simpl'],['simply']
Usability,"// if one of the arguments is not usable return empty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp:34,usab,usable,34,interpreter/cling/lib/Interpreter/LookupHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp,1,['usab'],['usable']
Usability,"// if set to true, the pass clears its buffer before rendering",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:28,clear,clears,28,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clears']
Usability,"// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:27,simpl,simple,27,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,"// if the user messed with the metaclass, then we may not have a C++ type,; // simply return here before more damage gets done",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx:79,simpl,simply,79,bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx,1,['simpl'],['simply']
Usability,"// if there is no typedef in instance then there is nothing guiding any; // template parameter typedef replacement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:60,guid,guiding,60,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['guid'],['guiding']
Usability,"// if this is closing a parent class element, clear the parent information",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/XMLReader.cxx:46,clear,clear,46,core/dictgen/src/XMLReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/XMLReader.cxx,1,['clear'],['clear']
Usability,"// if valid Proof session, clear packages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:27,clear,clear,27,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['clear'],['clear']
Usability,"// if valid Proof session, disable (clear) packages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:36,clear,clear,36,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['clear'],['clear']
Usability,"// if(auto item = GetTreeItem(nullptr); item) {; // if(set) item->SetColor(kRed);; // else item->ClearColor();; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:97,Clear,ClearColor,97,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['Clear'],['ClearColor']
Usability,"// important for example for SimpleLikelihoodRatioTestStat",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCSampler.cxx:29,Simpl,SimpleLikelihoodRatioTestStat,29,roofit/roostats/src/ToyMCSampler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCSampler.cxx,1,['Simpl'],['SimpleLikelihoodRatioTestStat']
Usability,"// important: 0, not Py_None; // fetch self, verify, and put the arguments in usable order",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPConstructor.cxx:78,usab,usable,78,bindings/pyroot/cppyy/CPyCppyy/src/CPPConstructor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPConstructor.cxx,1,['usab'],['usable']
Usability,// in 3d mode with orbit control ignore simple arrows,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:40,simpl,simple,40,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,"// in 6.28 DrawClone wont make the gPad defined :( ... so Draw then clear and Draw Clone",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooHypoSpace.cxx:68,clear,clear,68,roofit/xroofit/src/xRooHypoSpace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooHypoSpace.cxx,1,['clear'],['clear']
Usability,"// in OXView::Clear()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx:14,Clear,Clear,14,gui/guihtml/src/TGHtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx,1,['Clear'],['Clear']
Usability,"// in any case clear mesh, enable orbit control again",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:15,clear,clear,15,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clear']
Usability,"// in case of N = 1 do also a simple gauss fit; // using TF1 gausN; // if (N == 1) {",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooFit.cxx:30,simpl,simple,30,roofit/roofit/test/testRooFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooFit.cxx,1,['simpl'],['simple']
Usability,"// in case of rotation of an angle PI, the rotation matrix is symmetric and; // uX = uY = uZ = 0. Use then conversion through the quaternion",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/src/3DConversions.cxx:80,uX,uX,80,math/genvector/src/3DConversions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/src/3DConversions.cxx,1,['uX'],['uX']
Usability,// in simple case shape as it is,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:6,simpl,simple,6,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,"// init GD parameters and clear coeff vectors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx:26,clear,clear,26,tmva/tmva/src/RuleFitParams.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx,1,['clear'],['clear']
Usability,"// initialize FitConfig from given parameter values and step sizes; // if npar different than existing one - clear old one and create new ones",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitConfig.cxx:109,clear,clear,109,math/mathcore/src/FitConfig.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitConfig.cxx,1,['clear'],['clear']
Usability,"// inline or simple namespace",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:13,simpl,simple,13,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['simpl'],['simple']
Usability,"// inverse of Caucy is simply the tan(PI(z-0.5))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/QuantFuncMathCore.cxx:23,simpl,simply,23,math/mathcore/src/QuantFuncMathCore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/QuantFuncMathCore.cxx,2,['simpl'],['simply']
Usability,"// invoke, unwind, resume, unreachable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:19,resume,resume,19,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,1,['resume'],['resume']
Usability,// isDebug() is exactly true for register operands of a DBG_VALUE. So we; // simply infer it when parsing and do not need to print it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp:77,simpl,simply,77,interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOperand.cpp,1,['simpl'],['simply']
Usability,"// isDegeneratePartition() - Returns true if the interval partition contains; // a single interval, and thus cannot be simplified anymore.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h:119,simpl,simplified,119,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,1,['simpl'],['simplified']
Usability,"// isImm0_4095Neg is used with 32-bit immediates only.; // 32-bit immediates are zero extended to 64-bit when parsed,; // thus simple -CE->getValue() results in a big negative number,; // not a small positive number as intended",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:127,simpl,simple,127,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['simpl'],['simple']
Usability,"// it is interpreted as a regression tree, where; // currently the separation type (simple least square); // cannot be chosen freely)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DecisionTree.cxx:84,simpl,simple,84,tmva/tmva/src/DecisionTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DecisionTree.cxx,1,['simpl'],['simple']
Usability,"// it's a choice not to force learning function being const, even if possible",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mlp/inc/TMultiLayerPerceptron.h:30,learn,learning,30,math/mlp/inc/TMultiLayerPerceptron.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mlp/inc/TMultiLayerPerceptron.h,1,['learn'],['learning']
Usability,"// iterate through all the rules; // we call this method only for genrefex variables, functions and enums - it is simpler than the class case:; // if we have No - it is veto even if we have explicit yes as well",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/SelectionRules.cxx:114,simpl,simpler,114,core/dictgen/src/SelectionRules.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/SelectionRules.cxx,3,['simpl'],['simpler']
Usability,"// just clear highlight",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomHierarchy.cxx:8,clear,clear,8,geom/webviewer/src/RGeomHierarchy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomHierarchy.cxx,1,['clear'],['clear']
Usability,"// just cut peaces from second geometry, which just simple plane",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:52,simpl,simple,52,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,"// kTRUE if Redo/Undo methods are new/delete",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TQCommand.h:17,Undo,Undo,17,core/base/inc/TQCommand.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TQCommand.h,1,['Undo'],['Undo']
Usability,"// keep undocked toolbar on the top; //(but under win32 key handling will be broken : todo)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldDragManager.cxx:8,undo,undocked,8,gui/guibuilder/src/TGuiBldDragManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldDragManager.cxx,1,['undo'],['undocked']
Usability,// la can't produce a usable address when addresses are 64-bit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:22,usab,usable,22,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['usab'],['usable']
Usability,"// ld64 expects the members to be 8-byte aligned for 64-bit content and at; // least 4-byte aligned for 32-bit content. Opt for the larger encoding; // uniformly.; // We do this for all bsd formats because it simplifies aligning members.; // For the big archive format, the symbol table is the last member, so there; // is no need to align.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp:209,simpl,simplifies,209,interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp,1,['simpl'],['simplifies']
Usability,// lhbrx is known to have the top bits cleared out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:39,clear,cleared,39,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['clear'],['cleared']
Usability,"// linear plot. we simply need to find the appropriate bin; // for the",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:19,simpl,simply,19,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,2,['simpl'],['simply']
Usability,// list of base values for non-simple codes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:31,simpl,simple,31,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,// list of extra bits for non-simple codes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:30,simpl,simple,30,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,"// local session case; // if feedback option selected",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:29,feedback,feedback,29,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['feedback'],['feedback']
Usability,"// lookup through python failed, so simply cook up a '::' -> '.' replacement",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx:36,simpl,simply,36,bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx,1,['simpl'],['simply']
Usability,"// loop increments all of the iterators while leaving scalars unmodified; // TODO this could be simplified with fold expressions or std::apply in C++17",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:96,simpl,simplified,96,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,1,['simpl'],['simplified']
Usability,"// loop over feedback histo list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:13,feedback,feedback,13,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['feedback'],['feedback']
Usability,"// many of simple shapes have 12 faces",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx:11,simpl,simple,11,geom/webviewer/src/RGeomData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx,1,['simpl'],['simple']
Usability,// mapped_iterator - This is a simple iterator adapter that causes a function to; // be applied whenever operator* is invoked on the iterator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:31,simpl,simple,31,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['simpl'],['simple']
Usability,"// math_functions.hpp expects this host function be defined on MacOS, but it; // ends up not being there because of the games we play here. Just define it; // ourselves; it's simple enough.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:175,simpl,simple,175,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,1,['simpl'],['simple']
Usability,"// matrix-vector product:; // use apply(i) function for matrices. Tested (11/05/06) with using (i,j) but; // performances are slightly worse (not clear why); //==============================================================================; // meta_row_dot; //==============================================================================",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/MatrixFunctions.h:146,clear,clear,146,math/smatrix/inc/Math/MatrixFunctions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/MatrixFunctions.h,1,['clear'],['clear']
Usability,"// memory leak in workspace, some RooLinkedLists aren't cleared, fixed in ROOT 6.28",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:56,clear,cleared,56,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['clear'],['cleared']
Usability,// method definition entries must be clear for next implementation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:37,clear,clear,37,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,3,['clear'],['clear']
Usability,"// minuit2 simplex fails in 2d; //histGaus2D.push_back( algoType( ""Minuit2"", ""Simplex"", """", CompareResult(cmpPars,6)) );; // special algos",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx:11,simpl,simplex,11,test/stressHistoFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx,2,"['Simpl', 'simpl']","['Simplex', 'simplex']"
Usability,"// most probably, pad is cleared",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:25,clear,cleared,25,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['cleared']
Usability,"// mov Wa, Wm; // ldr Xd, [Xn, Xa, lsl #N]; // ->; // ldr Xd, [Xn, Wm, uxtw #N]; // Zero-extension looks like an ORRWrs followed by a SUBREG_TO_REG.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:71,ux,uxtw,71,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['ux'],['uxtw']
Usability,"// musttail calls can only be simplified if they are also DCEd.; // As we can't guarantee this here, don't simplify them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:30,simpl,simplified,30,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,['simpl'],"['simplified', 'simplify']"
Usability,"// namespace Detail; // clang-format off; /**; \class ROOT::Experimental::RFieldBase; \ingroup NTuple; \brief A field translates read and write calls from/to underlying columns to/from tree values. A field is a serializable C++ type or a container for a collection of sub fields. The RFieldBase and its; type-safe descendants provide the object to column mapper. They map C++ objects to primitive columns. The; mapping is trivial for simple types such as 'double'. Complex types resolve to multiple primitive columns.; The field knows based on its type and the field name the type(s) and name(s) of the columns. Note: the class hierarchy starting at RFieldBase is not meant to be extended by user-provided child classes.; This is and can only be partially enforced through C++.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:434,simpl,simple,434,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,1,['simpl'],['simple']
Usability,// namespace Detail; ///////////////////////////////////////////////////////////////////////; /** \class RMenuItems; \ingroup GpadROOT7; \brief List of items for object context menu; \author Sergey Linev; \date 2017-06-29; \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome!; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RMenuItems.hxx:331,Feedback,Feedback,331,graf2d/gpadv7/inc/ROOT/RMenuItems.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RMenuItems.hxx,1,['Feedback'],['Feedback']
Usability,"// namespace Internal; /** \class RDrawable; \ingroup GpadROOT7; \brief Base class for drawable entities: objects that can be painted on a `RPad`.; \authors Axel Naumann <axel@cern.ch>, Sergey Linev <s.linev@gsi.de>; \date 2015-08-07; \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome!; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RDrawable.hxx:343,Feedback,Feedback,343,graf2d/gpadv7/inc/ROOT/RDrawable.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RDrawable.hxx,1,['Feedback'],['Feedback']
Usability,// namespace attrvisitor; /// A simple visitor class that helps create attribute visitors.; ///; /// This class does not preserve constness of Attr pointers (see; /// also ConstAttrVisitor).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/AttrVisitor.h:32,simpl,simple,32,interpreter/llvm-project/clang/include/clang/AST/AttrVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/AttrVisitor.h,1,['simpl'],['simple']
Usability,// namespace clang; /// Helper macro to simplify type switches.; /// The macro implicitly exposes a type T in the scope of the inner block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/PrimType.h:40,simpl,simplify,40,interpreter/llvm-project/clang/lib/AST/Interp/PrimType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/PrimType.h,1,['simpl'],['simplify']
Usability,// namespace declvisitor; /// A simple visitor class that helps create declaration visitors.; ///; /// This class does not preserve constness of Decl pointers (see also; /// ConstDeclVisitor).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclVisitor.h:32,simpl,simple,32,interpreter/llvm-project/clang/include/clang/AST/DeclVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclVisitor.h,1,['simpl'],['simple']
Usability,"// namespace detail; /// Constructs a simple \c RewriteRule. \c Edits can be an \c EditGenerator,; /// multiple \c ASTEdits, or a single \c ASTEdit.; /// @{",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:38,simpl,simple,38,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,1,['simpl'],['simple']
Usability,"// namespace llvm; /// Fully generic combining of x86 shuffle instructions.; ///; /// This should be the last combine run over the x86 shuffle instructions. Once; /// they have been fully optimized, this will recursively consider all chains; /// of single-use shuffle instructions, build a generic model of the cumulative; /// shuffle operation, and check for simpler instructions which implement this; /// operation. We use this primarily for two purposes:; ///; /// 1) Collapse generic shuffles to specialized single instructions when; /// equivalent. In most cases, this is just an encoding size win, but; /// sometimes we will collapse multiple generic shuffles into a single; /// special-purpose shuffle.; /// 2) Look for sequences of shuffle instructions with 3 or more total; /// instructions, and replace them with the slightly more expensive SSSE3; /// PSHUFB instruction if available. We do this as the last combining step; /// to ensure we avoid using PSHUFB if we can implement the shuffle with; /// a suitable short sequence of other instructions. The PSHUFB will either; /// use a register or have to read from memory and so is slightly (but only; /// slightly) more expensive than the other shuffle instructions.; ///; /// Because this is inherently a quadratic operation (for each shuffle in; /// a chain, we recurse up the chain), the depth is limited to 8 instructions.; /// This should never be an issue in practice as the shuffle lowering doesn't; /// produce sequences of more than 8 instructions.; ///; /// FIXME: We will currently miss some cases where the redundant shuffling; /// would simplify under the threshold for PSHUFB formation because of; /// combine-ordering. To fix this, we should do the redundant instruction; /// combining in this recursive walk.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:360,simpl,simpler,360,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['simpl'],"['simpler', 'simplify']"
Usability,// namespace llvm; //===----------------------------------------------------------------------===//; // PMStack implementation; //; // Pop Pass Manager from the stack and clear its analysis info.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:171,clear,clear,171,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,1,['clear'],['clear']
Usability,"// namespace sys; /// This interface provides simple read-only access to a block of memory, and; /// provides simple methods for reading files and standard input into a memory; /// buffer. In addition to basic access to the characters in the file, this; /// interface guarantees you can read one character past the end of the file,; /// and that this character will read as '\0'.; ///; /// The '\0' guarantee is needed to support an optimization -- it's intended to; /// be more efficient for clients which are reading all the data to stop; /// reading when they encounter a '\0' than to continually check the file; /// position to see if it has reached the end of the file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h:46,simpl,simple,46,interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h,2,['simpl'],['simple']
Usability,// namespace templateargumentvisitor; /// A simple visitor class that helps create template argument visitors.; ///; /// This class does not preserve constness of TemplateArgument references (see; /// also ConstTemplateArgumentVisitor).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateArgumentVisitor.h:44,simpl,simple,44,interpreter/llvm-project/clang/include/clang/AST/TemplateArgumentVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateArgumentVisitor.h,1,['simpl'],['simple']
Usability,"// namespace; // OpenACC 3.3, section 1.7:; // To simplify the specification and convey appropriate constraint information,; // a pqr-list is a comma-separated list of pdr items. The one exception is a; // clause-list, which is a list of one or more clauses optionally separated by; // commas.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:50,simpl,simplify,50,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,1,['simpl'],['simplify']
Usability,"// namespace; // Test that a simple fit with Gauss and Voigt yields the same values as with; // ROOT 6.18. The fit requires numeric integration for the Voigt. To suppress; // false positives, the precision for numeric integrals was increased by 1000x.; // This test uses Minuit2.; //; // Previously in: roottest/root/roofitstats/stabilityTests.cxx",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/stabilityTests.cxx:29,simpl,simple,29,roofit/roofit/test/stabilityTests.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/stabilityTests.cxx,1,['simpl'],['simple']
Usability,// namespace; /// ------------------ Value Simplify Attribute ----------------------------,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:43,Simpl,Simplify,43,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['Simpl'],['Simplify']
Usability,"// namespace; /// Helper function to generate a reproducer function for simplifying \p Cond.; /// The reproducer function contains a series of @llvm.assume calls, one for; /// each condition in \p Stack. For each condition, the operand instruction are; /// cloned until we reach operands that have an entry in \p Value2Index. Those; /// will then be added as function arguments. \p DT is used to order cloned; /// instructions. The reproducer function will get added to \p M, if it is; /// non-null. Otherwise no reproducer function is generated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:72,simpl,simplifying,72,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,1,['simpl'],['simplifying']
Usability,// namespace; /// Strips any positional args and possible argv[0] from a command-line; /// provided by the user to construct a FixedCompilationDatabase.; ///; /// FixedCompilationDatabase requires a command line to be in this format as it; /// constructs the command line for each file by appending the name of the file; /// to be compiled. FixedCompilationDatabase also adds its own argv[0] to the; /// start of the command line although its value is not important as it's just; /// ignored by the Driver invoked by the ClangTool using the; /// FixedCompilationDatabase.; ///; /// FIXME: This functionality should probably be made available by; /// clang::driver::Driver although what the interface should look like is not; /// clear.; ///; /// \param[in] Args Args as provided by the user.; /// \return Resulting stripped command line.; /// \li true if successful.; /// \li false if \c Args cannot be used for compilation jobs (e.g.; /// contains an option like -E or -version).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:729,clear,clear,729,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,1,['clear'],['clear']
Usability,"// namespace; ////////////////////////////////////////////////////////////////////////////////; /// Extract all content from a RooFit datasets as a map of spans.; /// Spans with the weights and squared weights will be also stored in the map,; /// keyed with the names `_weight` and the `_weight_sumW2`. If the dataset is; /// unweighted, these weight spans will only contain the single value `1.0`.; /// Entries with zero weight will be skipped.; ///; /// \return A `std::map` with spans keyed to name pointers.; /// \param[in] data The input dataset.; /// \param[in] rangeName Select only entries from the data in a given range; /// (empty string for no range).; /// \param[in] simPdf A simultaneous pdf to use as a guide for splitting the; /// dataset. The spans from each channel data will be prefixed with; /// the channel name.; /// \param[in] skipZeroWeights Skip entries with zero weight when filling the; /// data spans. Be very careful with enabling it, because the user; /// might not expect that the batch results are not aligned with the; /// original dataset anymore!; /// \param[in] takeGlobalObservablesFromData Take also the global observables; /// stored in the dataset.; /// \param[in] buffers Pass here an empty stack of `double` vectors, which will; /// be used as memory for the data if the memory in the dataset; /// object can't be used directly (e.g. because you used the range; /// selection or the splitting by categories).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BatchModeDataHelpers.cxx:717,guid,guide,717,roofit/roofitcore/src/BatchModeDataHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BatchModeDataHelpers.cxx,1,['guid'],['guide']
Usability,"// namespace; ////////////////////////////////////////////////////////////////////////////////; /// Plot the distribution of pull values for the specified parameter on a newly created frame. If asymmetric; /// errors are calculated in the fit (by MINOS) those will be used in the pull calculation.; ///; /// If the parameters of the models for generation and fit differ, simple heuristics are used to find the; /// corresponding parameters:; /// - Parameters have the same name: They will be used to compute pulls.; /// - Parameters have different names: The position of the fit parameter in the set of fit parameters will be; /// computed. The parameter at the same position in the set of generator parameters will be used.; ///; /// Further options:; /// <table>; /// <tr><th> Arguments <th> Effect; /// <tr><td> FrameRange(double lo, double hi) <td> Set range of frame to given specification; /// <tr><td> FrameBins(int bins) <td> Set default number of bins of frame to given number; /// <tr><td> Frame() <td> Pass supplied named arguments to RooAbsRealLValue::frame() function. See there; /// for list of allowed arguments; /// <tr><td> FitGauss(bool flag) <td> Add a gaussian fit to the frame; /// </table>; ///; /// If no frame specifications are given, the AutoSymRange() feature will be used to set a default range.; /// Any other named argument is passed to the RooAbsData::plotOn(). See that function for allowed options.; ///; /// If you want to have more control over the Gaussian fit to the pull; /// distribution, you can also do it after the call to plotPull():; ///; /// ~~~ {.cpp}; /// RooPlot *frame = mcstudy->plotPull(myVariable, RooFit::Bins(40), RooFit::FitGauss(false));; /// RooRealVar pullMean(""pullMean"",""Mean of pull"",0,-10,10) ;; /// RooRealVar pullSigma(""pullSigma"",""Width of pull"",1,0.1,5) ;; /// pullMean.setPlotLabel(""pull #mu""); // optional (to get nicer plot labels if you want); /// pullSigma.setPlotLabel(""pull #sigma""); // optional; /// RooGaussian pullGauss(""pull",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCStudy.cxx:371,simpl,simple,371,roofit/roofitcore/src/RooMCStudy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCStudy.cxx,1,['simpl'],['simple']
Usability,"// need to clear the cache of the created integral - do this before deleting things!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:11,clear,clear,11,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['clear'],['clear']
Usability,"// need to set th epdf to clear the cache in ToyMCSampler; // pdf we must use is background pdf",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverter.cxx:26,clear,clear,26,roofit/roostats/src/HypoTestInverter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverter.cxx,1,['clear'],['clear']
Usability,"// need to simplify obtained recurrent ONNX model",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/test/TestSofieModels.cxx:11,simpl,simplify,11,tmva/sofie/test/TestSofieModels.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/test/TestSofieModels.cxx,1,['simpl'],['simplify']
Usability,"// needsFrameIndexResolution - Do we need to perform FI resolution for; // this function. Normally, this is required only when the function; // has any stack objects. However, FI resolution actually has another job,; // not apparent from the title - it resolves callframesetup/destroy; // that were not simplified earlier.; // So, this is required for x86 functions that have push sequences even; // when there are no stack objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:303,simpl,simplified,303,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['simpl'],['simplified']
Usability,// neg x with only low bit demanded is simply x.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:39,simpl,simply,39,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['simpl'],['simply']
Usability,"// nested-name-specifier:; // nested-name-specifier 'template'[opt] simple-template-id '::'; // Parse the optional 'template' keyword, then make sure we have; // 'identifier <' after it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:68,simpl,simple-template-id,68,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['simpl'],['simple-template-id']
Usability,"// new frame containing control buttons and feedback histos canvas",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:44,feedback,feedback,44,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['feedback'],['feedback']
Usability,"// no INCREF yet for simple cleanup in case of error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx:21,simpl,simple,21,bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx,1,['simpl'],['simple']
Usability,// noexcept functions are simple terminate scopes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:26,simpl,simple,26,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,1,['simpl'],['simple']
Usability,// non-simple--look up in lists,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:7,simpl,simple--look,7,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple--look']
Usability,"// not $, simple copy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:10,simpl,simple,10,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['simpl'],['simple']
Usability,"// not a minimum - not clear what to do",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx:23,clear,clear,23,hist/unfold/src/TUnfold.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx,1,['clear'],['clear']
Usability,"// not clear how to do at this point",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldDragManager.cxx:7,clear,clear,7,gui/guibuilder/src/TGuiBldDragManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldDragManager.cxx,1,['clear'],['clear']
Usability,"// not text shown for vertical progress bars",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGProgressBar.cxx:31,progress bar,progress bars,31,gui/gui/src/TGProgressBar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGProgressBar.cxx,1,['progress bar'],['progress bars']
Usability,"// note : this will work only for this type of constraints; // expressed as RooPoisson, RooGaussian, RooLognormal, RooGamma; // SimpleGaussianConstraint is CMS's own version of a RooGaussian, which also works.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooFit.cxx:128,Simpl,SimpleGaussianConstraint,128,roofit/xroofit/src/xRooFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooFit.cxx,1,['Simpl'],['SimpleGaussianConstraint']
Usability,"// note: making nll or profile class variables can only be done in the constructor; // as all other hooks are const (which has to be because GetHypoTest is const). However,; // when setting it only in constructor, they would have to be changed every time SetNullModel; // or SetAltModel is called. Simply put, converting them into class variables breaks; // encapsulation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/FrequentistCalculator.cxx:298,Simpl,Simply,298,roofit/roostats/src/FrequentistCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/FrequentistCalculator.cxx,1,['Simpl'],['Simply']
Usability,"// note: the normalization of event weights will affect the choice; // of learning rate, one will have to experiment to get the right value.; // in general, if the ""average"" event weight is 1, the learning rate; // should be good if set around 0.02 (a good value if all event weights are 1)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx:74,learn,learning,74,tmva/tmva/src/MethodMLP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx,2,['learn'],['learning']
Usability,"// now peel scopes one by one, pulling in the python naming (which will; // simply recurse if not overridden in python)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx:76,simpl,simply,76,bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx,1,['simpl'],['simply']
Usability,"// now prune the tree in steps until it is gone. At each pruning step, the pruning; // takes place at the node that is regarded as the ""weakest link"".; // for automatic pruning, at each step, we calculate the current quality of the; // tree and in the end we will prune at the minimum of the tree quality; // for the fixed parameter pruning, the cut is simply set at a relative position; // in the sequence according to the ""length"" of the sequence of pruned trees.; // 100: at the end (pruned until the root node would be the next pruning candidate; // 50: in the middle of the sequence; // etc...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/CostComplexityPruneTool.cxx:353,simpl,simply,353,tmva/tmva/src/CostComplexityPruneTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/CostComplexityPruneTool.cxx,1,['simpl'],['simply']
Usability,"// now, when evaluating `SimpleVariation`, we should notice that it returns 2 values, not 3, and throw",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx:25,Simpl,SimpleVariation,25,tree/dataframe/test/dataframe_vary.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_vary.cxx,1,['Simpl'],['SimpleVariation']
Usability,"// number of feedback histos",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/inc/TSessionViewer.h:13,feedback,feedback,13,gui/sessionviewer/inc/TSessionViewer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/inc/TSessionViewer.h,1,['feedback'],['feedback']
Usability,// number of simple-valued codes (0..s-1),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,simpl,simple-valued,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple-valued']
Usability,"// number of undo arguments",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TQCommand.h:13,undo,undo,13,core/base/inc/TQCommand.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TQCommand.h,1,['undo'],['undo']
Usability,"// number of undocumented overloads",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/inc/TDocParser.h:13,undo,undocumented,13,html/inc/TDocParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/inc/TDocParser.h,1,['undo'],['undocumented']
Usability,// oVerflow cleared,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h:12,clear,cleared,12,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiCondCode.h,3,['clear'],['cleared']
Usability,// objc-receiver:; // typename-specifier; // simple-type-specifier; // expression (that starts with one of the above),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:45,simpl,simple-type-specifier,45,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['simpl'],['simple-type-specifier']
Usability,"// object to which undo/redo actions applied",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TQCommand.h:19,undo,undo,19,core/base/inc/TQCommand.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TQCommand.h,1,['undo'],['undo']
Usability,"// ok, finally, clear the failbit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx:16,clear,clear,16,roofit/roofitcore/src/BidirMMapPipe.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx,1,['clear'],['clear']
Usability,"// once classes can be extended, should consider re-use; for now, since derived; // python classes can differ in what they override, simply use different shims",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx:133,simpl,simply,133,bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx,1,['simpl'],['simply']
Usability,"// option ""nodelete"" is passed when Clear is called from; // THashList::Clear() or THashList::Delete() or Rehash().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashTable.cxx:36,Clear,Clear,36,core/cont/src/THashTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashTable.cxx,2,['Clear'],['Clear']
Usability,"// or if no constant, simply copy parameters from function2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:22,simpl,simply,22,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['simpl'],['simply']
Usability,"// ordering on this axis makes no sense. Clear all arrays.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoVoxelFinder.cxx:41,Clear,Clear,41,geom/geom/src/TGeoVoxelFinder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoVoxelFinder.cxx,3,['Clear'],['Clear']
Usability,"// otherwise, it simply looks if ""variable == true"" (""greater 0.5 to be ""sure"" )",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCategory.cxx:17,simpl,simply,17,tmva/tmva/src/MethodCategory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCategory.cxx,1,['simpl'],['simply']
Usability,"// overload stops here; // A successful instantiation needs to be cached to pre-empt future instantiations. There; // are two names involved, the original asked (which may be partial) and the received.; //; // Caching scheme: if the match is exact, simply add the overload to the pre-existing; // one, or create a new overload for later lookups. If the match is not exact, do the; // same, but also create an alias. Only add exact matches to the set of known template; // instantiations, to prevent piling on from different partial instantiations.; //; // TODO: this caches the lookup method before the call, meaning that failing overloads; // can add already existing overloads to the set of methods.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/TemplateProxy.cxx:249,simpl,simply,249,bindings/pyroot/cppyy/CPyCppyy/src/TemplateProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/TemplateProxy.cxx,1,['simpl'],['simply']
Usability,"// paramPoint used to be given as parameter; // situation is clear when there is only one null.; // WHAT TO DO FOR MANY nullptr DENSITIES?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCImportanceSampler.cxx:61,clear,clear,61,roofit/roostats/src/ToyMCImportanceSampler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCImportanceSampler.cxx,1,['clear'],['clear']
Usability,"// pause/continue button",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/Tetris.h:3,pause,pause,3,test/Tetris.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/Tetris.h,1,['pause'],['pause']
Usability,"// plan to replace the above: return a SimpleInterval integrating; // over all other parameters except the one specified as argument; // virtual SimpleInterval* GetInterval( RooRealVar* parameter ) const { return 0; }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/BayesianCalculator.h:39,Simpl,SimpleInterval,39,roofit/roostats/inc/RooStats/BayesianCalculator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/BayesianCalculator.h,2,['Simpl'],['SimpleInterval']
Usability,// postfix-expression: simple-type-specifier '(' expression-list[opt] ')'; // simple-type-specifier braced-init-list; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:23,simpl,simple-type-specifier,23,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,2,['simpl'],['simple-type-specifier']
Usability,// preg is usable for this virtual register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:11,usab,usable,11,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,1,['usab'],['usable']
Usability,"// preserve key for longpoll or when with session key used for HMAC hash of messages; // conn->fKey.clear();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:100,clear,clear,100,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['clear'],['clear']
Usability,"// presumably not a class enum; simply pretend int",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPEnum.cxx:32,simpl,simply,32,bindings/pyroot/cppyy/CPyCppyy/src/CPPEnum.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPEnum.cxx,1,['simpl'],['simply']
Usability,"// print data in case of number counting (simple data sets)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ProfileLikelihoodTestStat.cxx:42,simpl,simple,42,roofit/roostats/src/ProfileLikelihoodTestStat.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ProfileLikelihoodTestStat.cxx,1,['simpl'],['simple']
Usability,"// printf(""----------------------------------------- eta(%f, %f)\n"", etaMin, etaMax);; // clear",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveCalo.cxx:90,clear,clear,90,graf3d/eve7/src/REveCalo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveCalo.cxx,1,['clear'],['clear']
Usability,"// printf(""Redraw %dx%d at %d,%d\n"", w, h, x, y);; // Allocate and clear a pixmap upon which to draw",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx:67,clear,clear,67,gui/guihtml/src/TGHtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx,1,['clear'],['clear']
Usability,"// probability and rarity accessors (see Users Guide for definition of Rarity)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Reader.h:47,Guid,Guide,47,tmva/tmva/inc/TMVA/Reader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Reader.h,1,['Guid'],['Guide']
Usability,"// problem: if obj is living in a collapsed node it wont actually get deleted; /*auto _b = dynamic_cast<TGFileBrowser*>( dynamic_cast<TRootBrowser*>(b->GetBrowserImp())->fActBrowser );; if (_b) {; std::cout << _b->fRootDir->GetText() << std::endl;; if (auto item = _b->fListTree->FindItemByObj(_b->fRootDir,it->get()); item) {; std::cout << ""Found obj: "" << item << "" "" << item->GetText() << std::endl;; _b->fListTree->RecursiveDeleteItem(_b->fRootDir,it->get());; }. //b->RecursiveRemove(it->get());; if (auto item = _b->fListTree->FindItemByObj(_b->fRootDir,it->get()); item) {; std::cout << ""Still Found obj: "" << item << std::endl;; }; _b->fListTree->ClearViewPort();. }*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:655,Clear,ClearViewPort,655,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['Clear'],['ClearViewPort']
Usability,"// progress bar",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/inc/TProofProgressDialog.h:3,progress bar,progress bar,3,gui/sessionviewer/inc/TProofProgressDialog.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/inc/TProofProgressDialog.h,1,['progress bar'],['progress bar']
Usability,"// projected were already destroyed in REveElement::Anihilate(), now only clear its list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveElement.cxx:74,clear,clear,74,graf3d/eve7/src/REveElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveElement.cxx,1,['clear'],['clear']
Usability,"// projected were already destroyed in TEveElement::Anihilate(), now only clear its list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveElement.cxx:74,clear,clear,74,graf3d/eve/src/TEveElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveElement.cxx,1,['clear'],['clear']
Usability,"// propagate error matrix vyy to the result; // vyy: error matrix on input data fY; // ematrix: output; // binMap: see method GetEmatrix(); // clearEmat: set kTRUE to clear the histogram prior to adding the errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx:143,clear,clearEmat,143,hist/unfold/src/TUnfoldSys.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx,2,['clear'],"['clear', 'clearEmat']"
Usability,"// provide simple rebin with average values; // TODO: provide methods in histogram classes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/src/RHistDrawable.cxx:11,simpl,simple,11,hist/histdrawv7/src/RHistDrawable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/src/RHistDrawable.cxx,3,['simpl'],['simple']
Usability,"// rc has a peculiar algorithm to output VERSIONINFO VALUEs. Each VALUE; // is a mapping from the key (string) to the value (a sequence of ints or; // a sequence of strings).; //; // If integers are to be written: width of each integer written depends on; // whether it's been declared 'long' (it's DWORD then) or not (it's WORD).; // ValueLength defined in structure referenced below is then the total; // number of bytes taken by these integers.; //; // If strings are to be written: characters are always WORDs.; // Moreover, '\0' character is written after the last string, and between; // every two strings separated by comma (if strings are not comma-separated,; // they're simply concatenated). ValueLength is equal to the number of WORDs; // written (that is, half of the bytes written).; //; // Ref: msdn.microsoft.com/en-us/library/windows/desktop/ms646994.aspx",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp:680,simpl,simply,680,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp,1,['simpl'],['simply']
Usability,"// recorder of operations for undo and redo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TQCommand.h:30,undo,undo,30,core/base/inc/TQCommand.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TQCommand.h,1,['undo'],['undo']
Usability,"// recursive chain of `Report`s; // RRange simply forwards these calls to the previous node",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx:43,simpl,simply,43,tree/dataframe/inc/ROOT/RDF/RRange.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx,1,['simpl'],['simply']
Usability,"// recursively clear the nodes content (S/N etc, but not the cut criteria)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DecisionTreeNode.h:15,clear,clear,15,tmva/tmva/inc/TMVA/DecisionTreeNode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DecisionTreeNode.h,1,['clear'],['clear']
Usability,"// reloadable methods; // called when the widget is cleared",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h:52,clear,cleared,52,gui/guihtml/inc/TGHtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h,1,['clear'],['cleared']
Usability,"// remove reference on the painter; // when only display cleared, try to clear all browser items",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:57,clear,cleared,57,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['clear'],"['clear', 'cleared']"
Usability,"// remove the corresponding entry from the feedback list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:43,feedback,feedback,43,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['feedback'],['feedback']
Usability,"// removeMatchingExtensions - Examines a subscript pair.; // If the source and destination are identically sign (or zero); // extended, it strips off the extension in an effect to simplify; // the actual analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:180,simpl,simplify,180,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['simpl'],['simplify']
Usability,"// request childs for current element; // TODO: we do not know child index, but simply can supply search child as argument",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/browser/model/BrowserModel.js:80,simpl,simply,80,ui5/browser/model/BrowserModel.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/browser/model/BrowserModel.js,1,['simpl'],['simply']
Usability,"// required to use numpy arrays; // NOTE: sys.argv has to be cleared because otherwise TensorFlow breaks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx:61,clear,cleared,61,tmva/pymva/src/MethodPyKeras.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx,1,['clear'],['cleared']
Usability,// requires (...) {; // ^ - a requires expression as a; // simple-requirement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:59,simpl,simple-requirement,59,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['simpl'],['simple-requirement']
Usability,"// reset and clear fit result; // to be called when a new model or data are set in the calculator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ProfileLikelihoodCalculator.cxx:13,clear,clear,13,roofit/roostats/src/ProfileLikelihoodCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ProfileLikelihoodCalculator.cxx,1,['clear'],['clear']
Usability,"// reset self if needed, allowing simple re-use",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx:34,simpl,simple,34,bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,1,['simpl'],['simple']
Usability,"// restore FPSCR from stack and clear bits 0-4, 7, 28-31; // The other bits are program global according to the AAPCS",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp:32,clear,clear,32,interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,1,['clear'],['clear']
Usability,// result can be simple string or object with req and kind fields,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:17,simpl,simple,17,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,"// resume.entry:; // %index.addr = getelementptr inbounds %f.Frame, %f.Frame* %FramePtr, i32 0,; // i32 2; // % index = load i32, i32* %index.addr; // switch i32 %index, label %unreachable [; // i32 0, label %resume.0; // i32 1, label %resume.1; // ...; // ]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:3,resume,resume,3,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,3,['resume'],['resume']
Usability,"// retrieve, store, and clear errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx:24,clear,clear,24,bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,1,['clear'],['clear']
Usability,"// return -1 or 1 for bg or signal event; // clear old range and prepare new range",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDEFoam.cxx:45,clear,clear,45,tmva/tmva/src/MethodPDEFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDEFoam.cxx,1,['clear'],['clear']
Usability,"// reverse left/right rather than simply !SortFunc(left, right); // to expose different paths in the comparison logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:34,simpl,simply,34,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['simpl'],['simply']
Usability,// rewriteFirstIterationLoopExitValues does not rely on the computation of; // trip count and therefore can further simplify exit values in addition to; // rewriteLoopExitValues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:116,simpl,simplify,116,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['simpl'],['simplify']
Usability,"// sanitizeWS(); // clears the caches that might exist up to now, as well interfere with getParameters calls",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:20,clear,clears,20,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['clear'],['clears']
Usability,// save a copy of LiveInterval in StackSlotToOrigLI because the original; // LiveInterval may be cleared after all its references are spilled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:97,clear,cleared,97,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['clear'],['cleared']
Usability,// save simple names.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/MicrosoftDemangle.h:8,simpl,simple,8,interpreter/llvm-project/llvm/include/llvm/Demangle/MicrosoftDemangle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/MicrosoftDemangle.h,1,['simpl'],['simple']
Usability,// save+clear FP regs with ClearRegs,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp:8,clear,clear,8,interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,2,"['Clear', 'clear']","['ClearRegs', 'clear']"
Usability,"// sdiv, srem -> sdivrem; // If the divisor is constant, then return DIVREM only if isIntDivCheap() is; // true. Otherwise, we break the simplification logic in visitREM().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:137,simpl,simplification,137,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['simpl'],['simplification']
Usability,"// seems I have to remake the function each time, as haven't figured out what cache needs clearing?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:90,clear,clearing,90,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,2,['clear'],['clearing']
Usability,"// server may returns simple buffer, which combines all segments together",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:22,simpl,simple,22,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,"// set a small tolerance for the tests; // The default of 10*-2 make sometimes Simplex do not converge; //const double gDefaultTolerance = 1.E-4;; // Options to indicate how the test has to be run",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx:79,Simpl,Simplex,79,test/stressHistoFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistoFit.cxx,1,['Simpl'],['Simplex']
Usability,"// set descriptor if simple socket (needed when created; // by TPServerSocket)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPSocket.cxx:21,simpl,simple,21,net/net/src/TPSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPSocket.cxx,1,['simpl'],['simple']
Usability,"// set fitter object, and clear",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MinuitFitter.cxx:26,clear,clear,26,tmva/tmva/src/MinuitFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MinuitFitter.cxx,1,['clear'],['clear']
Usability,"// set learning method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodTMlpANN.cxx:7,learn,learning,7,tmva/tmva/src/MethodTMlpANN.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodTMlpANN.cxx,1,['learn'],['learning']
Usability,"// set the learning rate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/TSynapse.h:11,learn,learning,11,tmva/tmva/inc/TMVA/TSynapse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/TSynapse.h,1,['learn'],['learning']
Usability,"// set up random simplex",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:17,simpl,simplex,17,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,1,['simpl'],['simplex']
Usability,// set_intersect mutates PStoreAddresses in place. Rename it here to make it; // clear what it contains.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:81,clear,clear,81,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['clear'],['clear']
Usability,"// setge X, C is canonicalized to setgt, so we do not need to match that; // pattern. The setlt sibling is folded in SimplifySelectCC() because it does; // not require the 'not' op.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:117,Simpl,SimplifySelectCC,117,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Simpl'],['SimplifySelectCC']
Usability,"// should get cleared when we sterilize",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:14,clear,cleared,14,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['clear'],['cleared']
Usability,"// similarly fold (and (X (load ([non_ext|any_ext|zero_ext] V))), c) ->; // (X (load ([non_ext|zero_ext] V))) if 'and' only clears top bits which must; // already be zero by virtue of the width of the base type of the load.; //; // the 'X' node here can either be nothing or an extract_vector_elt to catch; // more cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:124,clear,clears,124,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['clear'],['clears']
Usability,"// simple",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ProfileLikelihoodTestStat.cxx:3,simpl,simple,3,roofit/roostats/src/ProfileLikelihoodTestStat.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ProfileLikelihoodTestStat.cxx,1,['simpl'],['simple']
Usability,"// simple 1-dim array of the declared type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/LowLevelViews.cxx:3,simpl,simple,3,bindings/pyroot/cppyy/CPyCppyy/src/LowLevelViews.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/LowLevelViews.cxx,1,['simpl'],['simple']
Usability,"// simple Matrix vector op",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/test/matrix_op.h:3,simpl,simple,3,math/smatrix/test/matrix_op.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/test/matrix_op.h,1,['simpl'],['simple']
Usability,// simple [],MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,simpl,simple,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,"// simple array types",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Executors.cxx:3,simpl,simple,3,bindings/pyroot/cppyy/CPyCppyy/src/Executors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Executors.cxx,1,['simpl'],['simple']
Usability,"// simple array; set or resize as necessary",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:3,simpl,simple,3,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,1,['simpl'],['simple']
Usability,"// simple box geometry is compact and can be delivered as raw",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx:3,simpl,simple,3,geom/webviewer/src/RGeomData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx,1,['simpl'],['simple']
Usability,"// simple case",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx:3,simpl,simple,3,bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,2,['simpl'],['simple']
Usability,"// simple case with no multiplicity",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorDraw.cxx:3,simpl,simple,3,tree/treeplayer/src/TSelectorDraw.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorDraw.cxx,1,['simpl'],['simple']
Usability,"// simple case: methods from current class (collect constructors along the way)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx:3,simpl,simple,3,bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx,1,['simpl'],['simple']
Usability,"// simple check - if canvas there, can use painter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,simpl,simple,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['simpl'],['simple']
Usability,"// simple check whether unfolding is possible, given the matrices fA and fV",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx:3,simpl,simple,3,hist/unfold/src/TUnfold.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx,1,['simpl'],['simple']
Usability,"// simple chi2/2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx:3,simpl,simple,3,math/fumili/src/TFumili.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx,1,['simpl'],['simple']
Usability,"// simple class to measure time",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/test/stressKalman.cxx:3,simpl,simple,3,math/smatrix/test/stressKalman.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/test/stressKalman.cxx,2,['simpl'],['simple']
Usability,// simple code is just the value,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,simpl,simple,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,"// simple copy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx:3,simpl,simple,3,hist/unfold/src/TUnfoldSys.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx,1,['simpl'],['simple']
Usability,"// simple echo loop test",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx:3,simpl,simple,3,roofit/roofitcore/src/BidirMMapPipe.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx,1,['simpl'],['simple']
Usability,"// simple else: process if nothing else was true",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooArgSet.cxx:3,simpl,simple,3,roofit/roofitcore/src/RooArgSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooArgSet.cxx,1,['simpl'],['simple']
Usability,// simple extension of histogram to make sum,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,simpl,simple,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,"// simple gradient calculator using the 2 points rule",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx:3,simpl,simple,3,math/mathcore/src/FitUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx,1,['simpl'],['simple']
Usability,"// simple heuristics here for considering potential register; // pressure, the logics here is that the differnce are used; // to measure the distance between def and use, the longer distance; // more likely cause register pressure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:3,simpl,simple,3,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['simpl'],['simple']
Usability,// simple line,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,simpl,simple,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,"// simple linear extrapolation to critical value ... return nan if problem",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooHypoSpace.cxx:3,simpl,simple,3,roofit/xroofit/src/xRooHypoSpace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooHypoSpace.cxx,1,['simpl'],['simple']
Usability,// simple lvalue,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGValue.h:3,simpl,simple,3,interpreter/llvm-project/clang/lib/CodeGen/CGValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGValue.h,1,['simpl'],['simple']
Usability,"// simple placeholders for ones that don't exist",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:3,simpl,simple,3,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['simpl'],['simple']
Usability,"// simple poll test - children send 5 results in random intervals",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx:3,simpl,simple,3,roofit/roofitcore/src/BidirMMapPipe.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx,1,['simpl'],['simple']
Usability,"// simple polling loop until specified version delivered to the clients; // first 500 loops done without sleep, then with 1ms sleep and last 500 with 100 ms sleep",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx:3,simpl,simple,3,gui/webgui6/src/TWebCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx,1,['simpl'],['simple']
Usability,"// simple quadratic polynomial",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_spline.cxx:3,simpl,simple,3,hist/hist/test/test_spline.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_spline.cxx,1,['simpl'],['simple']
Usability,"// simple replace of object does not help - one can have different; // complex relations between histogram and stat box, histogram and colz axis,; // one could have THStack or TMultiGraph object; // The only that could be done is update of content",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,simpl,simple,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,"// simple run function to process all requests in same thread",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TFastCgi.cxx:3,simpl,simple,3,net/http/src/TFastCgi.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TFastCgi.cxx,1,['simpl'],['simple']
Usability,"// simple static request counter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TFastCgi.cxx:3,simpl,simple,3,net/http/src/TFastCgi.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TFastCgi.cxx,1,['simpl'],['simple']
Usability,"// simple statistics operations on tree entries",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Tools.h:3,simpl,simple,3,tmva/tmva/inc/TMVA/Tools.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Tools.h,1,['simpl'],['simple']
Usability,"// simple test of fitting a Tgraph",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/fit/testFit.cxx:3,simpl,simple,3,math/mathcore/test/fit/testFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/fit/testFit.cxx,1,['simpl'],['simple']
Usability,"// simple test of unuran",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/test/unuranDistr.cxx:3,simpl,simple,3,math/unuran/test/unuranDistr.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/test/unuranDistr.cxx,4,['simpl'],['simple']
Usability,// simple workaround to wait until modules are loaded,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/scripts/geoworker.js:3,simpl,simple,3,js/scripts/geoworker.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/scripts/geoworker.js,1,['simpl'],['simple']
Usability,"// simple, superfast hash for pointers and alike",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx:3,simpl,simple,3,core/base/src/TString.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx,1,['simpl'],['simple']
Usability,// simple-asm-expr[opt],MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,simpl,simple-asm-expr,3,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['simpl'],['simple-asm-expr']
Usability,// simple-declaration,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:3,simpl,simple-declaration,3,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['simpl'],['simple-declaration']
Usability,// simple-type-specifier,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:3,simpl,simple-type-specifier,3,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['simpl'],['simple-type-specifier']
Usability,"// simplex",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:3,simpl,simplex,3,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,1,['simpl'],['simplex']
Usability,"// simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.; // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w; // impossible. Only the 24 indices which have non-zero entries make any sense.; // We use a thresholding to set the coordinates in turn from the largest magnitude.; // The number 3 in the ""simplex"" array is at the position of the largest coordinate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs:3,simpl,simplex,3,js/modules/three_addons.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs,2,['simpl'],['simplex']
Usability,// simplify drawing,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,simpl,simplify,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simplify']
Usability,"// simplify work for javascript and delete all (ok, most of) cross-references",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,simpl,simplify,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simplify']
Usability,"// simply don't know; // the instance fails the lively test if it owns the C++ object while having a; // reference count of 1 (meaning: it could delete the C++ instance any moment)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/API.cxx:3,simpl,simply,3,bindings/pyroot/cppyy/CPyCppyy/src/API.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/API.cxx,1,['simpl'],['simply']
Usability,"// simply generate and load kDim uniform random numbers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx:3,simpl,simply,3,math/foam/src/TFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx,2,['simpl'],['simply']
Usability,"// simply made it static so it doesn't need to be re-booked every time",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/VariableNormalizeTransform.cxx:3,simpl,simply,3,tmva/tmva/src/VariableNormalizeTransform.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/VariableNormalizeTransform.cxx,1,['simpl'],['simply']
Usability,"// simply restore and expose as the actual smart pointer class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx:3,simpl,simply,3,bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx,1,['simpl'],['simply']
Usability,"// simply use relative move from point, can optimize in the future",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,simpl,simply,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['simpl'],['simply']
Usability,"// some model needs some simplifications",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/test/TestSofieModels.cxx:25,simpl,simplifications,25,tmva/sofie/test/TestSofieModels.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/test/TestSofieModels.cxx,1,['simpl'],['simplifications']
Usability,"// some older libXpm's don't have this function and it is typically; // implemented with a simple free(); // XpmFree(data);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/GX11Gui.cxx:91,simpl,simple,91,graf2d/x11/src/GX11Gui.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/GX11Gui.cxx,1,['simpl'],['simple']
Usability,"// sometimes is faster to create a temp, not clear why; //==============================================================================; // transpose; //==============================================================================",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/MatrixFunctions.h:45,clear,clear,45,math/smatrix/inc/Math/MatrixFunctions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/MatrixFunctions.h,1,['clear'],['clear']
Usability,"// special cases:; // 1) for Thumb1 code we sometimes materialize the constant via constpool; // load.; // 2) for Thumb1 execute only code we materialize the constant via the; // following pattern:; // movs r3, #:upper8_15:<const>; // lsls r3, #8; // adds r3, #:upper0_7:<const>; // lsls r3, #8; // adds r3, #:lower8_15:<const>; // lsls r3, #8; // adds r3, #:lower0_7:<const>; // So we need to special-case MOVS, ADDS and LSLS, and keep track of; // where we are in the sequence with the simplest of state machines.; // 3) for Thumb2 execute only code we materialize the constant via; // immediate constants in 2 separate instructions (MOVW/MOVT).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMAsmPrinter.cpp:488,simpl,simplest,488,interpreter/llvm-project/llvm/lib/Target/ARM/ARMAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMAsmPrinter.cpp,1,['simpl'],['simplest']
Usability,// special handling of simple arrays,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:23,simpl,simple,23,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,// special situation when snapid not yet assigned - just keep ref until snapid is there; // maybe keep full list - for now not clear if really needed,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:127,clear,clear,127,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clear']
Usability,"// specify nullptr means clear attribute",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/src/RAttrMap.cxx:25,clear,clear,25,graf2d/gpadv7/src/RAttrMap.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/src/RAttrMap.cxx,1,['clear'],['clear']
Usability,"// sret+inreg indicates a call that returns a C++ class value. This is; // actually equivalent to just passing and returning a void* pointer; // as the first argument. Translate it that way, instead of trying; // to model ""inreg"" in the thunk's calling convention, to simplify; // the rest of the code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Arm64ECCallLowering.cpp:268,simpl,simplify,268,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Arm64ECCallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Arm64ECCallLowering.cpp,1,['simpl'],['simplify']
Usability,"// static const char * const kETestStatTypeString[] = { ""Simple Likelihood Ratio"", ""Ratio Of Profiled Likelihoods"",; // ""Profile Likelihood Ratio"", ""Profile Likelihood One-Sided"", ""Profile Likelihood One-Sided Discovery"",; // ""Profile Likelihood Signed"", ""Max Likelihood Estimate"", ""Number Of Observed Events"" };",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/stressRooStats_tests.h:57,Simpl,Simple,57,roofit/roostats/test/stressRooStats_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/stressRooStats_tests.h,1,['Simpl'],['Simple']
Usability,"// static methods for setting and retrieving the default options; /// Set the default Minimizer type and corresponding algorithms.; /// Here is the list of the available minimizers and their corresponding algorithms.; /// For some minimizers (e.g. Fumili) there are no specific algorithms available, then there is no need to specify it.; ///; /// \anchor ROOTMinimizers; /// ### ROOT Minimizers; ///; /// - Minuit Minimizer based on TMinuit, the legacy Minuit implementation. Here are the available algorithms:; /// - Migrad default algorithm based on the variable metric minimizer; /// - Minimize combination of Simplex and Migrad; /// - Simplex minimization algorithm not using the gradient information; /// - Scan brute function scan; /// - Minuit2 New C++ implementation of Minuit (the recommended one); /// - Migrad (default); /// - Minimize; /// - Simplex; /// - Fumili2 new implementation of Fumili integrated in Minuit2; /// - Fumili Minimizer using an approximation for the Hessian based on first derivatives of the model function (see TFumili). Works only for chi-squared and likelihood functions.; /// - Linear Linear minimizer (fitter) working only for linear functions (see TLinearFitter and TLinearMinimizer); /// - GSLMultiMin Minimizer from GSL based on the ROOT::Math::GSLMinimizer. Available algorithms are:; /// - BFGS2 (default); /// - BFGS; /// - ConjugateFR; /// - ConjugatePR; /// - SteepestDescent; /// - GSLMultiFit Minimizer based on GSL for minimizing only non linear least-squared functions (using an approximation similar to Fumili). See ROOT::Math::GSLMultiFit.; /// - GSLSimAn Simulated annealing minimizer from GSL (see ROOT::Math::GSLSimAnMinimizer). It is a stochastic minimization algorithm using only function values and not the gradient.; /// - Genetic Genetic minimization algorithms (see TMVA::Genetic); ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimizerOptions.h:613,Simpl,Simplex,613,math/mathcore/inc/Math/MinimizerOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimizerOptions.h,3,['Simpl'],['Simplex']
Usability,"// std::cout << ""ALL SIMPLEX PARAMETERS: ""<< std::endl;; // for (unsigned int i = 0; i < simplex.Simplex().size(); ++i); // std::cout << "" i = "" << i << "" x = "" << simplex(i).second << "" fval(x) = "" << simplex(i).first <<; // std::endl;; // trace the iterations (need to create a MinimumState although errors and gradient are not existing)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/SimplexBuilder.cxx:21,SIMPL,SIMPLEX,21,math/minuit2/src/SimplexBuilder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/SimplexBuilder.cxx,5,"['SIMPL', 'Simpl', 'simpl']","['SIMPLEX', 'Simplex', 'simplex']"
Usability,"// std::cout << ""Minuit2Minimizer: minimize using SIMPLEX "" << std::endl;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/Minuit2Minimizer.cxx:50,SIMPL,SIMPLEX,50,math/minuit2/src/Minuit2Minimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/Minuit2Minimizer.cxx,1,['SIMPL'],['SIMPLEX']
Usability,"// std::cout << ""clear histo "" << histoName << std::endl;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Monitoring.h:17,clear,clear,17,tmva/tmva/inc/TMVA/Monitoring.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Monitoring.h,1,['clear'],['clear']
Usability,"// std::cout << ""clear histo which exists "" << histoName << std::endl;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Monitoring.h:17,clear,clear,17,tmva/tmva/inc/TMVA/Monitoring.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Monitoring.h,1,['clear'],['clear']
Usability,"// std::pair<unsigned, unsigned> is used to implement a simple voting; // algorithm and choose the lane with the least number of operands that; // can freely move about or less profitable because it already has the; // most optimal set of operands. The first unsigned is a counter for; // voting, the second unsigned is the counter of lanes with instructions; // with same/alternate opcodes and same parent basic block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:56,simpl,simple,56,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['simpl'],['simple']
Usability,"// step 3.2: When previous and current operands share the same symbolic; // value, try to simplify ""PrevOpnd ^ CurrOpnd ^ ConstOpnd""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:90,simpl,simplify,90,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['simpl'],['simplify']
Usability,"// stl container of simple type are always 'loaded'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TBranchProxyClassDescriptor.cxx:20,simpl,simple,20,tree/treeplayer/src/TBranchProxyClassDescriptor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TBranchProxyClassDescriptor.cxx,1,['simpl'],['simple']
Usability,"// store X, null -> turns into 'unreachable' in SimplifyCFG; // store X, GEP(null, Y) -> turns into 'unreachable' in SimplifyCFG",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:48,Simpl,SimplifyCFG,48,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,2,['Simpl'],['SimplifyCFG']
Usability,"// strip-off leading blanks; // very simple minded pre-processor parsing, only works in case macro file; // starts with ""#ifndef __CINT__"". In that case everything till next; // ""#else"" or ""#endif"" will be skipped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:37,simpl,simple,37,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['simpl'],['simple']
Usability,"// success; // Failed, try a simpler 27-color.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGColorDialog.cxx:29,simpl,simpler,29,gui/gui/src/TGColorDialog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGColorDialog.cxx,1,['simpl'],['simpler']
Usability,"// success; // Failed, try then a much simpler 8-color.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGColorDialog.cxx:39,simpl,simpler,39,gui/gui/src/TGColorDialog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGColorDialog.cxx,1,['simpl'],['simpler']
Usability,"// sum<1 for internal parametrization of the simplex",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx:45,simpl,simplex,45,math/foam/src/TFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoam.cxx,2,['simpl'],['simplex']
Usability,// suppress simple click handler if double click detected,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:12,simpl,simple,12,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,"// sxtw, sxtx, uxtw or lsl (== uxtx)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp:15,ux,uxtw,15,interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp,2,['ux'],"['uxtw', 'uxtx']"
Usability,"// test first in a simple network with linear activations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestConvBackpropagation.cxx:19,simpl,simple,19,tmva/tmva/test/DNN/CNN/TestConvBackpropagation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/TestConvBackpropagation.cxx,3,['simpl'],['simple']
Usability,"// test with a simple quadratic function 2d; // minimum is at F(0,0) = 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/testADMinim.cxx:15,simpl,simple,15,math/minuit2/test/testADMinim.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/testADMinim.cxx,2,['simpl'],['simple']
Usability,"// testSIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 - a2*i]; // where i is an induction variable, c1 and c2 are loop invariant, and a1 and; // a2 are constant, we attack it with an SIV test. While they can all be; // solved with the Exact SIV test, it's worthwhile to use simpler tests when; // they apply; they're cheaper and sometimes more precise.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:303,simpl,simpler,303,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['simpl'],['simpler']
Usability,"// testStatType = 0 Simple Likelihood Ratio (the LEP TestStat); // = 1 Ratio of Profiled Likelihood Ratios (the Tevatron TestStat); // = 2 Profile Likelihood Ratio (the LHC TestStat); // = 3 Profile Likelihood One Sided (pll = 0 if mu < mu_hat); // = 4 Profile Likelihood Signed (pll = -pll if mu < mu_hat); // = 5 Max Likelihood Estimate as test statistic; // = 6 Number of Observed Events as test statistic",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/stressRooStats_tests.h:20,Simpl,Simple,20,roofit/roostats/test/stressRooStats_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/stressRooStats_tests.h,1,['Simpl'],['Simple']
Usability,"// the ClearArea effectively turned off the cursor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEdit.cxx:7,Clear,ClearArea,7,gui/gui/src/TGTextEdit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEdit.cxx,1,['Clear'],['ClearArea']
Usability,"// the RVec<simple type> field optimization should ignore the mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_bulk.cxx:12,simpl,simple,12,tree/ntuple/v7/test/ntuple_bulk.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_bulk.cxx,1,['simpl'],['simple']
Usability,"// the RealAdaBoost does use a simple ""yes (signal)"" or ""no (background)""; // answer from your single MVA, but a ""signal probability"" instead (in the BDT case,; // that would be the 'purity' in the leaf node. For some MLP parameter, the MVA output; // can also interpreted as a probability, but here I try a general approach to get this; // probability from the MVA distributions...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBoost.cxx:31,simpl,simple,31,tmva/tmva/src/MethodBoost.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBoost.cxx,1,['simpl'],['simple']
Usability,// the current material requires lighting info; // note: all lighting uniforms are always set correctly; // they simply reference the renderer's state for their; // values; //; // use the current material's .needsUpdate flags to set; // the GL state when required,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:113,simpl,simply,113,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simply']
Usability,"// the number of arguments isn't known until instantiation and as far as C++ is concerned, all; // same-named operators are simply overloads; so will pre-emptively add both names if with and; // without arguments differ, letting the normal overload mechanism resolve on call",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx:124,simpl,simply,124,bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx,1,['simpl'],['simply']
Usability,// the only reason we should be here is V_SET_INACTIVE has; // an undef input so it is being replaced by a simple copy.; // There should be a second undef source that we should remove.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:107,simpl,simple,107,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['simpl'],['simple']
Usability,"// the simple one, automatically calculates the mvaVal and uses the SAME sig/bkg ratio as given in the training sample (typically 50/50 .. (NormMode=EqualNumEvents) but can be different)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBase.h:7,simpl,simple,7,tmva/tmva/inc/TMVA/MethodBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBase.h,1,['simpl'],['simple']
Usability,"// the simple one, automatically calculates the mvaVal and uses the; // SAME sig/bkg ratio as given in the training sample (typically 50/50; // .. (NormMode=EqualNumEvents) but can be different)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx:7,simpl,simple,7,tmva/tmva/src/MethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx,1,['simpl'],['simple']
Usability,"// the simple type missing are kBits and kCounter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:7,simpl,simple,7,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,1,['simpl'],['simple']
Usability,"// the system feedback list is always in the input list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:14,feedback,feedback,14,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['feedback'],['feedback']
Usability,"// the time spent in learning phase",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProofProgressStatus.h:21,learn,learning,21,proof/proof/inc/TProofProgressStatus.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProofProgressStatus.h,1,['learn'],['learning']
Usability,"// the top node is already further away than our limit, so we can simply return the limit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:66,simpl,simply,66,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['simpl'],['simply']
Usability,"// there seems to be a nasty bug somewhere that can make the cache become invalid, so clear it here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNLLVar.cxx:86,clear,clear,86,roofit/xroofit/src/xRooNLLVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNLLVar.cxx,1,['clear'],['clear']
Usability,"// theta = theta - learningRate * currentBiasUpdates",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adadelta.h:19,learn,learningRate,19,tmva/tmva/inc/TMVA/DNN/Adadelta.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adadelta.h,1,['learn'],['learningRate']
Usability,"// theta = theta - learningRate * currentWeightUpdates",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adadelta.h:19,learn,learningRate,19,tmva/tmva/inc/TMVA/DNN/Adadelta.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adadelta.h,1,['learn'],['learningRate']
Usability,"// this is debatable, and probably should not care, but the use case is pretty; // circumscribed anyway, so might as well keep the functionality simple",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx:145,simpl,simple,145,bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx,1,['simpl'],['simple']
Usability,// this is simple case of direct usage of the branch,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:11,simpl,simple,11,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,"// this must not be zero otherwise things go wrong.; // See related comment at the files->Clear(""nodelete"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:90,Clear,Clear,90,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,2,['Clear'],['Clear']
Usability,"// timer already switched off; // process local feedback objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:48,feedback,feedback,48,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,2,['feedback'],['feedback']
Usability,"// to re-use the argument handling, simply change the argument array into a tuple (the; // benefits of not allocating the tuple are relatively minor in this case)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPConstructor.cxx:36,simpl,simply,36,bindings/pyroot/cppyy/CPyCppyy/src/CPPConstructor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPConstructor.cxx,1,['simpl'],['simply']
Usability,"// todo: clear the range attribute on all servers; // could make this controlled by a flag but probably easiest to enforce so you must set range; // in children after if you wanted to override",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:9,clear,clear,9,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['clear'],['clear']
Usability,"// total number of times to update the progress bar",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx:39,progress bar,progress bar,39,tmva/tmva/src/MethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx,1,['progress bar'],['progress bar']
Usability,"// trick to update feedback histos",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:19,feedback,feedback,19,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['feedback'],['feedback']
Usability,// trunc(X) - trunc(Y) -> trunc(X - Y) if everything simplifies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:53,simpl,simplifies,53,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['simpl'],['simplifies']
Usability,// type-specifier:; // simple-type-specifier; // class-specifier; // enum-specifier; // elaborated-type-specifier; // typename-specifier; // cv-qualifier; // class-specifier; // elaborated-type-specifier,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:23,simpl,simple-type-specifier,23,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['simpl'],['simple-type-specifier']
Usability,// uadd.sat; // We need to clear all the known zeros as we can only use the leading ones.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/KnownBits.cpp:27,clear,clear,27,interpreter/llvm-project/llvm/lib/Support/KnownBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/KnownBits.cpp,1,['clear'],['clear']
Usability,"// under Windows, switch progress bar and color off by default, as the typical windows shell doesn't handle these; // (would need different sequences..)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Envelope.cxx:25,progress bar,progress bar,25,tmva/tmva/src/Envelope.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Envelope.cxx,3,['progress bar'],['progress bar']
Usability,"// undo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASPaletteEditor.cxx:3,undo,undo,3,graf2d/asimage/src/TASPaletteEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASPaletteEditor.cxx,1,['undo'],['undo']
Usability,"// undo action",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TQCommand.h:3,undo,undo,3,core/base/inc/TQCommand.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TQCommand.h,2,['undo'],['undo']
Usability,"// undo command",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEdit.cxx:3,undo,undo,3,gui/gui/src/TGTextEdit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEdit.cxx,1,['undo'],['undo']
Usability,"// undo the flip in real part of z if needed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/res/RooHeterogeneousMath.h:3,undo,undo,3,roofit/batchcompute/res/RooHeterogeneousMath.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/res/RooHeterogeneousMath.h,1,['undo'],['undo']
Usability,"// undo the swap here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHistError.cxx:3,undo,undo,3,roofit/roofitcore/src/RooHistError.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHistError.cxx,2,['undo'],['undo']
Usability,"// undo values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TQCommand.h:3,undo,undo,3,core/base/inc/TQCommand.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TQCommand.h,1,['undo'],['undo']
Usability,"// undo/redo in progress",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TQCommand.cxx:3,undo,undo,3,core/base/src/TQCommand.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TQCommand.cxx,1,['undo'],['undo']
Usability,"// undos",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/Editor.h:3,undo,undos,3,core/textinput/src/textinput/Editor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/Editor.h,1,['undo'],['undos']
Usability,// unlock color and depth buffer and make them writable for subsequent rendering/clearing,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:81,clear,clearing,81,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['clear'],['clearing']
Usability,"// update the SimplexParameter object with a new value y = FCN(p)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/SimplexParameters.cxx:14,Simpl,SimplexParameter,14,math/minuit2/src/SimplexParameters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/SimplexParameters.cxx,1,['Simpl'],['SimplexParameter']
Usability,"// update undo / redo button",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASPaletteEditor.cxx:10,undo,undo,10,graf2d/asimage/src/TASPaletteEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASPaletteEditor.cxx,1,['undo'],['undo']
Usability,"// updating the biases.; // theta = theta - learningRate * currentBiasGradients / (sqrt(Vt + epsilon))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adagrad.h:44,learn,learningRate,44,tmva/tmva/inc/TMVA/DNN/Adagrad.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adagrad.h,1,['learn'],['learningRate']
Usability,"// updating the biases; // theta = theta - learningRate * Vt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/SGD.h:43,learn,learningRate,43,tmva/tmva/inc/TMVA/DNN/SGD.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/SGD.h,1,['learn'],['learningRate']
Usability,"// updating the weights.; // theta = theta - learningRate * Vt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/SGD.h:45,learn,learningRate,45,tmva/tmva/inc/TMVA/DNN/SGD.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/SGD.h,1,['learn'],['learningRate']
Usability,"// updating the weights.; // theta = theta - learningRate * currentWeightGradients / (sqrt(Vt + epsilon))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adagrad.h:45,learn,learningRate,45,tmva/tmva/inc/TMVA/DNN/Adagrad.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adagrad.h,1,['learn'],['learningRate']
Usability,"// use UnixPathName to simplify handling of backslashes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebDisplayHandle.cxx:23,simpl,simplify,23,gui/webdisplay/src/RWebDisplayHandle.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebDisplayHandle.cxx,1,['simpl'],['simplify']
Usability,// use analytic normal values when open/closing paraboloid around 0; // cut faces (top or bottom) set with simple normal,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:107,simpl,simple,107,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['simpl'],['simple']
Usability,"// use clear instead of delete",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TLinearFitter.cxx:7,clear,clear,7,math/minuit/src/TLinearFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TLinearFitter.cxx,1,['clear'],['clear']
Usability,// use max bitcode size as a guide,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/llvm-isel-fuzzer.cpp:29,guid,guide,29,interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/llvm-isel-fuzzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-isel-fuzzer/llvm-isel-fuzzer.cpp,1,['guid'],['guide']
Usability,"// use simple hex coding while special symbols are hard to handle",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebPainting.cxx:7,simpl,simple,7,gui/webgui6/src/TWebPainting.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebPainting.cxx,1,['simpl'],['simple']
